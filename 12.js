var e = Object.defineProperty
  , t = (t,n,r)=>(((t,n,r)=>{
    n in t ? e(t, n, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }) : t[n] = r
  }
)(t, "symbol" != typeof n ? n + "" : n, r),
  r);
function n(e, t) {
  const n = Object.create(null)
    , r = e.split(",");
  for (let o = 0; o < r.length; o++)
    n[r[o]] = !0;
  return t ? e=>!!n[e.toLowerCase()] : e=>!!n[e]
}
!function() {
  const e = document.createElement("link").relList;
  if (!(e && e.supports && e.supports("modulepreload"))) {
    for (const e of document.querySelectorAll('link[rel="modulepreload"]'))
      t(e);
    new MutationObserver((e=>{
        for (const n of e)
          if ("childList" === n.type)
            for (const e of n.addedNodes)
              "LINK" === e.tagName && "modulepreload" === e.rel && t(e)
      }
    )).observe(document, {
      childList: !0,
      subtree: !0
    })
  }
  function t(e) {
    if (e.ep)
      return;
    e.ep = !0;
    const t = function(e) {
      const t = {};
      return e.integrity && (t.integrity = e.integrity),
      e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy),
        "use-credentials" === e.crossOrigin ? t.credentials = "include" : "anonymous" === e.crossOrigin ? t.credentials = "omit" : t.credentials = "same-origin",
        t
    }(e);
    fetch(e.href, t)
  }
}();
const r = {}
  , o = []
  , a = ()=>{}
  , i = ()=>!1
  , s = /^on[^a-z]/
  , l = e=>s.test(e)
  , u = e=>e.startsWith("onUpdate:")
  , c = Object.assign
  , d = (e,t)=>{
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
  }
  , f = Object.prototype.hasOwnProperty
  , p = (e,t)=>f.call(e, t)
  , h = Array.isArray
  , v = e=>"[object Map]" === A(e)
  , g = e=>"[object Set]" === A(e)
  , m = e=>"[object Date]" === A(e)
  , y = e=>"function" == typeof e
  , b = e=>"string" == typeof e
  , w = e=>"symbol" == typeof e
  , x = e=>null !== e && "object" == typeof e
  , S = e=>x(e) && y(e.then) && y(e.catch)
  , E = Object.prototype.toString
  , A = e=>E.call(e)
  , C = e=>A(e).slice(8, -1)
  , k = e=>"[object Object]" === A(e)
  , T = e=>b(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e
  , D = n(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , O = e=>{
    const t = Object.create(null);
    return n=>t[n] || (t[n] = e(n))
  }
  , _ = /-(\w)/g
  , R = O((e=>e.replace(_, ((e,t)=>t ? t.toUpperCase() : ""))))
  , L = /\B([A-Z])/g
  , I = O((e=>e.replace(L, "-$1").toLowerCase()))
  , P = O((e=>e.charAt(0).toUpperCase() + e.slice(1)))
  , F = O((e=>e ? `on${P(e)}` : ""))
  , B = (e,t)=>!Object.is(e, t)
  , N = (e,t)=>{
    for (let n = 0; n < e.length; n++)
      e[n](t)
  }
  , M = (e,t,n)=>{
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      value: n
    })
  }
  , j = e=>{
    const t = parseFloat(e);
    return isNaN(t) ? e : t
  }
  , V = e=>{
    const t = b(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t
  }
;
let U;
const $ = ()=>U || (U = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {})
  , H = n("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console");
function z(e) {
  if (h(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const r = e[n]
        , o = b(r) ? q(r) : z(r);
      if (o)
        for (const e in o)
          t[e] = o[e]
    }
    return t
  }
  return b(e) || x(e) ? e : void 0
}
const K = /;(?![^(]*\))/g
  , W = /:([^]+)/
  , G = /\/\*[^]*?\*\//g;
function q(e) {
  const t = {};
  return e.replace(G, "").split(K).forEach((e=>{
      if (e) {
        const n = e.split(W);
        n.length > 1 && (t[n[0].trim()] = n[1].trim())
      }
    }
  )),
    t
}
function Y(e) {
  let t = "";
  if (b(e))
    t = e;
  else if (h(e))
    for (let n = 0; n < e.length; n++) {
      const r = Y(e[n]);
      r && (t += r + " ")
    }
  else if (x(e))
    for (const n in e)
      e[n] && (t += n + " ");
  return t.trim()
}
function X(e) {
  if (!e)
    return null;
  let {class: t, style: n} = e;
  return t && !b(t) && (e.class = Y(t)),
  n && (e.style = z(n)),
    e
}
const Q = n("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");
function J(e) {
  return !!e || "" === e
}
function Z(e, t) {
  if (e === t)
    return !0;
  let n = m(e)
    , r = m(t);
  if (n || r)
    return !(!n || !r) && e.getTime() === t.getTime();
  if (n = w(e),
    r = w(t),
  n || r)
    return e === t;
  if (n = h(e),
    r = h(t),
  n || r)
    return !(!n || !r) && function(e, t) {
      if (e.length !== t.length)
        return !1;
      let n = !0;
      for (let r = 0; n && r < e.length; r++)
        n = Z(e[r], t[r]);
      return n
    }(e, t);
  if (n = x(e),
    r = x(t),
  n || r) {
    if (!n || !r)
      return !1;
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (const n in e) {
      const r = e.hasOwnProperty(n)
        , o = t.hasOwnProperty(n);
      if (r && !o || !r && o || !Z(e[n], t[n]))
        return !1
    }
  }
  return String(e) === String(t)
}
function ee(e, t) {
  return e.findIndex((e=>Z(e, t)))
}
const te = e=>b(e) ? e : null == e ? "" : h(e) || x(e) && (e.toString === E || !y(e.toString)) ? JSON.stringify(e, ne, 2) : String(e)
  , ne = (e,t)=>t && t.__v_isRef ? ne(e, t.value) : v(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce(((e,[t,n])=>(e[`${t} =>`] = n,
    e)), {})
} : g(t) ? {
  [`Set(${t.size})`]: [...t.values()]
} : !x(t) || h(t) || k(t) ? t : String(t);
let re;
class oe {
  constructor(e=!1) {
    this.detached = e,
      this._active = !0,
      this.effects = [],
      this.cleanups = [],
      this.parent = re,
    !e && re && (this.index = (re.scopes || (re.scopes = [])).push(this) - 1)
  }
  get active() {
    return this._active
  }
  run(e) {
    if (this._active) {
      const t = re;
      try {
        return re = this,
          e()
      } finally {
        re = t
      }
    }
  }
  on() {
    re = this
  }
  off() {
    re = this.parent
  }
  stop(e) {
    if (this._active) {
      let t, n;
      for (t = 0,
             n = this.effects.length; t < n; t++)
        this.effects[t].stop();
      for (t = 0,
             n = this.cleanups.length; t < n; t++)
        this.cleanups[t]();
      if (this.scopes)
        for (t = 0,
               n = this.scopes.length; t < n; t++)
          this.scopes[t].stop(!0);
      if (!this.detached && this.parent && !e) {
        const e = this.parent.scopes.pop();
        e && e !== this && (this.parent.scopes[this.index] = e,
          e.index = this.index)
      }
      this.parent = void 0,
        this._active = !1
    }
  }
}
function ae(e) {
  return new oe(e)
}
function ie(e, t=re) {
  t && t.active && t.effects.push(e)
}
function se() {
  return re
}
function le(e) {
  re && re.cleanups.push(e)
}
const ue = e=>{
  const t = new Set(e);
  return t.w = 0,
    t.n = 0,
    t
}
  , ce = e=>(e.w & he) > 0
  , de = e=>(e.n & he) > 0
  , fe = new WeakMap;
let pe = 0
  , he = 1;
const ve = 30;
let ge;
const me = Symbol("")
  , ye = Symbol("");
class be {
  constructor(e, t=null, n) {
    this.fn = e,
      this.scheduler = t,
      this.active = !0,
      this.deps = [],
      this.parent = void 0,
      ie(this, n)
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = ge
      , t = Ee;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent
    }
    try {
      return this.parent = ge,
        ge = this,
        Ee = !0,
        he = 1 << ++pe,
        pe <= ve ? (({deps: e})=>{
            if (e.length)
              for (let t = 0; t < e.length; t++)
                e[t].w |= he
          }
        )(this) : we(this),
        this.fn()
    } finally {
      pe <= ve && (e=>{
          const {deps: t} = e;
          if (t.length) {
            let n = 0;
            for (let r = 0; r < t.length; r++) {
              const o = t[r];
              ce(o) && !de(o) ? o.delete(e) : t[n++] = o,
                o.w &= ~he,
                o.n &= ~he
            }
            t.length = n
          }
        }
      )(this),
        he = 1 << --pe,
        ge = this.parent,
        Ee = t,
        this.parent = void 0,
      this.deferStop && this.stop()
    }
  }
  stop() {
    ge === this ? this.deferStop = !0 : this.active && (we(this),
    this.onStop && this.onStop(),
      this.active = !1)
  }
}
function we(e) {
  const {deps: t} = e;
  if (t.length) {
    for (let n = 0; n < t.length; n++)
      t[n].delete(e);
    t.length = 0
  }
}
function xe(e, t) {
  e.effect && (e = e.effect.fn);
  const n = new be(e);
  t && (c(n, t),
  t.scope && ie(n, t.scope)),
  t && t.lazy || n.run();
  const r = n.run.bind(n);
  return r.effect = n,
    r
}
function Se(e) {
  e.effect.stop()
}
let Ee = !0;
const Ae = [];
function Ce() {
  Ae.push(Ee),
    Ee = !1
}
function ke() {
  const e = Ae.pop();
  Ee = void 0 === e || e
}
function Te(e, t, n) {
  if (Ee && ge) {
    let t = fe.get(e);
    t || fe.set(e, t = new Map);
    let r = t.get(n);
    r || t.set(n, r = ue()),
      De(r)
  }
}
function De(e, t) {
  let n = !1;
  pe <= ve ? de(e) || (e.n |= he,
    n = !ce(e)) : n = !e.has(ge),
  n && (e.add(ge),
    ge.deps.push(e))
}
function Oe(e, t, n, r, o, a) {
  const i = fe.get(e);
  if (!i)
    return;
  let s = [];
  if ("clear" === t)
    s = [...i.values()];
  else if ("length" === n && h(e)) {
    const e = Number(r);
    i.forEach(((t,n)=>{
        ("length" === n || n >= e) && s.push(t)
      }
    ))
  } else
    switch (void 0 !== n && s.push(i.get(n)),
      t) {
      case "add":
        h(e) ? T(n) && s.push(i.get("length")) : (s.push(i.get(me)),
        v(e) && s.push(i.get(ye)));
        break;
      case "delete":
        h(e) || (s.push(i.get(me)),
        v(e) && s.push(i.get(ye)));
        break;
      case "set":
        v(e) && s.push(i.get(me))
    }
  if (1 === s.length)
    s[0] && _e(s[0]);
  else {
    const e = [];
    for (const t of s)
      t && e.push(...t);
    _e(ue(e))
  }
}
function _e(e, t) {
  const n = h(e) ? e : [...e];
  for (const r of n)
    r.computed && Re(r);
  for (const r of n)
    r.computed || Re(r)
}
function Re(e, t) {
  (e !== ge || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run())
}
const Le = n("__proto__,__v_isRef,__isVue")
  , Ie = new Set(Object.getOwnPropertyNames(Symbol).filter((e=>"arguments" !== e && "caller" !== e)).map((e=>Symbol[e])).filter(w))
  , Pe = Ue()
  , Fe = Ue(!1, !0)
  , Be = Ue(!0)
  , Ne = Ue(!0, !0)
  , Me = je();
function je() {
  const e = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((t=>{
      e[t] = function(...e) {
        const n = Dt(this);
        for (let t = 0, o = this.length; t < o; t++)
          Te(n, 0, t + "");
        const r = n[t](...e);
        return -1 === r || !1 === r ? n[t](...e.map(Dt)) : r
      }
    }
  )),
    ["push", "pop", "shift", "unshift", "splice"].forEach((t=>{
        e[t] = function(...e) {
          Ce();
          const n = Dt(this)[t].apply(this, e);
          return ke(),
            n
        }
      }
    )),
    e
}
function Ve(e) {
  const t = Dt(this);
  return Te(t, 0, e),
    t.hasOwnProperty(e)
}
function Ue(e=!1, t=!1) {
  return function(n, r, o) {
    if ("__v_isReactive" === r)
      return !e;
    if ("__v_isReadonly" === r)
      return e;
    if ("__v_isShallow" === r)
      return t;
    if ("__v_raw" === r && o === (e ? t ? yt : mt : t ? gt : vt).get(n))
      return n;
    const a = h(n);
    if (!e) {
      if (a && p(Me, r))
        return Reflect.get(Me, r, o);
      if ("hasOwnProperty" === r)
        return Ve
    }
    const i = Reflect.get(n, r, o);
    return (w(r) ? Ie.has(r) : Le(r)) ? i : (e || Te(n, 0, r),
      t ? i : Pt(i) ? a && T(r) ? i : i.value : x(i) ? e ? xt(i) : bt(i) : i)
  }
}
function $e(e=!1) {
  return function(t, n, r, o) {
    let a = t[n];
    if (Ct(a) && Pt(a) && !Pt(r))
      return !1;
    if (!e && (kt(r) || Ct(r) || (a = Dt(a),
      r = Dt(r)),
    !h(t) && Pt(a) && !Pt(r)))
      return a.value = r,
        !0;
    const i = h(t) && T(n) ? Number(n) < t.length : p(t, n)
      , s = Reflect.set(t, n, r, o);
    return t === Dt(o) && (i ? B(r, a) && Oe(t, "set", n, r) : Oe(t, "add", n, r)),
      s
  }
}
const He = {
  get: Pe,
  set: $e(),
  deleteProperty: function(e, t) {
    const n = p(e, t);
    e[t];
    const r = Reflect.deleteProperty(e, t);
    return r && n && Oe(e, "delete", t, void 0),
      r
  },
  has: function(e, t) {
    const n = Reflect.has(e, t);
    return w(t) && Ie.has(t) || Te(e, 0, t),
      n
  },
  ownKeys: function(e) {
    return Te(e, 0, h(e) ? "length" : me),
      Reflect.ownKeys(e)
  }
}
  , ze = {
  get: Be,
  set: (e,t)=>!0,
  deleteProperty: (e,t)=>!0
}
  , Ke = c({}, He, {
  get: Fe,
  set: $e(!0)
})
  , We = c({}, ze, {
  get: Ne
})
  , Ge = e=>e
  , qe = e=>Reflect.getPrototypeOf(e);
function Ye(e, t, n=!1, r=!1) {
  const o = Dt(e = e.__v_raw)
    , a = Dt(t);
  n || (t !== a && Te(o, 0, t),
    Te(o, 0, a));
  const {has: i} = qe(o)
    , s = r ? Ge : n ? Rt : _t;
  return i.call(o, t) ? s(e.get(t)) : i.call(o, a) ? s(e.get(a)) : void (e !== o && e.get(t))
}
function Xe(e, t=!1) {
  const n = this.__v_raw
    , r = Dt(n)
    , o = Dt(e);
  return t || (e !== o && Te(r, 0, e),
    Te(r, 0, o)),
    e === o ? n.has(e) : n.has(e) || n.has(o)
}
function Qe(e, t=!1) {
  return e = e.__v_raw,
  !t && Te(Dt(e), 0, me),
    Reflect.get(e, "size", e)
}
function Je(e) {
  e = Dt(e);
  const t = Dt(this);
  return qe(t).has.call(t, e) || (t.add(e),
    Oe(t, "add", e, e)),
    this
}
function Ze(e, t) {
  t = Dt(t);
  const n = Dt(this)
    , {has: r, get: o} = qe(n);
  let a = r.call(n, e);
  a || (e = Dt(e),
    a = r.call(n, e));
  const i = o.call(n, e);
  return n.set(e, t),
    a ? B(t, i) && Oe(n, "set", e, t) : Oe(n, "add", e, t),
    this
}
function et(e) {
  const t = Dt(this)
    , {has: n, get: r} = qe(t);
  let o = n.call(t, e);
  o || (e = Dt(e),
    o = n.call(t, e)),
  r && r.call(t, e);
  const a = t.delete(e);
  return o && Oe(t, "delete", e, void 0),
    a
}
function tt() {
  const e = Dt(this)
    , t = 0 !== e.size
    , n = e.clear();
  return t && Oe(e, "clear", void 0, void 0),
    n
}
function nt(e, t) {
  return function(n, r) {
    const o = this
      , a = o.__v_raw
      , i = Dt(a)
      , s = t ? Ge : e ? Rt : _t;
    return !e && Te(i, 0, me),
      a.forEach(((e,t)=>n.call(r, s(e), s(t), o)))
  }
}
function rt(e, t, n) {
  return function(...r) {
    const o = this.__v_raw
      , a = Dt(o)
      , i = v(a)
      , s = "entries" === e || e === Symbol.iterator && i
      , l = "keys" === e && i
      , u = o[e](...r)
      , c = n ? Ge : t ? Rt : _t;
    return !t && Te(a, 0, l ? ye : me),
      {
        next() {
          const {value: e, done: t} = u.next();
          return t ? {
            value: e,
            done: t
          } : {
            value: s ? [c(e[0]), c(e[1])] : c(e),
            done: t
          }
        },
        [Symbol.iterator]() {
          return this
        }
      }
  }
}
function ot(e) {
  return function(...t) {
    return "delete" !== e && this
  }
}
function at() {
  const e = {
    get(e) {
      return Ye(this, e)
    },
    get size() {
      return Qe(this)
    },
    has: Xe,
    add: Je,
    set: Ze,
    delete: et,
    clear: tt,
    forEach: nt(!1, !1)
  }
    , t = {
    get(e) {
      return Ye(this, e, !1, !0)
    },
    get size() {
      return Qe(this)
    },
    has: Xe,
    add: Je,
    set: Ze,
    delete: et,
    clear: tt,
    forEach: nt(!1, !0)
  }
    , n = {
    get(e) {
      return Ye(this, e, !0)
    },
    get size() {
      return Qe(this, !0)
    },
    has(e) {
      return Xe.call(this, e, !0)
    },
    add: ot("add"),
    set: ot("set"),
    delete: ot("delete"),
    clear: ot("clear"),
    forEach: nt(!0, !1)
  }
    , r = {
    get(e) {
      return Ye(this, e, !0, !0)
    },
    get size() {
      return Qe(this, !0)
    },
    has(e) {
      return Xe.call(this, e, !0)
    },
    add: ot("add"),
    set: ot("set"),
    delete: ot("delete"),
    clear: ot("clear"),
    forEach: nt(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((o=>{
      e[o] = rt(o, !1, !1),
        n[o] = rt(o, !0, !1),
        t[o] = rt(o, !1, !0),
        r[o] = rt(o, !0, !0)
    }
  )),
    [e, n, t, r]
}
const [it,st,lt,ut] = at();
function ct(e, t) {
  const n = t ? e ? ut : lt : e ? st : it;
  return (t,r,o)=>"__v_isReactive" === r ? !e : "__v_isReadonly" === r ? e : "__v_raw" === r ? t : Reflect.get(p(n, r) && r in t ? n : t, r, o)
}
const dt = {
  get: ct(!1, !1)
}
  , ft = {
  get: ct(!1, !0)
}
  , pt = {
  get: ct(!0, !1)
}
  , ht = {
  get: ct(!0, !0)
}
  , vt = new WeakMap
  , gt = new WeakMap
  , mt = new WeakMap
  , yt = new WeakMap;
function bt(e) {
  return Ct(e) ? e : Et(e, !1, He, dt, vt)
}
function wt(e) {
  return Et(e, !1, Ke, ft, gt)
}
function xt(e) {
  return Et(e, !0, ze, pt, mt)
}
function St(e) {
  return Et(e, !0, We, ht, yt)
}
function Et(e, t, n, r, o) {
  if (!x(e))
    return e;
  if (e.__v_raw && (!t || !e.__v_isReactive))
    return e;
  const a = o.get(e);
  if (a)
    return a;
  const i = (s = e).__v_skip || !Object.isExtensible(s) ? 0 : function(e) {
    switch (e) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0
    }
  }(C(s));
  var s;
  if (0 === i)
    return e;
  const l = new Proxy(e,2 === i ? r : n);
  return o.set(e, l),
    l
}
function At(e) {
  return Ct(e) ? At(e.__v_raw) : !(!e || !e.__v_isReactive)
}
function Ct(e) {
  return !(!e || !e.__v_isReadonly)
}
function kt(e) {
  return !(!e || !e.__v_isShallow)
}
function Tt(e) {
  return At(e) || Ct(e)
}
function Dt(e) {
  const t = e && e.__v_raw;
  return t ? Dt(t) : e
}
function Ot(e) {
  return M(e, "__v_skip", !0),
    e
}
const _t = e=>x(e) ? bt(e) : e
  , Rt = e=>x(e) ? xt(e) : e;
function Lt(e) {
  Ee && ge && De((e = Dt(e)).dep || (e.dep = ue()))
}
function It(e, t) {
  const n = (e = Dt(e)).dep;
  n && _e(n)
}
function Pt(e) {
  return !(!e || !0 !== e.__v_isRef)
}
function Ft(e) {
  return Nt(e, !1)
}
function Bt(e) {
  return Nt(e, !0)
}
function Nt(e, t) {
  return Pt(e) ? e : new Mt(e,t)
}
class Mt {
  constructor(e, t) {
    this.__v_isShallow = t,
      this.dep = void 0,
      this.__v_isRef = !0,
      this._rawValue = t ? e : Dt(e),
      this._value = t ? e : _t(e)
  }
  get value() {
    return Lt(this),
      this._value
  }
  set value(e) {
    const t = this.__v_isShallow || kt(e) || Ct(e);
    e = t ? e : Dt(e),
    B(e, this._rawValue) && (this._rawValue = e,
      this._value = t ? e : _t(e),
      It(this))
  }
}
function jt(e) {
  It(e)
}
function Vt(e) {
  return Pt(e) ? e.value : e
}
function Ut(e) {
  return y(e) ? e() : Vt(e)
}
const $t = {
  get: (e,t,n)=>Vt(Reflect.get(e, t, n)),
  set: (e,t,n,r)=>{
    const o = e[t];
    return Pt(o) && !Pt(n) ? (o.value = n,
      !0) : Reflect.set(e, t, n, r)
  }
};
function Ht(e) {
  return At(e) ? e : new Proxy(e,$t)
}
class zt {
  constructor(e) {
    this.dep = void 0,
      this.__v_isRef = !0;
    const {get: t, set: n} = e((()=>Lt(this)), (()=>It(this)));
    this._get = t,
      this._set = n
  }
  get value() {
    return this._get()
  }
  set value(e) {
    this._set(e)
  }
}
function Kt(e) {
  return new zt(e)
}
function Wt(e) {
  const t = h(e) ? new Array(e.length) : {};
  for (const n in e)
    t[n] = Xt(e, n);
  return t
}
class Gt {
  constructor(e, t, n) {
    this._object = e,
      this._key = t,
      this._defaultValue = n,
      this.__v_isRef = !0
  }
  get value() {
    const e = this._object[this._key];
    return void 0 === e ? this._defaultValue : e
  }
  set value(e) {
    this._object[this._key] = e
  }
  get dep() {
    return e = Dt(this._object),
      t = this._key,
      null == (n = fe.get(e)) ? void 0 : n.get(t);
    var e, t, n
  }
}
class qt {
  constructor(e) {
    this._getter = e,
      this.__v_isRef = !0,
      this.__v_isReadonly = !0
  }
  get value() {
    return this._getter()
  }
}
function Yt(e, t, n) {
  return Pt(e) ? e : y(e) ? new qt(e) : x(e) && arguments.length > 1 ? Xt(e, t, n) : Ft(e)
}
function Xt(e, t, n) {
  const r = e[t];
  return Pt(r) ? r : new Gt(e,t,n)
}
class Qt {
  constructor(e, t, n, r) {
    this._setter = t,
      this.dep = void 0,
      this.__v_isRef = !0,
      this.__v_isReadonly = !1,
      this._dirty = !0,
      this.effect = new be(e,(()=>{
          this._dirty || (this._dirty = !0,
            It(this))
        }
      )),
      this.effect.computed = this,
      this.effect.active = this._cacheable = !r,
      this.__v_isReadonly = n
  }
  get value() {
    const e = Dt(this);
    return Lt(e),
    !e._dirty && e._cacheable || (e._dirty = !1,
      e._value = e.effect.run()),
      e._value
  }
  set value(e) {
    this._setter(e)
  }
}
function Jt(e, t, n=!1) {
  let r, o;
  const i = y(e);
  i ? (r = e,
    o = a) : (r = e.get,
    o = e.set);
  return new Qt(r,o,i || !o,n)
}
function Zt(e, ...t) {}
function en(e, t) {}
function tn(e, t, n, r) {
  let o;
  try {
    o = r ? e(...r) : e()
  } catch (a) {
    rn(a, t, n)
  }
  return o
}
function nn(e, t, n, r) {
  if (y(e)) {
    const o = tn(e, t, n, r);
    return o && S(o) && o.catch((e=>{
        rn(e, t, n)
      }
    )),
      o
  }
  const o = [];
  for (let a = 0; a < e.length; a++)
    o.push(nn(e[a], t, n, r));
  return o
}
function rn(e, t, n, r=!0) {
  t && t.vnode;
  if (t) {
    let r = t.parent;
    const o = t.proxy
      , a = n;
    for (; r; ) {
      const t = r.ec;
      if (t)
        for (let n = 0; n < t.length; n++)
          if (!1 === t[n](e, o, a))
            return;
      r = r.parent
    }
    const i = t.appContext.config.errorHandler;
    if (i)
      return void tn(i, null, 10, [e, o, a])
  }
  !function(e, t, n, r=!0) {
    console.error(e)
  }(e, 0, 0, r)
}
let on = !1
  , an = !1;
const sn = [];
let ln = 0;
const un = [];
let cn = null
  , dn = 0;
const fn = Promise.resolve();
let pn = null;
function hn(e) {
  const t = pn || fn;
  return e ? t.then(this ? e.bind(this) : e) : t
}
function vn(e) {
  sn.length && sn.includes(e, on && e.allowRecurse ? ln + 1 : ln) || (null == e.id ? sn.push(e) : sn.splice(function(e) {
    let t = ln + 1
      , n = sn.length;
    for (; t < n; ) {
      const r = t + n >>> 1;
      wn(sn[r]) < e ? t = r + 1 : n = r
    }
    return t
  }(e.id), 0, e),
    gn())
}
function gn() {
  on || an || (an = !0,
    pn = fn.then(Sn))
}
function mn(e) {
  h(e) ? un.push(...e) : cn && cn.includes(e, e.allowRecurse ? dn + 1 : dn) || un.push(e),
    gn()
}
function yn(e, t=(on ? ln + 1 : 0)) {
  for (; t < sn.length; t++) {
    const e = sn[t];
    e && e.pre && (sn.splice(t, 1),
      t--,
      e())
  }
}
function bn(e) {
  if (un.length) {
    const e = [...new Set(un)];
    if (un.length = 0,
      cn)
      return void cn.push(...e);
    for (cn = e,
           cn.sort(((e,t)=>wn(e) - wn(t))),
           dn = 0; dn < cn.length; dn++)
      cn[dn]();
    cn = null,
      dn = 0
  }
}
const wn = e=>null == e.id ? 1 / 0 : e.id
  , xn = (e,t)=>{
    const n = wn(e) - wn(t);
    if (0 === n) {
      if (e.pre && !t.pre)
        return -1;
      if (t.pre && !e.pre)
        return 1
    }
    return n
  }
;
function Sn(e) {
  an = !1,
    on = !0,
    sn.sort(xn);
  try {
    for (ln = 0; ln < sn.length; ln++) {
      const e = sn[ln];
      e && !1 !== e.active && tn(e, null, 14)
    }
  } finally {
    ln = 0,
      sn.length = 0,
      bn(),
      on = !1,
      pn = null,
    (sn.length || un.length) && Sn()
  }
}
let En, An = [];
function Cn(e, t) {
  var n, r;
  if (En = e,
    En)
    En.enabled = !0,
      An.forEach((({event: e, args: t})=>En.emit(e, ...t))),
      An = [];
  else if ("undefined" != typeof window && window.HTMLElement && !(null == (r = null == (n = window.navigator) ? void 0 : n.userAgent) ? void 0 : r.includes("jsdom"))) {
    (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((e=>{
        Cn(e, t)
      }
    )),
      setTimeout((()=>{
          En || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null,
            An = [])
        }
      ), 3e3)
  } else
    An = []
}
function kn(e, t, ...n) {
  if (e.isUnmounted)
    return;
  const o = e.vnode.props || r;
  let a = n;
  const i = t.startsWith("update:")
    , s = i && t.slice(7);
  if (s && s in o) {
    const e = `${"modelValue" === s ? "model" : s}Modifiers`
      , {number: t, trim: i} = o[e] || r;
    i && (a = n.map((e=>b(e) ? e.trim() : e))),
    t && (a = n.map(j))
  }
  let l, u = o[l = F(t)] || o[l = F(R(t))];
  !u && i && (u = o[l = F(I(t))]),
  u && nn(u, e, 6, a);
  const c = o[l + "Once"];
  if (c) {
    if (e.emitted) {
      if (e.emitted[l])
        return
    } else
      e.emitted = {};
    e.emitted[l] = !0,
      nn(c, e, 6, a)
  }
}
function Tn(e, t, n=!1) {
  const r = t.emitsCache
    , o = r.get(e);
  if (void 0 !== o)
    return o;
  const a = e.emits;
  let i = {}
    , s = !1;
  if (!y(e)) {
    const r = e=>{
        const n = Tn(e, t, !0);
        n && (s = !0,
          c(i, n))
      }
    ;
    !n && t.mixins.length && t.mixins.forEach(r),
    e.extends && r(e.extends),
    e.mixins && e.mixins.forEach(r)
  }
  return a || s ? (h(a) ? a.forEach((e=>i[e] = null)) : c(i, a),
  x(e) && r.set(e, i),
    i) : (x(e) && r.set(e, null),
    null)
}
function Dn(e, t) {
  return !(!e || !l(t)) && (t = t.slice(2).replace(/Once$/, ""),
  p(e, t[0].toLowerCase() + t.slice(1)) || p(e, I(t)) || p(e, t))
}
let On = null
  , _n = null;
function Rn(e) {
  const t = On;
  return On = e,
    _n = e && e.type.__scopeId || null,
    t
}
function Ln(e) {
  _n = e
}
function In() {
  _n = null
}
const Pn = e=>Fn;
function Fn(e, t=On, n) {
  if (!t)
    return e;
  if (e._n)
    return e;
  const r = (...n)=>{
      r._d && Da(-1);
      const o = Rn(t);
      let a;
      try {
        a = e(...n)
      } finally {
        Rn(o),
        r._d && Da(1)
      }
      return a
    }
  ;
  return r._n = !0,
    r._c = !0,
    r._d = !0,
    r
}
function Bn(e) {
  const {type: t, vnode: n, proxy: r, withProxy: o, props: a, propsOptions: [i], slots: s, attrs: l, emit: c, render: d, renderCache: f, data: p, setupState: h, ctx: v, inheritAttrs: g} = e;
  let m, y;
  const b = Rn(e);
  try {
    if (4 & n.shapeFlag) {
      const e = o || r;
      m = Ka(d.call(e, e, f, a, h, p, v)),
        y = l
    } else {
      const e = t;
      0,
        m = Ka(e.length > 1 ? e(a, {
          attrs: l,
          slots: s,
          emit: c
        }) : e(a, null)),
        y = t.props ? l : Nn(l)
    }
  } catch (x) {
    Ea.length = 0,
      rn(x, e, 1),
      m = ja(xa)
  }
  let w = m;
  if (y && !1 !== g) {
    const e = Object.keys(y)
      , {shapeFlag: t} = w;
    e.length && 7 & t && (i && e.some(u) && (y = Mn(y, i)),
      w = Ua(w, y))
  }
  return n.dirs && (w = Ua(w),
    w.dirs = w.dirs ? w.dirs.concat(n.dirs) : n.dirs),
  n.transition && (w.transition = n.transition),
    m = w,
    Rn(b),
    m
}
const Nn = e=>{
    let t;
    for (const n in e)
      ("class" === n || "style" === n || l(n)) && ((t || (t = {}))[n] = e[n]);
    return t
  }
  , Mn = (e,t)=>{
    const n = {};
    for (const r in e)
      u(r) && r.slice(9)in t || (n[r] = e[r]);
    return n
  }
;
function jn(e, t, n) {
  const r = Object.keys(t);
  if (r.length !== Object.keys(e).length)
    return !0;
  for (let o = 0; o < r.length; o++) {
    const a = r[o];
    if (t[a] !== e[a] && !Dn(n, a))
      return !0
  }
  return !1
}
function Vn({vnode: e, parent: t}, n) {
  for (; t && t.subTree === e; )
    (e = t.vnode).el = n,
      t = t.parent
}
const Un = e=>e.__isSuspense
  , $n = {
  name: "Suspense",
  __isSuspense: !0,
  process(e, t, n, r, o, a, i, s, l, u) {
    null == e ? function(e, t, n, r, o, a, i, s, l) {
      const {p: u, o: {createElement: c}} = l
        , d = c("div")
        , f = e.suspense = zn(e, o, r, t, d, n, a, i, s, l);
      u(null, f.pendingBranch = e.ssContent, d, null, r, f, a, i),
        f.deps > 0 ? (Hn(e, "onPending"),
          Hn(e, "onFallback"),
          u(null, e.ssFallback, t, n, r, null, a, i),
          Gn(f, e.ssFallback)) : f.resolve(!1, !0)
    }(t, n, r, o, a, i, s, l, u) : function(e, t, n, r, o, a, i, s, {p: l, um: u, o: {createElement: c}}) {
      const d = t.suspense = e.suspense;
      d.vnode = t,
        t.el = e.el;
      const f = t.ssContent
        , p = t.ssFallback
        , {activeBranch: h, pendingBranch: v, isInFallback: g, isHydrating: m} = d;
      if (v)
        d.pendingBranch = f,
          Ia(f, v) ? (l(v, f, d.hiddenContainer, null, o, d, a, i, s),
            d.deps <= 0 ? d.resolve() : g && (l(h, p, n, r, o, null, a, i, s),
              Gn(d, p))) : (d.pendingId++,
            m ? (d.isHydrating = !1,
              d.activeBranch = v) : u(v, o, d),
            d.deps = 0,
            d.effects.length = 0,
            d.hiddenContainer = c("div"),
            g ? (l(null, f, d.hiddenContainer, null, o, d, a, i, s),
              d.deps <= 0 ? d.resolve() : (l(h, p, n, r, o, null, a, i, s),
                Gn(d, p))) : h && Ia(f, h) ? (l(h, f, n, r, o, d, a, i, s),
              d.resolve(!0)) : (l(null, f, d.hiddenContainer, null, o, d, a, i, s),
            d.deps <= 0 && d.resolve()));
      else if (h && Ia(f, h))
        l(h, f, n, r, o, d, a, i, s),
          Gn(d, f);
      else if (Hn(t, "onPending"),
        d.pendingBranch = f,
        d.pendingId++,
        l(null, f, d.hiddenContainer, null, o, d, a, i, s),
      d.deps <= 0)
        d.resolve();
      else {
        const {timeout: e, pendingId: t} = d;
        e > 0 ? setTimeout((()=>{
            d.pendingId === t && d.fallback(p)
          }
        ), e) : 0 === e && d.fallback(p)
      }
    }(e, t, n, r, o, i, s, l, u)
  },
  hydrate: function(e, t, n, r, o, a, i, s, l) {
    const u = t.suspense = zn(t, r, n, e.parentNode, document.createElement("div"), null, o, a, i, s, !0)
      , c = l(e, u.pendingBranch = t.ssContent, n, u, a, i);
    0 === u.deps && u.resolve(!1, !0);
    return c
  },
  create: zn,
  normalize: function(e) {
    const {shapeFlag: t, children: n} = e
      , r = 32 & t;
    e.ssContent = Kn(r ? n.default : n),
      e.ssFallback = r ? Kn(n.fallback) : ja(xa)
  }
};
function Hn(e, t) {
  const n = e.props && e.props[t];
  y(n) && n()
}
function zn(e, t, n, r, o, a, i, s, l, u, c=!1) {
  const {p: d, m: f, um: p, n: h, o: {parentNode: v, remove: g}} = u;
  let m;
  const y = function(e) {
    var t;
    return null != (null == (t = e.props) ? void 0 : t.suspensible) && !1 !== e.props.suspensible
  }(e);
  y && (null == t ? void 0 : t.pendingBranch) && (m = t.pendingId,
    t.deps++);
  const b = e.props ? V(e.props.timeout) : void 0
    , w = {
    vnode: e,
    parent: t,
    parentComponent: n,
    isSVG: i,
    container: r,
    hiddenContainer: o,
    anchor: a,
    deps: 0,
    pendingId: 0,
    timeout: "number" == typeof b ? b : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !0,
    isHydrating: c,
    isUnmounted: !1,
    effects: [],
    resolve(e=!1, n=!1) {
      const {vnode: r, activeBranch: o, pendingBranch: a, pendingId: i, effects: s, parentComponent: l, container: u} = w;
      if (w.isHydrating)
        w.isHydrating = !1;
      else if (!e) {
        const e = o && a.transition && "out-in" === a.transition.mode;
        e && (o.transition.afterLeave = ()=>{
            i === w.pendingId && f(a, u, t, 0)
          }
        );
        let {anchor: t} = w;
        o && (t = h(o),
          p(o, l, w, !0)),
        e || f(a, u, t, 0)
      }
      Gn(w, a),
        w.pendingBranch = null,
        w.isInFallback = !1;
      let c = w.parent
        , d = !1;
      for (; c; ) {
        if (c.pendingBranch) {
          c.effects.push(...s),
            d = !0;
          break
        }
        c = c.parent
      }
      d || mn(s),
        w.effects = [],
      y && t && t.pendingBranch && m === t.pendingId && (t.deps--,
      0 !== t.deps || n || t.resolve()),
        Hn(r, "onResolve")
    },
    fallback(e) {
      if (!w.pendingBranch)
        return;
      const {vnode: t, activeBranch: n, parentComponent: r, container: o, isSVG: a} = w;
      Hn(t, "onFallback");
      const i = h(n)
        , u = ()=>{
        w.isInFallback && (d(null, e, o, i, r, null, a, s, l),
          Gn(w, e))
      }
        , c = e.transition && "out-in" === e.transition.mode;
      c && (n.transition.afterLeave = u),
        w.isInFallback = !0,
        p(n, r, null, !0),
      c || u()
    },
    move(e, t, n) {
      w.activeBranch && f(w.activeBranch, e, t, n),
        w.container = e
    },
    next: ()=>w.activeBranch && h(w.activeBranch),
    registerDep(e, t) {
      const n = !!w.pendingBranch;
      n && w.deps++;
      const r = e.vnode.el;
      e.asyncDep.catch((t=>{
          rn(t, e, 0)
        }
      )).then((o=>{
          if (e.isUnmounted || w.isUnmounted || w.pendingId !== e.suspenseId)
            return;
          e.asyncResolved = !0;
          const {vnode: a} = e;
          di(e, o, !1),
          r && (a.el = r);
          const s = !r && e.subTree.el;
          t(e, a, v(r || e.subTree.el), r ? null : h(e.subTree), w, i, l),
          s && g(s),
            Vn(e, a.el),
          n && 0 == --w.deps && w.resolve()
        }
      ))
    },
    unmount(e, t) {
      w.isUnmounted = !0,
      w.activeBranch && p(w.activeBranch, n, e, t),
      w.pendingBranch && p(w.pendingBranch, n, e, t)
    }
  };
  return w
}
function Kn(e) {
  let t;
  if (y(e)) {
    const n = Ta && e._c;
    n && (e._d = !1,
      Ca()),
      e = e(),
    n && (e._d = !0,
      t = Aa,
      ka())
  }
  if (h(e)) {
    const t = function(e) {
      let t;
      for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (!La(r))
          return;
        if (r.type !== xa || "v-if" === r.children) {
          if (t)
            return;
          t = r
        }
      }
      return t
    }(e);
    e = t
  }
  return e = Ka(e),
  t && !e.dynamicChildren && (e.dynamicChildren = t.filter((t=>t !== e))),
    e
}
function Wn(e, t) {
  t && t.pendingBranch ? h(e) ? t.effects.push(...e) : t.effects.push(e) : mn(e)
}
function Gn(e, t) {
  e.activeBranch = t;
  const {vnode: n, parentComponent: r} = e
    , o = n.el = t.el;
  r && r.subTree === n && (r.vnode.el = o,
    Vn(r, o))
}
function qn(e, t) {
  return Zn(e, null, t)
}
function Yn(e, t) {
  return Zn(e, null, {
    flush: "post"
  })
}
function Xn(e, t) {
  return Zn(e, null, {
    flush: "sync"
  })
}
const Qn = {};
function Jn(e, t, n) {
  return Zn(e, t, n)
}
function Zn(e, t, {immediate: n, deep: o, flush: i, onTrack: s, onTrigger: l}=r) {
  var u;
  const c = se() === (null == (u = Za) ? void 0 : u.scope) ? Za : null;
  let f, p, v = !1, g = !1;
  if (Pt(e) ? (f = ()=>e.value,
    v = kt(e)) : At(e) ? (f = ()=>e,
    o = !0) : h(e) ? (g = !0,
    v = e.some((e=>At(e) || kt(e))),
    f = ()=>e.map((e=>Pt(e) ? e.value : At(e) ? nr(e) : y(e) ? tn(e, c, 2) : void 0))) : f = y(e) ? t ? ()=>tn(e, c, 2) : ()=>{
      if (!c || !c.isUnmounted)
        return p && p(),
          nn(e, c, 3, [b])
    }
    : a,
  t && o) {
    const e = f;
    f = ()=>nr(e())
  }
  let m, b = e=>{
      p = E.onStop = ()=>{
        tn(e, c, 4)
      }
    }
  ;
  if (ui) {
    if (b = a,
      t ? n && nn(t, c, 3, [f(), g ? [] : void 0, b]) : f(),
    "sync" !== i)
      return a;
    {
      const e = xi();
      m = e.__watcherHandles || (e.__watcherHandles = [])
    }
  }
  let w = g ? new Array(e.length).fill(Qn) : Qn;
  const x = ()=>{
      if (E.active)
        if (t) {
          const e = E.run();
          (o || v || (g ? e.some(((e,t)=>B(e, w[t]))) : B(e, w))) && (p && p(),
            nn(t, c, 3, [e, w === Qn ? void 0 : g && w[0] === Qn ? [] : w, b]),
            w = e)
        } else
          E.run()
    }
  ;
  let S;
  x.allowRecurse = !!t,
    "sync" === i ? S = x : "post" === i ? S = ()=>ia(x, c && c.suspense) : (x.pre = !0,
    c && (x.id = c.uid),
      S = ()=>vn(x));
  const E = new be(f,S);
  t ? n ? x() : w = E.run() : "post" === i ? ia(E.run.bind(E), c && c.suspense) : E.run();
  const A = ()=>{
      E.stop(),
      c && c.scope && d(c.scope.effects, E)
    }
  ;
  return m && m.push(A),
    A
}
function er(e, t, n) {
  const r = this.proxy
    , o = b(e) ? e.includes(".") ? tr(r, e) : ()=>r[e] : e.bind(r, r);
  let a;
  y(t) ? a = t : (a = t.handler,
    n = t);
  const i = Za;
  oi(this);
  const s = Zn(o, a.bind(r), n);
  return i ? oi(i) : ai(),
    s
}
function tr(e, t) {
  const n = t.split(".");
  return ()=>{
    let t = e;
    for (let e = 0; e < n.length && t; e++)
      t = t[n[e]];
    return t
  }
}
function nr(e, t) {
  if (!x(e) || e.__v_skip)
    return e;
  if ((t = t || new Set).has(e))
    return e;
  if (t.add(e),
    Pt(e))
    nr(e.value, t);
  else if (h(e))
    for (let n = 0; n < e.length; n++)
      nr(e[n], t);
  else if (g(e) || v(e))
    e.forEach((e=>{
        nr(e, t)
      }
    ));
  else if (k(e))
    for (const n in e)
      nr(e[n], t);
  return e
}
function rr(e, t) {
  const n = On;
  if (null === n)
    return e;
  const o = gi(n) || n.proxy
    , a = e.dirs || (e.dirs = []);
  for (let i = 0; i < t.length; i++) {
    let[e,n,s,l=r] = t[i];
    e && (y(e) && (e = {
      mounted: e,
      updated: e
    }),
    e.deep && nr(n),
      a.push({
        dir: e,
        instance: o,
        value: n,
        oldValue: void 0,
        arg: s,
        modifiers: l
      }))
  }
  return e
}
function or(e, t, n, r) {
  const o = e.dirs
    , a = t && t.dirs;
  for (let i = 0; i < o.length; i++) {
    const s = o[i];
    a && (s.oldValue = a[i].value);
    let l = s.dir[r];
    l && (Ce(),
      nn(l, n, 8, [e.el, s, e, t]),
      ke())
  }
}
function ar() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: new Map
  };
  return Lr((()=>{
      e.isMounted = !0
    }
  )),
    Fr((()=>{
        e.isUnmounting = !0
      }
    )),
    e
}
const ir = [Function, Array]
  , sr = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  onBeforeEnter: ir,
  onEnter: ir,
  onAfterEnter: ir,
  onEnterCancelled: ir,
  onBeforeLeave: ir,
  onLeave: ir,
  onAfterLeave: ir,
  onLeaveCancelled: ir,
  onBeforeAppear: ir,
  onAppear: ir,
  onAfterAppear: ir,
  onAppearCancelled: ir
}
  , lr = {
  name: "BaseTransition",
  props: sr,
  setup(e, {slots: t}) {
    const n = ei()
      , r = ar();
    let o;
    return ()=>{
      const a = t.default && hr(t.default(), !0);
      if (!a || !a.length)
        return;
      let i = a[0];
      if (a.length > 1)
        for (const e of a)
          if (e.type !== xa) {
            i = e;
            break
          }
      const s = Dt(e)
        , {mode: l} = s;
      if (r.isLeaving)
        return dr(i);
      const u = fr(i);
      if (!u)
        return dr(i);
      const c = cr(u, s, r, n);
      pr(u, c);
      const d = n.subTree
        , f = d && fr(d);
      let p = !1;
      const {getTransitionKey: h} = u.type;
      if (h) {
        const e = h();
        void 0 === o ? o = e : e !== o && (o = e,
          p = !0)
      }
      if (f && f.type !== xa && (!Ia(u, f) || p)) {
        const e = cr(f, s, r, n);
        if (pr(f, e),
        "out-in" === l)
          return r.isLeaving = !0,
            e.afterLeave = ()=>{
              r.isLeaving = !1,
              !1 !== n.update.active && n.update()
            }
            ,
            dr(i);
        "in-out" === l && u.type !== xa && (e.delayLeave = (e,t,n)=>{
            ur(r, f)[String(f.key)] = f,
              e._leaveCb = ()=>{
                t(),
                  e._leaveCb = void 0,
                  delete c.delayedLeave
              }
              ,
              c.delayedLeave = n
          }
        )
      }
      return i
    }
  }
};
function ur(e, t) {
  const {leavingVNodes: n} = e;
  let r = n.get(t.type);
  return r || (r = Object.create(null),
    n.set(t.type, r)),
    r
}
function cr(e, t, n, r) {
  const {appear: o, mode: a, persisted: i=!1, onBeforeEnter: s, onEnter: l, onAfterEnter: u, onEnterCancelled: c, onBeforeLeave: d, onLeave: f, onAfterLeave: p, onLeaveCancelled: v, onBeforeAppear: g, onAppear: m, onAfterAppear: y, onAppearCancelled: b} = t
    , w = String(e.key)
    , x = ur(n, e)
    , S = (e,t)=>{
    e && nn(e, r, 9, t)
  }
    , E = (e,t)=>{
    const n = t[1];
    S(e, t),
      h(e) ? e.every((e=>e.length <= 1)) && n() : e.length <= 1 && n()
  }
    , A = {
    mode: a,
    persisted: i,
    beforeEnter(t) {
      let r = s;
      if (!n.isMounted) {
        if (!o)
          return;
        r = g || s
      }
      t._leaveCb && t._leaveCb(!0);
      const a = x[w];
      a && Ia(e, a) && a.el._leaveCb && a.el._leaveCb(),
        S(r, [t])
    },
    enter(e) {
      let t = l
        , r = u
        , a = c;
      if (!n.isMounted) {
        if (!o)
          return;
        t = m || l,
          r = y || u,
          a = b || c
      }
      let i = !1;
      const s = e._enterCb = t=>{
          i || (i = !0,
            S(t ? a : r, [e]),
          A.delayedLeave && A.delayedLeave(),
            e._enterCb = void 0)
        }
      ;
      t ? E(t, [e, s]) : s()
    },
    leave(t, r) {
      const o = String(e.key);
      if (t._enterCb && t._enterCb(!0),
        n.isUnmounting)
        return r();
      S(d, [t]);
      let a = !1;
      const i = t._leaveCb = n=>{
          a || (a = !0,
            r(),
            S(n ? v : p, [t]),
            t._leaveCb = void 0,
          x[o] === e && delete x[o])
        }
      ;
      x[o] = e,
        f ? E(f, [t, i]) : i()
    },
    clone: e=>cr(e, t, n, r)
  };
  return A
}
function dr(e) {
  if (br(e))
    return (e = Ua(e)).children = null,
      e
}
function fr(e) {
  return br(e) ? e.children ? e.children[0] : void 0 : e
}
function pr(e, t) {
  6 & e.shapeFlag && e.component ? pr(e.component.subTree, t) : 128 & e.shapeFlag ? (e.ssContent.transition = t.clone(e.ssContent),
    e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function hr(e, t=!1, n) {
  let r = []
    , o = 0;
  for (let a = 0; a < e.length; a++) {
    let i = e[a];
    const s = null == n ? i.key : String(n) + String(null != i.key ? i.key : a);
    i.type === ba ? (128 & i.patchFlag && o++,
      r = r.concat(hr(i.children, t, s))) : (t || i.type !== xa) && r.push(null != s ? Ua(i, {
      key: s
    }) : i)
  }
  if (o > 1)
    for (let a = 0; a < r.length; a++)
      r[a].patchFlag = -2;
  return r
}
function vr(e, t) {
  return y(e) ? (()=>c({
    name: e.name
  }, t, {
    setup: e
  }))() : e
}
const gr = e=>!!e.type.__asyncLoader;
function mr(e) {
  y(e) && (e = {
    loader: e
  });
  const {loader: t, loadingComponent: n, errorComponent: r, delay: o=200, timeout: a, suspensible: i=!0, onError: s} = e;
  let l, u = null, c = 0;
  const d = ()=>{
      let e;
      return u || (e = u = t().catch((e=>{
          if (e = e instanceof Error ? e : new Error(String(e)),
            s)
            return new Promise(((t,n)=>{
                s(e, (()=>t((c++,
                  u = null,
                  d()))), (()=>n(e)), c + 1)
              }
            ));
          throw e
        }
      )).then((t=>e !== u && u ? u : (t && (t.__esModule || "Module" === t[Symbol.toStringTag]) && (t = t.default),
        l = t,
        t))))
    }
  ;
  return vr({
    name: "AsyncComponentWrapper",
    __asyncLoader: d,
    get __asyncResolved() {
      return l
    },
    setup() {
      const e = Za;
      if (l)
        return ()=>yr(l, e);
      const t = t=>{
          u = null,
            rn(t, e, 13, !r)
        }
      ;
      if (i && e.suspense || ui)
        return d().then((t=>()=>yr(t, e))).catch((e=>(t(e),
          ()=>r ? ja(r, {
            error: e
          }) : null)));
      const s = Ft(!1)
        , c = Ft()
        , f = Ft(!!o);
      return o && setTimeout((()=>{
          f.value = !1
        }
      ), o),
      null != a && setTimeout((()=>{
          if (!s.value && !c.value) {
            const e = new Error(`Async component timed out after ${a}ms.`);
            t(e),
              c.value = e
          }
        }
      ), a),
        d().then((()=>{
            s.value = !0,
            e.parent && br(e.parent.vnode) && vn(e.parent.update)
          }
        )).catch((e=>{
            t(e),
              c.value = e
          }
        )),
        ()=>s.value && l ? yr(l, e) : c.value && r ? ja(r, {
          error: c.value
        }) : n && !f.value ? ja(n) : void 0
    }
  })
}
function yr(e, t) {
  const {ref: n, props: r, children: o, ce: a} = t.vnode
    , i = ja(e, r, o);
  return i.ref = n,
    i.ce = a,
    delete t.vnode.ce,
    i
}
const br = e=>e.type.__isKeepAlive
  , wr = {
  name: "KeepAlive",
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(e, {slots: t}) {
    const n = ei()
      , r = n.ctx;
    if (!r.renderer)
      return ()=>{
        const e = t.default && t.default();
        return e && 1 === e.length ? e[0] : e
      }
        ;
    const o = new Map
      , a = new Set;
    let i = null;
    const s = n.suspense
      , {renderer: {p: l, m: u, um: c, o: {createElement: d}}} = r
      , f = d("div");
    function p(e) {
      Tr(e),
        c(e, n, s, !0)
    }
    function h(e) {
      o.forEach(((t,n)=>{
          const r = mi(t.type);
          !r || e && e(r) || v(n)
        }
      ))
    }
    function v(e) {
      const t = o.get(e);
      i && Ia(t, i) ? i && Tr(i) : p(t),
        o.delete(e),
        a.delete(e)
    }
    r.activate = (e,t,n,r,o)=>{
      const a = e.component;
      u(e, t, n, 0, s),
        l(a.vnode, e, t, n, a, s, r, e.slotScopeIds, o),
        ia((()=>{
            a.isDeactivated = !1,
            a.a && N(a.a);
            const t = e.props && e.props.onVnodeMounted;
            t && Ya(t, a.parent, e)
          }
        ), s)
    }
      ,
      r.deactivate = e=>{
        const t = e.component;
        u(e, f, null, 1, s),
          ia((()=>{
              t.da && N(t.da);
              const n = e.props && e.props.onVnodeUnmounted;
              n && Ya(n, t.parent, e),
                t.isDeactivated = !0
            }
          ), s)
      }
      ,
      Jn((()=>[e.include, e.exclude]), (([e,t])=>{
          e && h((t=>Sr(e, t))),
          t && h((e=>!Sr(t, e)))
        }
      ), {
        flush: "post",
        deep: !0
      });
    let g = null;
    const m = ()=>{
        null != g && o.set(g, Dr(n.subTree))
      }
    ;
    return Lr(m),
      Pr(m),
      Fr((()=>{
          o.forEach((e=>{
              const {subTree: t, suspense: r} = n
                , o = Dr(t);
              if (e.type !== o.type || e.key !== o.key)
                p(e);
              else {
                Tr(o);
                const e = o.component.da;
                e && ia(e, r)
              }
            }
          ))
        }
      )),
      ()=>{
        if (g = null,
          !t.default)
          return null;
        const n = t.default()
          , r = n[0];
        if (n.length > 1)
          return i = null,
            n;
        if (!(La(r) && (4 & r.shapeFlag || 128 & r.shapeFlag)))
          return i = null,
            r;
        let s = Dr(r);
        const l = s.type
          , u = mi(gr(s) ? s.type.__asyncResolved || {} : l)
          , {include: c, exclude: d, max: f} = e;
        if (c && (!u || !Sr(c, u)) || d && u && Sr(d, u))
          return i = s,
            r;
        const p = null == s.key ? l : s.key
          , h = o.get(p);
        return s.el && (s = Ua(s),
        128 & r.shapeFlag && (r.ssContent = s)),
          g = p,
          h ? (s.el = h.el,
            s.component = h.component,
          s.transition && pr(s, s.transition),
            s.shapeFlag |= 512,
            a.delete(p),
            a.add(p)) : (a.add(p),
          f && a.size > parseInt(f, 10) && v(a.values().next().value)),
          s.shapeFlag |= 256,
          i = s,
          Un(r.type) ? r : s
      }
  }
}
  , xr = wr;
function Sr(e, t) {
  return h(e) ? e.some((e=>Sr(e, t))) : b(e) ? e.split(",").includes(t) : "[object RegExp]" === A(e) && e.test(t)
}
function Er(e, t) {
  Cr(e, "a", t)
}
function Ar(e, t) {
  Cr(e, "da", t)
}
function Cr(e, t, n=Za) {
  const r = e.__wdc || (e.__wdc = ()=>{
      let t = n;
      for (; t; ) {
        if (t.isDeactivated)
          return;
        t = t.parent
      }
      return e()
    }
  );
  if (Or(t, r, n),
    n) {
    let e = n.parent;
    for (; e && e.parent; )
      br(e.parent.vnode) && kr(r, t, n, e),
        e = e.parent
  }
}
function kr(e, t, n, r) {
  const o = Or(t, e, r, !0);
  Br((()=>{
      d(r[t], o)
    }
  ), n)
}
function Tr(e) {
  e.shapeFlag &= -257,
    e.shapeFlag &= -513
}
function Dr(e) {
  return 128 & e.shapeFlag ? e.ssContent : e
}
function Or(e, t, n=Za, r=!1) {
  if (n) {
    const o = n[e] || (n[e] = [])
      , a = t.__weh || (t.__weh = (...r)=>{
        if (n.isUnmounted)
          return;
        Ce(),
          oi(n);
        const o = nn(t, n, e, r);
        return ai(),
          ke(),
          o
      }
    );
    return r ? o.unshift(a) : o.push(a),
      a
  }
}
const _r = e=>(t,n=Za)=>(!ui || "sp" === e) && Or(e, ((...e)=>t(...e)), n)
  , Rr = _r("bm")
  , Lr = _r("m")
  , Ir = _r("bu")
  , Pr = _r("u")
  , Fr = _r("bum")
  , Br = _r("um")
  , Nr = _r("sp")
  , Mr = _r("rtg")
  , jr = _r("rtc");
function Vr(e, t=Za) {
  Or("ec", e, t)
}
const Ur = "components"
  , $r = "directives";
function Hr(e, t) {
  return Gr(Ur, e, !0, t) || e
}
const zr = Symbol.for("v-ndc");
function Kr(e) {
  return b(e) ? Gr(Ur, e, !1) || e : e || zr
}
function Wr(e) {
  return Gr($r, e)
}
function Gr(e, t, n=!0, r=!1) {
  const o = On || Za;
  if (o) {
    const n = o.type;
    if (e === Ur) {
      const e = mi(n, !1);
      if (e && (e === t || e === R(t) || e === P(R(t))))
        return n
    }
    const a = qr(o[e] || n[e], t) || qr(o.appContext[e], t);
    return !a && r ? n : a
  }
}
function qr(e, t) {
  return e && (e[t] || e[R(t)] || e[P(R(t))])
}
function Yr(e, t, n, r) {
  let o;
  const a = n && n[r];
  if (h(e) || b(e)) {
    o = new Array(e.length);
    for (let n = 0, r = e.length; n < r; n++)
      o[n] = t(e[n], n, void 0, a && a[n])
  } else if ("number" == typeof e) {
    o = new Array(e);
    for (let n = 0; n < e; n++)
      o[n] = t(n + 1, n, void 0, a && a[n])
  } else if (x(e))
    if (e[Symbol.iterator])
      o = Array.from(e, ((e,n)=>t(e, n, void 0, a && a[n])));
    else {
      const n = Object.keys(e);
      o = new Array(n.length);
      for (let r = 0, i = n.length; r < i; r++) {
        const i = n[r];
        o[r] = t(e[i], i, r, a && a[r])
      }
    }
  else
    o = [];
  return n && (n[r] = o),
    o
}
function Xr(e, t) {
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (h(r))
      for (let t = 0; t < r.length; t++)
        e[r[t].name] = r[t].fn;
    else
      r && (e[r.name] = r.key ? (...e)=>{
          const t = r.fn(...e);
          return t && (t.key = r.key),
            t
        }
        : r.fn)
  }
  return e
}
function Qr(e, t, n={}, r, o) {
  if (On.isCE || On.parent && gr(On.parent) && On.parent.isCE)
    return "default" !== t && (n.name = t),
      ja("slot", n, r && r());
  let a = e[t];
  a && a._c && (a._d = !1),
    Ca();
  const i = a && Jr(a(n))
    , s = Ra(ba, {
    key: n.key || i && i.key || `_${t}`
  }, i || (r ? r() : []), i && 1 === e._ ? 64 : -2);
  return !o && s.scopeId && (s.slotScopeIds = [s.scopeId + "-s"]),
  a && a._c && (a._d = !0),
    s
}
function Jr(e) {
  return e.some((e=>!La(e) || e.type !== xa && !(e.type === ba && !Jr(e.children)))) ? e : null
}
function Zr(e, t) {
  const n = {};
  for (const r in e)
    n[t && /[A-Z]/.test(r) ? `on:${r}` : F(r)] = e[r];
  return n
}
const eo = e=>e ? ii(e) ? gi(e) || e.proxy : eo(e.parent) : null
  , to = c(Object.create(null), {
  $: e=>e,
  $el: e=>e.vnode.el,
  $data: e=>e.data,
  $props: e=>e.props,
  $attrs: e=>e.attrs,
  $slots: e=>e.slots,
  $refs: e=>e.refs,
  $parent: e=>eo(e.parent),
  $root: e=>eo(e.root),
  $emit: e=>e.emit,
  $options: e=>ko(e),
  $forceUpdate: e=>e.f || (e.f = ()=>vn(e.update)),
  $nextTick: e=>e.n || (e.n = hn.bind(e.proxy)),
  $watch: e=>er.bind(e)
})
  , no = (e,t)=>e !== r && !e.__isScriptSetup && p(e, t)
  , ro = {
  get({_: e}, t) {
    const {ctx: n, setupState: o, data: a, props: i, accessCache: s, type: l, appContext: u} = e;
    let c;
    if ("$" !== t[0]) {
      const l = s[t];
      if (void 0 !== l)
        switch (l) {
          case 1:
            return o[t];
          case 2:
            return a[t];
          case 4:
            return n[t];
          case 3:
            return i[t]
        }
      else {
        if (no(o, t))
          return s[t] = 1,
            o[t];
        if (a !== r && p(a, t))
          return s[t] = 2,
            a[t];
        if ((c = e.propsOptions[0]) && p(c, t))
          return s[t] = 3,
            i[t];
        if (n !== r && p(n, t))
          return s[t] = 4,
            n[t];
        So && (s[t] = 0)
      }
    }
    const d = to[t];
    let f, h;
    return d ? ("$attrs" === t && Te(e, 0, t),
      d(e)) : (f = l.__cssModules) && (f = f[t]) ? f : n !== r && p(n, t) ? (s[t] = 4,
      n[t]) : (h = u.config.globalProperties,
      p(h, t) ? h[t] : void 0)
  },
  set({_: e}, t, n) {
    const {data: o, setupState: a, ctx: i} = e;
    return no(a, t) ? (a[t] = n,
      !0) : o !== r && p(o, t) ? (o[t] = n,
      !0) : !p(e.props, t) && (("$" !== t[0] || !(t.slice(1)in e)) && (i[t] = n,
      !0))
  },
  has({_: {data: e, setupState: t, accessCache: n, ctx: o, appContext: a, propsOptions: i}}, s) {
    let l;
    return !!n[s] || e !== r && p(e, s) || no(t, s) || (l = i[0]) && p(l, s) || p(o, s) || p(to, s) || p(a.config.globalProperties, s)
  },
  defineProperty(e, t, n) {
    return null != n.get ? e._.accessCache[t] = 0 : p(n, "value") && this.set(e, t, n.value, null),
      Reflect.defineProperty(e, t, n)
  }
}
  , oo = c({}, ro, {
  get(e, t) {
    if (t !== Symbol.unscopables)
      return ro.get(e, t, e)
  },
  has: (e,t)=>"_" !== t[0] && !H(t)
});
function ao() {
  return null
}
function io() {
  return null
}
function so(e) {}
function lo(e) {}
function uo() {
  return null
}
function co() {}
function fo(e, t) {
  return null
}
function po() {
  return go().slots
}
function ho() {
  return go().attrs
}
function vo(e, t, n) {
  const r = ei();
  if (n && n.local) {
    const n = Ft(e[t]);
    return Jn((()=>e[t]), (e=>n.value = e)),
      Jn(n, (n=>{
          n !== e[t] && r.emit(`update:${t}`, n)
        }
      )),
      n
  }
  return {
    __v_isRef: !0,
    get value() {
      return e[t]
    },
    set value(e) {
      r.emit(`update:${t}`, e)
    }
  }
}
function go() {
  const e = ei();
  return e.setupContext || (e.setupContext = vi(e))
}
function mo(e) {
  return h(e) ? e.reduce(((e,t)=>(e[t] = null,
    e)), {}) : e
}
function yo(e, t) {
  const n = mo(e);
  for (const r in t) {
    if (r.startsWith("__skip"))
      continue;
    let e = n[r];
    e ? h(e) || y(e) ? e = n[r] = {
      type: e,
      default: t[r]
    } : e.default = t[r] : null === e && (e = n[r] = {
      default: t[r]
    }),
    e && t[`__skip_${r}`] && (e.skipFactory = !0)
  }
  return n
}
function bo(e, t) {
  return e && t ? h(e) && h(t) ? e.concat(t) : c({}, mo(e), mo(t)) : e || t
}
function wo(e, t) {
  const n = {};
  for (const r in e)
    t.includes(r) || Object.defineProperty(n, r, {
      enumerable: !0,
      get: ()=>e[r]
    });
  return n
}
function xo(e) {
  const t = ei();
  let n = e();
  return ai(),
  S(n) && (n = n.catch((e=>{
      throw oi(t),
        e
    }
  ))),
    [n, ()=>oi(t)]
}
let So = !0;
function Eo(e) {
  const t = ko(e)
    , n = e.proxy
    , r = e.ctx;
  So = !1,
  t.beforeCreate && Ao(t.beforeCreate, e, "bc");
  const {data: o, computed: i, methods: s, watch: l, provide: u, inject: c, created: d, beforeMount: f, mounted: p, beforeUpdate: v, updated: g, activated: m, deactivated: b, beforeDestroy: w, beforeUnmount: S, destroyed: E, unmounted: A, render: C, renderTracked: k, renderTriggered: T, errorCaptured: D, serverPrefetch: O, expose: _, inheritAttrs: R, components: L, directives: I, filters: P} = t;
  if (c && function(e, t, n=a) {
    h(e) && (e = _o(e));
    for (const r in e) {
      const n = e[r];
      let o;
      o = x(n) ? "default"in n ? jo(n.from || r, n.default, !0) : jo(n.from || r) : jo(n),
        Pt(o) ? Object.defineProperty(t, r, {
          enumerable: !0,
          configurable: !0,
          get: ()=>o.value,
          set: e=>o.value = e
        }) : t[r] = o
    }
  }(c, r, null),
    s)
    for (const a in s) {
      const e = s[a];
      y(e) && (r[a] = e.bind(n))
    }
  if (o) {
    const t = o.call(n, n);
    x(t) && (e.data = bt(t))
  }
  if (So = !0,
    i)
    for (const h in i) {
      const e = i[h]
        , t = y(e) ? e.bind(n, n) : y(e.get) ? e.get.bind(n, n) : a
        , o = !y(e) && y(e.set) ? e.set.bind(n) : a
        , s = yi({
        get: t,
        set: o
      });
      Object.defineProperty(r, h, {
        enumerable: !0,
        configurable: !0,
        get: ()=>s.value,
        set: e=>s.value = e
      })
    }
  if (l)
    for (const a in l)
      Co(l[a], r, n, a);
  if (u) {
    const e = y(u) ? u.call(n) : u;
    Reflect.ownKeys(e).forEach((t=>{
        Mo(t, e[t])
      }
    ))
  }
  function F(e, t) {
    h(t) ? t.forEach((t=>e(t.bind(n)))) : t && e(t.bind(n))
  }
  if (d && Ao(d, e, "c"),
    F(Rr, f),
    F(Lr, p),
    F(Ir, v),
    F(Pr, g),
    F(Er, m),
    F(Ar, b),
    F(Vr, D),
    F(jr, k),
    F(Mr, T),
    F(Fr, S),
    F(Br, A),
    F(Nr, O),
    h(_))
    if (_.length) {
      const t = e.exposed || (e.exposed = {});
      _.forEach((e=>{
          Object.defineProperty(t, e, {
            get: ()=>n[e],
            set: t=>n[e] = t
          })
        }
      ))
    } else
      e.exposed || (e.exposed = {});
  C && e.render === a && (e.render = C),
  null != R && (e.inheritAttrs = R),
  L && (e.components = L),
  I && (e.directives = I)
}
function Ao(e, t, n) {
  nn(h(e) ? e.map((e=>e.bind(t.proxy))) : e.bind(t.proxy), t, n)
}
function Co(e, t, n, r) {
  const o = r.includes(".") ? tr(n, r) : ()=>n[r];
  if (b(e)) {
    const n = t[e];
    y(n) && Jn(o, n)
  } else if (y(e))
    Jn(o, e.bind(n));
  else if (x(e))
    if (h(e))
      e.forEach((e=>Co(e, t, n, r)));
    else {
      const r = y(e.handler) ? e.handler.bind(n) : t[e.handler];
      y(r) && Jn(o, r, e)
    }
}
function ko(e) {
  const t = e.type
    , {mixins: n, extends: r} = t
    , {mixins: o, optionsCache: a, config: {optionMergeStrategies: i}} = e.appContext
    , s = a.get(t);
  let l;
  return s ? l = s : o.length || n || r ? (l = {},
  o.length && o.forEach((e=>To(l, e, i, !0))),
    To(l, t, i)) : l = t,
  x(t) && a.set(t, l),
    l
}
function To(e, t, n, r=!1) {
  const {mixins: o, extends: a} = t;
  a && To(e, a, n, !0),
  o && o.forEach((t=>To(e, t, n, !0)));
  for (const i in t)
    if (r && "expose" === i)
      ;
    else {
      const r = Do[i] || n && n[i];
      e[i] = r ? r(e[i], t[i]) : t[i]
    }
  return e
}
const Do = {
  data: Oo,
  props: Io,
  emits: Io,
  methods: Lo,
  computed: Lo,
  beforeCreate: Ro,
  created: Ro,
  beforeMount: Ro,
  mounted: Ro,
  beforeUpdate: Ro,
  updated: Ro,
  beforeDestroy: Ro,
  beforeUnmount: Ro,
  destroyed: Ro,
  unmounted: Ro,
  activated: Ro,
  deactivated: Ro,
  errorCaptured: Ro,
  serverPrefetch: Ro,
  components: Lo,
  directives: Lo,
  watch: function(e, t) {
    if (!e)
      return t;
    if (!t)
      return e;
    const n = c(Object.create(null), e);
    for (const r in t)
      n[r] = Ro(e[r], t[r]);
    return n
  },
  provide: Oo,
  inject: function(e, t) {
    return Lo(_o(e), _o(t))
  }
};
function Oo(e, t) {
  return t ? e ? function() {
      return c(y(e) ? e.call(this, this) : e, y(t) ? t.call(this, this) : t)
    }
    : t : e
}
function _o(e) {
  if (h(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++)
      t[e[n]] = e[n];
    return t
  }
  return e
}
function Ro(e, t) {
  return e ? [...new Set([].concat(e, t))] : t
}
function Lo(e, t) {
  return e ? c(Object.create(null), e, t) : t
}
function Io(e, t) {
  return e ? h(e) && h(t) ? [...new Set([...e, ...t])] : c(Object.create(null), mo(e), mo(null != t ? t : {})) : t
}
function Po() {
  return {
    app: null,
    config: {
      isNativeTag: i,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap,
    propsCache: new WeakMap,
    emitsCache: new WeakMap
  }
}
let Fo = 0;
function Bo(e, t) {
  return function(n, r=null) {
    y(n) || (n = c({}, n)),
    null == r || x(r) || (r = null);
    const o = Po()
      , a = new Set;
    let i = !1;
    const s = o.app = {
      _uid: Fo++,
      _component: n,
      _props: r,
      _container: null,
      _context: o,
      _instance: null,
      version: Ci,
      get config() {
        return o.config
      },
      set config(e) {},
      use: (e,...t)=>(a.has(e) || (e && y(e.install) ? (a.add(e),
        e.install(s, ...t)) : y(e) && (a.add(e),
        e(s, ...t))),
        s),
      mixin: e=>(o.mixins.includes(e) || o.mixins.push(e),
        s),
      component: (e,t)=>t ? (o.components[e] = t,
        s) : o.components[e],
      directive: (e,t)=>t ? (o.directives[e] = t,
        s) : o.directives[e],
      mount(a, l, u) {
        if (!i) {
          const c = ja(n, r);
          return c.appContext = o,
            l && t ? t(c, a) : e(c, a, u),
            i = !0,
            s._container = a,
            a.__vue_app__ = s,
          gi(c.component) || c.component.proxy
        }
      },
      unmount() {
        i && (e(null, s._container),
          delete s._container.__vue_app__)
      },
      provide: (e,t)=>(o.provides[e] = t,
        s),
      runWithContext(e) {
        No = s;
        try {
          return e()
        } finally {
          No = null
        }
      }
    };
    return s
  }
}
let No = null;
function Mo(e, t) {
  if (Za) {
    let n = Za.provides;
    const r = Za.parent && Za.parent.provides;
    r === n && (n = Za.provides = Object.create(r)),
      n[e] = t
  } else
    ;
}
function jo(e, t, n=!1) {
  const r = Za || On;
  if (r || No) {
    const o = r ? null == r.parent ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : No._context.provides;
    if (o && e in o)
      return o[e];
    if (arguments.length > 1)
      return n && y(t) ? t.call(r && r.proxy) : t
  }
}
function Vo() {
  return !!(Za || On || No)
}
function Uo(e, t, n, o) {
  const [a,i] = e.propsOptions;
  let s, l = !1;
  if (t)
    for (let r in t) {
      if (D(r))
        continue;
      const u = t[r];
      let c;
      a && p(a, c = R(r)) ? i && i.includes(c) ? (s || (s = {}))[c] = u : n[c] = u : Dn(e.emitsOptions, r) || r in o && u === o[r] || (o[r] = u,
        l = !0)
    }
  if (i) {
    const t = Dt(n)
      , o = s || r;
    for (let r = 0; r < i.length; r++) {
      const s = i[r];
      n[s] = $o(a, t, s, o[s], e, !p(o, s))
    }
  }
  return l
}
function $o(e, t, n, r, o, a) {
  const i = e[n];
  if (null != i) {
    const e = p(i, "default");
    if (e && void 0 === r) {
      const e = i.default;
      if (i.type !== Function && !i.skipFactory && y(e)) {
        const {propsDefaults: a} = o;
        n in a ? r = a[n] : (oi(o),
          r = a[n] = e.call(null, t),
          ai())
      } else
        r = e
    }
    i[0] && (a && !e ? r = !1 : !i[1] || "" !== r && r !== I(n) || (r = !0))
  }
  return r
}
function Ho(e, t, n=!1) {
  const a = t.propsCache
    , i = a.get(e);
  if (i)
    return i;
  const s = e.props
    , l = {}
    , u = [];
  let d = !1;
  if (!y(e)) {
    const r = e=>{
        d = !0;
        const [n,r] = Ho(e, t, !0);
        c(l, n),
        r && u.push(...r)
      }
    ;
    !n && t.mixins.length && t.mixins.forEach(r),
    e.extends && r(e.extends),
    e.mixins && e.mixins.forEach(r)
  }
  if (!s && !d)
    return x(e) && a.set(e, o),
      o;
  if (h(s))
    for (let o = 0; o < s.length; o++) {
      const e = R(s[o]);
      zo(e) && (l[e] = r)
    }
  else if (s)
    for (const r in s) {
      const e = R(r);
      if (zo(e)) {
        const t = s[r]
          , n = l[e] = h(t) || y(t) ? {
          type: t
        } : c({}, t);
        if (n) {
          const t = Go(Boolean, n.type)
            , r = Go(String, n.type);
          n[0] = t > -1,
            n[1] = r < 0 || t < r,
          (t > -1 || p(n, "default")) && u.push(e)
        }
      }
    }
  const f = [l, u];
  return x(e) && a.set(e, f),
    f
}
function zo(e) {
  return "$" !== e[0]
}
function Ko(e) {
  const t = e && e.toString().match(/^\s*(function|class) (\w+)/);
  return t ? t[2] : null === e ? "null" : ""
}
function Wo(e, t) {
  return Ko(e) === Ko(t)
}
function Go(e, t) {
  return h(t) ? t.findIndex((t=>Wo(t, e))) : y(t) && Wo(t, e) ? 0 : -1
}
const qo = e=>"_" === e[0] || "$stable" === e
  , Yo = e=>h(e) ? e.map(Ka) : [Ka(e)]
  , Xo = (e,t,n)=>{
    if (t._n)
      return t;
    const r = Fn(((...e)=>Yo(t(...e))), n);
    return r._c = !1,
      r
  }
  , Qo = (e,t,n)=>{
    const r = e._ctx;
    for (const o in e) {
      if (qo(o))
        continue;
      const n = e[o];
      if (y(n))
        t[o] = Xo(0, n, r);
      else if (null != n) {
        const e = Yo(n);
        t[o] = ()=>e
      }
    }
  }
  , Jo = (e,t)=>{
    const n = Yo(t);
    e.slots.default = ()=>n
  }
  , Zo = (e,t)=>{
    if (32 & e.vnode.shapeFlag) {
      const n = t._;
      n ? (e.slots = Dt(t),
        M(t, "_", n)) : Qo(t, e.slots = {})
    } else
      e.slots = {},
      t && Jo(e, t);
    M(e.slots, Fa, 1)
  }
  , ea = (e,t,n)=>{
    const {vnode: o, slots: a} = e;
    let i = !0
      , s = r;
    if (32 & o.shapeFlag) {
      const e = t._;
      e ? n && 1 === e ? i = !1 : (c(a, t),
      n || 1 !== e || delete a._) : (i = !t.$stable,
        Qo(t, a)),
        s = t
    } else
      t && (Jo(e, t),
        s = {
          default: 1
        });
    if (i)
      for (const r in a)
        qo(r) || r in s || delete a[r]
  }
;
function ta(e, t, n, o, a=!1) {
  if (h(e))
    return void e.forEach(((e,r)=>ta(e, t && (h(t) ? t[r] : t), n, o, a)));
  if (gr(o) && !a)
    return;
  const i = 4 & o.shapeFlag ? gi(o.component) || o.component.proxy : o.el
    , s = a ? null : i
    , {i: l, r: u} = e
    , c = t && t.r
    , f = l.refs === r ? l.refs = {} : l.refs
    , v = l.setupState;
  if (null != c && c !== u && (b(c) ? (f[c] = null,
  p(v, c) && (v[c] = null)) : Pt(c) && (c.value = null)),
    y(u))
    tn(u, l, 12, [s, f]);
  else {
    const t = b(u)
      , r = Pt(u);
    if (t || r) {
      const o = ()=>{
          if (e.f) {
            const n = t ? p(v, u) ? v[u] : f[u] : u.value;
            a ? h(n) && d(n, i) : h(n) ? n.includes(i) || n.push(i) : t ? (f[u] = [i],
            p(v, u) && (v[u] = f[u])) : (u.value = [i],
            e.k && (f[e.k] = u.value))
          } else
            t ? (f[u] = s,
            p(v, u) && (v[u] = s)) : r && (u.value = s,
            e.k && (f[e.k] = s))
        }
      ;
      s ? (o.id = -1,
        ia(o, n)) : o()
    }
  }
}
let na = !1;
const ra = e=>/svg/.test(e.namespaceURI) && "foreignObject" !== e.tagName
  , oa = e=>8 === e.nodeType;
function aa(e) {
  const {mt: t, p: n, o: {patchProp: r, createText: o, nextSibling: a, parentNode: i, remove: s, insert: u, createComment: c}} = e
    , d = (n,r,s,l,c,m=!1)=>{
      const y = oa(n) && "[" === n.data
        , b = ()=>v(n, r, s, l, c, y)
        , {type: w, ref: x, shapeFlag: S, patchFlag: E} = r;
      let A = n.nodeType;
      r.el = n,
      -2 === E && (m = !1,
        r.dynamicChildren = null);
      let C = null;
      switch (w) {
        case wa:
          3 !== A ? "" === r.children ? (u(r.el = o(""), i(n), n),
            C = n) : C = b() : (n.data !== r.children && (na = !0,
            n.data = r.children),
            C = a(n));
          break;
        case xa:
          C = 8 !== A || y ? b() : a(n);
          break;
        case Sa:
          if (y && (A = (n = a(n)).nodeType),
          1 === A || 3 === A) {
            C = n;
            const e = !r.children.length;
            for (let t = 0; t < r.staticCount; t++)
              e && (r.children += 1 === C.nodeType ? C.outerHTML : C.data),
              t === r.staticCount - 1 && (r.anchor = C),
                C = a(C);
            return y ? a(C) : C
          }
          b();
          break;
        case ba:
          C = y ? h(n, r, s, l, c, m) : b();
          break;
        default:
          if (1 & S)
            C = 1 !== A || r.type.toLowerCase() !== n.tagName.toLowerCase() ? b() : f(n, r, s, l, c, m);
          else if (6 & S) {
            r.slotScopeIds = c;
            const e = i(n);
            if (t(r, e, null, s, l, ra(e), m),
              C = y ? g(n) : a(n),
            C && oa(C) && "teleport end" === C.data && (C = a(C)),
              gr(r)) {
              let t;
              y ? (t = ja(ba),
                t.anchor = C ? C.previousSibling : e.lastChild) : t = 3 === n.nodeType ? $a("") : ja("div"),
                t.el = n,
                r.component.subTree = t
            }
          } else
            64 & S ? C = 8 !== A ? b() : r.type.hydrate(n, r, s, l, c, m, e, p) : 128 & S && (C = r.type.hydrate(n, r, s, l, ra(i(n)), c, m, e, d))
      }
      return null != x && ta(x, null, l, r),
        C
    }
    , f = (e,t,n,o,a,i)=>{
      i = i || !!t.dynamicChildren;
      const {type: u, props: c, patchFlag: d, shapeFlag: f, dirs: h} = t
        , v = "input" === u && h || "option" === u;
      if (v || -1 !== d) {
        if (h && or(t, null, n, "created"),
          c)
          if (v || !i || 48 & d)
            for (const t in c)
              (v && t.endsWith("value") || l(t) && !D(t)) && r(e, t, null, c[t], !1, void 0, n);
          else
            c.onClick && r(e, "onClick", null, c.onClick, !1, void 0, n);
        let u;
        if ((u = c && c.onVnodeBeforeMount) && Ya(u, n, t),
        h && or(t, null, n, "beforeMount"),
        ((u = c && c.onVnodeMounted) || h) && Wn((()=>{
            u && Ya(u, n, t),
            h && or(t, null, n, "mounted")
          }
        ), o),
        16 & f && (!c || !c.innerHTML && !c.textContent)) {
          let r = p(e.firstChild, t, e, n, o, a, i);
          for (; r; ) {
            na = !0;
            const e = r;
            r = r.nextSibling,
              s(e)
          }
        } else
          8 & f && e.textContent !== t.children && (na = !0,
            e.textContent = t.children)
      }
      return e.nextSibling
    }
    , p = (e,t,r,o,a,i,s)=>{
      s = s || !!t.dynamicChildren;
      const l = t.children
        , u = l.length;
      for (let c = 0; c < u; c++) {
        const t = s ? l[c] : l[c] = Ka(l[c]);
        if (e)
          e = d(e, t, o, a, i, s);
        else {
          if (t.type === wa && !t.children)
            continue;
          na = !0,
            n(null, t, r, null, o, a, ra(r), i)
        }
      }
      return e
    }
    , h = (e,t,n,r,o,s)=>{
      const {slotScopeIds: l} = t;
      l && (o = o ? o.concat(l) : l);
      const d = i(e)
        , f = p(a(e), t, d, n, r, o, s);
      return f && oa(f) && "]" === f.data ? a(t.anchor = f) : (na = !0,
        u(t.anchor = c("]"), d, f),
        f)
    }
    , v = (e,t,r,o,l,u)=>{
      if (na = !0,
        t.el = null,
        u) {
        const t = g(e);
        for (; ; ) {
          const n = a(e);
          if (!n || n === t)
            break;
          s(n)
        }
      }
      const c = a(e)
        , d = i(e);
      return s(e),
        n(null, t, d, c, r, o, ra(d), l),
        c
    }
    , g = e=>{
      let t = 0;
      for (; e; )
        if ((e = a(e)) && oa(e) && ("[" === e.data && t++,
        "]" === e.data)) {
          if (0 === t)
            return a(e);
          t--
        }
      return e
    }
  ;
  return [(e,t)=>{
    if (!t.hasChildNodes())
      return n(null, e, t),
        bn(),
        void (t._vnode = e);
    na = !1,
      d(t.firstChild, e, null, null, null),
      bn(),
      t._vnode = e,
    na && console.error("Hydration completed but contains mismatches.")
  }
    , d]
}
const ia = Wn;
function sa(e) {
  return ua(e)
}
function la(e) {
  return ua(e, aa)
}
function ua(e, t) {
  $().__VUE__ = !0;
  const {insert: n, remove: i, patchProp: s, createElement: l, createText: u, createComment: c, setText: d, setElementText: f, parentNode: h, nextSibling: v, setScopeId: g=a, insertStaticContent: m} = e
    , y = (e,t,n,r=null,o=null,a=null,i=!1,s=null,l=!!t.dynamicChildren)=>{
    if (e === t)
      return;
    e && !Ia(e, t) && (r = Y(e),
      z(e, o, a, !0),
      e = null),
    -2 === t.patchFlag && (l = !1,
      t.dynamicChildren = null);
    const {type: u, ref: c, shapeFlag: d} = t;
    switch (u) {
      case wa:
        b(e, t, n, r);
        break;
      case xa:
        w(e, t, n, r);
        break;
      case Sa:
        null == e && x(t, n, r, i);
        break;
      case ba:
        _(e, t, n, r, o, a, i, s, l);
        break;
      default:
        1 & d ? S(e, t, n, r, o, a, i, s, l) : 6 & d ? L(e, t, n, r, o, a, i, s, l) : (64 & d || 128 & d) && u.process(e, t, n, r, o, a, i, s, l, Q)
    }
    null != c && o && ta(c, e && e.ref, a, t || e, !t)
  }
    , b = (e,t,r,o)=>{
    if (null == e)
      n(t.el = u(t.children), r, o);
    else {
      const n = t.el = e.el;
      t.children !== e.children && d(n, t.children)
    }
  }
    , w = (e,t,r,o)=>{
    null == e ? n(t.el = c(t.children || ""), r, o) : t.el = e.el
  }
    , x = (e,t,n,r)=>{
    [e.el,e.anchor] = m(e.children, t, n, r, e.el, e.anchor)
  }
    , S = (e,t,n,r,o,a,i,s,l)=>{
    i = i || "svg" === t.type,
      null == e ? E(t, n, r, o, a, i, s, l) : k(e, t, o, a, i, s, l)
  }
    , E = (e,t,r,o,a,i,u,c)=>{
    let d, p;
    const {type: h, props: v, shapeFlag: g, transition: m, dirs: y} = e;
    if (d = e.el = l(e.type, i, v && v.is, v),
      8 & g ? f(d, e.children) : 16 & g && C(e.children, d, null, o, a, i && "foreignObject" !== h, u, c),
    y && or(e, null, o, "created"),
      A(d, e, e.scopeId, u, o),
      v) {
      for (const t in v)
        "value" === t || D(t) || s(d, t, null, v[t], i, e.children, o, a, q);
      "value"in v && s(d, "value", null, v.value),
      (p = v.onVnodeBeforeMount) && Ya(p, o, e)
    }
    y && or(e, null, o, "beforeMount");
    const b = (!a || a && !a.pendingBranch) && m && !m.persisted;
    b && m.beforeEnter(d),
      n(d, t, r),
    ((p = v && v.onVnodeMounted) || b || y) && ia((()=>{
        p && Ya(p, o, e),
        b && m.enter(d),
        y && or(e, null, o, "mounted")
      }
    ), a)
  }
    , A = (e,t,n,r,o)=>{
    if (n && g(e, n),
      r)
      for (let a = 0; a < r.length; a++)
        g(e, r[a]);
    if (o) {
      if (t === o.subTree) {
        const t = o.vnode;
        A(e, t, t.scopeId, t.slotScopeIds, o.parent)
      }
    }
  }
    , C = (e,t,n,r,o,a,i,s,l=0)=>{
    for (let u = l; u < e.length; u++) {
      const l = e[u] = s ? Wa(e[u]) : Ka(e[u]);
      y(null, l, t, n, r, o, a, i, s)
    }
  }
    , k = (e,t,n,o,a,i,l)=>{
    const u = t.el = e.el;
    let {patchFlag: c, dynamicChildren: d, dirs: p} = t;
    c |= 16 & e.patchFlag;
    const h = e.props || r
      , v = t.props || r;
    let g;
    n && ca(n, !1),
    (g = v.onVnodeBeforeUpdate) && Ya(g, n, t, e),
    p && or(t, e, n, "beforeUpdate"),
    n && ca(n, !0);
    const m = a && "foreignObject" !== t.type;
    if (d ? T(e.dynamicChildren, d, u, n, o, m, i) : l || j(e, t, u, null, n, o, m, i, !1),
    c > 0) {
      if (16 & c)
        O(u, t, h, v, n, o, a);
      else if (2 & c && h.class !== v.class && s(u, "class", null, v.class, a),
      4 & c && s(u, "style", h.style, v.style, a),
      8 & c) {
        const r = t.dynamicProps;
        for (let t = 0; t < r.length; t++) {
          const i = r[t]
            , l = h[i]
            , c = v[i];
          c === l && "value" !== i || s(u, i, l, c, a, e.children, n, o, q)
        }
      }
      1 & c && e.children !== t.children && f(u, t.children)
    } else
      l || null != d || O(u, t, h, v, n, o, a);
    ((g = v.onVnodeUpdated) || p) && ia((()=>{
        g && Ya(g, n, t, e),
        p && or(t, e, n, "updated")
      }
    ), o)
  }
    , T = (e,t,n,r,o,a,i)=>{
    for (let s = 0; s < t.length; s++) {
      const l = e[s]
        , u = t[s]
        , c = l.el && (l.type === ba || !Ia(l, u) || 70 & l.shapeFlag) ? h(l.el) : n;
      y(l, u, c, null, r, o, a, i, !0)
    }
  }
    , O = (e,t,n,o,a,i,l)=>{
    if (n !== o) {
      if (n !== r)
        for (const r in n)
          D(r) || r in o || s(e, r, n[r], null, l, t.children, a, i, q);
      for (const r in o) {
        if (D(r))
          continue;
        const u = o[r]
          , c = n[r];
        u !== c && "value" !== r && s(e, r, c, u, l, t.children, a, i, q)
      }
      "value"in o && s(e, "value", n.value, o.value)
    }
  }
    , _ = (e,t,r,o,a,i,s,l,c)=>{
    const d = t.el = e ? e.el : u("")
      , f = t.anchor = e ? e.anchor : u("");
    let {patchFlag: p, dynamicChildren: h, slotScopeIds: v} = t;
    v && (l = l ? l.concat(v) : v),
      null == e ? (n(d, r, o),
        n(f, r, o),
        C(t.children, r, f, a, i, s, l, c)) : p > 0 && 64 & p && h && e.dynamicChildren ? (T(e.dynamicChildren, h, r, a, i, s, l),
      (null != t.key || a && t === a.subTree) && da(e, t, !0)) : j(e, t, r, f, a, i, s, l, c)
  }
    , L = (e,t,n,r,o,a,i,s,l)=>{
    t.slotScopeIds = s,
      null == e ? 512 & t.shapeFlag ? o.ctx.activate(t, n, r, i, l) : P(t, n, r, o, a, i, l) : F(e, t, l)
  }
    , P = (e,t,n,r,o,a,i)=>{
    const s = e.component = Ja(e, r, o);
    if (br(e) && (s.ctx.renderer = Q),
      ci(s),
      s.asyncDep) {
      if (o && o.registerDep(s, B),
        !e.el) {
        const e = s.subTree = ja(xa);
        w(null, e, t, n)
      }
    } else
      B(s, e, t, n, o, a, i)
  }
    , F = (e,t,n)=>{
    const r = t.component = e.component;
    if (function(e, t, n) {
      const {props: r, children: o, component: a} = e
        , {props: i, children: s, patchFlag: l} = t
        , u = a.emitsOptions;
      if (t.dirs || t.transition)
        return !0;
      if (!(n && l >= 0))
        return !(!o && !s || s && s.$stable) || r !== i && (r ? !i || jn(r, i, u) : !!i);
      if (1024 & l)
        return !0;
      if (16 & l)
        return r ? jn(r, i, u) : !!i;
      if (8 & l) {
        const e = t.dynamicProps;
        for (let t = 0; t < e.length; t++) {
          const n = e[t];
          if (i[n] !== r[n] && !Dn(u, n))
            return !0
        }
      }
      return !1
    }(e, t, n)) {
      if (r.asyncDep && !r.asyncResolved)
        return void M(r, t, n);
      r.next = t,
        function(e) {
          const t = sn.indexOf(e);
          t > ln && sn.splice(t, 1)
        }(r.update),
        r.update()
    } else
      t.el = e.el,
        r.vnode = t
  }
    , B = (e,t,n,r,o,a,i)=>{
    const s = e.effect = new be((()=>{
        if (e.isMounted) {
          let t, {next: n, bu: r, u: s, parent: l, vnode: u} = e, c = n;
          ca(e, !1),
            n ? (n.el = u.el,
              M(e, n, i)) : n = u,
          r && N(r),
          (t = n.props && n.props.onVnodeBeforeUpdate) && Ya(t, l, n, u),
            ca(e, !0);
          const d = Bn(e)
            , f = e.subTree;
          e.subTree = d,
            y(f, d, h(f.el), Y(f), e, o, a),
            n.el = d.el,
          null === c && Vn(e, d.el),
          s && ia(s, o),
          (t = n.props && n.props.onVnodeUpdated) && ia((()=>Ya(t, l, n, u)), o)
        } else {
          let i;
          const {el: s, props: l} = t
            , {bm: u, m: c, parent: d} = e
            , f = gr(t);
          if (ca(e, !1),
          u && N(u),
          !f && (i = l && l.onVnodeBeforeMount) && Ya(i, d, t),
            ca(e, !0),
          s && Z) {
            const n = ()=>{
                e.subTree = Bn(e),
                  Z(s, e.subTree, e, o, null)
              }
            ;
            f ? t.type.__asyncLoader().then((()=>!e.isUnmounted && n())) : n()
          } else {
            const i = e.subTree = Bn(e);
            y(null, i, n, r, e, o, a),
              t.el = i.el
          }
          if (c && ia(c, o),
          !f && (i = l && l.onVnodeMounted)) {
            const e = t;
            ia((()=>Ya(i, d, e)), o)
          }
          (256 & t.shapeFlag || d && gr(d.vnode) && 256 & d.vnode.shapeFlag) && e.a && ia(e.a, o),
            e.isMounted = !0,
            t = n = r = null
        }
      }
    ),(()=>vn(l)),e.scope)
      , l = e.update = ()=>s.run();
    l.id = e.uid,
      ca(e, !0),
      l()
  }
    , M = (e,t,n)=>{
    t.component = e;
    const r = e.vnode.props;
    e.vnode = t,
      e.next = null,
      function(e, t, n, r) {
        const {props: o, attrs: a, vnode: {patchFlag: i}} = e
          , s = Dt(o)
          , [l] = e.propsOptions;
        let u = !1;
        if (!(r || i > 0) || 16 & i) {
          let r;
          Uo(e, t, o, a) && (u = !0);
          for (const a in s)
            t && (p(t, a) || (r = I(a)) !== a && p(t, r)) || (l ? !n || void 0 === n[a] && void 0 === n[r] || (o[a] = $o(l, s, a, void 0, e, !0)) : delete o[a]);
          if (a !== s)
            for (const e in a)
              t && p(t, e) || (delete a[e],
                u = !0)
        } else if (8 & i) {
          const n = e.vnode.dynamicProps;
          for (let r = 0; r < n.length; r++) {
            let i = n[r];
            if (Dn(e.emitsOptions, i))
              continue;
            const c = t[i];
            if (l)
              if (p(a, i))
                c !== a[i] && (a[i] = c,
                  u = !0);
              else {
                const t = R(i);
                o[t] = $o(l, s, t, c, e, !1)
              }
            else
              c !== a[i] && (a[i] = c,
                u = !0)
          }
        }
        u && Oe(e, "set", "$attrs")
      }(e, t.props, r, n),
      ea(e, t.children, n),
      Ce(),
      yn(),
      ke()
  }
    , j = (e,t,n,r,o,a,i,s,l=!1)=>{
    const u = e && e.children
      , c = e ? e.shapeFlag : 0
      , d = t.children
      , {patchFlag: p, shapeFlag: h} = t;
    if (p > 0) {
      if (128 & p)
        return void U(u, d, n, r, o, a, i, s, l);
      if (256 & p)
        return void V(u, d, n, r, o, a, i, s, l)
    }
    8 & h ? (16 & c && q(u, o, a),
    d !== u && f(n, d)) : 16 & c ? 16 & h ? U(u, d, n, r, o, a, i, s, l) : q(u, o, a, !0) : (8 & c && f(n, ""),
    16 & h && C(d, n, r, o, a, i, s, l))
  }
    , V = (e,t,n,r,a,i,s,l,u)=>{
    t = t || o;
    const c = (e = e || o).length
      , d = t.length
      , f = Math.min(c, d);
    let p;
    for (p = 0; p < f; p++) {
      const r = t[p] = u ? Wa(t[p]) : Ka(t[p]);
      y(e[p], r, n, null, a, i, s, l, u)
    }
    c > d ? q(e, a, i, !0, !1, f) : C(t, n, r, a, i, s, l, u, f)
  }
    , U = (e,t,n,r,a,i,s,l,u)=>{
    let c = 0;
    const d = t.length;
    let f = e.length - 1
      , p = d - 1;
    for (; c <= f && c <= p; ) {
      const r = e[c]
        , o = t[c] = u ? Wa(t[c]) : Ka(t[c]);
      if (!Ia(r, o))
        break;
      y(r, o, n, null, a, i, s, l, u),
        c++
    }
    for (; c <= f && c <= p; ) {
      const r = e[f]
        , o = t[p] = u ? Wa(t[p]) : Ka(t[p]);
      if (!Ia(r, o))
        break;
      y(r, o, n, null, a, i, s, l, u),
        f--,
        p--
    }
    if (c > f) {
      if (c <= p) {
        const e = p + 1
          , o = e < d ? t[e].el : r;
        for (; c <= p; )
          y(null, t[c] = u ? Wa(t[c]) : Ka(t[c]), n, o, a, i, s, l, u),
            c++
      }
    } else if (c > p)
      for (; c <= f; )
        z(e[c], a, i, !0),
          c++;
    else {
      const h = c
        , v = c
        , g = new Map;
      for (c = v; c <= p; c++) {
        const e = t[c] = u ? Wa(t[c]) : Ka(t[c]);
        null != e.key && g.set(e.key, c)
      }
      let m, b = 0;
      const w = p - v + 1;
      let x = !1
        , S = 0;
      const E = new Array(w);
      for (c = 0; c < w; c++)
        E[c] = 0;
      for (c = h; c <= f; c++) {
        const r = e[c];
        if (b >= w) {
          z(r, a, i, !0);
          continue
        }
        let o;
        if (null != r.key)
          o = g.get(r.key);
        else
          for (m = v; m <= p; m++)
            if (0 === E[m - v] && Ia(r, t[m])) {
              o = m;
              break
            }
        void 0 === o ? z(r, a, i, !0) : (E[o - v] = c + 1,
          o >= S ? S = o : x = !0,
          y(r, t[o], n, null, a, i, s, l, u),
          b++)
      }
      const A = x ? function(e) {
        const t = e.slice()
          , n = [0];
        let r, o, a, i, s;
        const l = e.length;
        for (r = 0; r < l; r++) {
          const l = e[r];
          if (0 !== l) {
            if (o = n[n.length - 1],
            e[o] < l) {
              t[r] = o,
                n.push(r);
              continue
            }
            for (a = 0,
                   i = n.length - 1; a < i; )
              s = a + i >> 1,
                e[n[s]] < l ? a = s + 1 : i = s;
            l < e[n[a]] && (a > 0 && (t[r] = n[a - 1]),
              n[a] = r)
          }
        }
        a = n.length,
          i = n[a - 1];
        for (; a-- > 0; )
          n[a] = i,
            i = t[i];
        return n
      }(E) : o;
      for (m = A.length - 1,
             c = w - 1; c >= 0; c--) {
        const e = v + c
          , o = t[e]
          , f = e + 1 < d ? t[e + 1].el : r;
        0 === E[c] ? y(null, o, n, f, a, i, s, l, u) : x && (m < 0 || c !== A[m] ? H(o, n, f, 2) : m--)
      }
    }
  }
    , H = (e,t,r,o,a=null)=>{
    const {el: i, type: s, transition: l, children: u, shapeFlag: c} = e;
    if (6 & c)
      return void H(e.component.subTree, t, r, o);
    if (128 & c)
      return void e.suspense.move(t, r, o);
    if (64 & c)
      return void s.move(e, t, r, Q);
    if (s === ba) {
      n(i, t, r);
      for (let e = 0; e < u.length; e++)
        H(u[e], t, r, o);
      return void n(e.anchor, t, r)
    }
    if (s === Sa)
      return void (({el: e, anchor: t},r,o)=>{
          let a;
          for (; e && e !== t; )
            a = v(e),
              n(e, r, o),
              e = a;
          n(t, r, o)
        }
      )(e, t, r);
    if (2 !== o && 1 & c && l)
      if (0 === o)
        l.beforeEnter(i),
          n(i, t, r),
          ia((()=>l.enter(i)), a);
      else {
        const {leave: e, delayLeave: o, afterLeave: a} = l
          , s = ()=>n(i, t, r)
          , u = ()=>{
            e(i, (()=>{
                s(),
                a && a()
              }
            ))
          }
        ;
        o ? o(i, s, u) : u()
      }
    else
      n(i, t, r)
  }
    , z = (e,t,n,r=!1,o=!1)=>{
    const {type: a, props: i, ref: s, children: l, dynamicChildren: u, shapeFlag: c, patchFlag: d, dirs: f} = e;
    if (null != s && ta(s, null, n, e, !0),
    256 & c)
      return void t.ctx.deactivate(e);
    const p = 1 & c && f
      , h = !gr(e);
    let v;
    if (h && (v = i && i.onVnodeBeforeUnmount) && Ya(v, t, e),
    6 & c)
      G(e.component, n, r);
    else {
      if (128 & c)
        return void e.suspense.unmount(n, r);
      p && or(e, null, t, "beforeUnmount"),
        64 & c ? e.type.remove(e, t, n, o, Q, r) : u && (a !== ba || d > 0 && 64 & d) ? q(u, t, n, !1, !0) : (a === ba && 384 & d || !o && 16 & c) && q(l, t, n),
      r && K(e)
    }
    (h && (v = i && i.onVnodeUnmounted) || p) && ia((()=>{
        v && Ya(v, t, e),
        p && or(e, null, t, "unmounted")
      }
    ), n)
  }
    , K = e=>{
    const {type: t, el: n, anchor: r, transition: o} = e;
    if (t === ba)
      return void W(n, r);
    if (t === Sa)
      return void (({el: e, anchor: t})=>{
          let n;
          for (; e && e !== t; )
            n = v(e),
              i(e),
              e = n;
          i(t)
        }
      )(e);
    const a = ()=>{
        i(n),
        o && !o.persisted && o.afterLeave && o.afterLeave()
      }
    ;
    if (1 & e.shapeFlag && o && !o.persisted) {
      const {leave: t, delayLeave: r} = o
        , i = ()=>t(n, a);
      r ? r(e.el, a, i) : i()
    } else
      a()
  }
    , W = (e,t)=>{
    let n;
    for (; e !== t; )
      n = v(e),
        i(e),
        e = n;
    i(t)
  }
    , G = (e,t,n)=>{
    const {bum: r, scope: o, update: a, subTree: i, um: s} = e;
    r && N(r),
      o.stop(),
    a && (a.active = !1,
      z(i, e, t, n)),
    s && ia(s, t),
      ia((()=>{
          e.isUnmounted = !0
        }
      ), t),
    t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--,
    0 === t.deps && t.resolve())
  }
    , q = (e,t,n,r=!1,o=!1,a=0)=>{
    for (let i = a; i < e.length; i++)
      z(e[i], t, n, r, o)
  }
    , Y = e=>6 & e.shapeFlag ? Y(e.component.subTree) : 128 & e.shapeFlag ? e.suspense.next() : v(e.anchor || e.el)
    , X = (e,t,n)=>{
    null == e ? t._vnode && z(t._vnode, null, null, !0) : y(t._vnode || null, e, t, null, null, null, n),
      yn(),
      bn(),
      t._vnode = e
  }
    , Q = {
    p: y,
    um: z,
    m: H,
    r: K,
    mt: P,
    mc: C,
    pc: j,
    pbc: T,
    n: Y,
    o: e
  };
  let J, Z;
  return t && ([J,Z] = t(Q)),
    {
      render: X,
      hydrate: J,
      createApp: Bo(X, J)
    }
}
function ca({effect: e, update: t}, n) {
  e.allowRecurse = t.allowRecurse = n
}
function da(e, t, n=!1) {
  const r = e.children
    , o = t.children;
  if (h(r) && h(o))
    for (let a = 0; a < r.length; a++) {
      const e = r[a];
      let t = o[a];
      1 & t.shapeFlag && !t.dynamicChildren && ((t.patchFlag <= 0 || 32 === t.patchFlag) && (t = o[a] = Wa(o[a]),
        t.el = e.el),
      n || da(e, t)),
      t.type === wa && (t.el = e.el)
    }
}
const fa = e=>e && (e.disabled || "" === e.disabled)
  , pa = e=>"undefined" != typeof SVGElement && e instanceof SVGElement
  , ha = (e,t)=>{
  const n = e && e.to;
  if (b(n)) {
    if (t) {
      return t(n)
    }
    return null
  }
  return n
}
  , va = {
  __isTeleport: !0,
  process(e, t, n, r, o, a, i, s, l, u) {
    const {mc: c, pc: d, pbc: f, o: {insert: p, querySelector: h, createText: v, createComment: g}} = u
      , m = fa(t.props);
    let {shapeFlag: y, children: b, dynamicChildren: w} = t;
    if (null == e) {
      const e = t.el = v("")
        , u = t.anchor = v("");
      p(e, n, r),
        p(u, n, r);
      const d = t.target = ha(t.props, h)
        , f = t.targetAnchor = v("");
      d && (p(f, d),
        i = i || pa(d));
      const g = (e,t)=>{
          16 & y && c(b, e, t, o, a, i, s, l)
        }
      ;
      m ? g(n, u) : d && g(d, f)
    } else {
      t.el = e.el;
      const r = t.anchor = e.anchor
        , c = t.target = e.target
        , p = t.targetAnchor = e.targetAnchor
        , v = fa(e.props)
        , g = v ? n : c
        , y = v ? r : p;
      if (i = i || pa(c),
        w ? (f(e.dynamicChildren, w, g, o, a, i, s),
          da(e, t, !0)) : l || d(e, t, g, y, o, a, i, s, !1),
        m)
        v || ga(t, n, r, u, 1);
      else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
        const e = t.target = ha(t.props, h);
        e && ga(t, e, null, u, 0)
      } else
        v && ga(t, c, p, u, 1)
    }
    ya(t)
  },
  remove(e, t, n, r, {um: o, o: {remove: a}}, i) {
    const {shapeFlag: s, children: l, anchor: u, targetAnchor: c, target: d, props: f} = e;
    if (d && a(c),
    (i || !fa(f)) && (a(u),
    16 & s))
      for (let p = 0; p < l.length; p++) {
        const e = l[p];
        o(e, t, n, !0, !!e.dynamicChildren)
      }
  },
  move: ga,
  hydrate: function(e, t, n, r, o, a, {o: {nextSibling: i, parentNode: s, querySelector: l}}, u) {
    const c = t.target = ha(t.props, l);
    if (c) {
      const l = c._lpa || c.firstChild;
      if (16 & t.shapeFlag)
        if (fa(t.props))
          t.anchor = u(i(e), t, s(e), n, r, o, a),
            t.targetAnchor = l;
        else {
          t.anchor = i(e);
          let s = l;
          for (; s; )
            if (s = i(s),
            s && 8 === s.nodeType && "teleport anchor" === s.data) {
              t.targetAnchor = s,
                c._lpa = t.targetAnchor && i(t.targetAnchor);
              break
            }
          u(l, t, c, n, r, o, a)
        }
      ya(t)
    }
    return t.anchor && i(t.anchor)
  }
};
function ga(e, t, n, {o: {insert: r}, m: o}, a=2) {
  0 === a && r(e.targetAnchor, t, n);
  const {el: i, anchor: s, shapeFlag: l, children: u, props: c} = e
    , d = 2 === a;
  if (d && r(i, t, n),
  (!d || fa(c)) && 16 & l)
    for (let f = 0; f < u.length; f++)
      o(u[f], t, n, 2);
  d && r(s, t, n)
}
const ma = va;
function ya(e) {
  const t = e.ctx;
  if (t && t.ut) {
    let n = e.children[0].el;
    for (; n !== e.targetAnchor; )
      1 === n.nodeType && n.setAttribute("data-v-owner", t.uid),
        n = n.nextSibling;
    t.ut()
  }
}
const ba = Symbol.for("v-fgt")
  , wa = Symbol.for("v-txt")
  , xa = Symbol.for("v-cmt")
  , Sa = Symbol.for("v-stc")
  , Ea = [];
let Aa = null;
function Ca(e=!1) {
  Ea.push(Aa = e ? null : [])
}
function ka() {
  Ea.pop(),
    Aa = Ea[Ea.length - 1] || null
}
let Ta = 1;
function Da(e) {
  Ta += e
}
function Oa(e) {
  return e.dynamicChildren = Ta > 0 ? Aa || o : null,
    ka(),
  Ta > 0 && Aa && Aa.push(e),
    e
}
function _a(e, t, n, r, o, a) {
  return Oa(Ma(e, t, n, r, o, a, !0))
}
function Ra(e, t, n, r, o) {
  return Oa(ja(e, t, n, r, o, !0))
}
function La(e) {
  return !!e && !0 === e.__v_isVNode
}
function Ia(e, t) {
  return e.type === t.type && e.key === t.key
}
function Pa(e) {}
const Fa = "__vInternal"
  , Ba = ({key: e})=>null != e ? e : null
  , Na = ({ref: e, ref_key: t, ref_for: n})=>("number" == typeof e && (e = "" + e),
  null != e ? b(e) || Pt(e) || y(e) ? {
    i: On,
    r: e,
    k: t,
    f: !!n
  } : e : null);
function Ma(e, t=null, n=null, r=0, o=null, a=(e === ba ? 0 : 1), i=!1, s=!1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && Ba(t),
    ref: t && Na(t),
    scopeId: _n,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: a,
    patchFlag: r,
    dynamicProps: o,
    dynamicChildren: null,
    appContext: null,
    ctx: On
  };
  return s ? (Ga(l, n),
  128 & a && e.normalize(l)) : n && (l.shapeFlag |= b(n) ? 8 : 16),
  Ta > 0 && !i && Aa && (l.patchFlag > 0 || 6 & a) && 32 !== l.patchFlag && Aa.push(l),
    l
}
const ja = function(e, t=null, n=null, r=0, o=null, a=!1) {
  e && e !== zr || (e = xa);
  if (La(e)) {
    const r = Ua(e, t, !0);
    return n && Ga(r, n),
    Ta > 0 && !a && Aa && (6 & r.shapeFlag ? Aa[Aa.indexOf(e)] = r : Aa.push(r)),
      r.patchFlag |= -2,
      r
  }
  i = e,
  y(i) && "__vccOpts"in i && (e = e.__vccOpts);
  var i;
  if (t) {
    t = Va(t);
    let {class: e, style: n} = t;
    e && !b(e) && (t.class = Y(e)),
    x(n) && (Tt(n) && !h(n) && (n = c({}, n)),
      t.style = z(n))
  }
  const s = b(e) ? 1 : Un(e) ? 128 : (e=>e.__isTeleport)(e) ? 64 : x(e) ? 4 : y(e) ? 2 : 0;
  return Ma(e, t, n, r, o, s, a, !0)
};
function Va(e) {
  return e ? Tt(e) || Fa in e ? c({}, e) : e : null
}
function Ua(e, t, n=!1) {
  const {props: r, ref: o, patchFlag: a, children: i} = e
    , s = t ? qa(r || {}, t) : r;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: s,
    key: s && Ba(s),
    ref: t && t.ref ? n && o ? h(o) ? o.concat(Na(t)) : [o, Na(t)] : Na(t) : o,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: i,
    target: e.target,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    patchFlag: t && e.type !== ba ? -1 === a ? 16 : 16 | a : a,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: e.transition,
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && Ua(e.ssContent),
    ssFallback: e.ssFallback && Ua(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  }
}
function $a(e=" ", t=0) {
  return ja(wa, null, e, t)
}
function Ha(e, t) {
  const n = ja(Sa, null, e);
  return n.staticCount = t,
    n
}
function za(e="", t=!1) {
  return t ? (Ca(),
    Ra(xa, null, e)) : ja(xa, null, e)
}
function Ka(e) {
  return null == e || "boolean" == typeof e ? ja(xa) : h(e) ? ja(ba, null, e.slice()) : "object" == typeof e ? Wa(e) : ja(wa, null, String(e))
}
function Wa(e) {
  return null === e.el && -1 !== e.patchFlag || e.memo ? e : Ua(e)
}
function Ga(e, t) {
  let n = 0;
  const {shapeFlag: r} = e;
  if (null == t)
    t = null;
  else if (h(t))
    n = 16;
  else if ("object" == typeof t) {
    if (65 & r) {
      const n = t.default;
      return void (n && (n._c && (n._d = !1),
        Ga(e, n()),
      n._c && (n._d = !0)))
    }
    {
      n = 32;
      const r = t._;
      r || Fa in t ? 3 === r && On && (1 === On.slots._ ? t._ = 1 : (t._ = 2,
        e.patchFlag |= 1024)) : t._ctx = On
    }
  } else
    y(t) ? (t = {
      default: t,
      _ctx: On
    },
      n = 32) : (t = String(t),
      64 & r ? (n = 16,
        t = [$a(t)]) : n = 8);
  e.children = t,
    e.shapeFlag |= n
}
function qa(...e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    for (const e in r)
      if ("class" === e)
        t.class !== r.class && (t.class = Y([t.class, r.class]));
      else if ("style" === e)
        t.style = z([t.style, r.style]);
      else if (l(e)) {
        const n = t[e]
          , o = r[e];
        !o || n === o || h(n) && n.includes(o) || (t[e] = n ? [].concat(n, o) : o)
      } else
        "" !== e && (t[e] = r[e])
  }
  return t
}
function Ya(e, t, n, r=null) {
  nn(e, t, 7, [n, r])
}
const Xa = Po();
let Qa = 0;
function Ja(e, t, n) {
  const o = e.type
    , a = (t ? t.appContext : e.appContext) || Xa
    , i = {
    uid: Qa++,
    vnode: e,
    type: o,
    parent: t,
    appContext: a,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new oe(!0),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(a.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: Ho(o, a),
    emitsOptions: Tn(o, a),
    emit: null,
    emitted: null,
    propsDefaults: r,
    inheritAttrs: o.inheritAttrs,
    ctx: r,
    data: r,
    props: r,
    attrs: r,
    slots: r,
    refs: r,
    setupState: r,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return i.ctx = {
    _: i
  },
    i.root = t ? t.root : i,
    i.emit = kn.bind(null, i),
  e.ce && e.ce(i),
    i
}
let Za = null;
const ei = ()=>Za || On;
let ti, ni, ri = "__VUE_INSTANCE_SETTERS__";
(ni = $()[ri]) || (ni = $()[ri] = []),
  ni.push((e=>Za = e)),
  ti = e=>{
    ni.length > 1 ? ni.forEach((t=>t(e))) : ni[0](e)
  }
;
const oi = e=>{
    ti(e),
      e.scope.on()
  }
  , ai = ()=>{
    Za && Za.scope.off(),
      ti(null)
  }
;
function ii(e) {
  return 4 & e.vnode.shapeFlag
}
let si, li, ui = !1;
function ci(e, t=!1) {
  ui = t;
  const {props: n, children: r} = e.vnode
    , o = ii(e);
  !function(e, t, n, r=!1) {
    const o = {}
      , a = {};
    M(a, Fa, 1),
      e.propsDefaults = Object.create(null),
      Uo(e, t, o, a);
    for (const i in e.propsOptions[0])
      i in o || (o[i] = void 0);
    n ? e.props = r ? o : wt(o) : e.type.props ? e.props = o : e.props = a,
      e.attrs = a
  }(e, n, o, t),
    Zo(e, r);
  const a = o ? function(e, t) {
    const n = e.type;
    e.accessCache = Object.create(null),
      e.proxy = Ot(new Proxy(e.ctx,ro));
    const {setup: r} = n;
    if (r) {
      const n = e.setupContext = r.length > 1 ? vi(e) : null;
      oi(e),
        Ce();
      const o = tn(r, e, 0, [e.props, n]);
      if (ke(),
        ai(),
        S(o)) {
        if (o.then(ai, ai),
          t)
          return o.then((n=>{
              di(e, n, t)
            }
          )).catch((t=>{
              rn(t, e, 0)
            }
          ));
        e.asyncDep = o
      } else
        di(e, o, t)
    } else
      hi(e, t)
  }(e, t) : void 0;
  return ui = !1,
    a
}
function di(e, t, n) {
  y(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : x(t) && (e.setupState = Ht(t)),
    hi(e, n)
}
function fi(e) {
  si = e,
    li = e=>{
      e.render._rc && (e.withProxy = new Proxy(e.ctx,oo))
    }
}
const pi = ()=>!si;
function hi(e, t, n) {
  const r = e.type;
  if (!e.render) {
    if (!t && si && !r.render) {
      const t = r.template || ko(e).template;
      if (t) {
        const {isCustomElement: n, compilerOptions: o} = e.appContext.config
          , {delimiters: a, compilerOptions: i} = r
          , s = c(c({
          isCustomElement: n,
          delimiters: a
        }, o), i);
        r.render = si(t, s)
      }
    }
    e.render = r.render || a,
    li && li(e)
  }
  oi(e),
    Ce(),
    Eo(e),
    ke(),
    ai()
}
function vi(e) {
  const t = t=>{
      e.exposed = t || {}
    }
  ;
  return {
    get attrs() {
      return function(e) {
        return e.attrsProxy || (e.attrsProxy = new Proxy(e.attrs,{
          get: (t,n)=>(Te(e, 0, "$attrs"),
            t[n])
        }))
      }(e)
    },
    slots: e.slots,
    emit: e.emit,
    expose: t
  }
}
function gi(e) {
  if (e.exposed)
    return e.exposeProxy || (e.exposeProxy = new Proxy(Ht(Ot(e.exposed)),{
      get: (t,n)=>n in t ? t[n] : n in to ? to[n](e) : void 0,
      has: (e,t)=>t in e || t in to
    }))
}
function mi(e, t=!0) {
  return y(e) ? e.displayName || e.name : e.name || t && e.__name
}
const yi = (e,t)=>Jt(e, 0, ui);
function bi(e, t, n) {
  const r = arguments.length;
  return 2 === r ? x(t) && !h(t) ? La(t) ? ja(e, null, [t]) : ja(e, t) : ja(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === r && La(n) && (n = [n]),
    ja(e, t, n))
}
const wi = Symbol.for("v-scx")
  , xi = ()=>jo(wi);
function Si() {}
function Ei(e, t, n, r) {
  const o = n[r];
  if (o && Ai(o, e))
    return o;
  const a = t();
  return a.memo = e.slice(),
    n[r] = a
}
function Ai(e, t) {
  const n = e.memo;
  if (n.length != t.length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (B(n[r], t[r]))
      return !1;
  return Ta > 0 && Aa && Aa.push(e),
    !0
}
const Ci = "3.3.4"
  , ki = {
  createComponentInstance: Ja,
  setupComponent: ci,
  renderComponentRoot: Bn,
  setCurrentRenderingInstance: Rn,
  isVNode: La,
  normalizeVNode: Ka
}
  , Ti = null
  , Di = null
  , Oi = "undefined" != typeof document ? document : null
  , _i = Oi && Oi.createElement("template")
  , Ri = {
  insert: (e,t,n)=>{
    t.insertBefore(e, n || null)
  }
  ,
  remove: e=>{
    const t = e.parentNode;
    t && t.removeChild(e)
  }
  ,
  createElement: (e,t,n,r)=>{
    const o = t ? Oi.createElementNS("http://www.w3.org/2000/svg", e) : Oi.createElement(e, n ? {
      is: n
    } : void 0);
    return "select" === e && r && null != r.multiple && o.setAttribute("multiple", r.multiple),
      o
  }
  ,
  createText: e=>Oi.createTextNode(e),
  createComment: e=>Oi.createComment(e),
  setText: (e,t)=>{
    e.nodeValue = t
  }
  ,
  setElementText: (e,t)=>{
    e.textContent = t
  }
  ,
  parentNode: e=>e.parentNode,
  nextSibling: e=>e.nextSibling,
  querySelector: e=>Oi.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "")
  },
  insertStaticContent(e, t, n, r, o, a) {
    const i = n ? n.previousSibling : t.lastChild;
    if (o && (o === a || o.nextSibling))
      for (; t.insertBefore(o.cloneNode(!0), n),
             o !== a && (o = o.nextSibling); )
        ;
    else {
      _i.innerHTML = r ? `<svg>${e}</svg>` : e;
      const o = _i.content;
      if (r) {
        const e = o.firstChild;
        for (; e.firstChild; )
          o.appendChild(e.firstChild);
        o.removeChild(e)
      }
      t.insertBefore(o, n)
    }
    return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
  }
};
const Li = /\s*!important$/;
function Ii(e, t, n) {
  if (h(n))
    n.forEach((n=>Ii(e, t, n)));
  else if (null == n && (n = ""),
    t.startsWith("--"))
    e.setProperty(t, n);
  else {
    const r = function(e, t) {
      const n = Fi[t];
      if (n)
        return n;
      let r = R(t);
      if ("filter" !== r && r in e)
        return Fi[t] = r;
      r = P(r);
      for (let o = 0; o < Pi.length; o++) {
        const n = Pi[o] + r;
        if (n in e)
          return Fi[t] = n
      }
      return t
    }(e, t);
    Li.test(n) ? e.setProperty(I(r), n.replace(Li, ""), "important") : e[r] = n
  }
}
const Pi = ["Webkit", "Moz", "ms"]
  , Fi = {};
const Bi = "http://www.w3.org/1999/xlink";
function Ni(e, t, n, r) {
  e.addEventListener(t, n, r)
}
function Mi(e, t, n, r, o=null) {
  const a = e._vei || (e._vei = {})
    , i = a[t];
  if (r && i)
    i.value = r;
  else {
    const [n,s] = function(e) {
      let t;
      if (ji.test(e)) {
        let n;
        for (t = {}; n = e.match(ji); )
          e = e.slice(0, e.length - n[0].length),
            t[n[0].toLowerCase()] = !0
      }
      const n = ":" === e[2] ? e.slice(3) : I(e.slice(2));
      return [n, t]
    }(t);
    if (r) {
      const i = a[t] = function(e, t) {
        const n = e=>{
            if (e._vts) {
              if (e._vts <= n.attached)
                return
            } else
              e._vts = Date.now();
            nn(function(e, t) {
              if (h(t)) {
                const n = e.stopImmediatePropagation;
                return e.stopImmediatePropagation = ()=>{
                  n.call(e),
                    e._stopped = !0
                }
                  ,
                  t.map((e=>t=>!t._stopped && e && e(t)))
              }
              return t
            }(e, n.value), t, 5, [e])
          }
        ;
        return n.value = e,
          n.attached = $i(),
          n
      }(r, o);
      Ni(e, n, i, s)
    } else
      i && (!function(e, t, n, r) {
        e.removeEventListener(t, n, r)
      }(e, n, i, s),
        a[t] = void 0)
  }
}
const ji = /(?:Once|Passive|Capture)$/;
let Vi = 0;
const Ui = Promise.resolve()
  , $i = ()=>Vi || (Ui.then((()=>Vi = 0)),
  Vi = Date.now());
const Hi = /^on[a-z]/;
function zi(e, t) {
  const n = vr(e);
  class r extends Gi {
    constructor(e) {
      super(n, e, t)
    }
  }
  return r.def = n,
    r
}
const Ki = e=>zi(e, Xs)
  , Wi = "undefined" != typeof HTMLElement ? HTMLElement : class {
  }
;
class Gi extends Wi {
  constructor(e, t={}, n) {
    super(),
      this._def = e,
      this._props = t,
      this._instance = null,
      this._connected = !1,
      this._resolved = !1,
      this._numberProps = null,
      this.shadowRoot && n ? n(this._createVNode(), this.shadowRoot) : (this.attachShadow({
        mode: "open"
      }),
      this._def.__asyncLoader || this._resolveProps(this._def))
  }
  connectedCallback() {
    this._connected = !0,
    this._instance || (this._resolved ? this._update() : this._resolveDef())
  }
  disconnectedCallback() {
    this._connected = !1,
      hn((()=>{
          this._connected || (Ys(null, this.shadowRoot),
            this._instance = null)
        }
      ))
  }
  _resolveDef() {
    this._resolved = !0;
    for (let n = 0; n < this.attributes.length; n++)
      this._setAttr(this.attributes[n].name);
    new MutationObserver((e=>{
        for (const t of e)
          this._setAttr(t.attributeName)
      }
    )).observe(this, {
      attributes: !0
    });
    const e = (e,t=!1)=>{
      const {props: n, styles: r} = e;
      let o;
      if (n && !h(n))
        for (const a in n) {
          const e = n[a];
          (e === Number || e && e.type === Number) && (a in this._props && (this._props[a] = V(this._props[a])),
            (o || (o = Object.create(null)))[R(a)] = !0)
        }
      this._numberProps = o,
      t && this._resolveProps(e),
        this._applyStyles(r),
        this._update()
    }
      , t = this._def.__asyncLoader;
    t ? t().then((t=>e(t, !0))) : e(this._def)
  }
  _resolveProps(e) {
    const {props: t} = e
      , n = h(t) ? t : Object.keys(t || {});
    for (const r of Object.keys(this))
      "_" !== r[0] && n.includes(r) && this._setProp(r, this[r], !0, !1);
    for (const r of n.map(R))
      Object.defineProperty(this, r, {
        get() {
          return this._getProp(r)
        },
        set(e) {
          this._setProp(r, e)
        }
      })
  }
  _setAttr(e) {
    let t = this.getAttribute(e);
    const n = R(e);
    this._numberProps && this._numberProps[n] && (t = V(t)),
      this._setProp(n, t, !1)
  }
  _getProp(e) {
    return this._props[e]
  }
  _setProp(e, t, n=!0, r=!0) {
    t !== this._props[e] && (this._props[e] = t,
    r && this._instance && this._update(),
    n && (!0 === t ? this.setAttribute(I(e), "") : "string" == typeof t || "number" == typeof t ? this.setAttribute(I(e), t + "") : t || this.removeAttribute(I(e))))
  }
  _update() {
    Ys(this._createVNode(), this.shadowRoot)
  }
  _createVNode() {
    const e = ja(this._def, c({}, this._props));
    return this._instance || (e.ce = e=>{
        this._instance = e,
          e.isCE = !0;
        const t = (e,t)=>{
            this.dispatchEvent(new CustomEvent(e,{
              detail: t
            }))
          }
        ;
        e.emit = (e,...n)=>{
          t(e, n),
          I(e) !== e && t(I(e), n)
        }
        ;
        let n = this;
        for (; n = n && (n.parentNode || n.host); )
          if (n instanceof Gi) {
            e.parent = n._instance,
              e.provides = n._instance.provides;
            break
          }
      }
    ),
      e
  }
  _applyStyles(e) {
    e && e.forEach((e=>{
        const t = document.createElement("style");
        t.textContent = e,
          this.shadowRoot.appendChild(t)
      }
    ))
  }
}
function qi(e="$style") {
  {
    const t = ei();
    if (!t)
      return r;
    const n = t.type.__cssModules;
    if (!n)
      return r;
    const o = n[e];
    return o || r
  }
}
function Yi(e) {
  const t = ei();
  if (!t)
    return;
  const n = t.ut = (n=e(t.proxy))=>{
      Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach((e=>Qi(e, n)))
    }
    , r = ()=>{
      const r = e(t.proxy);
      Xi(t.subTree, r),
        n(r)
    }
  ;
  Yn(r),
    Lr((()=>{
        const e = new MutationObserver(r);
        e.observe(t.subTree.el.parentNode, {
          childList: !0
        }),
          Br((()=>e.disconnect()))
      }
    ))
}
function Xi(e, t) {
  if (128 & e.shapeFlag) {
    const n = e.suspense;
    e = n.activeBranch,
    n.pendingBranch && !n.isHydrating && n.effects.push((()=>{
        Xi(n.activeBranch, t)
      }
    ))
  }
  for (; e.component; )
    e = e.component.subTree;
  if (1 & e.shapeFlag && e.el)
    Qi(e.el, t);
  else if (e.type === ba)
    e.children.forEach((e=>Xi(e, t)));
  else if (e.type === Sa) {
    let {el: n, anchor: r} = e;
    for (; n && (Qi(n, t),
    n !== r); )
      n = n.nextSibling
  }
}
function Qi(e, t) {
  if (1 === e.nodeType) {
    const n = e.style;
    for (const e in t)
      n.setProperty(`--${e}`, t[e])
  }
}
const Ji = "transition"
  , Zi = "animation"
  , es = (e,{slots: t})=>bi(lr, as(e), t);
es.displayName = "Transition";
const ts = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}
  , ns = es.props = c({}, sr, ts)
  , rs = (e,t=[])=>{
  h(e) ? e.forEach((e=>e(...t))) : e && e(...t)
}
  , os = e=>!!e && (h(e) ? e.some((e=>e.length > 1)) : e.length > 1);
function as(e) {
  const t = {};
  for (const c in e)
    c in ts || (t[c] = e[c]);
  if (!1 === e.css)
    return t;
  const {name: n="v", type: r, duration: o, enterFromClass: a=`${n}-enter-from`, enterActiveClass: i=`${n}-enter-active`, enterToClass: s=`${n}-enter-to`, appearFromClass: l=a, appearActiveClass: u=i, appearToClass: d=s, leaveFromClass: f=`${n}-leave-from`, leaveActiveClass: p=`${n}-leave-active`, leaveToClass: h=`${n}-leave-to`} = e
    , v = function(e) {
      if (null == e)
        return null;
      if (x(e))
        return [is(e.enter), is(e.leave)];
      {
        const t = is(e);
        return [t, t]
      }
    }(o)
    , g = v && v[0]
    , m = v && v[1]
    , {onBeforeEnter: y, onEnter: b, onEnterCancelled: w, onLeave: S, onLeaveCancelled: E, onBeforeAppear: A=y, onAppear: C=b, onAppearCancelled: k=w} = t
    , T = (e,t,n)=>{
      ls(e, t ? d : s),
        ls(e, t ? u : i),
      n && n()
    }
    , D = (e,t)=>{
      e._isLeaving = !1,
        ls(e, f),
        ls(e, h),
        ls(e, p),
      t && t()
    }
    , O = e=>(t,n)=>{
      const o = e ? C : b
        , i = ()=>T(t, e, n);
      rs(o, [t, i]),
        us((()=>{
            ls(t, e ? l : a),
              ss(t, e ? d : s),
            os(o) || ds(t, r, g, i)
          }
        ))
    }
  ;
  return c(t, {
    onBeforeEnter(e) {
      rs(y, [e]),
        ss(e, a),
        ss(e, i)
    },
    onBeforeAppear(e) {
      rs(A, [e]),
        ss(e, l),
        ss(e, u)
    },
    onEnter: O(!1),
    onAppear: O(!0),
    onLeave(e, t) {
      e._isLeaving = !0;
      const n = ()=>D(e, t);
      ss(e, f),
        vs(),
        ss(e, p),
        us((()=>{
            e._isLeaving && (ls(e, f),
              ss(e, h),
            os(S) || ds(e, r, m, n))
          }
        )),
        rs(S, [e, n])
    },
    onEnterCancelled(e) {
      T(e, !1),
        rs(w, [e])
    },
    onAppearCancelled(e) {
      T(e, !0),
        rs(k, [e])
    },
    onLeaveCancelled(e) {
      D(e),
        rs(E, [e])
    }
  })
}
function is(e) {
  return V(e)
}
function ss(e, t) {
  t.split(/\s+/).forEach((t=>t && e.classList.add(t))),
    (e._vtc || (e._vtc = new Set)).add(t)
}
function ls(e, t) {
  t.split(/\s+/).forEach((t=>t && e.classList.remove(t)));
  const {_vtc: n} = e;
  n && (n.delete(t),
  n.size || (e._vtc = void 0))
}
function us(e) {
  requestAnimationFrame((()=>{
      requestAnimationFrame(e)
    }
  ))
}
let cs = 0;
function ds(e, t, n, r) {
  const o = e._endId = ++cs
    , a = ()=>{
      o === e._endId && r()
    }
  ;
  if (n)
    return setTimeout(a, n);
  const {type: i, timeout: s, propCount: l} = fs(e, t);
  if (!i)
    return r();
  const u = i + "end";
  let c = 0;
  const d = ()=>{
      e.removeEventListener(u, f),
        a()
    }
    , f = t=>{
      t.target === e && ++c >= l && d()
    }
  ;
  setTimeout((()=>{
      c < l && d()
    }
  ), s + 1),
    e.addEventListener(u, f)
}
function fs(e, t) {
  const n = window.getComputedStyle(e)
    , r = e=>(n[e] || "").split(", ")
    , o = r(`${Ji}Delay`)
    , a = r(`${Ji}Duration`)
    , i = ps(o, a)
    , s = r(`${Zi}Delay`)
    , l = r(`${Zi}Duration`)
    , u = ps(s, l);
  let c = null
    , d = 0
    , f = 0;
  t === Ji ? i > 0 && (c = Ji,
    d = i,
    f = a.length) : t === Zi ? u > 0 && (c = Zi,
    d = u,
    f = l.length) : (d = Math.max(i, u),
    c = d > 0 ? i > u ? Ji : Zi : null,
    f = c ? c === Ji ? a.length : l.length : 0);
  return {
    type: c,
    timeout: d,
    propCount: f,
    hasTransform: c === Ji && /\b(transform|all)(,|$)/.test(r(`${Ji}Property`).toString())
  }
}
function ps(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max(...t.map(((t,n)=>hs(t) + hs(e[n]))))
}
function hs(e) {
  return 1e3 * Number(e.slice(0, -1).replace(",", "."))
}
function vs() {
  return document.body.offsetHeight
}
const gs = new WeakMap
  , ms = new WeakMap
  , ys = {
  name: "TransitionGroup",
  props: c({}, ns, {
    tag: String,
    moveClass: String
  }),
  setup(e, {slots: t}) {
    const n = ei()
      , r = ar();
    let o, a;
    return Pr((()=>{
        if (!o.length)
          return;
        const t = e.moveClass || `${e.name || "v"}-move`;
        if (!function(e, t, n) {
          const r = e.cloneNode();
          e._vtc && e._vtc.forEach((e=>{
              e.split(/\s+/).forEach((e=>e && r.classList.remove(e)))
            }
          ));
          n.split(/\s+/).forEach((e=>e && r.classList.add(e))),
            r.style.display = "none";
          const o = 1 === t.nodeType ? t : t.parentNode;
          o.appendChild(r);
          const {hasTransform: a} = fs(r);
          return o.removeChild(r),
            a
        }(o[0].el, n.vnode.el, t))
          return;
        o.forEach(ws),
          o.forEach(xs);
        const r = o.filter(Ss);
        vs(),
          r.forEach((e=>{
              const n = e.el
                , r = n.style;
              ss(n, t),
                r.transform = r.webkitTransform = r.transitionDuration = "";
              const o = n._moveCb = e=>{
                  e && e.target !== n || e && !/transform$/.test(e.propertyName) || (n.removeEventListener("transitionend", o),
                    n._moveCb = null,
                    ls(n, t))
                }
              ;
              n.addEventListener("transitionend", o)
            }
          ))
      }
    )),
      ()=>{
        const i = Dt(e)
          , s = as(i);
        let l = i.tag || ba;
        o = a,
          a = t.default ? hr(t.default()) : [];
        for (let e = 0; e < a.length; e++) {
          const t = a[e];
          null != t.key && pr(t, cr(t, s, r, n))
        }
        if (o)
          for (let e = 0; e < o.length; e++) {
            const t = o[e];
            pr(t, cr(t, s, r, n)),
              gs.set(t, t.el.getBoundingClientRect())
          }
        return ja(l, null, a)
      }
  }
}
  , bs = ys;
function ws(e) {
  const t = e.el;
  t._moveCb && t._moveCb(),
  t._enterCb && t._enterCb()
}
function xs(e) {
  ms.set(e, e.el.getBoundingClientRect())
}
function Ss(e) {
  const t = gs.get(e)
    , n = ms.get(e)
    , r = t.left - n.left
    , o = t.top - n.top;
  if (r || o) {
    const t = e.el.style;
    return t.transform = t.webkitTransform = `translate(${r}px,${o}px)`,
      t.transitionDuration = "0s",
      e
  }
}
const Es = e=>{
    const t = e.props["onUpdate:modelValue"] || !1;
    return h(t) ? e=>N(t, e) : t
  }
;
function As(e) {
  e.target.composing = !0
}
function Cs(e) {
  const t = e.target;
  t.composing && (t.composing = !1,
    t.dispatchEvent(new Event("input")))
}
const ks = {
  created(e, {modifiers: {lazy: t, trim: n, number: r}}, o) {
    e._assign = Es(o);
    const a = r || o.props && "number" === o.props.type;
    Ni(e, t ? "change" : "input", (t=>{
        if (t.target.composing)
          return;
        let r = e.value;
        n && (r = r.trim()),
        a && (r = j(r)),
          e._assign(r)
      }
    )),
    n && Ni(e, "change", (()=>{
        e.value = e.value.trim()
      }
    )),
    t || (Ni(e, "compositionstart", As),
      Ni(e, "compositionend", Cs),
      Ni(e, "change", Cs))
  },
  mounted(e, {value: t}) {
    e.value = null == t ? "" : t
  },
  beforeUpdate(e, {value: t, modifiers: {lazy: n, trim: r, number: o}}, a) {
    if (e._assign = Es(a),
      e.composing)
      return;
    if (document.activeElement === e && "range" !== e.type) {
      if (n)
        return;
      if (r && e.value.trim() === t)
        return;
      if ((o || "number" === e.type) && j(e.value) === t)
        return
    }
    const i = null == t ? "" : t;
    e.value !== i && (e.value = i)
  }
}
  , Ts = {
  deep: !0,
  created(e, t, n) {
    e._assign = Es(n),
      Ni(e, "change", (()=>{
          const t = e._modelValue
            , n = Ls(e)
            , r = e.checked
            , o = e._assign;
          if (h(t)) {
            const e = ee(t, n)
              , a = -1 !== e;
            if (r && !a)
              o(t.concat(n));
            else if (!r && a) {
              const n = [...t];
              n.splice(e, 1),
                o(n)
            }
          } else if (g(t)) {
            const e = new Set(t);
            r ? e.add(n) : e.delete(n),
              o(e)
          } else
            o(Is(e, r))
        }
      ))
  },
  mounted: Ds,
  beforeUpdate(e, t, n) {
    e._assign = Es(n),
      Ds(e, t, n)
  }
};
function Ds(e, {value: t, oldValue: n}, r) {
  e._modelValue = t,
    h(t) ? e.checked = ee(t, r.props.value) > -1 : g(t) ? e.checked = t.has(r.props.value) : t !== n && (e.checked = Z(t, Is(e, !0)))
}
const Os = {
  created(e, {value: t}, n) {
    e.checked = Z(t, n.props.value),
      e._assign = Es(n),
      Ni(e, "change", (()=>{
          e._assign(Ls(e))
        }
      ))
  },
  beforeUpdate(e, {value: t, oldValue: n}, r) {
    e._assign = Es(r),
    t !== n && (e.checked = Z(t, r.props.value))
  }
}
  , _s = {
  deep: !0,
  created(e, {value: t, modifiers: {number: n}}, r) {
    const o = g(t);
    Ni(e, "change", (()=>{
        const t = Array.prototype.filter.call(e.options, (e=>e.selected)).map((e=>n ? j(Ls(e)) : Ls(e)));
        e._assign(e.multiple ? o ? new Set(t) : t : t[0])
      }
    )),
      e._assign = Es(r)
  },
  mounted(e, {value: t}) {
    Rs(e, t)
  },
  beforeUpdate(e, t, n) {
    e._assign = Es(n)
  },
  updated(e, {value: t}) {
    Rs(e, t)
  }
};
function Rs(e, t) {
  const n = e.multiple;
  if (!n || h(t) || g(t)) {
    for (let r = 0, o = e.options.length; r < o; r++) {
      const o = e.options[r]
        , a = Ls(o);
      if (n)
        h(t) ? o.selected = ee(t, a) > -1 : o.selected = t.has(a);
      else if (Z(Ls(o), t))
        return void (e.selectedIndex !== r && (e.selectedIndex = r))
    }
    n || -1 === e.selectedIndex || (e.selectedIndex = -1)
  }
}
function Ls(e) {
  return "_value"in e ? e._value : e.value
}
function Is(e, t) {
  const n = t ? "_trueValue" : "_falseValue";
  return n in e ? e[n] : t
}
const Ps = {
  created(e, t, n) {
    Bs(e, t, n, null, "created")
  },
  mounted(e, t, n) {
    Bs(e, t, n, null, "mounted")
  },
  beforeUpdate(e, t, n, r) {
    Bs(e, t, n, r, "beforeUpdate")
  },
  updated(e, t, n, r) {
    Bs(e, t, n, r, "updated")
  }
};
function Fs(e, t) {
  switch (e) {
    case "SELECT":
      return _s;
    case "TEXTAREA":
      return ks;
    default:
      switch (t) {
        case "checkbox":
          return Ts;
        case "radio":
          return Os;
        default:
          return ks
      }
  }
}
function Bs(e, t, n, r, o) {
  const a = Fs(e.tagName, n.props && n.props.type)[o];
  a && a(e, t, n, r)
}
const Ns = ["ctrl", "shift", "alt", "meta"]
  , Ms = {
  stop: e=>e.stopPropagation(),
  prevent: e=>e.preventDefault(),
  self: e=>e.target !== e.currentTarget,
  ctrl: e=>!e.ctrlKey,
  shift: e=>!e.shiftKey,
  alt: e=>!e.altKey,
  meta: e=>!e.metaKey,
  left: e=>"button"in e && 0 !== e.button,
  middle: e=>"button"in e && 1 !== e.button,
  right: e=>"button"in e && 2 !== e.button,
  exact: (e,t)=>Ns.some((n=>e[`${n}Key`] && !t.includes(n)))
}
  , js = (e,t)=>(n,...r)=>{
  for (let e = 0; e < t.length; e++) {
    const r = Ms[t[e]];
    if (r && r(n, t))
      return
  }
  return e(n, ...r)
}
  , Vs = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}
  , Us = (e,t)=>n=>{
  if (!("key"in n))
    return;
  const r = I(n.key);
  return t.some((e=>e === r || Vs[e] === r)) ? e(n) : void 0
}
  , $s = {
  beforeMount(e, {value: t}, {transition: n}) {
    e._vod = "none" === e.style.display ? "" : e.style.display,
      n && t ? n.beforeEnter(e) : Hs(e, t)
  },
  mounted(e, {value: t}, {transition: n}) {
    n && t && n.enter(e)
  },
  updated(e, {value: t, oldValue: n}, {transition: r}) {
    !t != !n && (r ? t ? (r.beforeEnter(e),
      Hs(e, !0),
      r.enter(e)) : r.leave(e, (()=>{
        Hs(e, !1)
      }
    )) : Hs(e, t))
  },
  beforeUnmount(e, {value: t}) {
    Hs(e, t)
  }
};
function Hs(e, t) {
  e.style.display = t ? e._vod : "none"
}
const zs = c({
  patchProp: (e,t,n,r,o=!1,a,i,s,c)=>{
    "class" === t ? function(e, t, n) {
      const r = e._vtc;
      r && (t = (t ? [t, ...r] : [...r]).join(" ")),
        null == t ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
    }(e, r, o) : "style" === t ? function(e, t, n) {
      const r = e.style
        , o = b(n);
      if (n && !o) {
        if (t && !b(t))
          for (const e in t)
            null == n[e] && Ii(r, e, "");
        for (const e in n)
          Ii(r, e, n[e])
      } else {
        const a = r.display;
        o ? t !== n && (r.cssText = n) : t && e.removeAttribute("style"),
        "_vod"in e && (r.display = a)
      }
    }(e, n, r) : l(t) ? u(t) || Mi(e, t, 0, r, i) : ("." === t[0] ? (t = t.slice(1),
      1) : "^" === t[0] ? (t = t.slice(1),
      0) : function(e, t, n, r) {
      if (r)
        return "innerHTML" === t || "textContent" === t || !!(t in e && Hi.test(t) && y(n));
      if ("spellcheck" === t || "draggable" === t || "translate" === t)
        return !1;
      if ("form" === t)
        return !1;
      if ("list" === t && "INPUT" === e.tagName)
        return !1;
      if ("type" === t && "TEXTAREA" === e.tagName)
        return !1;
      if (Hi.test(t) && b(n))
        return !1;
      return t in e
    }(e, t, r, o)) ? function(e, t, n, r, o, a, i) {
      if ("innerHTML" === t || "textContent" === t)
        return r && i(r, o, a),
          void (e[t] = null == n ? "" : n);
      const s = e.tagName;
      if ("value" === t && "PROGRESS" !== s && !s.includes("-")) {
        e._value = n;
        const r = null == n ? "" : n;
        return ("OPTION" === s ? e.getAttribute("value") : e.value) !== r && (e.value = r),
          void (null == n && e.removeAttribute(t))
      }
      let l = !1;
      if ("" === n || null == n) {
        const r = typeof e[t];
        "boolean" === r ? n = J(n) : null == n && "string" === r ? (n = "",
          l = !0) : "number" === r && (n = 0,
          l = !0)
      }
      try {
        e[t] = n
      } catch (Y_) {}
      l && e.removeAttribute(t)
    }(e, t, r, a, i, s, c) : ("true-value" === t ? e._trueValue = r : "false-value" === t && (e._falseValue = r),
      function(e, t, n, r, o) {
        if (r && t.startsWith("xlink:"))
          null == n ? e.removeAttributeNS(Bi, t.slice(6, t.length)) : e.setAttributeNS(Bi, t, n);
        else {
          const r = Q(t);
          null == n || r && !J(n) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : n)
        }
      }(e, t, r, o))
  }
}, Ri);
let Ks, Ws = !1;
function Gs() {
  return Ks || (Ks = sa(zs))
}
function qs() {
  return Ks = Ws ? Ks : la(zs),
    Ws = !0,
    Ks
}
const Ys = (...e)=>{
    Gs().render(...e)
  }
  , Xs = (...e)=>{
    qs().hydrate(...e)
  }
  , Qs = (...e)=>{
    const t = Gs().createApp(...e)
      , {mount: n} = t;
    return t.mount = e=>{
      const r = Zs(e);
      if (!r)
        return;
      const o = t._component;
      y(o) || o.render || o.template || (o.template = r.innerHTML),
        r.innerHTML = "";
      const a = n(r, !1, r instanceof SVGElement);
      return r instanceof Element && (r.removeAttribute("v-cloak"),
        r.setAttribute("data-v-app", "")),
        a
    }
      ,
      t
  }
  , Js = (...e)=>{
    const t = qs().createApp(...e)
      , {mount: n} = t;
    return t.mount = e=>{
      const t = Zs(e);
      if (t)
        return n(t, !0, t instanceof SVGElement)
    }
      ,
      t
  }
;
function Zs(e) {
  if (b(e)) {
    return document.querySelector(e)
  }
  return e
}
let el = !1;
const tl = ()=>{
    el || (el = !0,
        ks.getSSRProps = ({value: e})=>({
          value: e
        }),
        Os.getSSRProps = ({value: e},t)=>{
          if (t.props && Z(t.props.value, e))
            return {
              checked: !0
            }
        }
        ,
        Ts.getSSRProps = ({value: e},t)=>{
          if (h(e)) {
            if (t.props && ee(e, t.props.value) > -1)
              return {
                checked: !0
              }
          } else if (g(e)) {
            if (t.props && e.has(t.props.value))
              return {
                checked: !0
              }
          } else if (e)
            return {
              checked: !0
            }
        }
        ,
        Ps.getSSRProps = (e,t)=>{
          if ("string" != typeof t.type)
            return;
          const n = Fs(t.type.toUpperCase(), t.props && t.props.type);
          return n.getSSRProps ? n.getSSRProps(e, t) : void 0
        }
        ,
        $s.getSSRProps = ({value: e})=>{
          if (!e)
            return {
              style: {
                display: "none"
              }
            }
        }
    )
  }
;
/*!
  * pinia v2.1.4
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
let nl;
const rl = e=>nl = e
  , ol = Symbol();
function al(e) {
  return e && "object" == typeof e && "[object Object]" === Object.prototype.toString.call(e) && "function" != typeof e.toJSON
}
var il, sl;
(sl = il || (il = {})).direct = "direct",
  sl.patchObject = "patch object",
  sl.patchFunction = "patch function";
const ll = ()=>{}
;
function ul(e, t, n, r=ll) {
  e.push(t);
  const o = ()=>{
      const n = e.indexOf(t);
      n > -1 && (e.splice(n, 1),
        r())
    }
  ;
  return !n && se() && le(o),
    o
}
function cl(e, ...t) {
  e.slice().forEach((e=>{
      e(...t)
    }
  ))
}
const dl = e=>e();
function fl(e, t) {
  e instanceof Map && t instanceof Map && t.forEach(((t,n)=>e.set(n, t))),
  e instanceof Set && t instanceof Set && t.forEach(e.add, e);
  for (const n in t) {
    if (!t.hasOwnProperty(n))
      continue;
    const r = t[n]
      , o = e[n];
    al(o) && al(r) && e.hasOwnProperty(n) && !Pt(r) && !At(r) ? e[n] = fl(o, r) : e[n] = r
  }
  return e
}
const pl = Symbol();
const {assign: hl} = Object;
function vl(e) {
  return !(!Pt(e) || !e.effect)
}
function gl(e, t, n={}, r, o, a) {
  let i;
  const s = hl({
    actions: {}
  }, n)
    , l = {
    deep: !0
  };
  let u, c, d, f = [], p = [];
  const h = r.state.value[e];
  let v;
  function g(t) {
    let n;
    u = c = !1,
      "function" == typeof t ? (t(r.state.value[e]),
        n = {
          type: il.patchFunction,
          storeId: e,
          events: d
        }) : (fl(r.state.value[e], t),
        n = {
          type: il.patchObject,
          payload: t,
          storeId: e,
          events: d
        });
    const o = v = Symbol();
    hn().then((()=>{
        v === o && (u = !0)
      }
    )),
      c = !0,
      cl(f, n, r.state.value[e])
  }
  a || h || (r.state.value[e] = {}),
    Ft({});
  const m = a ? function() {
      const {state: e} = n
        , t = e ? e() : {};
      this.$patch((e=>{
          hl(e, t)
        }
      ))
    }
    : ll;
  function y(t, n) {
    return function() {
      rl(r);
      const o = Array.from(arguments)
        , a = []
        , i = [];
      let s;
      cl(p, {
        args: o,
        name: t,
        store: b,
        after: function(e) {
          a.push(e)
        },
        onError: function(e) {
          i.push(e)
        }
      });
      try {
        s = n.apply(this && this.$id === e ? this : b, o)
      } catch (l) {
        throw cl(i, l),
          l
      }
      return s instanceof Promise ? s.then((e=>(cl(a, e),
        e))).catch((e=>(cl(i, e),
        Promise.reject(e)))) : (cl(a, s),
        s)
    }
  }
  const b = bt({
    _p: r,
    $id: e,
    $onAction: ul.bind(null, p),
    $patch: g,
    $reset: m,
    $subscribe(t, n={}) {
      const o = ul(f, t, n.detached, (()=>a()))
        , a = i.run((()=>Jn((()=>r.state.value[e]), (r=>{
          ("sync" === n.flush ? c : u) && t({
            storeId: e,
            type: il.direct,
            events: d
          }, r)
        }
      ), hl({}, l, n))));
      return o
    },
    $dispose: function() {
      i.stop(),
        f = [],
        p = [],
        r._s.delete(e)
    }
  });
  r._s.set(e, b);
  const w = r._a && r._a.runWithContext || dl
    , x = r._e.run((()=>(i = ae(),
    w((()=>i.run(t))))));
  for (const E in x) {
    const t = x[E];
    if (Pt(t) && !vl(t) || At(t))
      a || (!h || al(S = t) && S.hasOwnProperty(pl) || (Pt(t) ? t.value = h[E] : fl(t, h[E])),
        r.state.value[e][E] = t);
    else if ("function" == typeof t) {
      const e = y(E, t);
      x[E] = e,
        s.actions[E] = t
    }
  }
  var S;
  return hl(b, x),
    hl(Dt(b), x),
    Object.defineProperty(b, "$state", {
      get: ()=>r.state.value[e],
      set: e=>{
        g((t=>{
            hl(t, e)
          }
        ))
      }
    }),
    r._p.forEach((e=>{
        hl(b, i.run((()=>e({
          store: b,
          app: r._a,
          pinia: r,
          options: s
        }))))
      }
    )),
  h && a && n.hydrate && n.hydrate(b.$state, h),
    u = !0,
    c = !0,
    b
}
function ml(e, t, n) {
  let r, o;
  const a = "function" == typeof t;
  function i(e, n) {
    const i = Vo();
    (e = e || (i ? jo(ol, null) : null)) && rl(e),
    (e = nl)._s.has(r) || (a ? gl(r, t, o, e) : function(e, t, n, r) {
      const {state: o, actions: a, getters: i} = t
        , s = n.state.value[e];
      let l;
      l = gl(e, (function() {
          s || (n.state.value[e] = o ? o() : {});
          const t = Wt(n.state.value[e]);
          return hl(t, a, Object.keys(i || {}).reduce(((t,r)=>(t[r] = Ot(yi((()=>{
              rl(n);
              const t = n._s.get(e);
              return i[r].call(t, t)
            }
          ))),
            t)), {}))
        }
      ), t, n, 0, !0)
    }(r, o, e));
    return e._s.get(r)
  }
  return "string" == typeof e ? (r = e,
    o = a ? n : t) : (o = e,
    r = e.id),
    i.$id = r,
    i
}
const yl = {}
  , bl = function(e, t, n) {
  if (!t || 0 === t.length)
    return e();
  const r = document.getElementsByTagName("link");
  return Promise.all(t.map((e=>{
      if ((e = function(e) {
        return "/" + e
      }(e))in yl)
        return;
      yl[e] = !0;
      const t = e.endsWith(".css")
        , o = t ? '[rel="stylesheet"]' : "";
      if (!!n)
        for (let n = r.length - 1; n >= 0; n--) {
          const o = r[n];
          if (o.href === e && (!t || "stylesheet" === o.rel))
            return
        }
      else if (document.querySelector(`link[href="${e}"]${o}`))
        return;
      const a = document.createElement("link");
      return a.rel = t ? "stylesheet" : "modulepreload",
      t || (a.as = "script",
        a.crossOrigin = ""),
        a.href = e,
        document.head.appendChild(a),
        t ? new Promise(((t,n)=>{
            a.addEventListener("load", t),
              a.addEventListener("error", (()=>n(new Error(`Unable to preload CSS for ${e}`))))
          }
        )) : void 0
    }
  ))).then((()=>e())).catch((e=>{
      const t = new Event("vite:preloadError",{
        cancelable: !0
      });
      if (t.payload = e,
        window.dispatchEvent(t),
        !t.defaultPrevented)
        throw e
    }
  ))
}
  , wl = "undefined" != typeof window;
const xl = Object.assign;
function Sl(e, t) {
  const n = {};
  for (const r in t) {
    const o = t[r];
    n[r] = Al(o) ? o.map(e) : e(o)
  }
  return n
}
const El = ()=>{}
  , Al = Array.isArray
  , Cl = /\/$/
  , kl = e=>e.replace(Cl, "");
function Tl(e, t, n="/") {
  let r, o = {}, a = "", i = "";
  const s = t.indexOf("#");
  let l = t.indexOf("?");
  return s < l && s >= 0 && (l = -1),
  l > -1 && (r = t.slice(0, l),
    a = t.slice(l + 1, s > -1 ? s : t.length),
    o = e(a)),
  s > -1 && (r = r || t.slice(0, s),
    i = t.slice(s, t.length)),
    r = function(e, t) {
      if (e.startsWith("/"))
        return e;
      if (!e)
        return t;
      const n = t.split("/")
        , r = e.split("/")
        , o = r[r.length - 1];
      ".." !== o && "." !== o || r.push("");
      let a, i, s = n.length - 1;
      for (a = 0; a < r.length; a++)
        if (i = r[a],
        "." !== i) {
          if (".." !== i)
            break;
          s > 1 && s--
        }
      return n.slice(0, s).join("/") + "/" + r.slice(a - (a === r.length ? 1 : 0)).join("/")
    }(null != r ? r : t, n),
    {
      fullPath: r + (a && "?") + a + i,
      path: r,
      query: o,
      hash: i
    }
}
function Dl(e, t) {
  return t && e.toLowerCase().startsWith(t.toLowerCase()) ? e.slice(t.length) || "/" : e
}
function Ol(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t)
}
function _l(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const n in e)
    if (!Rl(e[n], t[n]))
      return !1;
  return !0
}
function Rl(e, t) {
  return Al(e) ? Ll(e, t) : Al(t) ? Ll(t, e) : e === t
}
function Ll(e, t) {
  return Al(t) ? e.length === t.length && e.every(((e,n)=>e === t[n])) : 1 === e.length && e[0] === t
}
var Il, Pl, Fl, Bl;
(Pl = Il || (Il = {})).pop = "pop",
  Pl.push = "push",
  (Bl = Fl || (Fl = {})).back = "back",
  Bl.forward = "forward",
  Bl.unknown = "";
const Nl = /^[^#]+#/;
function Ml(e, t) {
  return e.replace(Nl, "#") + t
}
const jl = ()=>({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function Vl(e) {
  let t;
  if ("el"in e) {
    const n = e.el
      , r = "string" == typeof n && n.startsWith("#")
      , o = "string" == typeof n ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
    if (!o)
      return;
    t = function(e, t) {
      const n = document.documentElement.getBoundingClientRect()
        , r = e.getBoundingClientRect();
      return {
        behavior: t.behavior,
        left: r.left - n.left - (t.left || 0),
        top: r.top - n.top - (t.top || 0)
      }
    }(o, e)
  } else
    t = e;
  "scrollBehavior"in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(null != t.left ? t.left : window.pageXOffset, null != t.top ? t.top : window.pageYOffset)
}
function Ul(e, t) {
  return (history.state ? history.state.position - t : -1) + e
}
const $l = new Map;
let Hl = ()=>location.protocol + "//" + location.host;
function zl(e, t) {
  const {pathname: n, search: r, hash: o} = t
    , a = e.indexOf("#");
  if (a > -1) {
    let t = o.includes(e.slice(a)) ? e.slice(a).length : 1
      , n = o.slice(t);
    return "/" !== n[0] && (n = "/" + n),
      Dl(n, "")
  }
  return Dl(n, e) + r + o
}
function Kl(e, t, n, r=!1, o=!1) {
  return {
    back: e,
    current: t,
    forward: n,
    replaced: r,
    position: window.history.length,
    scroll: o ? jl() : null
  }
}
function Wl(e) {
  const t = function(e) {
    const {history: t, location: n} = window
      , r = {
      value: zl(e, n)
    }
      , o = {
      value: t.state
    };
    function a(r, a, i) {
      const s = e.indexOf("#")
        , l = s > -1 ? (n.host && document.querySelector("base") ? e : e.slice(s)) + r : Hl() + e + r;
      try {
        t[i ? "replaceState" : "pushState"](a, "", l),
          o.value = a
      } catch (u) {
        console.error(u),
          n[i ? "replace" : "assign"](l)
      }
    }
    return o.value || a(r.value, {
      back: null,
      current: r.value,
      forward: null,
      position: t.length - 1,
      replaced: !0,
      scroll: null
    }, !0),
      {
        location: r,
        state: o,
        push: function(e, n) {
          const i = xl({}, o.value, t.state, {
            forward: e,
            scroll: jl()
          });
          a(i.current, i, !0),
            a(e, xl({}, Kl(r.value, e, null), {
              position: i.position + 1
            }, n), !1),
            r.value = e
        },
        replace: function(e, n) {
          a(e, xl({}, t.state, Kl(o.value.back, e, o.value.forward, !0), n, {
            position: o.value.position
          }), !0),
            r.value = e
        }
      }
  }(e = function(e) {
    if (!e)
      if (wl) {
        const t = document.querySelector("base");
        e = (e = t && t.getAttribute("href") || "/").replace(/^\w+:\/\/[^\/]+/, "")
      } else
        e = "/";
    return "/" !== e[0] && "#" !== e[0] && (e = "/" + e),
      kl(e)
  }(e))
    , n = function(e, t, n, r) {
    let o = []
      , a = []
      , i = null;
    const s = ({state: a})=>{
        const s = zl(e, location)
          , l = n.value
          , u = t.value;
        let c = 0;
        if (a) {
          if (n.value = s,
            t.value = a,
          i && i === l)
            return void (i = null);
          c = u ? a.position - u.position : 0
        } else
          r(s);
        o.forEach((e=>{
            e(n.value, l, {
              delta: c,
              type: Il.pop,
              direction: c ? c > 0 ? Fl.forward : Fl.back : Fl.unknown
            })
          }
        ))
      }
    ;
    function l() {
      const {history: e} = window;
      e.state && e.replaceState(xl({}, e.state, {
        scroll: jl()
      }), "")
    }
    return window.addEventListener("popstate", s),
      window.addEventListener("beforeunload", l, {
        passive: !0
      }),
      {
        pauseListeners: function() {
          i = n.value
        },
        listen: function(e) {
          o.push(e);
          const t = ()=>{
              const t = o.indexOf(e);
              t > -1 && o.splice(t, 1)
            }
          ;
          return a.push(t),
            t
        },
        destroy: function() {
          for (const e of a)
            e();
          a = [],
            window.removeEventListener("popstate", s),
            window.removeEventListener("beforeunload", l)
        }
      }
  }(e, t.state, t.location, t.replace);
  const r = xl({
    location: "",
    base: e,
    go: function(e, t=!0) {
      t || n.pauseListeners(),
        history.go(e)
    },
    createHref: Ml.bind(null, e)
  }, t, n);
  return Object.defineProperty(r, "location", {
    enumerable: !0,
    get: ()=>t.location.value
  }),
    Object.defineProperty(r, "state", {
      enumerable: !0,
      get: ()=>t.state.value
    }),
    r
}
function Gl(e) {
  return "string" == typeof e || "symbol" == typeof e
}
const ql = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
}
  , Yl = Symbol("");
var Xl, Ql;
function Jl(e, t) {
  return xl(new Error, {
    type: e,
    [Yl]: !0
  }, t)
}
function Zl(e, t) {
  return e instanceof Error && Yl in e && (null == t || !!(e.type & t))
}
(Ql = Xl || (Xl = {}))[Ql.aborted = 4] = "aborted",
  Ql[Ql.cancelled = 8] = "cancelled",
  Ql[Ql.duplicated = 16] = "duplicated";
const eu = "[^/]+?"
  , tu = {
  sensitive: !1,
  strict: !1,
  start: !0,
  end: !0
}
  , nu = /[.+*?^${}()[\]/\\]/g;
function ru(e, t) {
  let n = 0;
  for (; n < e.length && n < t.length; ) {
    const r = t[n] - e[n];
    if (r)
      return r;
    n++
  }
  return e.length < t.length ? 1 === e.length && 80 === e[0] ? -1 : 1 : e.length > t.length ? 1 === t.length && 80 === t[0] ? 1 : -1 : 0
}
function ou(e, t) {
  let n = 0;
  const r = e.score
    , o = t.score;
  for (; n < r.length && n < o.length; ) {
    const e = ru(r[n], o[n]);
    if (e)
      return e;
    n++
  }
  if (1 === Math.abs(o.length - r.length)) {
    if (au(r))
      return 1;
    if (au(o))
      return -1
  }
  return o.length - r.length
}
function au(e) {
  const t = e[e.length - 1];
  return e.length > 0 && t[t.length - 1] < 0
}
const iu = {
  type: 0,
  value: ""
}
  , su = /[a-zA-Z0-9_]/;
function lu(e, t, n) {
  const r = function(e, t) {
    const n = xl({}, tu, t)
      , r = [];
    let o = n.start ? "^" : "";
    const a = [];
    for (const l of e) {
      const e = l.length ? [] : [90];
      n.strict && !l.length && (o += "/");
      for (let t = 0; t < l.length; t++) {
        const r = l[t];
        let i = 40 + (n.sensitive ? .25 : 0);
        if (0 === r.type)
          t || (o += "/"),
            o += r.value.replace(nu, "\\$&"),
            i += 40;
        else if (1 === r.type) {
          const {value: e, repeatable: n, optional: u, regexp: c} = r;
          a.push({
            name: e,
            repeatable: n,
            optional: u
          });
          const d = c || eu;
          if (d !== eu) {
            i += 10;
            try {
              new RegExp(`(${d})`)
            } catch (s) {
              throw new Error(`Invalid custom RegExp for param "${e}" (${d}): ` + s.message)
            }
          }
          let f = n ? `((?:${d})(?:/(?:${d}))*)` : `(${d})`;
          t || (f = u && l.length < 2 ? `(?:/${f})` : "/" + f),
          u && (f += "?"),
            o += f,
            i += 20,
          u && (i += -8),
          n && (i += -20),
          ".*" === d && (i += -50)
        }
        e.push(i)
      }
      r.push(e)
    }
    if (n.strict && n.end) {
      const e = r.length - 1;
      r[e][r[e].length - 1] += .7000000000000001
    }
    n.strict || (o += "/?"),
      n.end ? o += "$" : n.strict && (o += "(?:/|$)");
    const i = new RegExp(o,n.sensitive ? "" : "i");
    return {
      re: i,
      score: r,
      keys: a,
      parse: function(e) {
        const t = e.match(i)
          , n = {};
        if (!t)
          return null;
        for (let r = 1; r < t.length; r++) {
          const e = t[r] || ""
            , o = a[r - 1];
          n[o.name] = e && o.repeatable ? e.split("/") : e
        }
        return n
      },
      stringify: function(t) {
        let n = ""
          , r = !1;
        for (const o of e) {
          r && n.endsWith("/") || (n += "/"),
            r = !1;
          for (const e of o)
            if (0 === e.type)
              n += e.value;
            else if (1 === e.type) {
              const {value: a, repeatable: i, optional: s} = e
                , l = a in t ? t[a] : "";
              if (Al(l) && !i)
                throw new Error(`Provided param "${a}" is an array but it is not repeatable (* or + modifiers)`);
              const u = Al(l) ? l.join("/") : l;
              if (!u) {
                if (!s)
                  throw new Error(`Missing required param "${a}"`);
                o.length < 2 && (n.endsWith("/") ? n = n.slice(0, -1) : r = !0)
              }
              n += u
            }
        }
        return n || "/"
      }
    }
  }(function(e) {
    if (!e)
      return [[]];
    if ("/" === e)
      return [[iu]];
    if (!e.startsWith("/"))
      throw new Error(`Invalid path "${e}"`);
    function t(e) {
      throw new Error(`ERR (${n})/"${u}": ${e}`)
    }
    let n = 0
      , r = n;
    const o = [];
    let a;
    function i() {
      a && o.push(a),
        a = []
    }
    let s, l = 0, u = "", c = "";
    function d() {
      u && (0 === n ? a.push({
        type: 0,
        value: u
      }) : 1 === n || 2 === n || 3 === n ? (a.length > 1 && ("*" === s || "+" === s) && t(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),
        a.push({
          type: 1,
          value: u,
          regexp: c,
          repeatable: "*" === s || "+" === s,
          optional: "*" === s || "?" === s
        })) : t("Invalid state to consume buffer"),
        u = "")
    }
    function f() {
      u += s
    }
    for (; l < e.length; )
      if (s = e[l++],
      "\\" !== s || 2 === n)
        switch (n) {
          case 0:
            "/" === s ? (u && d(),
              i()) : ":" === s ? (d(),
              n = 1) : f();
            break;
          case 4:
            f(),
              n = r;
            break;
          case 1:
            "(" === s ? n = 2 : su.test(s) ? f() : (d(),
              n = 0,
            "*" !== s && "?" !== s && "+" !== s && l--);
            break;
          case 2:
            ")" === s ? "\\" == c[c.length - 1] ? c = c.slice(0, -1) + s : n = 3 : c += s;
            break;
          case 3:
            d(),
              n = 0,
            "*" !== s && "?" !== s && "+" !== s && l--,
              c = "";
            break;
          default:
            t("Unknown state")
        }
      else
        r = n,
          n = 4;
    return 2 === n && t(`Unfinished custom RegExp for param "${u}"`),
      d(),
      i(),
      o
  }(e.path), n)
    , o = xl(r, {
    record: e,
    parent: t,
    children: [],
    alias: []
  });
  return t && !o.record.aliasOf == !t.record.aliasOf && t.children.push(o),
    o
}
function uu(e, t) {
  const n = []
    , r = new Map;
  function o(e, n, r) {
    const s = !r
      , l = function(e) {
      return {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: void 0,
        beforeEnter: e.beforeEnter,
        props: du(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in e ? e.components || null : e.component && {
          default: e.component
        }
      }
    }(e);
    l.aliasOf = r && r.record;
    const u = hu(t, e)
      , c = [l];
    if ("alias"in e) {
      const t = "string" == typeof e.alias ? [e.alias] : e.alias;
      for (const e of t)
        c.push(xl({}, l, {
          components: r ? r.record.components : l.components,
          path: e,
          aliasOf: r ? r.record : l
        }))
    }
    let d, f;
    for (const t of c) {
      const {path: c} = t;
      if (n && "/" !== c[0]) {
        const e = n.record.path
          , r = "/" === e[e.length - 1] ? "" : "/";
        t.path = n.record.path + (c && r + c)
      }
      if (d = lu(t, n, u),
        r ? r.alias.push(d) : (f = f || d,
        f !== d && f.alias.push(d),
        s && e.name && !fu(d) && a(e.name)),
        l.children) {
        const e = l.children;
        for (let t = 0; t < e.length; t++)
          o(e[t], d, r && r.children[t])
      }
      r = r || d,
      (d.record.components && Object.keys(d.record.components).length || d.record.name || d.record.redirect) && i(d)
    }
    return f ? ()=>{
        a(f)
      }
      : El
  }
  function a(e) {
    if (Gl(e)) {
      const t = r.get(e);
      t && (r.delete(e),
        n.splice(n.indexOf(t), 1),
        t.children.forEach(a),
        t.alias.forEach(a))
    } else {
      const t = n.indexOf(e);
      t > -1 && (n.splice(t, 1),
      e.record.name && r.delete(e.record.name),
        e.children.forEach(a),
        e.alias.forEach(a))
    }
  }
  function i(e) {
    let t = 0;
    for (; t < n.length && ou(e, n[t]) >= 0 && (e.record.path !== n[t].record.path || !vu(e, n[t])); )
      t++;
    n.splice(t, 0, e),
    e.record.name && !fu(e) && r.set(e.record.name, e)
  }
  return t = hu({
    strict: !1,
    end: !0,
    sensitive: !1
  }, t),
    e.forEach((e=>o(e))),
    {
      addRoute: o,
      resolve: function(e, t) {
        let o, a, i, s = {};
        if ("name"in e && e.name) {
          if (o = r.get(e.name),
            !o)
            throw Jl(1, {
              location: e
            });
          i = o.record.name,
            s = xl(cu(t.params, o.keys.filter((e=>!e.optional)).map((e=>e.name))), e.params && cu(e.params, o.keys.map((e=>e.name)))),
            a = o.stringify(s)
        } else if ("path"in e)
          a = e.path,
            o = n.find((e=>e.re.test(a))),
          o && (s = o.parse(a),
            i = o.record.name);
        else {
          if (o = t.name ? r.get(t.name) : n.find((e=>e.re.test(t.path))),
            !o)
            throw Jl(1, {
              location: e,
              currentLocation: t
            });
          i = o.record.name,
            s = xl({}, t.params, e.params),
            a = o.stringify(s)
        }
        const l = [];
        let u = o;
        for (; u; )
          l.unshift(u.record),
            u = u.parent;
        return {
          name: i,
          path: a,
          params: s,
          matched: l,
          meta: pu(l)
        }
      },
      removeRoute: a,
      getRoutes: function() {
        return n
      },
      getRecordMatcher: function(e) {
        return r.get(e)
      }
    }
}
function cu(e, t) {
  const n = {};
  for (const r of t)
    r in e && (n[r] = e[r]);
  return n
}
function du(e) {
  const t = {}
    , n = e.props || !1;
  if ("component"in e)
    t.default = n;
  else
    for (const r in e.components)
      t[r] = "object" == typeof n ? n[r] : n;
  return t
}
function fu(e) {
  for (; e; ) {
    if (e.record.aliasOf)
      return !0;
    e = e.parent
  }
  return !1
}
function pu(e) {
  return e.reduce(((e,t)=>xl(e, t.meta)), {})
}
function hu(e, t) {
  const n = {};
  for (const r in e)
    n[r] = r in t ? t[r] : e[r];
  return n
}
function vu(e, t) {
  return t.children.some((t=>t === e || vu(e, t)))
}
const gu = /#/g
  , mu = /&/g
  , yu = /\//g
  , bu = /=/g
  , wu = /\?/g
  , xu = /\+/g
  , Su = /%5B/g
  , Eu = /%5D/g
  , Au = /%5E/g
  , Cu = /%60/g
  , ku = /%7B/g
  , Tu = /%7C/g
  , Du = /%7D/g
  , Ou = /%20/g;
function _u(e) {
  return encodeURI("" + e).replace(Tu, "|").replace(Su, "[").replace(Eu, "]")
}
function Ru(e) {
  return _u(e).replace(xu, "%2B").replace(Ou, "+").replace(gu, "%23").replace(mu, "%26").replace(Cu, "`").replace(ku, "{").replace(Du, "}").replace(Au, "^")
}
function Lu(e) {
  return null == e ? "" : function(e) {
    return _u(e).replace(gu, "%23").replace(wu, "%3F")
  }(e).replace(yu, "%2F")
}
function Iu(e) {
  try {
    return decodeURIComponent("" + e)
  } catch (t) {}
  return "" + e
}
function Pu(e) {
  const t = {};
  if ("" === e || "?" === e)
    return t;
  const n = ("?" === e[0] ? e.slice(1) : e).split("&");
  for (let r = 0; r < n.length; ++r) {
    const e = n[r].replace(xu, " ")
      , o = e.indexOf("=")
      , a = Iu(o < 0 ? e : e.slice(0, o))
      , i = o < 0 ? null : Iu(e.slice(o + 1));
    if (a in t) {
      let e = t[a];
      Al(e) || (e = t[a] = [e]),
        e.push(i)
    } else
      t[a] = i
  }
  return t
}
function Fu(e) {
  let t = "";
  for (let n in e) {
    const r = e[n];
    if (n = Ru(n).replace(bu, "%3D"),
    null == r) {
      void 0 !== r && (t += (t.length ? "&" : "") + n);
      continue
    }
    (Al(r) ? r.map((e=>e && Ru(e))) : [r && Ru(r)]).forEach((e=>{
        void 0 !== e && (t += (t.length ? "&" : "") + n,
        null != e && (t += "=" + e))
      }
    ))
  }
  return t
}
function Bu(e) {
  const t = {};
  for (const n in e) {
    const r = e[n];
    void 0 !== r && (t[n] = Al(r) ? r.map((e=>null == e ? null : "" + e)) : null == r ? r : "" + r)
  }
  return t
}
const Nu = Symbol("")
  , Mu = Symbol("")
  , ju = Symbol("")
  , Vu = Symbol("")
  , Uu = Symbol("");
function $u() {
  let e = [];
  return {
    add: function(t) {
      return e.push(t),
        ()=>{
          const n = e.indexOf(t);
          n > -1 && e.splice(n, 1)
        }
    },
    list: ()=>e.slice(),
    reset: function() {
      e = []
    }
  }
}
function Hu(e, t, n, r, o) {
  const a = r && (r.enterCallbacks[o] = r.enterCallbacks[o] || []);
  return ()=>new Promise(((i,s)=>{
      const l = e=>{
        var l;
        !1 === e ? s(Jl(4, {
          from: n,
          to: t
        })) : e instanceof Error ? s(e) : "string" == typeof (l = e) || l && "object" == typeof l ? s(Jl(2, {
          from: t,
          to: e
        })) : (a && r.enterCallbacks[o] === a && "function" == typeof e && a.push(e),
          i())
      }
        , u = e.call(r && r.instances[o], t, n, l);
      let c = Promise.resolve(u);
      e.length < 3 && (c = c.then(l)),
        c.catch((e=>s(e)))
    }
  ))
}
function zu(e, t, n, r) {
  const o = [];
  for (const i of e)
    for (const e in i.components) {
      let s = i.components[e];
      if ("beforeRouteEnter" === t || i.instances[e])
        if ("object" == typeof (a = s) || "displayName"in a || "props"in a || "__vccOpts"in a) {
          const a = (s.__vccOpts || s)[t];
          a && o.push(Hu(a, n, r, i, e))
        } else {
          let a = s();
          o.push((()=>a.then((o=>{
              if (!o)
                return Promise.reject(new Error(`Couldn't resolve component "${e}" at "${i.path}"`));
              const a = (s = o).__esModule || "Module" === s[Symbol.toStringTag] ? o.default : o;
              var s;
              i.components[e] = a;
              const l = (a.__vccOpts || a)[t];
              return l && Hu(l, n, r, i, e)()
            }
          ))))
        }
    }
  var a;
  return o
}
function Ku(e) {
  const t = jo(ju)
    , n = jo(Vu)
    , r = yi((()=>t.resolve(Vt(e.to))))
    , o = yi((()=>{
      const {matched: e} = r.value
        , {length: t} = e
        , o = e[t - 1]
        , a = n.matched;
      if (!o || !a.length)
        return -1;
      const i = a.findIndex(Ol.bind(null, o));
      if (i > -1)
        return i;
      const s = Gu(e[t - 2]);
      return t > 1 && Gu(o) === s && a[a.length - 1].path !== s ? a.findIndex(Ol.bind(null, e[t - 2])) : i
    }
  ))
    , a = yi((()=>o.value > -1 && function(e, t) {
    for (const n in t) {
      const r = t[n]
        , o = e[n];
      if ("string" == typeof r) {
        if (r !== o)
          return !1
      } else if (!Al(o) || o.length !== r.length || r.some(((e,t)=>e !== o[t])))
        return !1
    }
    return !0
  }(n.params, r.value.params)))
    , i = yi((()=>o.value > -1 && o.value === n.matched.length - 1 && _l(n.params, r.value.params)));
  return {
    route: r,
    href: yi((()=>r.value.href)),
    isActive: a,
    isExactActive: i,
    navigate: function(n={}) {
      return function(e) {
        if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
          return;
        if (e.defaultPrevented)
          return;
        if (void 0 !== e.button && 0 !== e.button)
          return;
        if (e.currentTarget && e.currentTarget.getAttribute) {
          const t = e.currentTarget.getAttribute("target");
          if (/\b_blank\b/i.test(t))
            return
        }
        e.preventDefault && e.preventDefault();
        return !0
      }(n) ? t[Vt(e.replace) ? "replace" : "push"](Vt(e.to)).catch(El) : Promise.resolve()
    }
  }
}
const Wu = vr({
  name: "RouterLink",
  compatConfig: {
    MODE: 3
  },
  props: {
    to: {
      type: [String, Object],
      required: !0
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink: Ku,
  setup(e, {slots: t}) {
    const n = bt(Ku(e))
      , {options: r} = jo(ju)
      , o = yi((()=>({
      [qu(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
      [qu(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
    })));
    return ()=>{
      const r = t.default && t.default(n);
      return e.custom ? r : bi("a", {
        "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
        href: n.href,
        onClick: n.navigate,
        class: o.value
      }, r)
    }
  }
});
function Gu(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const qu = (e,t,n)=>null != e ? e : null != t ? t : n
  , Yu = vr({
  name: "RouterView",
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  compatConfig: {
    MODE: 3
  },
  setup(e, {attrs: t, slots: n}) {
    const r = jo(Uu)
      , o = yi((()=>e.route || r.value))
      , a = jo(Mu, 0)
      , i = yi((()=>{
        let e = Vt(a);
        const {matched: t} = o.value;
        let n;
        for (; (n = t[e]) && !n.components; )
          e++;
        return e
      }
    ))
      , s = yi((()=>o.value.matched[i.value]));
    Mo(Mu, yi((()=>i.value + 1))),
      Mo(Nu, s),
      Mo(Uu, o);
    const l = Ft();
    return Jn((()=>[l.value, s.value, e.name]), (([e,t,n],[r,o,a])=>{
        t && (t.instances[n] = e,
        o && o !== t && e && e === r && (t.leaveGuards.size || (t.leaveGuards = o.leaveGuards),
        t.updateGuards.size || (t.updateGuards = o.updateGuards))),
        !e || !t || o && Ol(t, o) && r || (t.enterCallbacks[n] || []).forEach((t=>t(e)))
      }
    ), {
      flush: "post"
    }),
      ()=>{
        const r = o.value
          , a = e.name
          , i = s.value
          , u = i && i.components[a];
        if (!u)
          return Xu(n.default, {
            Component: u,
            route: r
          });
        const c = i.props[a]
          , d = c ? !0 === c ? r.params : "function" == typeof c ? c(r) : c : null
          , f = bi(u, xl({}, d, t, {
          onVnodeUnmounted: e=>{
            e.component.isUnmounted && (i.instances[a] = null)
          }
          ,
          ref: l
        }));
        return Xu(n.default, {
          Component: f,
          route: r
        }) || f
      }
  }
});
function Xu(e, t) {
  if (!e)
    return null;
  const n = e(t);
  return 1 === n.length ? n[0] : n
}
const Qu = Yu;
function Ju() {
  return jo(ju)
}
function Zu() {
  return jo(Vu)
}
const ec = e=>Array.from(e.querySelectorAll('a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])')).filter((e=>tc(e) && (e=>"fixed" !== getComputedStyle(e).position && null !== e.offsetParent)(e)))
  , tc = e=>{
  if (e.tabIndex > 0 || 0 === e.tabIndex && null !== e.getAttribute("tabIndex"))
    return !0;
  if (e.disabled)
    return !1;
  switch (e.nodeName) {
    case "A":
      return !!e.href && "ignore" !== e.rel;
    case "INPUT":
      return !("hidden" === e.type || "file" === e.type);
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return !0;
    default:
      return !1
  }
}
  , nc = function(e, t, ...n) {
  let r;
  r = t.includes("mouse") || t.includes("click") ? "MouseEvents" : t.includes("key") ? "KeyboardEvent" : "HTMLEvents";
  const o = document.createEvent(r);
  return o.initEvent(t, ...n),
    e.dispatchEvent(o),
    e
}
  , rc = e=>!e.getAttribute("aria-owns")
  , oc = (e,t,n)=>{
  const {parentNode: r} = e;
  if (!r)
    return null;
  const o = r.querySelectorAll(n);
  return o[Array.prototype.indexOf.call(o, e) + t] || null
}
  , ac = e=>{
  e && (e.focus(),
  !rc(e) && e.click())
}
  , ic = (e,t,{checkForDefaultPrevented: n=!0}={})=>r=>{
  const o = null == e ? void 0 : e(r);
  if (!1 === n || !o)
    return null == t ? void 0 : t(r)
}
  , sc = e=>t=>"mouse" === t.pointerType ? e(t) : void 0;
var lc, uc = Object.defineProperty, cc = Object.defineProperties, dc = Object.getOwnPropertyDescriptors, fc = Object.getOwnPropertySymbols, pc = Object.prototype.hasOwnProperty, hc = Object.prototype.propertyIsEnumerable, vc = (e,t,n)=>t in e ? uc(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n;
function gc(e, t) {
  var n;
  const r = Bt();
  return qn((()=>{
      r.value = e()
    }
  ), ((e,t)=>cc(e, dc(t)))(((e,t)=>{
      for (var n in t || (t = {}))
        pc.call(t, n) && vc(e, n, t[n]);
      if (fc)
        for (var n of fc(t))
          hc.call(t, n) && vc(e, n, t[n]);
      return e
    }
  )({}, t), {
    flush: null != (n = null == t ? void 0 : t.flush) ? n : "sync"
  })),
    xt(r)
}
const mc = "undefined" != typeof window
  , yc = e=>"string" == typeof e
  , bc = ()=>{}
  , wc = mc && (null == (lc = null == window ? void 0 : window.navigator) ? void 0 : lc.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function xc(e) {
  return "function" == typeof e ? e() : Vt(e)
}
function Sc(e, t) {
  return function(...n) {
    return new Promise(((r,o)=>{
        Promise.resolve(e((()=>t.apply(this, n)), {
          fn: t,
          thisArg: this,
          args: n
        })).then(r).catch(o)
      }
    ))
  }
}
function Ec(e) {
  return !!se() && (le(e),
    !0)
}
function Ac(e, t=200, n={}) {
  return Sc(function(e, t={}) {
    let n, r, o = bc;
    const a = e=>{
        clearTimeout(e),
          o(),
          o = bc
      }
    ;
    return i=>{
      const s = xc(e)
        , l = xc(t.maxWait);
      return n && a(n),
        s <= 0 || void 0 !== l && l <= 0 ? (r && (a(r),
          r = null),
          Promise.resolve(i())) : new Promise(((e,u)=>{
            o = t.rejectOnCancel ? u : e,
            l && !r && (r = setTimeout((()=>{
                n && a(n),
                  r = null,
                  e(i())
              }
            ), l)),
              n = setTimeout((()=>{
                  r && a(r),
                    r = null,
                    e(i())
                }
              ), s)
          }
        ))
    }
  }(t, n), e)
}
function Cc(e, t=200, n=!1, r=!0, o=!1) {
  return Sc(function(e, t=!0, n=!0, r=!1) {
    let o, a, i = 0, s = !0, l = bc;
    const u = ()=>{
        o && (clearTimeout(o),
          o = void 0,
          l(),
          l = bc)
      }
    ;
    return c=>{
      const d = xc(e)
        , f = Date.now() - i
        , p = ()=>a = c();
      return u(),
        d <= 0 ? (i = Date.now(),
          p()) : (f > d && (n || !s) ? (i = Date.now(),
          p()) : t && (a = new Promise(((e,t)=>{
            l = r ? t : e,
              o = setTimeout((()=>{
                  i = Date.now(),
                    s = !0,
                    e(p()),
                    u()
                }
              ), Math.max(0, d - f))
          }
        ))),
        n || o || (o = setTimeout((()=>s = !0), d)),
          s = !1,
          a)
    }
  }(t, n, r, o), e)
}
function kc(e, t=!0) {
  ei() ? Lr(e) : t ? e() : hn(e)
}
function Tc(e, t, n={}) {
  const {immediate: r=!0} = n
    , o = Ft(!1);
  let a = null;
  function i() {
    a && (clearTimeout(a),
      a = null)
  }
  function s() {
    o.value = !1,
      i()
  }
  function l(...n) {
    i(),
      o.value = !0,
      a = setTimeout((()=>{
          o.value = !1,
            a = null,
            e(...n)
        }
      ), xc(t))
  }
  return r && (o.value = !0,
  mc && l()),
    Ec(s),
    {
      isPending: xt(o),
      start: l,
      stop: s
    }
}
function Dc(e) {
  var t;
  const n = xc(e);
  return null != (t = null == n ? void 0 : n.$el) ? t : n
}
const Oc = mc ? window : void 0
  , _c = mc ? window.document : void 0;
function Rc(...e) {
  let t, n, r, o;
  if (yc(e[0]) || Array.isArray(e[0]) ? ([n,r,o] = e,
    t = Oc) : [t,n,r,o] = e,
    !t)
    return bc;
  Array.isArray(n) || (n = [n]),
  Array.isArray(r) || (r = [r]);
  const a = []
    , i = ()=>{
      a.forEach((e=>e())),
        a.length = 0
    }
    , s = Jn((()=>[Dc(t), xc(o)]), (([e,t])=>{
        i(),
        e && a.push(...n.flatMap((n=>r.map((r=>((e,t,n,r)=>(e.addEventListener(t, n, r),
          ()=>e.removeEventListener(t, n, r)))(e, n, r, t))))))
      }
    ), {
      immediate: !0,
      flush: "post"
    })
    , l = ()=>{
      s(),
        i()
    }
  ;
  return Ec(l),
    l
}
let Lc = !1;
function Ic(e, t, n={}) {
  const {window: r=Oc, ignore: o=[], capture: a=!0, detectIframe: i=!1} = n;
  if (!r)
    return;
  wc && !Lc && (Lc = !0,
    Array.from(r.document.body.children).forEach((e=>e.addEventListener("click", bc))));
  let s = !0;
  const l = e=>o.some((t=>{
      if ("string" == typeof t)
        return Array.from(r.document.querySelectorAll(t)).some((t=>t === e.target || e.composedPath().includes(t)));
      {
        const n = Dc(t);
        return n && (e.target === n || e.composedPath().includes(n))
      }
    }
  ))
    , u = [Rc(r, "click", (n=>{
      const r = Dc(e);
      r && r !== n.target && !n.composedPath().includes(r) && (0 === n.detail && (s = !l(n)),
        s ? t(n) : s = !0)
    }
  ), {
    passive: !0,
    capture: a
  }), Rc(r, "pointerdown", (t=>{
      const n = Dc(e);
      n && (s = !t.composedPath().includes(n) && !l(t))
    }
  ), {
    passive: !0
  }), i && Rc(r, "blur", (n=>{
      var o;
      const a = Dc(e);
      "IFRAME" !== (null == (o = r.document.activeElement) ? void 0 : o.tagName) || (null == a ? void 0 : a.contains(r.document.activeElement)) || t(n)
    }
  ))].filter(Boolean);
  return ()=>u.forEach((e=>e()))
}
function Pc(e, t=!1) {
  const n = Ft()
    , r = ()=>n.value = Boolean(e());
  return r(),
    kc(r, t),
    n
}
const Fc = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}
  , Bc = "__vueuse_ssr_handlers__";
Fc[Bc] = Fc[Bc] || {};
var Nc = Object.getOwnPropertySymbols
  , Mc = Object.prototype.hasOwnProperty
  , jc = Object.prototype.propertyIsEnumerable
  , Vc = (e,t)=>{
    var n = {};
    for (var r in e)
      Mc.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (null != e && Nc)
      for (var r of Nc(e))
        t.indexOf(r) < 0 && jc.call(e, r) && (n[r] = e[r]);
    return n
  }
;
function Uc(e, t, n={}) {
  const r = n
    , {window: o=Oc} = r
    , a = Vc(r, ["window"]);
  let i;
  const s = Pc((()=>o && "ResizeObserver"in o))
    , l = ()=>{
      i && (i.disconnect(),
        i = void 0)
    }
    , u = Jn((()=>Dc(e)), (e=>{
        l(),
        s.value && o && e && (i = new ResizeObserver(t),
          i.observe(e, a))
      }
    ), {
      immediate: !0,
      flush: "post"
    })
    , c = ()=>{
      l(),
        u()
    }
  ;
  return Ec(c),
    {
      isSupported: s,
      stop: c
    }
}
function $c(e, t={}) {
  const {reset: n=!0, windowResize: r=!0, windowScroll: o=!0, immediate: a=!0} = t
    , i = Ft(0)
    , s = Ft(0)
    , l = Ft(0)
    , u = Ft(0)
    , c = Ft(0)
    , d = Ft(0)
    , f = Ft(0)
    , p = Ft(0);
  function h() {
    const t = Dc(e);
    if (!t)
      return void (n && (i.value = 0,
        s.value = 0,
        l.value = 0,
        u.value = 0,
        c.value = 0,
        d.value = 0,
        f.value = 0,
        p.value = 0));
    const r = t.getBoundingClientRect();
    i.value = r.height,
      s.value = r.bottom,
      l.value = r.left,
      u.value = r.right,
      c.value = r.top,
      d.value = r.width,
      f.value = r.x,
      p.value = r.y
  }
  return Uc(e, h),
    Jn((()=>Dc(e)), (e=>!e && h())),
  o && Rc("scroll", h, {
    capture: !0,
    passive: !0
  }),
  r && Rc("resize", h, {
    passive: !0
  }),
    kc((()=>{
        a && h()
      }
    )),
    {
      height: i,
      bottom: s,
      left: l,
      right: u,
      top: c,
      width: d,
      x: f,
      y: p,
      update: h
    }
}
var Hc, zc, Kc = Object.getOwnPropertySymbols, Wc = Object.prototype.hasOwnProperty, Gc = Object.prototype.propertyIsEnumerable;
function qc(e, t, n={}) {
  const r = n
    , {window: o=Oc} = r
    , a = ((e,t)=>{
      var n = {};
      for (var r in e)
        Wc.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
      if (null != e && Kc)
        for (var r of Kc(e))
          t.indexOf(r) < 0 && Gc.call(e, r) && (n[r] = e[r]);
      return n
    }
  )(r, ["window"]);
  let i;
  const s = Pc((()=>o && "MutationObserver"in o))
    , l = ()=>{
      i && (i.disconnect(),
        i = void 0)
    }
    , u = Jn((()=>Dc(e)), (e=>{
        l(),
        s.value && o && e && (i = new MutationObserver(t),
          i.observe(e, a))
      }
    ), {
      immediate: !0
    })
    , c = ()=>{
      l(),
        u()
    }
  ;
  return Ec(c),
    {
      isSupported: s,
      stop: c
    }
}
(zc = Hc || (Hc = {})).UP = "UP",
  zc.RIGHT = "RIGHT",
  zc.DOWN = "DOWN",
  zc.LEFT = "LEFT",
  zc.NONE = "NONE";
var Yc = Object.defineProperty
  , Xc = Object.getOwnPropertySymbols
  , Qc = Object.prototype.hasOwnProperty
  , Jc = Object.prototype.propertyIsEnumerable
  , Zc = (e,t,n)=>t in e ? Yc(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n;
function ed(e, t, n, r={}) {
  var o, a, i;
  const {clone: s=!1, passive: l=!1, eventName: u, deep: c=!1, defaultValue: d} = r
    , f = ei()
    , p = n || (null == f ? void 0 : f.emit) || (null == (o = null == f ? void 0 : f.$emit) ? void 0 : o.bind(f)) || (null == (i = null == (a = null == f ? void 0 : f.proxy) ? void 0 : a.$emit) ? void 0 : i.bind(null == f ? void 0 : f.proxy));
  let h = u;
  t || (t = "modelValue"),
    h = u || h || `update:${t.toString()}`;
  const v = e=>{
    return s ? (e=>"function" == typeof e)(s) ? s(e) : (t = e,
      JSON.parse(JSON.stringify(t))) : e;
    var t
  }
    , g = ()=>void 0 !== e[t] ? v(e[t]) : d;
  if (l) {
    const n = Ft(g());
    return Jn((()=>e[t]), (e=>n.value = v(e))),
      Jn(n, (n=>{
          (n !== e[t] || c) && p(h, n)
        }
      ), {
        deep: c
      }),
      n
  }
  return yi({
    get: ()=>g(),
    set(e) {
      p(h, e)
    }
  })
}
((e,t)=>{
    for (var n in t || (t = {}))
      Qc.call(t, n) && Zc(e, n, t[n]);
    if (Xc)
      for (var n of Xc(t))
        Jc.call(t, n) && Zc(e, n, t[n])
  }
)({
  linear: function(e) {
    return e
  }
}, {
  easeInSine: [.12, 0, .39, 0],
  easeOutSine: [.61, 1, .88, 1],
  easeInOutSine: [.37, 0, .63, 1],
  easeInQuad: [.11, 0, .5, 0],
  easeOutQuad: [.5, 1, .89, 1],
  easeInOutQuad: [.45, 0, .55, 1],
  easeInCubic: [.32, 0, .67, 0],
  easeOutCubic: [.33, 1, .68, 1],
  easeInOutCubic: [.65, 0, .35, 1],
  easeInQuart: [.5, 0, .75, 0],
  easeOutQuart: [.25, 1, .5, 1],
  easeInOutQuart: [.76, 0, .24, 1],
  easeInQuint: [.64, 0, .78, 0],
  easeOutQuint: [.22, 1, .36, 1],
  easeInOutQuint: [.83, 0, .17, 1],
  easeInExpo: [.7, 0, .84, 0],
  easeOutExpo: [.16, 1, .3, 1],
  easeInOutExpo: [.87, 0, .13, 1],
  easeInCirc: [.55, 0, 1, .45],
  easeOutCirc: [0, .55, .45, 1],
  easeInOutCirc: [.85, 0, .15, 1],
  easeInBack: [.36, 0, .66, -.56],
  easeOutBack: [.34, 1.56, .64, 1],
  easeInOutBack: [.68, -.6, .32, 1.6]
});
const td = ()=>mc && /firefox/i.test(window.navigator.userAgent)
  , nd = e=>{
    let t = 0
      , n = e;
    for (; n; )
      t += n.offsetTop,
        n = n.offsetParent;
    return t
  }
  , rd = (e,t)=>Math.abs(nd(e) - nd(t))
  , od = e=>{
    let t, n;
    return "touchend" === e.type ? (n = e.changedTouches[0].clientY,
      t = e.changedTouches[0].clientX) : e.type.startsWith("touch") ? (n = e.touches[0].clientY,
      t = e.touches[0].clientX) : (n = e.clientY,
      t = e.clientX),
      {
        clientX: t,
        clientY: n
      }
  }
;
const ad = "object" == typeof global && global && global.Object === Object && global;
var id = "object" == typeof self && self && self.Object === Object && self;
const sd = ad || id || Function("return this")();
const ld = sd.Symbol;
var ud = Object.prototype
  , cd = ud.hasOwnProperty
  , dd = ud.toString
  , fd = ld ? ld.toStringTag : void 0;
var pd = Object.prototype.toString;
var hd = "[object Null]"
  , vd = "[object Undefined]"
  , gd = ld ? ld.toStringTag : void 0;
function md(e) {
  return null == e ? void 0 === e ? vd : hd : gd && gd in Object(e) ? function(e) {
    var t = cd.call(e, fd)
      , n = e[fd];
    try {
      e[fd] = void 0;
      var r = !0
    } catch (Y_) {}
    var o = dd.call(e);
    return r && (t ? e[fd] = n : delete e[fd]),
      o
  }(e) : function(e) {
    return pd.call(e)
  }(e)
}
function yd(e) {
  return null != e && "object" == typeof e
}
var bd = "[object Symbol]";
function wd(e) {
  return "symbol" == typeof e || yd(e) && md(e) == bd
}
function xd(e, t) {
  for (var n = -1, r = null == e ? 0 : e.length, o = Array(r); ++n < r; )
    o[n] = t(e[n], n, e);
  return o
}
const Sd = Array.isArray;
var Ed = 1 / 0
  , Ad = ld ? ld.prototype : void 0
  , Cd = Ad ? Ad.toString : void 0;
function kd(e) {
  if ("string" == typeof e)
    return e;
  if (Sd(e))
    return xd(e, kd) + "";
  if (wd(e))
    return Cd ? Cd.call(e) : "";
  var t = e + "";
  return "0" == t && 1 / e == -Ed ? "-0" : t
}
var Td = /\s/;
var Dd = /^\s+/;
function Od(e) {
  return e ? e.slice(0, function(e) {
    for (var t = e.length; t-- && Td.test(e.charAt(t)); )
      ;
    return t
  }(e) + 1).replace(Dd, "") : e
}
function _d(e) {
  var t = typeof e;
  return null != e && ("object" == t || "function" == t)
}
var Rd = NaN
  , Ld = /^[-+]0x[0-9a-f]+$/i
  , Id = /^0b[01]+$/i
  , Pd = /^0o[0-7]+$/i
  , Fd = parseInt;
function Bd(e) {
  if ("number" == typeof e)
    return e;
  if (wd(e))
    return Rd;
  if (_d(e)) {
    var t = "function" == typeof e.valueOf ? e.valueOf() : e;
    e = _d(t) ? t + "" : t
  }
  if ("string" != typeof e)
    return 0 === e ? e : +e;
  e = Od(e);
  var n = Id.test(e);
  return n || Pd.test(e) ? Fd(e.slice(2), n ? 2 : 8) : Ld.test(e) ? Rd : +e
}
var Nd = 1 / 0
  , Md = 17976931348623157e292;
function jd(e) {
  var t = function(e) {
    return e ? (e = Bd(e)) === Nd || e === -Nd ? (e < 0 ? -1 : 1) * Md : e == e ? e : 0 : 0 === e ? e : 0
  }(e)
    , n = t % 1;
  return t == t ? n ? t - n : t : 0
}
function Vd(e) {
  return e
}
var Ud = "[object AsyncFunction]"
  , $d = "[object Function]"
  , Hd = "[object GeneratorFunction]"
  , zd = "[object Proxy]";
function Kd(e) {
  if (!_d(e))
    return !1;
  var t = md(e);
  return t == $d || t == Hd || t == Ud || t == zd
}
const Wd = sd["__core-js_shared__"];
var Gd, qd = (Gd = /[^.]+$/.exec(Wd && Wd.keys && Wd.keys.IE_PROTO || "")) ? "Symbol(src)_1." + Gd : "";
var Yd = Function.prototype.toString;
function Xd(e) {
  if (null != e) {
    try {
      return Yd.call(e)
    } catch (Y_) {}
    try {
      return e + ""
    } catch (Y_) {}
  }
  return ""
}
var Qd = /^\[object .+?Constructor\]$/
  , Jd = Function.prototype
  , Zd = Object.prototype
  , ef = Jd.toString
  , tf = Zd.hasOwnProperty
  , nf = RegExp("^" + ef.call(tf).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function rf(e) {
  return !(!_d(e) || (t = e,
  qd && qd in t)) && (Kd(e) ? nf : Qd).test(Xd(e));
  var t
}
function of(e, t) {
  var n = function(e, t) {
    return null == e ? void 0 : e[t]
  }(e, t);
  return rf(n) ? n : void 0
}
const af = of(sd, "WeakMap");
var sf = Object.create;
const lf = function() {
  function e() {}
  return function(t) {
    if (!_d(t))
      return {};
    if (sf)
      return sf(t);
    e.prototype = t;
    var n = new e;
    return e.prototype = void 0,
      n
  }
}();
function uf(e, t) {
  var n = -1
    , r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t
}
var cf = Date.now;
var df = function() {
  try {
    var e = of(Object, "defineProperty");
    return e({}, "", {}),
      e
  } catch (Y_) {}
}();
const ff = df;
var pf = ff ? function(e, t) {
    return ff(e, "toString", {
      configurable: !0,
      enumerable: !1,
      value: (n = t,
          function() {
            return n
          }
      ),
      writable: !0
    });
    var n
  }
  : Vd;
var hf, vf, gf;
const mf = (hf = pf,
    vf = 0,
    gf = 0,
    function() {
      var e = cf()
        , t = 16 - (e - gf);
      if (gf = e,
      t > 0) {
        if (++vf >= 800)
          return arguments[0]
      } else
        vf = 0;
      return hf.apply(void 0, arguments)
    }
);
function yf(e, t, n, r) {
  for (var o = e.length, a = n + (r ? 1 : -1); r ? a-- : ++a < o; )
    if (t(e[a], a, e))
      return a;
  return -1
}
function bf(e) {
  return e != e
}
function wf(e, t) {
  return !!(null == e ? 0 : e.length) && function(e, t, n) {
    return t == t ? function(e, t, n) {
      for (var r = n - 1, o = e.length; ++r < o; )
        if (e[r] === t)
          return r;
      return -1
    }(e, t, n) : yf(e, bf, n)
  }(e, t, 0) > -1
}
var xf = 9007199254740991
  , Sf = /^(?:0|[1-9]\d*)$/;
function Ef(e, t) {
  var n = typeof e;
  return !!(t = null == t ? xf : t) && ("number" == n || "symbol" != n && Sf.test(e)) && e > -1 && e % 1 == 0 && e < t
}
function Af(e, t, n) {
  "__proto__" == t && ff ? ff(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n
}
function Cf(e, t) {
  return e === t || e != e && t != t
}
var kf = Object.prototype.hasOwnProperty;
function Tf(e, t, n) {
  var r = e[t];
  kf.call(e, t) && Cf(r, n) && (void 0 !== n || t in e) || Af(e, t, n)
}
function Df(e, t, n, r) {
  var o = !n;
  n || (n = {});
  for (var a = -1, i = t.length; ++a < i; ) {
    var s = t[a]
      , l = r ? r(n[s], e[s], s, n, e) : void 0;
    void 0 === l && (l = e[s]),
      o ? Af(n, s, l) : Tf(n, s, l)
  }
  return n
}
var Of = Math.max;
function _f(e, t, n) {
  return t = Of(void 0 === t ? e.length - 1 : t, 0),
    function() {
      for (var r = arguments, o = -1, a = Of(r.length - t, 0), i = Array(a); ++o < a; )
        i[o] = r[t + o];
      o = -1;
      for (var s = Array(t + 1); ++o < t; )
        s[o] = r[o];
      return s[t] = n(i),
        function(e, t, n) {
          switch (n.length) {
            case 0:
              return e.call(t);
            case 1:
              return e.call(t, n[0]);
            case 2:
              return e.call(t, n[0], n[1]);
            case 3:
              return e.call(t, n[0], n[1], n[2])
          }
          return e.apply(t, n)
        }(e, this, s)
    }
}
function Rf(e, t) {
  return mf(_f(e, t, Vd), e + "")
}
var Lf = 9007199254740991;
function If(e) {
  return "number" == typeof e && e > -1 && e % 1 == 0 && e <= Lf
}
function Pf(e) {
  return null != e && If(e.length) && !Kd(e)
}
var Ff = Object.prototype;
function Bf(e) {
  var t = e && e.constructor;
  return e === ("function" == typeof t && t.prototype || Ff)
}
function Nf(e) {
  return yd(e) && "[object Arguments]" == md(e)
}
var Mf = Object.prototype
  , jf = Mf.hasOwnProperty
  , Vf = Mf.propertyIsEnumerable;
const Uf = Nf(function() {
    return arguments
  }()) ? Nf : function(e) {
    return yd(e) && jf.call(e, "callee") && !Vf.call(e, "callee")
  }
;
var $f = "object" == typeof exports && exports && !exports.nodeType && exports
  , Hf = $f && "object" == typeof module && module && !module.nodeType && module
  , zf = Hf && Hf.exports === $f ? sd.Buffer : void 0;
const Kf = (zf ? zf.isBuffer : void 0) || function() {
    return !1
  }
;
var Wf = {};
function Gf(e) {
  return function(t) {
    return e(t)
  }
}
Wf["[object Float32Array]"] = Wf["[object Float64Array]"] = Wf["[object Int8Array]"] = Wf["[object Int16Array]"] = Wf["[object Int32Array]"] = Wf["[object Uint8Array]"] = Wf["[object Uint8ClampedArray]"] = Wf["[object Uint16Array]"] = Wf["[object Uint32Array]"] = !0,
  Wf["[object Arguments]"] = Wf["[object Array]"] = Wf["[object ArrayBuffer]"] = Wf["[object Boolean]"] = Wf["[object DataView]"] = Wf["[object Date]"] = Wf["[object Error]"] = Wf["[object Function]"] = Wf["[object Map]"] = Wf["[object Number]"] = Wf["[object Object]"] = Wf["[object RegExp]"] = Wf["[object Set]"] = Wf["[object String]"] = Wf["[object WeakMap]"] = !1;
var qf = "object" == typeof exports && exports && !exports.nodeType && exports
  , Yf = qf && "object" == typeof module && module && !module.nodeType && module
  , Xf = Yf && Yf.exports === qf && ad.process;
const Qf = function() {
  try {
    var e = Yf && Yf.require && Yf.require("util").types;
    return e || Xf && Xf.binding && Xf.binding("util")
  } catch (Y_) {}
}();
var Jf = Qf && Qf.isTypedArray;
const Zf = Jf ? Gf(Jf) : function(e) {
    return yd(e) && If(e.length) && !!Wf[md(e)]
  }
;
var ep = Object.prototype.hasOwnProperty;
function tp(e, t) {
  var n = Sd(e)
    , r = !n && Uf(e)
    , o = !n && !r && Kf(e)
    , a = !n && !r && !o && Zf(e)
    , i = n || r || o || a
    , s = i ? function(e, t) {
    for (var n = -1, r = Array(e); ++n < e; )
      r[n] = t(n);
    return r
  }(e.length, String) : []
    , l = s.length;
  for (var u in e)
    !t && !ep.call(e, u) || i && ("length" == u || o && ("offset" == u || "parent" == u) || a && ("buffer" == u || "byteLength" == u || "byteOffset" == u) || Ef(u, l)) || s.push(u);
  return s
}
function np(e, t) {
  return function(n) {
    return e(t(n))
  }
}
const rp = np(Object.keys, Object);
var op = Object.prototype.hasOwnProperty;
function ap(e) {
  return Pf(e) ? tp(e) : function(e) {
    if (!Bf(e))
      return rp(e);
    var t = [];
    for (var n in Object(e))
      op.call(e, n) && "constructor" != n && t.push(n);
    return t
  }(e)
}
var ip = Object.prototype.hasOwnProperty;
function sp(e) {
  if (!_d(e))
    return function(e) {
      var t = [];
      if (null != e)
        for (var n in Object(e))
          t.push(n);
      return t
    }(e);
  var t = Bf(e)
    , n = [];
  for (var r in e)
    ("constructor" != r || !t && ip.call(e, r)) && n.push(r);
  return n
}
function lp(e) {
  return Pf(e) ? tp(e, !0) : sp(e)
}
var up = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
  , cp = /^\w*$/;
function dp(e, t) {
  if (Sd(e))
    return !1;
  var n = typeof e;
  return !("number" != n && "symbol" != n && "boolean" != n && null != e && !wd(e)) || (cp.test(e) || !up.test(e) || null != t && e in Object(t))
}
const fp = of(Object, "create");
var pp = Object.prototype.hasOwnProperty;
var hp = Object.prototype.hasOwnProperty;
function vp(e) {
  var t = -1
    , n = null == e ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1])
  }
}
function gp(e, t) {
  for (var n = e.length; n--; )
    if (Cf(e[n][0], t))
      return n;
  return -1
}
vp.prototype.clear = function() {
  this.__data__ = fp ? fp(null) : {},
    this.size = 0
}
  ,
  vp.prototype.delete = function(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0,
      t
  }
  ,
  vp.prototype.get = function(e) {
    var t = this.__data__;
    if (fp) {
      var n = t[e];
      return "__lodash_hash_undefined__" === n ? void 0 : n
    }
    return pp.call(t, e) ? t[e] : void 0
  }
  ,
  vp.prototype.has = function(e) {
    var t = this.__data__;
    return fp ? void 0 !== t[e] : hp.call(t, e)
  }
  ,
  vp.prototype.set = function(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1,
      n[e] = fp && void 0 === t ? "__lodash_hash_undefined__" : t,
      this
  }
;
var mp = Array.prototype.splice;
function yp(e) {
  var t = -1
    , n = null == e ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1])
  }
}
yp.prototype.clear = function() {
  this.__data__ = [],
    this.size = 0
}
  ,
  yp.prototype.delete = function(e) {
    var t = this.__data__
      , n = gp(t, e);
    return !(n < 0) && (n == t.length - 1 ? t.pop() : mp.call(t, n, 1),
      --this.size,
      !0)
  }
  ,
  yp.prototype.get = function(e) {
    var t = this.__data__
      , n = gp(t, e);
    return n < 0 ? void 0 : t[n][1]
  }
  ,
  yp.prototype.has = function(e) {
    return gp(this.__data__, e) > -1
  }
  ,
  yp.prototype.set = function(e, t) {
    var n = this.__data__
      , r = gp(n, e);
    return r < 0 ? (++this.size,
      n.push([e, t])) : n[r][1] = t,
      this
  }
;
const bp = of(sd, "Map");
function wp(e, t) {
  var n, r, o = e.__data__;
  return ("string" == (r = typeof (n = t)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? o["string" == typeof t ? "string" : "hash"] : o.map
}
function xp(e) {
  var t = -1
    , n = null == e ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1])
  }
}
xp.prototype.clear = function() {
  this.size = 0,
    this.__data__ = {
      hash: new vp,
      map: new (bp || yp),
      string: new vp
    }
}
  ,
  xp.prototype.delete = function(e) {
    var t = wp(this, e).delete(e);
    return this.size -= t ? 1 : 0,
      t
  }
  ,
  xp.prototype.get = function(e) {
    return wp(this, e).get(e)
  }
  ,
  xp.prototype.has = function(e) {
    return wp(this, e).has(e)
  }
  ,
  xp.prototype.set = function(e, t) {
    var n = wp(this, e)
      , r = n.size;
    return n.set(e, t),
      this.size += n.size == r ? 0 : 1,
      this
  }
;
var Sp = "Expected a function";
function Ep(e, t) {
  if ("function" != typeof e || null != t && "function" != typeof t)
    throw new TypeError(Sp);
  var n = function() {
    var r = arguments
      , o = t ? t.apply(this, r) : r[0]
      , a = n.cache;
    if (a.has(o))
      return a.get(o);
    var i = e.apply(this, r);
    return n.cache = a.set(o, i) || a,
      i
  };
  return n.cache = new (Ep.Cache || xp),
    n
}
Ep.Cache = xp;
var Ap = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
  , Cp = /\\(\\)?/g
  , kp = function(e) {
  var t = Ep(e, (function(e) {
      return 500 === n.size && n.clear(),
        e
    }
  ))
    , n = t.cache;
  return t
}((function(e) {
    var t = [];
    return 46 === e.charCodeAt(0) && t.push(""),
      e.replace(Ap, (function(e, n, r, o) {
          t.push(r ? o.replace(Cp, "$1") : n || e)
        }
      )),
      t
  }
));
const Tp = kp;
function Dp(e, t) {
  return Sd(e) ? e : dp(e, t) ? [e] : Tp(function(e) {
    return null == e ? "" : kd(e)
  }(e))
}
var Op = 1 / 0;
function _p(e) {
  if ("string" == typeof e || wd(e))
    return e;
  var t = e + "";
  return "0" == t && 1 / e == -Op ? "-0" : t
}
function Rp(e, t) {
  for (var n = 0, r = (t = Dp(t, e)).length; null != e && n < r; )
    e = e[_p(t[n++])];
  return n && n == r ? e : void 0
}
function Lp(e, t, n) {
  var r = null == e ? void 0 : Rp(e, t);
  return void 0 === r ? n : r
}
function Ip(e, t) {
  for (var n = -1, r = t.length, o = e.length; ++n < r; )
    e[o + n] = t[n];
  return e
}
var Pp = ld ? ld.isConcatSpreadable : void 0;
function Fp(e) {
  return Sd(e) || Uf(e) || !!(Pp && e && e[Pp])
}
function Bp(e, t, n, r, o) {
  var a = -1
    , i = e.length;
  for (n || (n = Fp),
       o || (o = []); ++a < i; ) {
    var s = e[a];
    t > 0 && n(s) ? t > 1 ? Bp(s, t - 1, n, r, o) : Ip(o, s) : r || (o[o.length] = s)
  }
  return o
}
function Np(e) {
  return (null == e ? 0 : e.length) ? Bp(e, 1) : []
}
function Mp(e) {
  return mf(_f(e, void 0, Np), e + "")
}
const jp = np(Object.getPrototypeOf, Object);
var Vp = "[object Object]"
  , Up = Function.prototype
  , $p = Object.prototype
  , Hp = Up.toString
  , zp = $p.hasOwnProperty
  , Kp = Hp.call(Object);
function Wp(e) {
  if (!yd(e) || md(e) != Vp)
    return !1;
  var t = jp(e);
  if (null === t)
    return !0;
  var n = zp.call(t, "constructor") && t.constructor;
  return "function" == typeof n && n instanceof n && Hp.call(n) == Kp
}
function Gp() {
  if (!arguments.length)
    return [];
  var e = arguments[0];
  return Sd(e) ? e : [e]
}
function qp(e) {
  var t = this.__data__ = new yp(e);
  this.size = t.size
}
qp.prototype.clear = function() {
  this.__data__ = new yp,
    this.size = 0
}
  ,
  qp.prototype.delete = function(e) {
    var t = this.__data__
      , n = t.delete(e);
    return this.size = t.size,
      n
  }
  ,
  qp.prototype.get = function(e) {
    return this.__data__.get(e)
  }
  ,
  qp.prototype.has = function(e) {
    return this.__data__.has(e)
  }
  ,
  qp.prototype.set = function(e, t) {
    var n = this.__data__;
    if (n instanceof yp) {
      var r = n.__data__;
      if (!bp || r.length < 199)
        return r.push([e, t]),
          this.size = ++n.size,
          this;
      n = this.__data__ = new xp(r)
    }
    return n.set(e, t),
      this.size = n.size,
      this
  }
;
var Yp = "object" == typeof exports && exports && !exports.nodeType && exports
  , Xp = Yp && "object" == typeof module && module && !module.nodeType && module
  , Qp = Xp && Xp.exports === Yp ? sd.Buffer : void 0
  , Jp = Qp ? Qp.allocUnsafe : void 0;
function Zp(e, t) {
  if (t)
    return e.slice();
  var n = e.length
    , r = Jp ? Jp(n) : new e.constructor(n);
  return e.copy(r),
    r
}
function eh() {
  return []
}
var th = Object.prototype.propertyIsEnumerable
  , nh = Object.getOwnPropertySymbols;
const rh = nh ? function(e) {
    return null == e ? [] : (e = Object(e),
      function(e, t) {
        for (var n = -1, r = null == e ? 0 : e.length, o = 0, a = []; ++n < r; ) {
          var i = e[n];
          t(i, n, e) && (a[o++] = i)
        }
        return a
      }(nh(e), (function(t) {
          return th.call(e, t)
        }
      )))
  }
  : eh;
const oh = Object.getOwnPropertySymbols ? function(e) {
    for (var t = []; e; )
      Ip(t, rh(e)),
        e = jp(e);
    return t
  }
  : eh;
function ah(e, t, n) {
  var r = t(e);
  return Sd(e) ? r : Ip(r, n(e))
}
function ih(e) {
  return ah(e, ap, rh)
}
function sh(e) {
  return ah(e, lp, oh)
}
const lh = of(sd, "DataView");
const uh = of(sd, "Promise");
const ch = of(sd, "Set");
var dh = "[object Map]"
  , fh = "[object Promise]"
  , ph = "[object Set]"
  , hh = "[object WeakMap]"
  , vh = "[object DataView]"
  , gh = Xd(lh)
  , mh = Xd(bp)
  , yh = Xd(uh)
  , bh = Xd(ch)
  , wh = Xd(af)
  , xh = md;
(lh && xh(new lh(new ArrayBuffer(1))) != vh || bp && xh(new bp) != dh || uh && xh(uh.resolve()) != fh || ch && xh(new ch) != ph || af && xh(new af) != hh) && (xh = function(e) {
    var t = md(e)
      , n = "[object Object]" == t ? e.constructor : void 0
      , r = n ? Xd(n) : "";
    if (r)
      switch (r) {
        case gh:
          return vh;
        case mh:
          return dh;
        case yh:
          return fh;
        case bh:
          return ph;
        case wh:
          return hh
      }
    return t
  }
);
const Sh = xh;
var Eh = Object.prototype.hasOwnProperty;
const Ah = sd.Uint8Array;
function Ch(e) {
  var t = new e.constructor(e.byteLength);
  return new Ah(t).set(new Ah(e)),
    t
}
var kh = /\w*$/;
var Th = ld ? ld.prototype : void 0
  , Dh = Th ? Th.valueOf : void 0;
function Oh(e, t) {
  var n = t ? Ch(e.buffer) : e.buffer;
  return new e.constructor(n,e.byteOffset,e.length)
}
var _h = "[object Boolean]"
  , Rh = "[object Date]"
  , Lh = "[object Map]"
  , Ih = "[object Number]"
  , Ph = "[object RegExp]"
  , Fh = "[object Set]"
  , Bh = "[object String]"
  , Nh = "[object Symbol]"
  , Mh = "[object ArrayBuffer]"
  , jh = "[object DataView]"
  , Vh = "[object Float32Array]"
  , Uh = "[object Float64Array]"
  , $h = "[object Int8Array]"
  , Hh = "[object Int16Array]"
  , zh = "[object Int32Array]"
  , Kh = "[object Uint8Array]"
  , Wh = "[object Uint8ClampedArray]"
  , Gh = "[object Uint16Array]"
  , qh = "[object Uint32Array]";
function Yh(e, t, n) {
  var r, o, a, i = e.constructor;
  switch (t) {
    case Mh:
      return Ch(e);
    case _h:
    case Rh:
      return new i(+e);
    case jh:
      return function(e, t) {
        var n = t ? Ch(e.buffer) : e.buffer;
        return new e.constructor(n,e.byteOffset,e.byteLength)
      }(e, n);
    case Vh:
    case Uh:
    case $h:
    case Hh:
    case zh:
    case Kh:
    case Wh:
    case Gh:
    case qh:
      return Oh(e, n);
    case Lh:
      return new i;
    case Ih:
    case Bh:
      return new i(e);
    case Ph:
      return (a = new (o = e).constructor(o.source,kh.exec(o))).lastIndex = o.lastIndex,
        a;
    case Fh:
      return new i;
    case Nh:
      return r = e,
        Dh ? Object(Dh.call(r)) : {}
  }
}
function Xh(e) {
  return "function" != typeof e.constructor || Bf(e) ? {} : lf(jp(e))
}
var Qh = Qf && Qf.isMap;
const Jh = Qh ? Gf(Qh) : function(e) {
    return yd(e) && "[object Map]" == Sh(e)
  }
;
var Zh = Qf && Qf.isSet;
const ev = Zh ? Gf(Zh) : function(e) {
    return yd(e) && "[object Set]" == Sh(e)
  }
;
var tv = 1
  , nv = 2
  , rv = 4
  , ov = "[object Arguments]"
  , av = "[object Function]"
  , iv = "[object GeneratorFunction]"
  , sv = "[object Object]"
  , lv = {};
function uv(e, t, n, r, o, a) {
  var i, s = t & tv, l = t & nv, u = t & rv;
  if (n && (i = o ? n(e, r, o, a) : n(e)),
  void 0 !== i)
    return i;
  if (!_d(e))
    return e;
  var c = Sd(e);
  if (c) {
    if (i = function(e) {
      var t = e.length
        , n = new e.constructor(t);
      return t && "string" == typeof e[0] && Eh.call(e, "index") && (n.index = e.index,
        n.input = e.input),
        n
    }(e),
      !s)
      return uf(e, i)
  } else {
    var d = Sh(e)
      , f = d == av || d == iv;
    if (Kf(e))
      return Zp(e, s);
    if (d == sv || d == ov || f && !o) {
      if (i = l || f ? {} : Xh(e),
        !s)
        return l ? function(e, t) {
          return Df(e, oh(e), t)
        }(e, function(e, t) {
          return e && Df(t, lp(t), e)
        }(i, e)) : function(e, t) {
          return Df(e, rh(e), t)
        }(e, function(e, t) {
          return e && Df(t, ap(t), e)
        }(i, e))
    } else {
      if (!lv[d])
        return o ? e : {};
      i = Yh(e, d, s)
    }
  }
  a || (a = new qp);
  var p = a.get(e);
  if (p)
    return p;
  a.set(e, i),
    ev(e) ? e.forEach((function(r) {
        i.add(uv(r, t, n, r, e, a))
      }
    )) : Jh(e) && e.forEach((function(r, o) {
        i.set(o, uv(r, t, n, o, e, a))
      }
    ));
  var h = c ? void 0 : (u ? l ? sh : ih : l ? lp : ap)(e);
  return function(e, t) {
    for (var n = -1, r = null == e ? 0 : e.length; ++n < r && !1 !== t(e[n], n, e); )
      ;
  }(h || e, (function(r, o) {
      h && (r = e[o = r]),
        Tf(i, o, uv(r, t, n, o, e, a))
    }
  )),
    i
}
lv[ov] = lv["[object Array]"] = lv["[object ArrayBuffer]"] = lv["[object DataView]"] = lv["[object Boolean]"] = lv["[object Date]"] = lv["[object Float32Array]"] = lv["[object Float64Array]"] = lv["[object Int8Array]"] = lv["[object Int16Array]"] = lv["[object Int32Array]"] = lv["[object Map]"] = lv["[object Number]"] = lv[sv] = lv["[object RegExp]"] = lv["[object Set]"] = lv["[object String]"] = lv["[object Symbol]"] = lv["[object Uint8Array]"] = lv["[object Uint8ClampedArray]"] = lv["[object Uint16Array]"] = lv["[object Uint32Array]"] = !0,
  lv["[object Error]"] = lv[av] = lv["[object WeakMap]"] = !1;
function cv(e) {
  return uv(e, 4)
}
function dv(e) {
  return uv(e, 5)
}
function fv(e) {
  var t = -1
    , n = null == e ? 0 : e.length;
  for (this.__data__ = new xp; ++t < n; )
    this.add(e[t])
}
function pv(e, t) {
  for (var n = -1, r = null == e ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1
}
function hv(e, t) {
  return e.has(t)
}
fv.prototype.add = fv.prototype.push = function(e) {
  return this.__data__.set(e, "__lodash_hash_undefined__"),
    this
}
  ,
  fv.prototype.has = function(e) {
    return this.__data__.has(e)
  }
;
var vv = 1
  , gv = 2;
function mv(e, t, n, r, o, a) {
  var i = n & vv
    , s = e.length
    , l = t.length;
  if (s != l && !(i && l > s))
    return !1;
  var u = a.get(e)
    , c = a.get(t);
  if (u && c)
    return u == t && c == e;
  var d = -1
    , f = !0
    , p = n & gv ? new fv : void 0;
  for (a.set(e, t),
         a.set(t, e); ++d < s; ) {
    var h = e[d]
      , v = t[d];
    if (r)
      var g = i ? r(v, h, d, t, e, a) : r(h, v, d, e, t, a);
    if (void 0 !== g) {
      if (g)
        continue;
      f = !1;
      break
    }
    if (p) {
      if (!pv(t, (function(e, t) {
          if (!hv(p, t) && (h === e || o(h, e, n, r, a)))
            return p.push(t)
        }
      ))) {
        f = !1;
        break
      }
    } else if (h !== v && !o(h, v, n, r, a)) {
      f = !1;
      break
    }
  }
  return a.delete(e),
    a.delete(t),
    f
}
function yv(e) {
  var t = -1
    , n = Array(e.size);
  return e.forEach((function(e, r) {
      n[++t] = [r, e]
    }
  )),
    n
}
function bv(e) {
  var t = -1
    , n = Array(e.size);
  return e.forEach((function(e) {
      n[++t] = e
    }
  )),
    n
}
var wv = 1
  , xv = 2
  , Sv = "[object Boolean]"
  , Ev = "[object Date]"
  , Av = "[object Error]"
  , Cv = "[object Map]"
  , kv = "[object Number]"
  , Tv = "[object RegExp]"
  , Dv = "[object Set]"
  , Ov = "[object String]"
  , _v = "[object Symbol]"
  , Rv = "[object ArrayBuffer]"
  , Lv = "[object DataView]"
  , Iv = ld ? ld.prototype : void 0
  , Pv = Iv ? Iv.valueOf : void 0;
var Fv = 1
  , Bv = Object.prototype.hasOwnProperty;
var Nv = 1
  , Mv = "[object Arguments]"
  , jv = "[object Array]"
  , Vv = "[object Object]"
  , Uv = Object.prototype.hasOwnProperty;
function $v(e, t, n, r, o, a) {
  var i = Sd(e)
    , s = Sd(t)
    , l = i ? jv : Sh(e)
    , u = s ? jv : Sh(t)
    , c = (l = l == Mv ? Vv : l) == Vv
    , d = (u = u == Mv ? Vv : u) == Vv
    , f = l == u;
  if (f && Kf(e)) {
    if (!Kf(t))
      return !1;
    i = !0,
      c = !1
  }
  if (f && !c)
    return a || (a = new qp),
      i || Zf(e) ? mv(e, t, n, r, o, a) : function(e, t, n, r, o, a, i) {
        switch (n) {
          case Lv:
            if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
              return !1;
            e = e.buffer,
              t = t.buffer;
          case Rv:
            return !(e.byteLength != t.byteLength || !a(new Ah(e), new Ah(t)));
          case Sv:
          case Ev:
          case kv:
            return Cf(+e, +t);
          case Av:
            return e.name == t.name && e.message == t.message;
          case Tv:
          case Ov:
            return e == t + "";
          case Cv:
            var s = yv;
          case Dv:
            var l = r & wv;
            if (s || (s = bv),
            e.size != t.size && !l)
              return !1;
            var u = i.get(e);
            if (u)
              return u == t;
            r |= xv,
              i.set(e, t);
            var c = mv(s(e), s(t), r, o, a, i);
            return i.delete(e),
              c;
          case _v:
            if (Pv)
              return Pv.call(e) == Pv.call(t)
        }
        return !1
      }(e, t, l, n, r, o, a);
  if (!(n & Nv)) {
    var p = c && Uv.call(e, "__wrapped__")
      , h = d && Uv.call(t, "__wrapped__");
    if (p || h) {
      var v = p ? e.value() : e
        , g = h ? t.value() : t;
      return a || (a = new qp),
        o(v, g, n, r, a)
    }
  }
  return !!f && (a || (a = new qp),
    function(e, t, n, r, o, a) {
      var i = n & Fv
        , s = ih(e)
        , l = s.length;
      if (l != ih(t).length && !i)
        return !1;
      for (var u = l; u--; ) {
        var c = s[u];
        if (!(i ? c in t : Bv.call(t, c)))
          return !1
      }
      var d = a.get(e)
        , f = a.get(t);
      if (d && f)
        return d == t && f == e;
      var p = !0;
      a.set(e, t),
        a.set(t, e);
      for (var h = i; ++u < l; ) {
        var v = e[c = s[u]]
          , g = t[c];
        if (r)
          var m = i ? r(g, v, c, t, e, a) : r(v, g, c, e, t, a);
        if (!(void 0 === m ? v === g || o(v, g, n, r, a) : m)) {
          p = !1;
          break
        }
        h || (h = "constructor" == c)
      }
      if (p && !h) {
        var y = e.constructor
          , b = t.constructor;
        y == b || !("constructor"in e) || !("constructor"in t) || "function" == typeof y && y instanceof y && "function" == typeof b && b instanceof b || (p = !1)
      }
      return a.delete(e),
        a.delete(t),
        p
    }(e, t, n, r, o, a))
}
function Hv(e, t, n, r, o) {
  return e === t || (null == e || null == t || !yd(e) && !yd(t) ? e != e && t != t : $v(e, t, n, r, Hv, o))
}
var zv = 1
  , Kv = 2;
function Wv(e) {
  return e == e && !_d(e)
}
function Gv(e, t) {
  return function(n) {
    return null != n && (n[e] === t && (void 0 !== t || e in Object(n)))
  }
}
function qv(e) {
  var t = function(e) {
    for (var t = ap(e), n = t.length; n--; ) {
      var r = t[n]
        , o = e[r];
      t[n] = [r, o, Wv(o)]
    }
    return t
  }(e);
  return 1 == t.length && t[0][2] ? Gv(t[0][0], t[0][1]) : function(n) {
    return n === e || function(e, t, n, r) {
      var o = n.length
        , a = o
        , i = !r;
      if (null == e)
        return !a;
      for (e = Object(e); o--; ) {
        var s = n[o];
        if (i && s[2] ? s[1] !== e[s[0]] : !(s[0]in e))
          return !1
      }
      for (; ++o < a; ) {
        var l = (s = n[o])[0]
          , u = e[l]
          , c = s[1];
        if (i && s[2]) {
          if (void 0 === u && !(l in e))
            return !1
        } else {
          var d = new qp;
          if (r)
            var f = r(u, c, l, e, t, d);
          if (!(void 0 === f ? Hv(c, u, zv | Kv, r, d) : f))
            return !1
        }
      }
      return !0
    }(n, e, t)
  }
}
function Yv(e, t) {
  return null != e && t in Object(e)
}
function Xv(e, t) {
  return null != e && function(e, t, n) {
    for (var r = -1, o = (t = Dp(t, e)).length, a = !1; ++r < o; ) {
      var i = _p(t[r]);
      if (!(a = null != e && n(e, i)))
        break;
      e = e[i]
    }
    return a || ++r != o ? a : !!(o = null == e ? 0 : e.length) && If(o) && Ef(i, o) && (Sd(e) || Uf(e))
  }(e, t, Yv)
}
var Qv, Jv = 1, Zv = 2;
function eg(e) {
  return dp(e) ? (t = _p(e),
      function(e) {
        return null == e ? void 0 : e[t]
      }
  ) : function(e) {
    return function(t) {
      return Rp(t, e)
    }
  }(e);
  var t
}
function tg(e) {
  return "function" == typeof e ? e : null == e ? Vd : "object" == typeof e ? Sd(e) ? (t = e[0],
      n = e[1],
      dp(t) && Wv(n) ? Gv(_p(t), n) : function(e) {
        var r = Lp(e, t);
        return void 0 === r && r === n ? Xv(e, t) : Hv(n, r, Jv | Zv)
      }
  ) : qv(e) : eg(e);
  var t, n
}
const ng = function(e, t, n) {
  for (var r = -1, o = Object(e), a = n(e), i = a.length; i--; ) {
    var s = a[Qv ? i : ++r];
    if (!1 === t(o[s], s, o))
      break
  }
  return e
};
var rg = function(e, t) {
  return function(n, r) {
    if (null == n)
      return n;
    if (!Pf(n))
      return e(n, r);
    for (var o = n.length, a = t ? o : -1, i = Object(n); (t ? a-- : ++a < o) && !1 !== r(i[a], a, i); )
      ;
    return n
  }
}((function(e, t) {
    return e && ng(e, t, ap)
  }
));
const og = rg;
const ag = function() {
  return sd.Date.now()
};
var ig = "Expected a function"
  , sg = Math.max
  , lg = Math.min;
function ug(e, t, n) {
  var r, o, a, i, s, l, u = 0, c = !1, d = !1, f = !0;
  if ("function" != typeof e)
    throw new TypeError(ig);
  function p(t) {
    var n = r
      , a = o;
    return r = o = void 0,
      u = t,
      i = e.apply(a, n)
  }
  function h(e) {
    var n = e - l;
    return void 0 === l || n >= t || n < 0 || d && e - u >= a
  }
  function v() {
    var e = ag();
    if (h(e))
      return g(e);
    s = setTimeout(v, function(e) {
      var n = t - (e - l);
      return d ? lg(n, a - (e - u)) : n
    }(e))
  }
  function g(e) {
    return s = void 0,
      f && r ? p(e) : (r = o = void 0,
        i)
  }
  function m() {
    var e = ag()
      , n = h(e);
    if (r = arguments,
      o = this,
      l = e,
      n) {
      if (void 0 === s)
        return function(e) {
          return u = e,
            s = setTimeout(v, t),
            c ? p(e) : i
        }(l);
      if (d)
        return clearTimeout(s),
          s = setTimeout(v, t),
          p(l)
    }
    return void 0 === s && (s = setTimeout(v, t)),
      i
  }
  return t = Bd(t) || 0,
  _d(n) && (c = !!n.leading,
    a = (d = "maxWait"in n) ? sg(Bd(n.maxWait) || 0, t) : a,
    f = "trailing"in n ? !!n.trailing : f),
    m.cancel = function() {
      void 0 !== s && clearTimeout(s),
        u = 0,
        r = l = o = s = void 0
    }
    ,
    m.flush = function() {
      return void 0 === s ? i : g(ag())
    }
    ,
    m
}
function cg(e, t, n) {
  (void 0 !== n && !Cf(e[t], n) || void 0 === n && !(t in e)) && Af(e, t, n)
}
function dg(e) {
  return yd(e) && Pf(e)
}
function fg(e, t) {
  if (("constructor" !== t || "function" != typeof e[t]) && "__proto__" != t)
    return e[t]
}
function pg(e, t, n, r, o, a, i) {
  var s = fg(e, n)
    , l = fg(t, n)
    , u = i.get(l);
  if (u)
    cg(e, n, u);
  else {
    var c, d = a ? a(s, l, n + "", e, t, i) : void 0, f = void 0 === d;
    if (f) {
      var p = Sd(l)
        , h = !p && Kf(l)
        , v = !p && !h && Zf(l);
      d = l,
        p || h || v ? Sd(s) ? d = s : dg(s) ? d = uf(s) : h ? (f = !1,
          d = Zp(l, !0)) : v ? (f = !1,
          d = Oh(l, !0)) : d = [] : Wp(l) || Uf(l) ? (d = s,
          Uf(s) ? d = Df(c = s, lp(c)) : _d(s) && !Kd(s) || (d = Xh(l))) : f = !1
    }
    f && (i.set(l, d),
      o(d, l, r, a, i),
      i.delete(l)),
      cg(e, n, d)
  }
}
function hg(e, t, n, r, o) {
  e !== t && ng(t, (function(a, i) {
      if (o || (o = new qp),
        _d(a))
        pg(e, t, i, n, hg, r, o);
      else {
        var s = r ? r(fg(e, i), a, i + "", e, t, o) : void 0;
        void 0 === s && (s = a),
          cg(e, i, s)
      }
    }
  ), lp)
}
function vg(e, t, n) {
  for (var r = -1, o = null == e ? 0 : e.length; ++r < o; )
    if (n(t, e[r]))
      return !0;
  return !1
}
var gg = Math.max
  , mg = Math.min;
function yg(e, t, n) {
  var r = null == e ? 0 : e.length;
  if (!r)
    return -1;
  var o = r - 1;
  return void 0 !== n && (o = jd(n),
    o = n < 0 ? gg(r + o, 0) : mg(o, r - 1)),
    yf(e, tg(t), o, !0)
}
function bg(e, t) {
  var n = -1
    , r = Pf(e) ? Array(e.length) : [];
  return og(e, (function(e, o, a) {
      r[++n] = t(e, o, a)
    }
  )),
    r
}
function wg(e, t) {
  return Bp(function(e, t) {
    return (Sd(e) ? xd : bg)(e, tg(t))
  }(e, t), 1)
}
var xg;
function Sg(e) {
  for (var t = -1, n = null == e ? 0 : e.length, r = {}; ++t < n; ) {
    var o = e[t];
    r[o[0]] = o[1]
  }
  return r
}
function Eg(e, t) {
  return t.length < 2 ? e : Rp(e, function(e, t, n) {
    var r = -1
      , o = e.length;
    t < 0 && (t = -t > o ? 0 : o + t),
    (n = n > o ? o : n) < 0 && (n += o),
      o = t > n ? 0 : n - t >>> 0,
      t >>>= 0;
    for (var a = Array(o); ++r < o; )
      a[r] = e[r + t];
    return a
  }(t, 0, -1))
}
function Ag(e, t) {
  return Hv(e, t)
}
function Cg(e) {
  return null == e
}
function kg(e) {
  return void 0 === e
}
const Tg = (xg = function(e, t, n) {
  hg(e, t, n)
}
  ,
  Rf((function(e, t) {
      var n = -1
        , r = t.length
        , o = r > 1 ? t[r - 1] : void 0
        , a = r > 2 ? t[2] : void 0;
      for (o = xg.length > 3 && "function" == typeof o ? (r--,
        o) : void 0,
           a && function(e, t, n) {
             if (!_d(n))
               return !1;
             var r = typeof t;
             return !!("number" == r ? Pf(n) && Ef(t, n.length) : "string" == r && t in n) && Cf(n[t], e)
           }(t[0], t[1], a) && (o = r < 3 ? void 0 : o,
             r = 1),
             e = Object(e); ++n < r; ) {
        var i = t[n];
        i && xg(e, i, n, o)
      }
      return e
    }
  )));
function Dg(e, t) {
  return null == (e = Eg(e, t = Dp(t, e))) || delete e[_p((n = t,
    r = null == n ? 0 : n.length,
    r ? n[r - 1] : void 0))];
  var n, r
}
function Og(e) {
  return Wp(e) ? void 0 : e
}
const _g = Mp((function(e, t) {
    var n = {};
    if (null == e)
      return n;
    var r = !1;
    t = xd(t, (function(t) {
        return t = Dp(t, e),
        r || (r = t.length > 1),
          t
      }
    )),
      Df(e, sh(e), n),
    r && (n = uv(n, 7, Og));
    for (var o = t.length; o--; )
      Dg(n, t[o]);
    return n
  }
));
function Rg(e, t, n, r) {
  if (!_d(e))
    return e;
  for (var o = -1, a = (t = Dp(t, e)).length, i = a - 1, s = e; null != s && ++o < a; ) {
    var l = _p(t[o])
      , u = n;
    if ("__proto__" === l || "constructor" === l || "prototype" === l)
      return e;
    if (o != i) {
      var c = s[l];
      void 0 === (u = r ? r(c, l, s) : void 0) && (u = _d(c) ? c : Ef(t[o + 1]) ? [] : {})
    }
    Tf(s, l, u),
      s = s[l]
  }
  return e
}
function Lg(e, t) {
  return function(e, t, n) {
    for (var r = -1, o = t.length, a = {}; ++r < o; ) {
      var i = t[r]
        , s = Rp(e, i);
      n(s, i) && Rg(a, Dp(i, e), s)
    }
    return a
  }(e, t, (function(t, n) {
      return Xv(e, n)
    }
  ))
}
const Ig = Mp((function(e, t) {
    return null == e ? {} : Lg(e, t)
  }
));
function Pg(e, t, n) {
  var r = !0
    , o = !0;
  if ("function" != typeof e)
    throw new TypeError("Expected a function");
  return _d(n) && (r = "leading"in n ? !!n.leading : r,
    o = "trailing"in n ? !!n.trailing : o),
    ug(e, t, {
      leading: r,
      maxWait: t,
      trailing: o
    })
}
const Fg = ch && 1 / bv(new ch([, -0]))[1] == 1 / 0 ? function(e) {
      return new ch(e)
    }
    : function() {}
;
function Bg(e, t, n) {
  var r = -1
    , o = wf
    , a = e.length
    , i = !0
    , s = []
    , l = s;
  if (n)
    i = !1,
      o = vg;
  else if (a >= 200) {
    var u = t ? null : Fg(e);
    if (u)
      return bv(u);
    i = !1,
      o = hv,
      l = new fv
  } else
    l = t ? [] : s;
  e: for (; ++r < a; ) {
    var c = e[r]
      , d = t ? t(c) : c;
    if (c = n || 0 !== c ? c : 0,
    i && d == d) {
      for (var f = l.length; f--; )
        if (l[f] === d)
          continue e;
      t && l.push(d),
        s.push(c)
    } else
      o(l, d, n) || (l !== s && l.push(d),
        s.push(c))
  }
  return s
}
const Ng = Rf((function(e) {
    return Bg(Bp(e, 1, dg, !0))
  }
))
  , Mg = e=>void 0 === e
  , jg = e=>"boolean" == typeof e
  , Vg = e=>"number" == typeof e
  , Ug = e=>!e && 0 !== e || h(e) && 0 === e.length || x(e) && !Object.keys(e).length
  , $g = e=>"undefined" != typeof Element && e instanceof Element
  , Hg = e=>Cg(e)
  , zg = e=>e === window
  , Kg = e=>mc ? window.requestAnimationFrame(e) : setTimeout(e, 16)
  , Wg = e=>mc ? window.cancelAnimationFrame(e) : clearTimeout(e)
  , Gg = (e="")=>e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
  , qg = e=>P(e)
  , Yg = e=>Object.keys(e)
  , Xg = (e,t,n)=>({
  get value() {
    return Lp(e, t, n)
  },
  set value(n) {
    !function(e, t, n) {
      null == e || Rg(e, t, n)
    }(e, t, n)
  }
});
class Qg extends Error {
  constructor(e) {
    super(e),
      this.name = "ElementPlusError"
  }
}
function Jg(e, t) {
  throw new Qg(`[${e}] ${t}`)
}
const Zg = (e="")=>e.split(" ").filter((e=>!!e.trim()))
  , em = (e,t)=>{
    if (!e || !t)
      return !1;
    if (t.includes(" "))
      throw new Error("className should not contain space.");
    return e.classList.contains(t)
  }
  , tm = (e,t)=>{
    e && t.trim() && e.classList.add(...Zg(t))
  }
  , nm = (e,t)=>{
    e && t.trim() && e.classList.remove(...Zg(t))
  }
  , rm = (e,t)=>{
    var n;
    if (!mc || !e || !t)
      return "";
    let r = R(t);
    "float" === r && (r = "cssFloat");
    try {
      const t = e.style[r];
      if (t)
        return t;
      const o = null == (n = document.defaultView) ? void 0 : n.getComputedStyle(e, "");
      return o ? o[r] : ""
    } catch (Y_) {
      return e.style[r]
    }
  }
;
function om(e, t="px") {
  return e ? Vg(e) || b(n = e) && !Number.isNaN(Number(n)) ? `${e}${t}` : b(e) ? e : void 0 : "";
  var n
}
const am = (e,t)=>{
    if (!mc)
      return !1;
    const n = {
      undefined: "overflow",
      true: "overflow-y",
      false: "overflow-x"
    }[String(t)]
      , r = rm(e, n);
    return ["scroll", "auto", "overlay"].some((e=>r.includes(e)))
  }
  , im = (e,t)=>{
    if (!mc)
      return;
    let n = e;
    for (; n; ) {
      if ([window, document, document.documentElement].includes(n))
        return window;
      if (am(n, t))
        return n;
      n = n.parentNode
    }
    return n
  }
;
let sm;
const lm = e=>{
    var t;
    if (!mc)
      return 0;
    if (void 0 !== sm)
      return sm;
    const n = document.createElement("div");
    n.className = `${e}-scrollbar__wrap`,
      n.style.visibility = "hidden",
      n.style.width = "100px",
      n.style.position = "absolute",
      n.style.top = "-9999px",
      document.body.appendChild(n);
    const r = n.offsetWidth;
    n.style.overflow = "scroll";
    const o = document.createElement("div");
    o.style.width = "100%",
      n.appendChild(o);
    const a = o.offsetWidth;
    return null == (t = n.parentNode) || t.removeChild(n),
      sm = r - a,
      sm
  }
;
function um(e, t) {
  if (!mc)
    return;
  if (!t)
    return void (e.scrollTop = 0);
  const n = [];
  let r = t.offsetParent;
  for (; null !== r && e !== r && e.contains(r); )
    n.push(r),
      r = r.offsetParent;
  const o = t.offsetTop + n.reduce(((e,t)=>e + t.offsetTop), 0)
    , a = o + t.offsetHeight
    , i = e.scrollTop
    , s = i + e.clientHeight;
  o < i ? e.scrollTop = o : a > s && (e.scrollTop = a - e.clientHeight)
}
const cm = (e,t)=>zg(t) ? e.ownerDocument.documentElement : t
  , dm = e=>zg(e) ? window.scrollY : e.scrollTop
  , fm = e=>mc && "" !== e ? b(e) ? document.querySelector(e) : e : null;
/*! Element Plus Icons Vue v2.3.1 */
var pm = vr({
  name: "ArrowDownBold",
  __name: "arrow-down-bold",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M104.704 338.752a64 64 0 0 1 90.496 0l316.8 316.8 316.8-316.8a64 64 0 0 1 90.496 90.496L557.248 791.296a64 64 0 0 1-90.496 0L104.704 429.248a64 64 0 0 1 0-90.496z"
    })]))
})
  , hm = vr({
  name: "ArrowDown",
  __name: "arrow-down",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
    })]))
})
  , vm = vr({
  name: "ArrowLeft",
  __name: "arrow-left",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
    })]))
})
  , gm = vr({
  name: "ArrowRight",
  __name: "arrow-right",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
    })]))
})
  , mm = vr({
  name: "ArrowUp",
  __name: "arrow-up",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
    })]))
})
  , ym = vr({
  name: "Back",
  __name: "back",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64"
    }), Ma("path", {
      fill: "currentColor",
      d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312z"
    })]))
})
  , bm = vr({
  name: "Calendar",
  __name: "calendar",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
    })]))
})
  , wm = vr({
  name: "CaretRight",
  __name: "caret-right",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M384 192v640l384-320.064z"
    })]))
})
  , xm = vr({
  name: "CaretTop",
  __name: "caret-top",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 320 192 704h639.936z"
    })]))
})
  , Sm = vr({
  name: "Check",
  __name: "check",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
    })]))
})
  , Em = vr({
  name: "CircleCheckFilled",
  __name: "circle-check-filled",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
    })]))
})
  , Am = vr({
  name: "CircleCheck",
  __name: "circle-check",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
    }), Ma("path", {
      fill: "currentColor",
      d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
    })]))
})
  , Cm = vr({
  name: "CircleCloseFilled",
  __name: "circle-close-filled",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
    })]))
})
  , km = vr({
  name: "CircleClose",
  __name: "circle-close",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
    }), Ma("path", {
      fill: "currentColor",
      d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
    })]))
})
  , Tm = vr({
  name: "Clock",
  __name: "clock",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
    }), Ma("path", {
      fill: "currentColor",
      d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
    }), Ma("path", {
      fill: "currentColor",
      d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
    })]))
})
  , Dm = vr({
  name: "Close",
  __name: "close",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
    })]))
})
  , Om = vr({
  name: "DArrowLeft",
  __name: "d-arrow-left",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
    })]))
})
  , _m = vr({
  name: "DArrowRight",
  __name: "d-arrow-right",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
    })]))
})
  , Rm = vr({
  name: "Delete",
  __name: "delete",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
    })]))
})
  , Lm = vr({
  name: "Document",
  __name: "document",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
    })]))
})
  , Im = vr({
  name: "Download",
  __name: "download",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-253.696 236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64z"
    })]))
})
  , Pm = vr({
  name: "Edit",
  __name: "edit",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M832 512a32 32 0 1 1 64 0v352a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h352a32 32 0 0 1 0 64H192v640h640z"
    }), Ma("path", {
      fill: "currentColor",
      d: "m469.952 554.24 52.8-7.552L847.104 222.4a32 32 0 1 0-45.248-45.248L477.44 501.44l-7.552 52.8zm422.4-422.4a96 96 0 0 1 0 135.808l-331.84 331.84a32 32 0 0 1-18.112 9.088L436.8 623.68a32 32 0 0 1-36.224-36.224l15.104-105.6a32 32 0 0 1 9.024-18.112l331.904-331.84a96 96 0 0 1 135.744 0z"
    })]))
})
  , Fm = vr({
  name: "FullScreen",
  __name: "full-screen",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
    })]))
})
  , Bm = vr({
  name: "Hide",
  __name: "hide",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
    }), Ma("path", {
      fill: "currentColor",
      d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
    })]))
})
  , Nm = vr({
  name: "InfoFilled",
  __name: "info-filled",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
    })]))
})
  , Mm = vr({
  name: "Loading",
  __name: "loading",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
    })]))
})
  , jm = vr({
  name: "Minus",
  __name: "minus",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
    })]))
})
  , Vm = vr({
  name: "MoreFilled",
  __name: "more-filled",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
    })]))
})
  , Um = vr({
  name: "More",
  __name: "more",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96"
    })]))
})
  , $m = vr({
  name: "PictureFilled",
  __name: "picture-filled",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112M256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384"
    })]))
})
  , Hm = vr({
  name: "Plus",
  __name: "plus",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
    })]))
})
  , zm = vr({
  name: "QuestionFilled",
  __name: "question-filled",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
    })]))
})
  , Km = vr({
  name: "RefreshLeft",
  __name: "refresh-left",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
    })]))
})
  , Wm = vr({
  name: "RefreshRight",
  __name: "refresh-right",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
    })]))
})
  , Gm = vr({
  name: "ScaleToOriginal",
  __name: "scale-to-original",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118M512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412M512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512"
    })]))
})
  , qm = vr({
  name: "Search",
  __name: "search",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
    })]))
})
  , Ym = vr({
  name: "SortDown",
  __name: "sort-down",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0"
    })]))
})
  , Xm = vr({
  name: "SortUp",
  __name: "sort-up",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248"
    })]))
})
  , Qm = vr({
  name: "StarFilled",
  __name: "star-filled",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"
    })]))
})
  , Jm = vr({
  name: "Star",
  __name: "star",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
    })]))
})
  , Zm = vr({
  name: "SuccessFilled",
  __name: "success-filled",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
    })]))
})
  , ey = vr({
  name: "Upload",
  __name: "upload",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248z"
    })]))
})
  , ty = vr({
  name: "VideoPause",
  __name: "video-pause",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768m-96-544q32 0 32 32v256q0 32-32 32t-32-32V384q0-32 32-32m192 0q32 0 32 32v256q0 32-32 32t-32-32V384q0-32 32-32"
    })]))
})
  , ny = vr({
  name: "VideoPlay",
  __name: "video-play",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768m-48-247.616L668.608 512 464 375.616zm10.624-342.656 249.472 166.336a48 48 0 0 1 0 79.872L474.624 718.272A48 48 0 0 1 400 678.336V345.6a48 48 0 0 1 74.624-39.936z"
    })]))
})
  , ry = vr({
  name: "View",
  __name: "view",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
    })]))
})
  , oy = vr({
  name: "WarningFilled",
  __name: "warning-filled",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
    })]))
})
  , ay = vr({
  name: "ZoomIn",
  __name: "zoom-in",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
    })]))
})
  , iy = vr({
  name: "ZoomOut",
  __name: "zoom-out",
  setup: e=>(e,t)=>(Ca(),
    _a("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [Ma("path", {
      fill: "currentColor",
      d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
    })]))
});
const sy = "__epPropKey"
  , ly = (e,t)=>{
  if (!x(e) || x(n = e) && n[sy])
    return e;
  var n;
  const {values: r, required: o, default: a, type: i, validator: s} = e
    , l = r || s ? t=>{
      let n = !1
        , o = [];
      if (r && (o = Array.from(r),
      p(e, "default") && o.push(a),
      n || (n = o.includes(t))),
      s && (n || (n = s(t))),
      !n && o.length > 0) {
        [...new Set(o)].map((e=>JSON.stringify(e))).join(", ");
        JSON.stringify(t)
      }
      return n
    }
    : void 0
    , u = {
    type: i,
    required: !!o,
    validator: l,
    [sy]: !0
  };
  return p(e, "default") && (u.default = a),
    u
}
  , uy = e=>Sg(Object.entries(e).map((([e,t])=>[e, ly(t)])))
  , cy = [String, Object, Function]
  , dy = {
  Close: Dm
}
  , fy = {
  Close: Dm,
  SuccessFilled: Zm,
  InfoFilled: Nm,
  WarningFilled: oy,
  CircleCloseFilled: Cm
}
  , py = {
  success: Zm,
  warning: oy,
  error: Cm,
  info: Nm
}
  , hy = {
  validating: Mm,
  success: Am,
  error: km
}
  , vy = (e,t)=>{
  if (e.install = n=>{
    for (const r of [e, ...Object.values(null != t ? t : {})])
      n.component(r.name, r)
  }
    ,
    t)
    for (const [n,r] of Object.entries(t))
      e[n] = r;
  return e
}
  , gy = (e,t)=>(e.install = n=>{
  e._context = n._context,
    n.config.globalProperties[t] = e
}
  ,
  e)
  , my = e=>(e.install = a,
  e)
  , yy = (...e)=>t=>{
  e.forEach((e=>{
      y(e) ? e(t) : e.value = t
    }
  ))
}
  , by = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}
  , wy = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"]
  , xy = "update:modelValue"
  , Sy = "change"
  , Ey = "input"
  , Ay = Symbol("INSTALLED_KEY")
  , Cy = ["", "default", "small", "large"]
  , ky = e=>["", ...Cy].includes(e);
var Ty = (e=>(e[e.TEXT = 1] = "TEXT",
  e[e.CLASS = 2] = "CLASS",
  e[e.STYLE = 4] = "STYLE",
  e[e.PROPS = 8] = "PROPS",
  e[e.FULL_PROPS = 16] = "FULL_PROPS",
  e[e.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS",
  e[e.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT",
  e[e.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT",
  e[e.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT",
  e[e.NEED_PATCH = 512] = "NEED_PATCH",
  e[e.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS",
  e[e.HOISTED = -1] = "HOISTED",
  e[e.BAIL = -2] = "BAIL",
  e))(Ty || {});
function Dy(e) {
  return La(e) && e.type === ba
}
function Oy(e) {
  return La(e) && !Dy(e) && !function(e) {
    return La(e) && e.type === xa
  }(e)
}
const _y = e=>{
  const t = h(e) ? e : [e]
    , n = [];
  return t.forEach((e=>{
      var t;
      h(e) ? n.push(..._y(e)) : La(e) && h(e.children) ? n.push(..._y(e.children)) : (n.push(e),
      La(e) && (null == (t = e.component) ? void 0 : t.subTree) && n.push(..._y(e.component.subTree)))
    }
  )),
    n
}
  , Ry = e=>[...new Set(e)]
  , Ly = e=>e || 0 === e ? Array.isArray(e) ? e : [e] : []
  , Iy = e=>/([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(e);
const Py = ["class", "style"]
  , Fy = /^on[A-Z]/
  , By = (e={})=>{
    const {excludeListeners: t=!1, excludeKeys: n} = e
      , r = yi((()=>((null == n ? void 0 : n.value) || []).concat(Py)))
      , o = ei();
    return yi(o ? ()=>{
        var e;
        return Sg(Object.entries(null == (e = o.proxy) ? void 0 : e.$attrs).filter((([e])=>!(r.value.includes(e) || t && Fy.test(e)))))
      }
      : ()=>({}))
  }
  , Ny = ({from: e, replacement: t, scope: n, version: r, ref: o, type: a="API"},i)=>{
    Jn((()=>Vt(i)), (e=>{}
    ), {
      immediate: !0
    })
  }
  , My = (e,t,n,r)=>{
    let o = {
      offsetX: 0,
      offsetY: 0
    };
    const a = t=>{
        const n = t.clientX
          , a = t.clientY
          , {offsetX: i, offsetY: s} = o
          , l = e.value.getBoundingClientRect()
          , u = l.left
          , c = l.top
          , d = l.width
          , f = l.height
          , p = document.documentElement.clientWidth
          , h = document.documentElement.clientHeight
          , v = -u + i
          , g = -c + s
          , m = p - u - d + i
          , y = h - c - f + s
          , b = t=>{
            let l = i + t.clientX - n
              , u = s + t.clientY - a;
            (null == r ? void 0 : r.value) || (l = Math.min(Math.max(l, v), m),
              u = Math.min(Math.max(u, g), y)),
              o = {
                offsetX: l,
                offsetY: u
              },
            e.value && (e.value.style.transform = `translate(${om(l)}, ${om(u)})`)
          }
          , w = ()=>{
            document.removeEventListener("mousemove", b),
              document.removeEventListener("mouseup", w)
          }
        ;
        document.addEventListener("mousemove", b),
          document.addEventListener("mouseup", w)
      }
      , i = ()=>{
        t.value && e.value && t.value.removeEventListener("mousedown", a)
      }
    ;
    Lr((()=>{
        qn((()=>{
            n.value ? t.value && e.value && t.value.addEventListener("mousedown", a) : i()
          }
        ))
      }
    )),
      Fr((()=>{
          i()
        }
      ))
  }
;
var jy = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tour: {
      next: "Next",
      previous: "Previous",
      finish: "Finish"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    },
    carousel: {
      leftArrow: "Carousel arrow left",
      rightArrow: "Carousel arrow right",
      indicator: "Carousel switch to index {index}"
    }
  }
};
const Vy = e=>(t,n)=>Uy(t, n, Vt(e))
  , Uy = (e,t,n)=>Lp(n, e, e).replace(/\{(\w+)\}/g, ((e,n)=>{
      var r;
      return `${null != (r = null == t ? void 0 : t[n]) ? r : `{${n}}`}`
    }
  ))
  , $y = Symbol("localeContextKey")
  , Hy = e=>{
    const t = e || jo($y, Ft());
    return (e=>({
      lang: yi((()=>Vt(e).name)),
      locale: Pt(e) ? e : Ft(e),
      t: Vy(e)
    }))(yi((()=>t.value || jy)))
  }
  , zy = "el"
  , Ky = (e,t,n,r,o)=>{
    let a = `${e}-${t}`;
    return n && (a += `-${n}`),
    r && (a += `__${r}`),
    o && (a += `--${o}`),
      a
  }
  , Wy = Symbol("namespaceContextKey")
  , Gy = e=>{
    const t = e || (ei() ? jo(Wy, Ft(zy)) : Ft(zy));
    return yi((()=>Vt(t) || zy))
  }
  , qy = (e,t)=>{
    const n = Gy(t);
    return {
      namespace: n,
      b: (t="")=>Ky(n.value, e, t, "", ""),
      e: t=>t ? Ky(n.value, e, "", t, "") : "",
      m: t=>t ? Ky(n.value, e, "", "", t) : "",
      be: (t,r)=>t && r ? Ky(n.value, e, t, r, "") : "",
      em: (t,r)=>t && r ? Ky(n.value, e, "", t, r) : "",
      bm: (t,r)=>t && r ? Ky(n.value, e, t, "", r) : "",
      bem: (t,r,o)=>t && r && o ? Ky(n.value, e, t, r, o) : "",
      is: (e,...t)=>{
        const n = !(t.length >= 1) || t[0];
        return e && n ? `is-${e}` : ""
      }
      ,
      cssVar: e=>{
        const t = {};
        for (const r in e)
          e[r] && (t[`--${n.value}-${r}`] = e[r]);
        return t
      }
      ,
      cssVarName: e=>`--${n.value}-${e}`,
      cssVarBlock: t=>{
        const r = {};
        for (const o in t)
          t[o] && (r[`--${n.value}-${e}-${o}`] = t[o]);
        return r
      }
      ,
      cssVarBlockName: t=>`--${n.value}-${e}-${t}`
    }
  }
  , Yy = (e,t={})=>{
    Pt(e) || Jg("[useLockscreen]", "You need to pass a ref param to this function");
    const n = t.ns || qy("popup")
      , r = Jt((()=>n.bm("parent", "hidden")));
    if (!mc || em(document.body, r.value))
      return;
    let o = 0
      , a = !1
      , i = "0";
    const s = ()=>{
        setTimeout((()=>{
            nm(null == document ? void 0 : document.body, r.value),
            a && document && (document.body.style.width = i)
          }
        ), 200)
      }
    ;
    Jn(e, (e=>{
        if (!e)
          return void s();
        a = !em(document.body, r.value),
        a && (i = document.body.style.width),
          o = lm(n.namespace.value);
        const t = document.documentElement.clientHeight < document.body.scrollHeight
          , l = rm(document.body, "overflowY");
        o > 0 && (t || "scroll" === l) && a && (document.body.style.width = `calc(100% - ${o}px)`),
          tm(document.body, r.value)
      }
    )),
      le((()=>s()))
  }
  , Xy = ly({
    type: Boolean,
    default: null
  })
  , Qy = ly({
    type: Function
  })
  , Jy = e=>{
    const t = `update:${e}`
      , n = `onUpdate:${e}`;
    return {
      useModelToggle: ({indicator: r, toggleReason: o, shouldHideWhenRouteChanges: a, shouldProceed: i, onShow: s, onHide: l})=>{
        const u = ei()
          , {emit: c} = u
          , d = u.props
          , f = yi((()=>y(d[n])))
          , p = yi((()=>null === d[e]))
          , h = e=>{
            !0 !== r.value && (r.value = !0,
            o && (o.value = e),
            y(s) && s(e))
          }
          , v = e=>{
            !1 !== r.value && (r.value = !1,
            o && (o.value = e),
            y(l) && l(e))
          }
          , g = e=>{
            if (!0 === d.disabled || y(i) && !i())
              return;
            const n = f.value && mc;
            n && c(t, !0),
            !p.value && n || h(e)
          }
          , m = e=>{
            if (!0 === d.disabled || !mc)
              return;
            const n = f.value && mc;
            n && c(t, !1),
            !p.value && n || v(e)
          }
          , b = e=>{
            jg(e) && (d.disabled && e ? f.value && c(t, !1) : r.value !== e && (e ? h() : v()))
          }
        ;
        return Jn((()=>d[e]), b),
        a && void 0 !== u.appContext.config.globalProperties.$route && Jn((()=>({
          ...u.proxy.$route
        })), (()=>{
            a.value && r.value && m()
          }
        )),
          Lr((()=>{
              b(d[e])
            }
          )),
          {
            hide: m,
            show: g,
            toggle: ()=>{
              r.value ? m() : g()
            }
            ,
            hasUpdateHandler: f
          }
      }
      ,
      useModelToggleProps: {
        [e]: Xy,
        [n]: Qy
      },
      useModelToggleEmits: [t]
    }
  }
;
Jy("modelValue");
const Zy = e=>{
    const t = ei();
    return yi((()=>{
        var n, r;
        return null == (r = null == (n = null == t ? void 0 : t.proxy) ? void 0 : n.$props) ? void 0 : r[e]
      }
    ))
  }
;
var eb = "top"
  , tb = "bottom"
  , nb = "right"
  , rb = "left"
  , ob = "auto"
  , ab = [eb, tb, nb, rb]
  , ib = "start"
  , sb = "end"
  , lb = "clippingParents"
  , ub = "viewport"
  , cb = "popper"
  , db = "reference"
  , fb = ab.reduce((function(e, t) {
    return e.concat([t + "-" + ib, t + "-" + sb])
  }
), [])
  , pb = [].concat(ab, [ob]).reduce((function(e, t) {
    return e.concat([t, t + "-" + ib, t + "-" + sb])
  }
), [])
  , hb = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];
function vb(e) {
  return e ? (e.nodeName || "").toLowerCase() : null
}
function gb(e) {
  if (null == e)
    return window;
  if ("[object Window]" !== e.toString()) {
    var t = e.ownerDocument;
    return t && t.defaultView || window
  }
  return e
}
function mb(e) {
  return e instanceof gb(e).Element || e instanceof Element
}
function yb(e) {
  return e instanceof gb(e).HTMLElement || e instanceof HTMLElement
}
function bb(e) {
  return "undefined" != typeof ShadowRoot && (e instanceof gb(e).ShadowRoot || e instanceof ShadowRoot)
}
var wb = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: function(e) {
    var t = e.state;
    Object.keys(t.elements).forEach((function(e) {
        var n = t.styles[e] || {}
          , r = t.attributes[e] || {}
          , o = t.elements[e];
        !yb(o) || !vb(o) || (Object.assign(o.style, n),
          Object.keys(r).forEach((function(e) {
              var t = r[e];
              !1 === t ? o.removeAttribute(e) : o.setAttribute(e, !0 === t ? "" : t)
            }
          )))
      }
    ))
  },
  effect: function(e) {
    var t = e.state
      , n = {
      popper: {
        position: t.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    return Object.assign(t.elements.popper.style, n.popper),
      t.styles = n,
    t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
      function() {
        Object.keys(t.elements).forEach((function(e) {
            var r = t.elements[e]
              , o = t.attributes[e] || {}
              , a = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce((function(e, t) {
                return e[t] = "",
                  e
              }
            ), {});
            !yb(r) || !vb(r) || (Object.assign(r.style, a),
              Object.keys(o).forEach((function(e) {
                  r.removeAttribute(e)
                }
              )))
          }
        ))
      }
  },
  requires: ["computeStyles"]
};
function xb(e) {
  return e.split("-")[0]
}
var Sb = Math.max
  , Eb = Math.min
  , Ab = Math.round;
function Cb(e, t) {
  void 0 === t && (t = !1);
  var n = e.getBoundingClientRect()
    , r = 1
    , o = 1;
  if (yb(e) && t) {
    var a = e.offsetHeight
      , i = e.offsetWidth;
    i > 0 && (r = Ab(n.width) / i || 1),
    a > 0 && (o = Ab(n.height) / a || 1)
  }
  return {
    width: n.width / r,
    height: n.height / o,
    top: n.top / o,
    right: n.right / r,
    bottom: n.bottom / o,
    left: n.left / r,
    x: n.left / r,
    y: n.top / o
  }
}
function kb(e) {
  var t = Cb(e)
    , n = e.offsetWidth
    , r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width),
  Math.abs(t.height - r) <= 1 && (r = t.height),
    {
      x: e.offsetLeft,
      y: e.offsetTop,
      width: n,
      height: r
    }
}
function Tb(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && bb(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r))
        return !0;
      r = r.parentNode || r.host
    } while (r)
  }
  return !1
}
function Db(e) {
  return gb(e).getComputedStyle(e)
}
function Ob(e) {
  return ["table", "td", "th"].indexOf(vb(e)) >= 0
}
function _b(e) {
  return ((mb(e) ? e.ownerDocument : e.document) || window.document).documentElement
}
function Rb(e) {
  return "html" === vb(e) ? e : e.assignedSlot || e.parentNode || (bb(e) ? e.host : null) || _b(e)
}
function Lb(e) {
  return yb(e) && "fixed" !== Db(e).position ? e.offsetParent : null
}
function Ib(e) {
  for (var t = gb(e), n = Lb(e); n && Ob(n) && "static" === Db(n).position; )
    n = Lb(n);
  return n && ("html" === vb(n) || "body" === vb(n) && "static" === Db(n).position) ? t : n || function(e) {
    var t = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
    if (-1 !== navigator.userAgent.indexOf("Trident") && yb(e) && "fixed" === Db(e).position)
      return null;
    var n = Rb(e);
    for (bb(n) && (n = n.host); yb(n) && ["html", "body"].indexOf(vb(n)) < 0; ) {
      var r = Db(n);
      if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || t && "filter" === r.willChange || t && r.filter && "none" !== r.filter)
        return n;
      n = n.parentNode
    }
    return null
  }(e) || t
}
function Pb(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}
function Fb(e, t, n) {
  return Sb(e, Eb(t, n))
}
function Bb(e) {
  return Object.assign({}, {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, e)
}
function Nb(e, t) {
  return t.reduce((function(t, n) {
      return t[n] = e,
        t
    }
  ), {})
}
var Mb = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: function(e) {
    var t, n = e.state, r = e.name, o = e.options, a = n.elements.arrow, i = n.modifiersData.popperOffsets, s = xb(n.placement), l = Pb(s), u = [rb, nb].indexOf(s) >= 0 ? "height" : "width";
    if (a && i) {
      var c = function(e, t) {
        return Bb("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, {
          placement: t.placement
        })) : e) ? e : Nb(e, ab))
      }(o.padding, n)
        , d = kb(a)
        , f = "y" === l ? eb : rb
        , p = "y" === l ? tb : nb
        , h = n.rects.reference[u] + n.rects.reference[l] - i[l] - n.rects.popper[u]
        , v = i[l] - n.rects.reference[l]
        , g = Ib(a)
        , m = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0
        , y = h / 2 - v / 2
        , b = c[f]
        , w = m - d[u] - c[p]
        , x = m / 2 - d[u] / 2 + y
        , S = Fb(b, x, w)
        , E = l;
      n.modifiersData[r] = ((t = {})[E] = S,
        t.centerOffset = S - x,
        t)
    }
  },
  effect: function(e) {
    var t = e.state
      , n = e.options.element
      , r = void 0 === n ? "[data-popper-arrow]" : n;
    null != r && ("string" == typeof r && !(r = t.elements.popper.querySelector(r)) || !Tb(t.elements.popper, r) || (t.elements.arrow = r))
  },
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function jb(e) {
  return e.split("-")[1]
}
var Vb = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function Ub(e) {
  var t, n = e.popper, r = e.popperRect, o = e.placement, a = e.variation, i = e.offsets, s = e.position, l = e.gpuAcceleration, u = e.adaptive, c = e.roundOffsets, d = e.isFixed, f = i.x, p = void 0 === f ? 0 : f, h = i.y, v = void 0 === h ? 0 : h, g = "function" == typeof c ? c({
    x: p,
    y: v
  }) : {
    x: p,
    y: v
  };
  p = g.x,
    v = g.y;
  var m = i.hasOwnProperty("x")
    , y = i.hasOwnProperty("y")
    , b = rb
    , w = eb
    , x = window;
  if (u) {
    var S = Ib(n)
      , E = "clientHeight"
      , A = "clientWidth";
    if (S === gb(n) && ("static" !== Db(S = _b(n)).position && "absolute" === s && (E = "scrollHeight",
      A = "scrollWidth")),
    o === eb || (o === rb || o === nb) && a === sb)
      w = tb,
        v -= (d && S === x && x.visualViewport ? x.visualViewport.height : S[E]) - r.height,
        v *= l ? 1 : -1;
    if (o === rb || (o === eb || o === tb) && a === sb)
      b = nb,
        p -= (d && S === x && x.visualViewport ? x.visualViewport.width : S[A]) - r.width,
        p *= l ? 1 : -1
  }
  var C, k = Object.assign({
    position: s
  }, u && Vb), T = !0 === c ? function(e) {
    var t = e.x
      , n = e.y
      , r = window.devicePixelRatio || 1;
    return {
      x: Ab(t * r) / r || 0,
      y: Ab(n * r) / r || 0
    }
  }({
    x: p,
    y: v
  }) : {
    x: p,
    y: v
  };
  return p = T.x,
    v = T.y,
    l ? Object.assign({}, k, ((C = {})[w] = y ? "0" : "",
      C[b] = m ? "0" : "",
      C.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + v + "px)" : "translate3d(" + p + "px, " + v + "px, 0)",
      C)) : Object.assign({}, k, ((t = {})[w] = y ? v + "px" : "",
      t[b] = m ? p + "px" : "",
      t.transform = "",
      t))
}
var $b = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: function(e) {
    var t = e.state
      , n = e.options
      , r = n.gpuAcceleration
      , o = void 0 === r || r
      , a = n.adaptive
      , i = void 0 === a || a
      , s = n.roundOffsets
      , l = void 0 === s || s
      , u = {
      placement: xb(t.placement),
      variation: jb(t.placement),
      popper: t.elements.popper,
      popperRect: t.rects.popper,
      gpuAcceleration: o,
      isFixed: "fixed" === t.options.strategy
    };
    null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, Ub(Object.assign({}, u, {
      offsets: t.modifiersData.popperOffsets,
      position: t.options.strategy,
      adaptive: i,
      roundOffsets: l
    })))),
    null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, Ub(Object.assign({}, u, {
      offsets: t.modifiersData.arrow,
      position: "absolute",
      adaptive: !1,
      roundOffsets: l
    })))),
      t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
      })
  },
  data: {}
}
  , Hb = {
  passive: !0
};
var zb = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {},
  effect: function(e) {
    var t = e.state
      , n = e.instance
      , r = e.options
      , o = r.scroll
      , a = void 0 === o || o
      , i = r.resize
      , s = void 0 === i || i
      , l = gb(t.elements.popper)
      , u = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return a && u.forEach((function(e) {
        e.addEventListener("scroll", n.update, Hb)
      }
    )),
    s && l.addEventListener("resize", n.update, Hb),
      function() {
        a && u.forEach((function(e) {
            e.removeEventListener("scroll", n.update, Hb)
          }
        )),
        s && l.removeEventListener("resize", n.update, Hb)
      }
  },
  data: {}
}
  , Kb = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Wb(e) {
  return e.replace(/left|right|bottom|top/g, (function(e) {
      return Kb[e]
    }
  ))
}
var Gb = {
  start: "end",
  end: "start"
};
function qb(e) {
  return e.replace(/start|end/g, (function(e) {
      return Gb[e]
    }
  ))
}
function Yb(e) {
  var t = gb(e);
  return {
    scrollLeft: t.pageXOffset,
    scrollTop: t.pageYOffset
  }
}
function Xb(e) {
  return Cb(_b(e)).left + Yb(e).scrollLeft
}
function Qb(e) {
  var t = Db(e)
    , n = t.overflow
    , r = t.overflowX
    , o = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + o + r)
}
function Jb(e) {
  return ["html", "body", "#document"].indexOf(vb(e)) >= 0 ? e.ownerDocument.body : yb(e) && Qb(e) ? e : Jb(Rb(e))
}
function Zb(e, t) {
  var n;
  void 0 === t && (t = []);
  var r = Jb(e)
    , o = r === (null == (n = e.ownerDocument) ? void 0 : n.body)
    , a = gb(r)
    , i = o ? [a].concat(a.visualViewport || [], Qb(r) ? r : []) : r
    , s = t.concat(i);
  return o ? s : s.concat(Zb(Rb(i)))
}
function ew(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  })
}
function tw(e, t) {
  return t === ub ? ew(function(e) {
    var t = gb(e)
      , n = _b(e)
      , r = t.visualViewport
      , o = n.clientWidth
      , a = n.clientHeight
      , i = 0
      , s = 0;
    return r && (o = r.width,
      a = r.height,
    /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (i = r.offsetLeft,
      s = r.offsetTop)),
      {
        width: o,
        height: a,
        x: i + Xb(e),
        y: s
      }
  }(e)) : mb(t) ? function(e) {
    var t = Cb(e);
    return t.top = t.top + e.clientTop,
      t.left = t.left + e.clientLeft,
      t.bottom = t.top + e.clientHeight,
      t.right = t.left + e.clientWidth,
      t.width = e.clientWidth,
      t.height = e.clientHeight,
      t.x = t.left,
      t.y = t.top,
      t
  }(t) : ew(function(e) {
    var t, n = _b(e), r = Yb(e), o = null == (t = e.ownerDocument) ? void 0 : t.body, a = Sb(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), i = Sb(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), s = -r.scrollLeft + Xb(e), l = -r.scrollTop;
    return "rtl" === Db(o || n).direction && (s += Sb(n.clientWidth, o ? o.clientWidth : 0) - a),
      {
        width: a,
        height: i,
        x: s,
        y: l
      }
  }(_b(e)))
}
function nw(e, t, n) {
  var r = "clippingParents" === t ? function(e) {
    var t = Zb(Rb(e))
      , n = ["absolute", "fixed"].indexOf(Db(e).position) >= 0 && yb(e) ? Ib(e) : e;
    return mb(n) ? t.filter((function(e) {
        return mb(e) && Tb(e, n) && "body" !== vb(e)
      }
    )) : []
  }(e) : [].concat(t)
    , o = [].concat(r, [n])
    , a = o[0]
    , i = o.reduce((function(t, n) {
      var r = tw(e, n);
      return t.top = Sb(r.top, t.top),
        t.right = Eb(r.right, t.right),
        t.bottom = Eb(r.bottom, t.bottom),
        t.left = Sb(r.left, t.left),
        t
    }
  ), tw(e, a));
  return i.width = i.right - i.left,
    i.height = i.bottom - i.top,
    i.x = i.left,
    i.y = i.top,
    i
}
function rw(e) {
  var t, n = e.reference, r = e.element, o = e.placement, a = o ? xb(o) : null, i = o ? jb(o) : null, s = n.x + n.width / 2 - r.width / 2, l = n.y + n.height / 2 - r.height / 2;
  switch (a) {
    case eb:
      t = {
        x: s,
        y: n.y - r.height
      };
      break;
    case tb:
      t = {
        x: s,
        y: n.y + n.height
      };
      break;
    case nb:
      t = {
        x: n.x + n.width,
        y: l
      };
      break;
    case rb:
      t = {
        x: n.x - r.width,
        y: l
      };
      break;
    default:
      t = {
        x: n.x,
        y: n.y
      }
  }
  var u = a ? Pb(a) : null;
  if (null != u) {
    var c = "y" === u ? "height" : "width";
    switch (i) {
      case ib:
        t[u] = t[u] - (n[c] / 2 - r[c] / 2);
        break;
      case sb:
        t[u] = t[u] + (n[c] / 2 - r[c] / 2)
    }
  }
  return t
}
function ow(e, t) {
  void 0 === t && (t = {});
  var n = t
    , r = n.placement
    , o = void 0 === r ? e.placement : r
    , a = n.boundary
    , i = void 0 === a ? lb : a
    , s = n.rootBoundary
    , l = void 0 === s ? ub : s
    , u = n.elementContext
    , c = void 0 === u ? cb : u
    , d = n.altBoundary
    , f = void 0 !== d && d
    , p = n.padding
    , h = void 0 === p ? 0 : p
    , v = Bb("number" != typeof h ? h : Nb(h, ab))
    , g = c === cb ? db : cb
    , m = e.rects.popper
    , y = e.elements[f ? g : c]
    , b = nw(mb(y) ? y : y.contextElement || _b(e.elements.popper), i, l)
    , w = Cb(e.elements.reference)
    , x = rw({
    reference: w,
    element: m,
    strategy: "absolute",
    placement: o
  })
    , S = ew(Object.assign({}, m, x))
    , E = c === cb ? S : w
    , A = {
    top: b.top - E.top + v.top,
    bottom: E.bottom - b.bottom + v.bottom,
    left: b.left - E.left + v.left,
    right: E.right - b.right + v.right
  }
    , C = e.modifiersData.offset;
  if (c === cb && C) {
    var k = C[o];
    Object.keys(A).forEach((function(e) {
        var t = [nb, tb].indexOf(e) >= 0 ? 1 : -1
          , n = [eb, tb].indexOf(e) >= 0 ? "y" : "x";
        A[e] += k[n] * t
      }
    ))
  }
  return A
}
var aw = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: function(e) {
    var t = e.state
      , n = e.options
      , r = e.name;
    if (!t.modifiersData[r]._skip) {
      for (var o = n.mainAxis, a = void 0 === o || o, i = n.altAxis, s = void 0 === i || i, l = n.fallbackPlacements, u = n.padding, c = n.boundary, d = n.rootBoundary, f = n.altBoundary, p = n.flipVariations, h = void 0 === p || p, v = n.allowedAutoPlacements, g = t.options.placement, m = xb(g), y = l || (m === g || !h ? [Wb(g)] : function(e) {
        if (xb(e) === ob)
          return [];
        var t = Wb(e);
        return [qb(e), t, qb(t)]
      }(g)), b = [g].concat(y).reduce((function(e, n) {
          return e.concat(xb(n) === ob ? function(e, t) {
            void 0 === t && (t = {});
            var n = t
              , r = n.placement
              , o = n.boundary
              , a = n.rootBoundary
              , i = n.padding
              , s = n.flipVariations
              , l = n.allowedAutoPlacements
              , u = void 0 === l ? pb : l
              , c = jb(r)
              , d = c ? s ? fb : fb.filter((function(e) {
                return jb(e) === c
              }
            )) : ab
              , f = d.filter((function(e) {
                return u.indexOf(e) >= 0
              }
            ));
            0 === f.length && (f = d);
            var p = f.reduce((function(t, n) {
                return t[n] = ow(e, {
                  placement: n,
                  boundary: o,
                  rootBoundary: a,
                  padding: i
                })[xb(n)],
                  t
              }
            ), {});
            return Object.keys(p).sort((function(e, t) {
                return p[e] - p[t]
              }
            ))
          }(t, {
            placement: n,
            boundary: c,
            rootBoundary: d,
            padding: u,
            flipVariations: h,
            allowedAutoPlacements: v
          }) : n)
        }
      ), []), w = t.rects.reference, x = t.rects.popper, S = new Map, E = !0, A = b[0], C = 0; C < b.length; C++) {
        var k = b[C]
          , T = xb(k)
          , D = jb(k) === ib
          , O = [eb, tb].indexOf(T) >= 0
          , _ = O ? "width" : "height"
          , R = ow(t, {
          placement: k,
          boundary: c,
          rootBoundary: d,
          altBoundary: f,
          padding: u
        })
          , L = O ? D ? nb : rb : D ? tb : eb;
        w[_] > x[_] && (L = Wb(L));
        var I = Wb(L)
          , P = [];
        if (a && P.push(R[T] <= 0),
        s && P.push(R[L] <= 0, R[I] <= 0),
          P.every((function(e) {
              return e
            }
          ))) {
          A = k,
            E = !1;
          break
        }
        S.set(k, P)
      }
      if (E)
        for (var F = function(e) {
          var t = b.find((function(t) {
              var n = S.get(t);
              if (n)
                return n.slice(0, e).every((function(e) {
                    return e
                  }
                ))
            }
          ));
          if (t)
            return A = t,
              "break"
        }, B = h ? 3 : 1; B > 0; B--) {
          if ("break" === F(B))
            break
        }
      t.placement !== A && (t.modifiersData[r]._skip = !0,
        t.placement = A,
        t.reset = !0)
    }
  },
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function iw(e, t, n) {
  return void 0 === n && (n = {
    x: 0,
    y: 0
  }),
    {
      top: e.top - t.height - n.y,
      right: e.right - t.width + n.x,
      bottom: e.bottom - t.height + n.y,
      left: e.left - t.width - n.x
    }
}
function sw(e) {
  return [eb, nb, tb, rb].some((function(t) {
      return e[t] >= 0
    }
  ))
}
var lw = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: function(e) {
    var t = e.state
      , n = e.name
      , r = t.rects.reference
      , o = t.rects.popper
      , a = t.modifiersData.preventOverflow
      , i = ow(t, {
      elementContext: "reference"
    })
      , s = ow(t, {
      altBoundary: !0
    })
      , l = iw(i, r)
      , u = iw(s, o, a)
      , c = sw(l)
      , d = sw(u);
    t.modifiersData[n] = {
      referenceClippingOffsets: l,
      popperEscapeOffsets: u,
      isReferenceHidden: c,
      hasPopperEscaped: d
    },
      t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": c,
        "data-popper-escaped": d
      })
  }
};
var uw = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: function(e) {
    var t = e.state
      , n = e.options
      , r = e.name
      , o = n.offset
      , a = void 0 === o ? [0, 0] : o
      , i = pb.reduce((function(e, n) {
        return e[n] = function(e, t, n) {
          var r = xb(e)
            , o = [rb, eb].indexOf(r) >= 0 ? -1 : 1
            , a = "function" == typeof n ? n(Object.assign({}, t, {
            placement: e
          })) : n
            , i = a[0]
            , s = a[1];
          return i = i || 0,
            s = (s || 0) * o,
            [rb, nb].indexOf(r) >= 0 ? {
              x: s,
              y: i
            } : {
              x: i,
              y: s
            }
        }(n, t.rects, a),
          e
      }
    ), {})
      , s = i[t.placement]
      , l = s.x
      , u = s.y;
    null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l,
      t.modifiersData.popperOffsets.y += u),
      t.modifiersData[r] = i
  }
};
var cw = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: function(e) {
    var t = e.state
      , n = e.name;
    t.modifiersData[n] = rw({
      reference: t.rects.reference,
      element: t.rects.popper,
      strategy: "absolute",
      placement: t.placement
    })
  },
  data: {}
};
var dw = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: function(e) {
    var t = e.state
      , n = e.options
      , r = e.name
      , o = n.mainAxis
      , a = void 0 === o || o
      , i = n.altAxis
      , s = void 0 !== i && i
      , l = n.boundary
      , u = n.rootBoundary
      , c = n.altBoundary
      , d = n.padding
      , f = n.tether
      , p = void 0 === f || f
      , h = n.tetherOffset
      , v = void 0 === h ? 0 : h
      , g = ow(t, {
      boundary: l,
      rootBoundary: u,
      padding: d,
      altBoundary: c
    })
      , m = xb(t.placement)
      , y = jb(t.placement)
      , b = !y
      , w = Pb(m)
      , x = function(e) {
      return "x" === e ? "y" : "x"
    }(w)
      , S = t.modifiersData.popperOffsets
      , E = t.rects.reference
      , A = t.rects.popper
      , C = "function" == typeof v ? v(Object.assign({}, t.rects, {
      placement: t.placement
    })) : v
      , k = "number" == typeof C ? {
      mainAxis: C,
      altAxis: C
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, C)
      , T = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null
      , D = {
      x: 0,
      y: 0
    };
    if (S) {
      if (a) {
        var O, _ = "y" === w ? eb : rb, R = "y" === w ? tb : nb, L = "y" === w ? "height" : "width", I = S[w], P = I + g[_], F = I - g[R], B = p ? -A[L] / 2 : 0, N = y === ib ? E[L] : A[L], M = y === ib ? -A[L] : -E[L], j = t.elements.arrow, V = p && j ? kb(j) : {
          width: 0,
          height: 0
        }, U = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }, $ = U[_], H = U[R], z = Fb(0, E[L], V[L]), K = b ? E[L] / 2 - B - z - $ - k.mainAxis : N - z - $ - k.mainAxis, W = b ? -E[L] / 2 + B + z + H + k.mainAxis : M + z + H + k.mainAxis, G = t.elements.arrow && Ib(t.elements.arrow), q = G ? "y" === w ? G.clientTop || 0 : G.clientLeft || 0 : 0, Y = null != (O = null == T ? void 0 : T[w]) ? O : 0, X = I + W - Y, Q = Fb(p ? Eb(P, I + K - Y - q) : P, I, p ? Sb(F, X) : F);
        S[w] = Q,
          D[w] = Q - I
      }
      if (s) {
        var J, Z = "x" === w ? eb : rb, ee = "x" === w ? tb : nb, te = S[x], ne = "y" === x ? "height" : "width", re = te + g[Z], oe = te - g[ee], ae = -1 !== [eb, rb].indexOf(m), ie = null != (J = null == T ? void 0 : T[x]) ? J : 0, se = ae ? re : te - E[ne] - A[ne] - ie + k.altAxis, le = ae ? te + E[ne] + A[ne] - ie - k.altAxis : oe, ue = p && ae ? function(e, t, n) {
          var r = Fb(e, t, n);
          return r > n ? n : r
        }(se, te, le) : Fb(p ? se : re, te, p ? le : oe);
        S[x] = ue,
          D[x] = ue - te
      }
      t.modifiersData[r] = D
    }
  },
  requiresIfExists: ["offset"]
};
function fw(e, t, n) {
  void 0 === n && (n = !1);
  var r = yb(t)
    , o = yb(t) && function(e) {
    var t = e.getBoundingClientRect()
      , n = Ab(t.width) / e.offsetWidth || 1
      , r = Ab(t.height) / e.offsetHeight || 1;
    return 1 !== n || 1 !== r
  }(t)
    , a = _b(t)
    , i = Cb(e, o)
    , s = {
    scrollLeft: 0,
    scrollTop: 0
  }
    , l = {
    x: 0,
    y: 0
  };
  return (r || !r && !n) && (("body" !== vb(t) || Qb(a)) && (s = function(e) {
    return e !== gb(e) && yb(e) ? function(e) {
      return {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
      }
    }(e) : Yb(e)
  }(t)),
    yb(t) ? ((l = Cb(t, !0)).x += t.clientLeft,
      l.y += t.clientTop) : a && (l.x = Xb(a))),
    {
      x: i.left + s.scrollLeft - l.x,
      y: i.top + s.scrollTop - l.y,
      width: i.width,
      height: i.height
    }
}
function pw(e) {
  var t = new Map
    , n = new Set
    , r = [];
  function o(e) {
    n.add(e.name),
      [].concat(e.requires || [], e.requiresIfExists || []).forEach((function(e) {
          if (!n.has(e)) {
            var r = t.get(e);
            r && o(r)
          }
        }
      )),
      r.push(e)
  }
  return e.forEach((function(e) {
      t.set(e.name, e)
    }
  )),
    e.forEach((function(e) {
        n.has(e.name) || o(e)
      }
    )),
    r
}
function hw(e) {
  var t;
  return function() {
    return t || (t = new Promise((function(n) {
        Promise.resolve().then((function() {
            t = void 0,
              n(e())
          }
        ))
      }
    ))),
      t
  }
}
var vw = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function gw() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return !t.some((function(e) {
      return !(e && "function" == typeof e.getBoundingClientRect)
    }
  ))
}
function mw(e) {
  void 0 === e && (e = {});
  var t = e
    , n = t.defaultModifiers
    , r = void 0 === n ? [] : n
    , o = t.defaultOptions
    , a = void 0 === o ? vw : o;
  return function(e, t, n) {
    void 0 === n && (n = a);
    var o = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, vw, a),
      modifiersData: {},
      elements: {
        reference: e,
        popper: t
      },
      attributes: {},
      styles: {}
    }
      , i = []
      , s = !1
      , l = {
      state: o,
      setOptions: function(n) {
        var s = "function" == typeof n ? n(o.options) : n;
        u(),
          o.options = Object.assign({}, a, o.options, s),
          o.scrollParents = {
            reference: mb(e) ? Zb(e) : e.contextElement ? Zb(e.contextElement) : [],
            popper: Zb(t)
          };
        var c = function(e) {
          var t = pw(e);
          return hb.reduce((function(e, n) {
              return e.concat(t.filter((function(e) {
                  return e.phase === n
                }
              )))
            }
          ), [])
        }(function(e) {
          var t = e.reduce((function(e, t) {
              var n = e[t.name];
              return e[t.name] = n ? Object.assign({}, n, t, {
                options: Object.assign({}, n.options, t.options),
                data: Object.assign({}, n.data, t.data)
              }) : t,
                e
            }
          ), {});
          return Object.keys(t).map((function(e) {
              return t[e]
            }
          ))
        }([].concat(r, o.options.modifiers)));
        return o.orderedModifiers = c.filter((function(e) {
            return e.enabled
          }
        )),
          o.orderedModifiers.forEach((function(e) {
              var t = e.name
                , n = e.options
                , r = void 0 === n ? {} : n
                , a = e.effect;
              if ("function" == typeof a) {
                var s = a({
                  state: o,
                  name: t,
                  instance: l,
                  options: r
                })
                  , u = function() {};
                i.push(s || u)
              }
            }
          )),
          l.update()
      },
      forceUpdate: function() {
        if (!s) {
          var e = o.elements
            , t = e.reference
            , n = e.popper;
          if (gw(t, n)) {
            o.rects = {
              reference: fw(t, Ib(n), "fixed" === o.options.strategy),
              popper: kb(n)
            },
              o.reset = !1,
              o.placement = o.options.placement,
              o.orderedModifiers.forEach((function(e) {
                  return o.modifiersData[e.name] = Object.assign({}, e.data)
                }
              ));
            for (var r = 0; r < o.orderedModifiers.length; r++)
              if (!0 !== o.reset) {
                var a = o.orderedModifiers[r]
                  , i = a.fn
                  , u = a.options
                  , c = void 0 === u ? {} : u
                  , d = a.name;
                "function" == typeof i && (o = i({
                  state: o,
                  options: c,
                  name: d,
                  instance: l
                }) || o)
              } else
                o.reset = !1,
                  r = -1
          }
        }
      },
      update: hw((function() {
          return new Promise((function(e) {
              l.forceUpdate(),
                e(o)
            }
          ))
        }
      )),
      destroy: function() {
        u(),
          s = !0
      }
    };
    if (!gw(e, t))
      return l;
    function u() {
      i.forEach((function(e) {
          return e()
        }
      )),
        i = []
    }
    return l.setOptions(n).then((function(e) {
        !s && n.onFirstUpdate && n.onFirstUpdate(e)
      }
    )),
      l
  }
}
mw(),
  mw({
    defaultModifiers: [zb, cw, $b, wb]
  });
var yw = mw({
  defaultModifiers: [zb, cw, $b, wb, uw, aw, dw, Mb, lw]
});
const bw = (e,t,n={})=>{
    const r = {
        name: "updateState",
        enabled: !0,
        phase: "write",
        fn: ({state: e})=>{
          const t = function(e) {
            const t = Object.keys(e.elements)
              , n = Sg(t.map((t=>[t, e.styles[t] || {}])))
              , r = Sg(t.map((t=>[t, e.attributes[t]])));
            return {
              styles: n,
              attributes: r
            }
          }(e);
          Object.assign(i.value, t)
        }
        ,
        requires: ["computeStyles"]
      }
      , o = yi((()=>{
          const {onFirstUpdate: e, placement: t, strategy: o, modifiers: a} = Vt(n);
          return {
            onFirstUpdate: e,
            placement: t || "bottom",
            strategy: o || "absolute",
            modifiers: [...a || [], r, {
              name: "applyStyles",
              enabled: !1
            }]
          }
        }
      ))
      , a = Bt()
      , i = Ft({
        styles: {
          popper: {
            position: Vt(o).strategy,
            left: "0",
            top: "0"
          },
          arrow: {
            position: "absolute"
          }
        },
        attributes: {}
      })
      , s = ()=>{
        a.value && (a.value.destroy(),
          a.value = void 0)
      }
    ;
    return Jn(o, (e=>{
        const t = Vt(a);
        t && t.setOptions(e)
      }
    ), {
      deep: !0
    }),
      Jn([e, t], (([e,t])=>{
          s(),
          e && t && (a.value = yw(e, t, Vt(o)))
        }
      )),
      Fr((()=>{
          s()
        }
      )),
      {
        state: yi((()=>{
            var e;
            return {
              ...(null == (e = Vt(a)) ? void 0 : e.state) || {}
            }
          }
        )),
        styles: yi((()=>Vt(i).styles)),
        attributes: yi((()=>Vt(i).attributes)),
        update: ()=>{
          var e;
          return null == (e = Vt(a)) ? void 0 : e.update()
        }
        ,
        forceUpdate: ()=>{
          var e;
          return null == (e = Vt(a)) ? void 0 : e.forceUpdate()
        }
        ,
        instanceRef: yi((()=>Vt(a)))
      }
  }
;
const ww = e=>{
    if (!e)
      return {
        onClick: a,
        onMousedown: a,
        onMouseup: a
      };
    let t = !1
      , n = !1;
    return {
      onClick: r=>{
        t && n && e(r),
          t = n = !1
      }
      ,
      onMousedown: e=>{
        t = e.target === e.currentTarget
      }
      ,
      onMouseup: e=>{
        n = e.target === e.currentTarget
      }
    }
  }
;
function xw() {
  let e;
  const t = ()=>window.clearTimeout(e);
  return Ec((()=>t())),
    {
      registerTimeout: (n,r)=>{
        t(),
          e = window.setTimeout(n, r)
      }
      ,
      cancelTimeout: t
    }
}
const Sw = {
    prefix: Math.floor(1e4 * Math.random()),
    current: 0
  }
  , Ew = Symbol("elIdInjection")
  , Aw = ()=>ei() ? jo(Ew, Sw) : Sw
  , Cw = e=>{
    const t = Aw()
      , n = Gy();
    return yi((()=>Vt(e) || `${n.value}-id-${t.prefix}-${t.current++}`))
  }
;
let kw = [];
const Tw = e=>{
    const t = e;
    t.key === by.esc && kw.forEach((e=>e(t)))
  }
;
let Dw;
const Ow = ()=>{
    const e = Gy()
      , t = Aw()
      , n = yi((()=>`${e.value}-popper-container-${t.prefix}`))
      , r = yi((()=>`#${n.value}`));
    return {
      id: n,
      selector: r
    }
  }
  , _w = ()=>{
    const {id: e, selector: t} = Ow();
    return Rr((()=>{
        mc && (Dw || document.body.querySelector(t.value) || (Dw = (e=>{
            const t = document.createElement("div");
            return t.id = e,
              document.body.appendChild(t),
              t
          }
        )(e.value)))
      }
    )),
      {
        id: e,
        selector: t
      }
  }
  , Rw = uy({
    showAfter: {
      type: Number,
      default: 0
    },
    hideAfter: {
      type: Number,
      default: 200
    },
    autoClose: {
      type: Number,
      default: 0
    }
  })
  , Lw = Symbol("elForwardRef")
  , Iw = Ft(0)
  , Pw = 2e3
  , Fw = Symbol("zIndexContextKey")
  , Bw = e=>{
    const t = e || (ei() ? jo(Fw, void 0) : void 0)
      , n = yi((()=>{
        const e = Vt(t);
        return Vg(e) ? e : Pw
      }
    ))
      , r = yi((()=>n.value + Iw.value));
    return {
      initialZIndex: n,
      currentZIndex: r,
      nextZIndex: ()=>(Iw.value++,
        r.value)
    }
  }
;
function Nw(e) {
  return e.split("-")[1]
}
function Mw(e) {
  return "y" === e ? "height" : "width"
}
function jw(e) {
  return e.split("-")[0]
}
function Vw(e) {
  return ["top", "bottom"].includes(jw(e)) ? "x" : "y"
}
function Uw(e, t, n) {
  let {reference: r, floating: o} = e;
  const a = r.x + r.width / 2 - o.width / 2
    , i = r.y + r.height / 2 - o.height / 2
    , s = Vw(t)
    , l = Mw(s)
    , u = r[l] / 2 - o[l] / 2
    , c = "x" === s;
  let d;
  switch (jw(t)) {
    case "top":
      d = {
        x: a,
        y: r.y - o.height
      };
      break;
    case "bottom":
      d = {
        x: a,
        y: r.y + r.height
      };
      break;
    case "right":
      d = {
        x: r.x + r.width,
        y: i
      };
      break;
    case "left":
      d = {
        x: r.x - o.width,
        y: i
      };
      break;
    default:
      d = {
        x: r.x,
        y: r.y
      }
  }
  switch (Nw(t)) {
    case "start":
      d[s] -= u * (n && c ? -1 : 1);
      break;
    case "end":
      d[s] += u * (n && c ? -1 : 1)
  }
  return d
}
function $w(e, t) {
  return "function" == typeof e ? e(t) : e
}
function Hw(e) {
  return "number" != typeof e ? (t = e,
    {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...t
    }) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
  var t
}
function zw(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  }
}
async function Kw(e, t) {
  var n;
  void 0 === t && (t = {});
  const {x: r, y: o, platform: a, rects: i, elements: s, strategy: l} = e
    , {boundary: u="clippingAncestors", rootBoundary: c="viewport", elementContext: d="floating", altBoundary: f=!1, padding: p=0} = $w(t, e)
    , h = Hw(p)
    , v = s[f ? "floating" === d ? "reference" : "floating" : d]
    , g = zw(await a.getClippingRect({
    element: null == (n = await (null == a.isElement ? void 0 : a.isElement(v))) || n ? v : v.contextElement || await (null == a.getDocumentElement ? void 0 : a.getDocumentElement(s.floating)),
    boundary: u,
    rootBoundary: c,
    strategy: l
  }))
    , m = "floating" === d ? {
    ...i.floating,
    x: r,
    y: o
  } : i.reference
    , y = await (null == a.getOffsetParent ? void 0 : a.getOffsetParent(s.floating))
    , b = await (null == a.isElement ? void 0 : a.isElement(y)) && await (null == a.getScale ? void 0 : a.getScale(y)) || {
    x: 1,
    y: 1
  }
    , w = zw(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: m,
    offsetParent: y,
    strategy: l
  }) : m);
  return {
    top: (g.top - w.top + h.top) / b.y,
    bottom: (w.bottom - g.bottom + h.bottom) / b.y,
    left: (g.left - w.left + h.left) / b.x,
    right: (w.right - g.right + h.right) / b.x
  }
}
const Ww = Math.min
  , Gw = Math.max;
function qw(e, t, n) {
  return Gw(e, Ww(t, n))
}
const Yw = e=>({
  name: "arrow",
  options: e,
  async fn(t) {
    const {x: n, y: r, placement: o, rects: a, platform: i, elements: s} = t
      , {element: l, padding: u=0} = $w(e, t) || {};
    if (null == l)
      return {};
    const c = Hw(u)
      , d = {
      x: n,
      y: r
    }
      , f = Vw(o)
      , p = Mw(f)
      , h = await i.getDimensions(l)
      , v = "y" === f
      , g = v ? "top" : "left"
      , m = v ? "bottom" : "right"
      , y = v ? "clientHeight" : "clientWidth"
      , b = a.reference[p] + a.reference[f] - d[f] - a.floating[p]
      , w = d[f] - a.reference[f]
      , x = await (null == i.getOffsetParent ? void 0 : i.getOffsetParent(l));
    let S = x ? x[y] : 0;
    S && await (null == i.isElement ? void 0 : i.isElement(x)) || (S = s.floating[y] || a.floating[p]);
    const E = b / 2 - w / 2
      , A = S / 2 - h[p] / 2 - 1
      , C = Ww(c[g], A)
      , k = Ww(c[m], A)
      , T = C
      , D = S - h[p] - k
      , O = S / 2 - h[p] / 2 + E
      , _ = qw(T, O, D)
      , R = null != Nw(o) && O != _ && a.reference[p] / 2 - (O < T ? C : k) - h[p] / 2 < 0 ? O < T ? T - O : D - O : 0;
    return {
      [f]: d[f] - R,
      data: {
        [f]: _,
        centerOffset: O - _ + R
      }
    }
  }
});
["top", "right", "bottom", "left"].reduce(((e,t)=>e.concat(t, t + "-start", t + "-end")), []);
const Xw = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Qw(e) {
  return e.replace(/left|right|bottom|top/g, (e=>Xw[e]))
}
const Jw = {
  start: "end",
  end: "start"
};
function Zw(e) {
  return e.replace(/start|end/g, (e=>Jw[e]))
}
const ex = function(e) {
  return void 0 === e && (e = {}),
    {
      name: "flip",
      options: e,
      async fn(t) {
        var n;
        const {placement: r, middlewareData: o, rects: a, initialPlacement: i, platform: s, elements: l} = t
          , {mainAxis: u=!0, crossAxis: c=!0, fallbackPlacements: d, fallbackStrategy: f="bestFit", fallbackAxisSideDirection: p="none", flipAlignment: h=!0, ...v} = $w(e, t)
          , g = jw(r)
          , m = jw(i) === i
          , y = await (null == s.isRTL ? void 0 : s.isRTL(l.floating))
          , b = d || (m || !h ? [Qw(i)] : function(e) {
          const t = Qw(e);
          return [Zw(e), t, Zw(t)]
        }(i));
        d || "none" === p || b.push(...function(e, t, n, r) {
          const o = Nw(e);
          let a = function(e, t, n) {
            const r = ["left", "right"]
              , o = ["right", "left"]
              , a = ["top", "bottom"]
              , i = ["bottom", "top"];
            switch (e) {
              case "top":
              case "bottom":
                return n ? t ? o : r : t ? r : o;
              case "left":
              case "right":
                return t ? a : i;
              default:
                return []
            }
          }(jw(e), "start" === n, r);
          return o && (a = a.map((e=>e + "-" + o)),
          t && (a = a.concat(a.map(Zw)))),
            a
        }(i, h, p, y));
        const w = [i, ...b]
          , x = await Kw(t, v)
          , S = [];
        let E = (null == (n = o.flip) ? void 0 : n.overflows) || [];
        if (u && S.push(x[g]),
          c) {
          const {main: e, cross: t} = function(e, t, n) {
            void 0 === n && (n = !1);
            const r = Nw(e)
              , o = Vw(e)
              , a = Mw(o);
            let i = "x" === o ? r === (n ? "end" : "start") ? "right" : "left" : "start" === r ? "bottom" : "top";
            return t.reference[a] > t.floating[a] && (i = Qw(i)),
              {
                main: i,
                cross: Qw(i)
              }
          }(r, a, y);
          S.push(x[e], x[t])
        }
        if (E = [...E, {
          placement: r,
          overflows: S
        }],
          !S.every((e=>e <= 0))) {
          var A, C;
          const e = ((null == (A = o.flip) ? void 0 : A.index) || 0) + 1
            , t = w[e];
          if (t)
            return {
              data: {
                index: e,
                overflows: E
              },
              reset: {
                placement: t
              }
            };
          let n = null == (C = E.filter((e=>e.overflows[0] <= 0)).sort(((e,t)=>e.overflows[1] - t.overflows[1]))[0]) ? void 0 : C.placement;
          if (!n)
            switch (f) {
              case "bestFit":
              {
                var k;
                const e = null == (k = E.map((e=>[e.placement, e.overflows.filter((e=>e > 0)).reduce(((e,t)=>e + t), 0)])).sort(((e,t)=>e[1] - t[1]))[0]) ? void 0 : k[0];
                e && (n = e);
                break
              }
              case "initialPlacement":
                n = i
            }
          if (r !== n)
            return {
              reset: {
                placement: n
              }
            }
        }
        return {}
      }
    }
}
  , tx = function(e) {
  return void 0 === e && (e = 0),
    {
      name: "offset",
      options: e,
      async fn(t) {
        const {x: n, y: r} = t
          , o = await async function(e, t) {
          const {placement: n, platform: r, elements: o} = e
            , a = await (null == r.isRTL ? void 0 : r.isRTL(o.floating))
            , i = jw(n)
            , s = Nw(n)
            , l = "x" === Vw(n)
            , u = ["left", "top"].includes(i) ? -1 : 1
            , c = a && l ? -1 : 1
            , d = $w(t, e);
          let {mainAxis: f, crossAxis: p, alignmentAxis: h} = "number" == typeof d ? {
            mainAxis: d,
            crossAxis: 0,
            alignmentAxis: null
          } : {
            mainAxis: 0,
            crossAxis: 0,
            alignmentAxis: null,
            ...d
          };
          return s && "number" == typeof h && (p = "end" === s ? -1 * h : h),
            l ? {
              x: p * c,
              y: f * u
            } : {
              x: f * u,
              y: p * c
            }
        }(t, e);
        return {
          x: n + o.x,
          y: r + o.y,
          data: o
        }
      }
    }
};
const nx = function(e) {
  return void 0 === e && (e = {}),
    {
      name: "shift",
      options: e,
      async fn(t) {
        const {x: n, y: r, placement: o} = t
          , {mainAxis: a=!0, crossAxis: i=!1, limiter: s={
          fn: e=>{
            let {x: t, y: n} = e;
            return {
              x: t,
              y: n
            }
          }
        }, ...l} = $w(e, t)
          , u = {
          x: n,
          y: r
        }
          , c = await Kw(t, l)
          , d = Vw(jw(o))
          , f = function(e) {
          return "x" === e ? "y" : "x"
        }(d);
        let p = u[d]
          , h = u[f];
        if (a) {
          const e = "y" === d ? "bottom" : "right";
          p = qw(p + c["y" === d ? "top" : "left"], p, p - c[e])
        }
        if (i) {
          const e = "y" === f ? "bottom" : "right";
          h = qw(h + c["y" === f ? "top" : "left"], h, h - c[e])
        }
        const v = s.fn({
          ...t,
          [d]: p,
          [f]: h
        });
        return {
          ...v,
          data: {
            x: v.x - n,
            y: v.y - r
          }
        }
      }
    }
};
function rx(e) {
  var t;
  return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window
}
function ox(e) {
  return rx(e).getComputedStyle(e)
}
function ax(e) {
  return e instanceof rx(e).Node
}
function ix(e) {
  return ax(e) ? (e.nodeName || "").toLowerCase() : "#document"
}
function sx(e) {
  return e instanceof HTMLElement || e instanceof rx(e).HTMLElement
}
function lx(e) {
  return "undefined" != typeof ShadowRoot && (e instanceof rx(e).ShadowRoot || e instanceof ShadowRoot)
}
function ux(e) {
  const {overflow: t, overflowX: n, overflowY: r, display: o} = ox(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o)
}
function cx(e) {
  return ["table", "td", "th"].includes(ix(e))
}
function dx(e) {
  const t = fx()
    , n = ox(e);
  return "none" !== n.transform || "none" !== n.perspective || !!n.containerType && "normal" !== n.containerType || !t && !!n.backdropFilter && "none" !== n.backdropFilter || !t && !!n.filter && "none" !== n.filter || ["transform", "perspective", "filter"].some((e=>(n.willChange || "").includes(e))) || ["paint", "layout", "strict", "content"].some((e=>(n.contain || "").includes(e)))
}
function fx() {
  return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none")
}
function px(e) {
  return ["html", "body", "#document"].includes(ix(e))
}
const hx = Math.min
  , vx = Math.max
  , gx = Math.round
  , mx = Math.floor
  , yx = e=>({
  x: e,
  y: e
});
function bx(e) {
  const t = ox(e);
  let n = parseFloat(t.width) || 0
    , r = parseFloat(t.height) || 0;
  const o = sx(e)
    , a = o ? e.offsetWidth : n
    , i = o ? e.offsetHeight : r
    , s = gx(n) !== a || gx(r) !== i;
  return s && (n = a,
    r = i),
    {
      width: n,
      height: r,
      $: s
    }
}
function wx(e) {
  return e instanceof Element || e instanceof rx(e).Element
}
function xx(e) {
  return wx(e) ? e : e.contextElement
}
function Sx(e) {
  const t = xx(e);
  if (!sx(t))
    return yx(1);
  const n = t.getBoundingClientRect()
    , {width: r, height: o, $: a} = bx(t);
  let i = (a ? gx(n.width) : n.width) / r
    , s = (a ? gx(n.height) : n.height) / o;
  return i && Number.isFinite(i) || (i = 1),
  s && Number.isFinite(s) || (s = 1),
    {
      x: i,
      y: s
    }
}
const Ex = yx(0);
function Ax(e) {
  const t = rx(e);
  return fx() && t.visualViewport ? {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  } : Ex
}
function Cx(e, t, n, r) {
  void 0 === t && (t = !1),
  void 0 === n && (n = !1);
  const o = e.getBoundingClientRect()
    , a = xx(e);
  let i = yx(1);
  t && (r ? wx(r) && (i = Sx(r)) : i = Sx(e));
  const s = (l = a,
  void 0 === (u = n) && (u = !1),
    !(c = r) || u && c !== rx(l) || !u ? yx(0) : Ax(a));
  var l, u, c;
  let d = (o.left + s.x) / i.x
    , f = (o.top + s.y) / i.y
    , p = o.width / i.x
    , h = o.height / i.y;
  if (a) {
    const e = rx(a)
      , t = r && wx(r) ? rx(r) : r;
    let n = e.frameElement;
    for (; n && r && t !== e; ) {
      const e = Sx(n)
        , t = n.getBoundingClientRect()
        , r = getComputedStyle(n)
        , o = t.left + (n.clientLeft + parseFloat(r.paddingLeft)) * e.x
        , a = t.top + (n.clientTop + parseFloat(r.paddingTop)) * e.y;
      d *= e.x,
        f *= e.y,
        p *= e.x,
        h *= e.y,
        d += o,
        f += a,
        n = rx(n).frameElement
    }
  }
  return zw({
    width: p,
    height: h,
    x: d,
    y: f
  })
}
function kx(e) {
  return wx(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  }
}
function Tx(e) {
  var t;
  return null == (t = (ax(e) ? e.ownerDocument : e.document) || window.document) ? void 0 : t.documentElement
}
function Dx(e) {
  return Cx(Tx(e)).left + kx(e).scrollLeft
}
function Ox(e) {
  if ("html" === ix(e))
    return e;
  const t = e.assignedSlot || e.parentNode || lx(e) && e.host || Tx(e);
  return lx(t) ? t.host : t
}
function _x(e) {
  const t = Ox(e);
  return px(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : sx(t) && ux(t) ? t : _x(t)
}
function Rx(e, t) {
  var n;
  void 0 === t && (t = []);
  const r = _x(e)
    , o = r === (null == (n = e.ownerDocument) ? void 0 : n.body)
    , a = rx(r);
  return o ? t.concat(a, a.visualViewport || [], ux(r) ? r : []) : t.concat(r, Rx(r))
}
function Lx(e, t, n) {
  let r;
  if ("viewport" === t)
    r = function(e, t) {
      const n = rx(e)
        , r = Tx(e)
        , o = n.visualViewport;
      let a = r.clientWidth
        , i = r.clientHeight
        , s = 0
        , l = 0;
      if (o) {
        a = o.width,
          i = o.height;
        const e = fx();
        (!e || e && "fixed" === t) && (s = o.offsetLeft,
          l = o.offsetTop)
      }
      return {
        width: a,
        height: i,
        x: s,
        y: l
      }
    }(e, n);
  else if ("document" === t)
    r = function(e) {
      const t = Tx(e)
        , n = kx(e)
        , r = e.ownerDocument.body
        , o = vx(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth)
        , a = vx(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
      let i = -n.scrollLeft + Dx(e);
      const s = -n.scrollTop;
      return "rtl" === ox(r).direction && (i += vx(t.clientWidth, r.clientWidth) - o),
        {
          width: o,
          height: a,
          x: i,
          y: s
        }
    }(Tx(e));
  else if (wx(t))
    r = function(e, t) {
      const n = Cx(e, !0, "fixed" === t)
        , r = n.top + e.clientTop
        , o = n.left + e.clientLeft
        , a = sx(e) ? Sx(e) : yx(1);
      return {
        width: e.clientWidth * a.x,
        height: e.clientHeight * a.y,
        x: o * a.x,
        y: r * a.y
      }
    }(t, n);
  else {
    const n = Ax(e);
    r = {
      ...t,
      x: t.x - n.x,
      y: t.y - n.y
    }
  }
  return zw(r)
}
function Ix(e, t) {
  const n = Ox(e);
  return !(n === t || !wx(n) || px(n)) && ("fixed" === ox(n).position || Ix(n, t))
}
function Px(e, t, n) {
  const r = sx(t)
    , o = Tx(t)
    , a = "fixed" === n
    , i = Cx(e, !0, a, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = yx(0);
  if (r || !r && !a)
    if (("body" !== ix(t) || ux(o)) && (s = kx(t)),
      sx(t)) {
      const e = Cx(t, !0, a, t);
      l.x = e.x + t.clientLeft,
        l.y = e.y + t.clientTop
    } else
      o && (l.x = Dx(o));
  return {
    x: i.left + s.scrollLeft - l.x,
    y: i.top + s.scrollTop - l.y,
    width: i.width,
    height: i.height
  }
}
function Fx(e, t) {
  return sx(e) && "fixed" !== ox(e).position ? t ? t(e) : e.offsetParent : null
}
function Bx(e, t) {
  const n = rx(e);
  if (!sx(e))
    return n;
  let r = Fx(e, t);
  for (; r && cx(r) && "static" === ox(r).position; )
    r = Fx(r, t);
  return r && ("html" === ix(r) || "body" === ix(r) && "static" === ox(r).position && !dx(r)) ? n : r || function(e) {
    let t = Ox(e);
    for (; sx(t) && !px(t); ) {
      if (dx(t))
        return t;
      t = Ox(t)
    }
    return null
  }(e) || n
}
const Nx = {
  convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
    let {rect: t, offsetParent: n, strategy: r} = e;
    const o = sx(n)
      , a = Tx(n);
    if (n === a)
      return t;
    let i = {
      scrollLeft: 0,
      scrollTop: 0
    }
      , s = yx(1);
    const l = yx(0);
    if ((o || !o && "fixed" !== r) && (("body" !== ix(n) || ux(a)) && (i = kx(n)),
      sx(n))) {
      const e = Cx(n);
      s = Sx(n),
        l.x = e.x + n.clientLeft,
        l.y = e.y + n.clientTop
    }
    return {
      width: t.width * s.x,
      height: t.height * s.y,
      x: t.x * s.x - i.scrollLeft * s.x + l.x,
      y: t.y * s.y - i.scrollTop * s.y + l.y
    }
  },
  getDocumentElement: Tx,
  getClippingRect: function(e) {
    let {element: t, boundary: n, rootBoundary: r, strategy: o} = e;
    const a = [..."clippingAncestors" === n ? function(e, t) {
      const n = t.get(e);
      if (n)
        return n;
      let r = Rx(e).filter((e=>wx(e) && "body" !== ix(e)))
        , o = null;
      const a = "fixed" === ox(e).position;
      let i = a ? Ox(e) : e;
      for (; wx(i) && !px(i); ) {
        const t = ox(i)
          , n = dx(i);
        n || "fixed" !== t.position || (o = null),
          (a ? !n && !o : !n && "static" === t.position && o && ["absolute", "fixed"].includes(o.position) || ux(i) && !n && Ix(e, i)) ? r = r.filter((e=>e !== i)) : o = t,
          i = Ox(i)
      }
      return t.set(e, r),
        r
    }(t, this._c) : [].concat(n), r]
      , i = a[0]
      , s = a.reduce(((e,n)=>{
        const r = Lx(t, n, o);
        return e.top = vx(r.top, e.top),
          e.right = hx(r.right, e.right),
          e.bottom = hx(r.bottom, e.bottom),
          e.left = vx(r.left, e.left),
          e
      }
    ), Lx(t, i, o));
    return {
      width: s.right - s.left,
      height: s.bottom - s.top,
      x: s.left,
      y: s.top
    }
  },
  getOffsetParent: Bx,
  getElementRects: async function(e) {
    let {reference: t, floating: n, strategy: r} = e;
    const o = this.getOffsetParent || Bx
      , a = this.getDimensions;
    return {
      reference: Px(t, await o(n), r),
      floating: {
        x: 0,
        y: 0,
        ...await a(n)
      }
    }
  },
  getClientRects: function(e) {
    return Array.from(e.getClientRects())
  },
  getDimensions: function(e) {
    return bx(e)
  },
  getScale: Sx,
  isElement: wx,
  isRTL: function(e) {
    return "rtl" === getComputedStyle(e).direction
  }
};
const Mx = (e,t,n)=>{
    const r = new Map
      , o = {
      platform: Nx,
      ...n
    }
      , a = {
      ...o.platform,
      _c: r
    };
    return (async(e,t,n)=>{
        const {placement: r="bottom", strategy: o="absolute", middleware: a=[], platform: i} = n
          , s = a.filter(Boolean)
          , l = await (null == i.isRTL ? void 0 : i.isRTL(t));
        let u = await i.getElementRects({
          reference: e,
          floating: t,
          strategy: o
        })
          , {x: c, y: d} = Uw(u, r, l)
          , f = r
          , p = {}
          , h = 0;
        for (let v = 0; v < s.length; v++) {
          const {name: n, fn: a} = s[v]
            , {x: g, y: m, data: y, reset: b} = await a({
            x: c,
            y: d,
            initialPlacement: r,
            placement: f,
            strategy: o,
            middlewareData: p,
            rects: u,
            platform: i,
            elements: {
              reference: e,
              floating: t
            }
          });
          c = null != g ? g : c,
            d = null != m ? m : d,
            p = {
              ...p,
              [n]: {
                ...p[n],
                ...y
              }
            },
          b && h <= 50 && (h++,
          "object" == typeof b && (b.placement && (f = b.placement),
          b.rects && (u = !0 === b.rects ? await i.getElementRects({
            reference: e,
            floating: t,
            strategy: o
          }) : b.rects),
            ({x: c, y: d} = Uw(u, f, l))),
            v = -1)
        }
        return {
          x: c,
          y: d,
          placement: f,
          strategy: o,
          middlewareData: p
        }
      }
    )(e, t, {
      ...o,
      platform: a
    })
  }
;
uy({});
const jx = ({middleware: e, placement: t, strategy: n})=>{
    const r = Ft()
      , o = Ft()
      , a = Ft()
      , i = Ft()
      , s = Ft({})
      , l = {
        x: a,
        y: i,
        placement: t,
        strategy: n,
        middlewareData: s
      }
      , u = async()=>{
        if (!mc)
          return;
        const a = (e=>{
            if (!mc)
              return;
            if (!e)
              return e;
            const t = Dc(e);
            return t || (Pt(e) ? t : e)
          }
        )(r)
          , i = Dc(o);
        if (!a || !i)
          return;
        const s = await Mx(a, i, {
          placement: Vt(t),
          strategy: Vt(n),
          middleware: Vt(e)
        });
        Yg(l).forEach((e=>{
            l[e].value = s[e]
          }
        ))
      }
    ;
    return Lr((()=>{
        qn((()=>{
            u()
          }
        ))
      }
    )),
      {
        ...l,
        update: u,
        referenceRef: r,
        contentRef: o
      }
  }
;
const Vx = (e,t)=>{
  const n = {}
    , r = Bt([]);
  return {
    children: r,
    addChild: o=>{
      n[o.uid] = o,
        r.value = ((e,t,n)=>_y(e.subTree).filter((e=>{
            var n;
            return La(e) && (null == (n = e.type) ? void 0 : n.name) === t && !!e.component
          }
        )).map((e=>e.component.uid)).map((e=>n[e])).filter((e=>!!e)))(e, t, n)
    }
    ,
    removeChild: e=>{
      delete n[e],
        r.value = r.value.filter((t=>t.uid !== e))
    }
  }
}
  , Ux = ly({
  type: String,
  values: Cy,
  required: !1
})
  , $x = Symbol("size");
function Hx(e, {afterFocus: t, beforeBlur: n, afterBlur: r}={}) {
  const o = ei()
    , {emit: a} = o
    , i = Bt()
    , s = Ft(!1);
  return Jn(i, (e=>{
      e && e.setAttribute("tabindex", "-1")
    }
  )),
    Rc(i, "click", (()=>{
        var t;
        null == (t = e.value) || t.focus()
      }
    )),
    {
      wrapperRef: i,
      isFocused: s,
      handleFocus: e=>{
        s.value || (s.value = !0,
          a("focus", e),
        null == t || t())
      }
      ,
      handleBlur: e=>{
        var t;
        !!y(n) && n(e) || e.relatedTarget && (null == (t = i.value) ? void 0 : t.contains(e.relatedTarget)) || (s.value = !1,
          a("blur", e),
        null == r || r())
      }
    }
}
const zx = Symbol()
  , Kx = Ft();
function Wx(e, t=void 0) {
  const n = ei() ? jo(zx, Kx) : Kx;
  return e ? yi((()=>{
      var r, o;
      return null != (o = null == (r = n.value) ? void 0 : r[e]) ? o : t
    }
  )) : n
}
function Gx(e, t) {
  const n = Wx()
    , r = qy(e, yi((()=>{
      var e;
      return (null == (e = n.value) ? void 0 : e.namespace) || zy
    }
  )))
    , o = Hy(yi((()=>{
      var e;
      return null == (e = n.value) ? void 0 : e.locale
    }
  )))
    , a = Bw(yi((()=>{
      var e;
      return (null == (e = n.value) ? void 0 : e.zIndex) || Pw
    }
  )))
    , i = yi((()=>{
      var e;
      return Vt(t) || (null == (e = n.value) ? void 0 : e.size) || ""
    }
  ));
  return qx(yi((()=>Vt(n) || {}))),
    {
      ns: r,
      locale: o,
      zIndex: a,
      size: i
    }
}
const qx = (e,t,n=!1)=>{
  var r;
  const o = !!ei()
    , a = o ? Wx() : void 0
    , i = null != (r = null == t ? void 0 : t.provide) ? r : o ? Mo : void 0;
  if (!i)
    return;
  const s = yi((()=>{
      const t = Vt(e);
      return (null == a ? void 0 : a.value) ? Yx(a.value, t) : t
    }
  ));
  return i(zx, s),
    i($y, yi((()=>s.value.locale))),
    i(Wy, yi((()=>s.value.namespace))),
    i(Fw, yi((()=>s.value.zIndex))),
    i($x, {
      size: yi((()=>s.value.size || ""))
    }),
  !n && Kx.value || (Kx.value = s.value),
    s
}
  , Yx = (e,t)=>{
  var n;
  const r = [...new Set([...Yg(e), ...Yg(t)])]
    , o = {};
  for (const a of r)
    o[a] = null != (n = t[a]) ? n : e[a];
  return o
}
  , Xx = uy({
  a11y: {
    type: Boolean,
    default: !0
  },
  locale: {
    type: Object
  },
  size: Ux,
  button: {
    type: Object
  },
  experimentalFeatures: {
    type: Object
  },
  keyboardNavigation: {
    type: Boolean,
    default: !0
  },
  message: {
    type: Object
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  }
})
  , Qx = {}
  , Jx = vy(vr({
  name: "ElConfigProvider",
  props: Xx,
  setup(e, {slots: t}) {
    Jn((()=>e.message), (e=>{
        Object.assign(Qx, null != e ? e : {})
      }
    ), {
      immediate: !0,
      deep: !0
    });
    const n = qx(e);
    return ()=>Qr(t, "default", {
      config: null == n ? void 0 : n.value
    })
  }
}))
  , Zx = uy({
  zIndex: {
    type: [Number, String],
    default: 100
  },
  target: {
    type: String,
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  position: {
    type: String,
    values: ["top", "bottom"],
    default: "top"
  }
})
  , eS = {
  scroll: ({scrollTop: e, fixed: t})=>Vg(e) && jg(t),
  [Sy]: e=>jg(e)
};
var tS = (e,t)=>{
    const n = e.__vccOpts || e;
    for (const [r,o] of t)
      n[r] = o;
    return n
  }
;
const nS = "ElAffix"
  , rS = vr({
  name: nS
});
const oS = vy(tS(vr({
  ...rS,
  props: Zx,
  emits: eS,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = qy("affix")
      , a = Bt()
      , i = Bt()
      , s = Bt()
      , {height: l} = function(e={}) {
        const {window: t=Oc, initialWidth: n=1 / 0, initialHeight: r=1 / 0, listenOrientation: o=!0, includeScrollbar: a=!0} = e
          , i = Ft(n)
          , s = Ft(r)
          , l = ()=>{
            t && (a ? (i.value = t.innerWidth,
              s.value = t.innerHeight) : (i.value = t.document.documentElement.clientWidth,
              s.value = t.document.documentElement.clientHeight))
          }
        ;
        return l(),
          kc(l),
          Rc("resize", l, {
            passive: !0
          }),
        o && Rc("orientationchange", l, {
          passive: !0
        }),
          {
            width: i,
            height: s
          }
      }()
      , {height: u, width: c, top: d, bottom: f, update: p} = $c(i, {
        windowScroll: !1
      })
      , h = $c(a)
      , v = Ft(!1)
      , g = Ft(0)
      , m = Ft(0)
      , y = yi((()=>({
        height: v.value ? `${u.value}px` : "",
        width: v.value ? `${c.value}px` : ""
      })))
      , b = yi((()=>{
          if (!v.value)
            return {};
          const e = r.offset ? om(r.offset) : 0;
          return {
            height: `${u.value}px`,
            width: `${c.value}px`,
            top: "top" === r.position ? e : "",
            bottom: "bottom" === r.position ? e : "",
            transform: m.value ? `translateY(${m.value}px)` : "",
            zIndex: r.zIndex
          }
        }
      ))
      , w = ()=>{
        if (s.value)
          if (g.value = s.value instanceof Window ? document.documentElement.scrollTop : s.value.scrollTop || 0,
          "top" === r.position)
            if (r.target) {
              const e = h.bottom.value - r.offset - u.value;
              v.value = r.offset > d.value && h.bottom.value > 0,
                m.value = e < 0 ? e : 0
            } else
              v.value = r.offset > d.value;
          else if (r.target) {
            const e = l.value - h.top.value - r.offset - u.value;
            v.value = l.value - r.offset < f.value && l.value > h.top.value,
              m.value = e < 0 ? -e : 0
          } else
            v.value = l.value - r.offset < f.value
      }
    ;
    return Jn(v, (e=>n("change", e))),
      Lr((()=>{
          var e;
          r.target ? (a.value = null != (e = document.querySelector(r.target)) ? e : void 0,
          a.value || Jg(nS, `Target is not existed: ${r.target}`)) : a.value = document.documentElement,
            s.value = im(i.value, !0),
            p()
        }
      )),
      Rc(s, "scroll", (()=>{
          p(),
            n("scroll", {
              scrollTop: g.value,
              fixed: v.value
            })
        }
      )),
      qn(w),
      t({
        update: w,
        updateRoot: p
      }),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "root",
          ref: i,
          class: Y(Vt(o).b()),
          style: z(Vt(y))
        }, [Ma("div", {
          class: Y({
            [Vt(o).m("fixed")]: v.value
          }),
          style: z(Vt(b))
        }, [Qr(e.$slots, "default")], 6)], 6))
  }
}), [["__file", "affix.vue"]]))
  , aS = uy({
  size: {
    type: [Number, String]
  },
  color: {
    type: String
  }
})
  , iS = vr({
  name: "ElIcon",
  inheritAttrs: !1
});
const sS = vy(tS(vr({
  ...iS,
  props: aS,
  setup(e) {
    const t = e
      , n = qy("icon")
      , r = yi((()=>{
        const {size: e, color: n} = t;
        return e || n ? {
          fontSize: Mg(e) ? void 0 : om(e),
          "--color": n
        } : {}
      }
    ));
    return (e,t)=>(Ca(),
      _a("i", qa({
        class: Vt(n).b(),
        style: Vt(r)
      }, e.$attrs), [Qr(e.$slots, "default")], 16))
  }
}), [["__file", "icon.vue"]]))
  , lS = uy({
  title: {
    type: String,
    default: ""
  },
  description: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: Yg(py),
    default: "info"
  },
  closable: {
    type: Boolean,
    default: !0
  },
  closeText: {
    type: String,
    default: ""
  },
  showIcon: Boolean,
  center: Boolean,
  effect: {
    type: String,
    values: ["light", "dark"],
    default: "light"
  }
})
  , uS = {
  close: e=>e instanceof MouseEvent
}
  , cS = vr({
  name: "ElAlert"
});
const dS = vy(tS(vr({
  ...cS,
  props: lS,
  emits: uS,
  setup(e, {emit: t}) {
    const n = e
      , {Close: r} = fy
      , o = po()
      , a = qy("alert")
      , i = Ft(!0)
      , s = yi((()=>py[n.type]))
      , l = yi((()=>[a.e("icon"), {
        [a.is("big")]: !!n.description || !!o.default
      }]))
      , u = yi((()=>({
        "with-description": n.description || o.default
      })))
      , c = e=>{
        i.value = !1,
          t("close", e)
      }
    ;
    return (e,t)=>(Ca(),
      Ra(es, {
        name: Vt(a).b("fade"),
        persisted: ""
      }, {
        default: Fn((()=>[rr(Ma("div", {
          class: Y([Vt(a).b(), Vt(a).m(e.type), Vt(a).is("center", e.center), Vt(a).is(e.effect)]),
          role: "alert"
        }, [e.showIcon && Vt(s) ? (Ca(),
          Ra(Vt(sS), {
            key: 0,
            class: Y(Vt(l))
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(Vt(s))))])),
            _: 1
          }, 8, ["class"])) : za("v-if", !0), Ma("div", {
          class: Y(Vt(a).e("content"))
        }, [e.title || e.$slots.title ? (Ca(),
          _a("span", {
            key: 0,
            class: Y([Vt(a).e("title"), Vt(u)])
          }, [Qr(e.$slots, "title", {}, (()=>[$a(te(e.title), 1)]))], 2)) : za("v-if", !0), e.$slots.default || e.description ? (Ca(),
          _a("p", {
            key: 1,
            class: Y(Vt(a).e("description"))
          }, [Qr(e.$slots, "default", {}, (()=>[$a(te(e.description), 1)]))], 2)) : za("v-if", !0), e.closable ? (Ca(),
          _a(ba, {
            key: 2
          }, [e.closeText ? (Ca(),
            _a("div", {
              key: 0,
              class: Y([Vt(a).e("close-btn"), Vt(a).is("customed")]),
              onClick: c
            }, te(e.closeText), 3)) : (Ca(),
            Ra(Vt(sS), {
              key: 1,
              class: Y(Vt(a).e("close-btn")),
              onClick: c
            }, {
              default: Fn((()=>[ja(Vt(r))])),
              _: 1
            }, 8, ["class"]))], 64)) : za("v-if", !0)], 2)], 2), [[$s, i.value]])])),
        _: 3
      }, 8, ["name"]))
  }
}), [["__file", "alert.vue"]]))
  , fS = Symbol("formContextKey")
  , pS = Symbol("formItemContextKey")
  , hS = (e,t={})=>{
  const n = Ft(void 0)
    , r = t.prop ? n : Zy("size")
    , o = t.global ? n : (()=>{
      const e = jo($x, {});
      return yi((()=>Vt(e.size) || ""))
    }
  )()
    , a = t.form ? {
    size: void 0
  } : jo(fS, void 0)
    , i = t.formItem ? {
    size: void 0
  } : jo(pS, void 0);
  return yi((()=>r.value || Vt(e) || (null == i ? void 0 : i.size) || (null == a ? void 0 : a.size) || o.value || ""))
}
  , vS = e=>{
  const t = Zy("disabled")
    , n = jo(fS, void 0);
  return yi((()=>t.value || Vt(e) || (null == n ? void 0 : n.disabled) || !1))
}
  , gS = ()=>({
  form: jo(fS, void 0),
  formItem: jo(pS, void 0)
})
  , mS = (e,{formItemContext: t, disableIdGeneration: n, disableIdManagement: r})=>{
  n || (n = Ft(!1)),
  r || (r = Ft(!1));
  const o = Ft();
  let a;
  const i = yi((()=>{
      var n;
      return !!(!e.label && t && t.inputIds && (null == (n = t.inputIds) ? void 0 : n.length) <= 1)
    }
  ));
  return Lr((()=>{
      a = Jn([Yt(e, "id"), n], (([e,n])=>{
          const a = null != e ? e : n ? void 0 : Cw().value;
          a !== o.value && ((null == t ? void 0 : t.removeInputId) && (o.value && t.removeInputId(o.value),
          (null == r ? void 0 : r.value) || n || !a || t.addInputId(a)),
            o.value = a)
        }
      ), {
        immediate: !0
      })
    }
  )),
    Br((()=>{
        a && a(),
        (null == t ? void 0 : t.removeInputId) && o.value && t.removeInputId(o.value)
      }
    )),
    {
      isLabeledByFormItem: i,
      inputId: o
    }
}
  , yS = uy({
  size: {
    type: String,
    values: Cy
  },
  disabled: Boolean
})
  , bS = uy({
  ...yS,
  model: Object,
  rules: {
    type: Object
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top"],
    default: "right"
  },
  requireAsteriskPosition: {
    type: String,
    values: ["left", "right"],
    default: "left"
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: !0
  },
  validateOnRuleChange: {
    type: Boolean,
    default: !0
  },
  hideRequiredAsterisk: Boolean,
  scrollToError: Boolean,
  scrollIntoViewOptions: {
    type: [Object, Boolean]
  }
})
  , wS = {
  validate: (e,t,n)=>(h(e) || b(e)) && jg(t) && b(n)
};
function xS() {
  const e = Ft([])
    , t = yi((()=>{
      if (!e.value.length)
        return "0";
      const t = Math.max(...e.value);
      return t ? `${t}px` : ""
    }
  ));
  function n(n) {
    const r = e.value.indexOf(n);
    return -1 === r && t.value,
      r
  }
  return {
    autoLabelWidth: t,
    registerLabelWidth: function(t, r) {
      if (t && r) {
        const o = n(r);
        e.value.splice(o, 1, t)
      } else
        t && e.value.push(t)
    },
    deregisterLabelWidth: function(t) {
      const r = n(t);
      r > -1 && e.value.splice(r, 1)
    }
  }
}
const SS = (e,t)=>{
  const n = Gp(t);
  return n.length > 0 ? e.filter((e=>e.prop && n.includes(e.prop))) : e
}
  , ES = vr({
  name: "ElForm"
})
  , AS = vr({
  ...ES,
  props: bS,
  emits: wS,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = []
      , a = hS()
      , i = qy("form")
      , s = yi((()=>{
          const {labelPosition: e, inline: t} = r;
          return [i.b(), i.m(a.value || "default"), {
            [i.m(`label-${e}`)]: e,
            [i.m("inline")]: t
          }]
        }
      ))
      , l = (e=[])=>{
        r.model && SS(o, e).forEach((e=>e.resetField()))
      }
      , u = (e=[])=>{
        SS(o, e).forEach((e=>e.clearValidate()))
      }
      , c = yi((()=>!!r.model))
      , d = async e=>p(void 0, e)
      , f = async(e=[])=>{
        if (!c.value)
          return !1;
        const t = (e=>{
            if (0 === o.length)
              return [];
            const t = SS(o, e);
            return t.length ? t : []
          }
        )(e);
        if (0 === t.length)
          return !0;
        let n = {};
        for (const o of t)
          try {
            await o.validate("")
          } catch (r) {
            n = {
              ...n,
              ...r
            }
          }
        return 0 === Object.keys(n).length || Promise.reject(n)
      }
      , p = async(e=[],t)=>{
        const n = !y(t);
        try {
          const n = await f(e);
          return !0 === n && (null == t || t(n)),
            n
        } catch (Y_) {
          if (Y_ instanceof Error)
            throw Y_;
          const o = Y_;
          return r.scrollToError && h(Object.keys(o)[0]),
          null == t || t(!1, o),
          n && Promise.reject(o)
        }
      }
      , h = e=>{
        var t;
        const n = SS(o, e)[0];
        n && (null == (t = n.$el) || t.scrollIntoView(r.scrollIntoViewOptions))
      }
    ;
    return Jn((()=>r.rules), (()=>{
        r.validateOnRuleChange && d().catch((e=>{}
        ))
      }
    ), {
      deep: !0
    }),
      Mo(fS, bt({
        ...Wt(r),
        emit: n,
        resetFields: l,
        clearValidate: u,
        validateField: p,
        getField: e=>o.find((t=>t.prop === e)),
        addField: e=>{
          o.push(e)
        }
        ,
        removeField: e=>{
          e.prop && o.splice(o.indexOf(e), 1)
        }
        ,
        ...xS()
      })),
      t({
        validate: d,
        validateField: p,
        resetFields: l,
        clearValidate: u,
        scrollToField: h
      }),
      (e,t)=>(Ca(),
        _a("form", {
          class: Y(Vt(s))
        }, [Qr(e.$slots, "default")], 2))
  }
});
var CS = tS(AS, [["__file", "form.vue"]]);
function kS() {
  return kS = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
    }
    return e
  }
    ,
    kS.apply(this, arguments)
}
function TS(e) {
  return (TS = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
      return e.__proto__ || Object.getPrototypeOf(e)
    }
  )(e)
}
function DS(e, t) {
  return (DS = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
      return e.__proto__ = t,
        e
    }
  )(e, t)
}
function OS(e, t, n) {
  return OS = function() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return !1;
    if (Reflect.construct.sham)
      return !1;
    if ("function" == typeof Proxy)
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
      ))),
        !0
    } catch (Y_) {
      return !1
    }
  }() ? Reflect.construct.bind() : function(e, t, n) {
    var r = [null];
    r.push.apply(r, t);
    var o = new (Function.bind.apply(e, r));
    return n && DS(o, n.prototype),
      o
  }
    ,
    OS.apply(null, arguments)
}
function _S(e) {
  var t = "function" == typeof Map ? new Map : void 0;
  return _S = function(e) {
    if (null === e || (n = e,
    -1 === Function.toString.call(n).indexOf("[native code]")))
      return e;
    var n;
    if ("function" != typeof e)
      throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== t) {
      if (t.has(e))
        return t.get(e);
      t.set(e, r)
    }
    function r() {
      return OS(e, arguments, TS(this).constructor)
    }
    return r.prototype = Object.create(e.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }),
      DS(r, e)
  }
    ,
    _S(e)
}
var RS = /%[sdj%]/g
  , LS = function() {};
function IS(e) {
  if (!e || !e.length)
    return null;
  var t = {};
  return e.forEach((function(e) {
      var n = e.field;
      t[n] = t[n] || [],
        t[n].push(e)
    }
  )),
    t
}
function PS(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var o = 0
    , a = n.length;
  return "function" == typeof e ? e.apply(null, n) : "string" == typeof e ? e.replace(RS, (function(e) {
      if ("%%" === e)
        return "%";
      if (o >= a)
        return e;
      switch (e) {
        case "%s":
          return String(n[o++]);
        case "%d":
          return Number(n[o++]);
        case "%j":
          try {
            return JSON.stringify(n[o++])
          } catch (t) {
            return "[Circular]"
          }
          break;
        default:
          return e
      }
    }
  )) : e
}
function FS(e, t) {
  return null == e || (!("array" !== t || !Array.isArray(e) || e.length) || !(!function(e) {
    return "string" === e || "url" === e || "hex" === e || "email" === e || "date" === e || "pattern" === e
  }(t) || "string" != typeof e || e))
}
function BS(e, t, n) {
  var r = 0
    , o = e.length;
  !function a(i) {
    if (i && i.length)
      n(i);
    else {
      var s = r;
      r += 1,
        s < o ? t(e[s], a) : n([])
    }
  }([])
}
"undefined" != typeof process && process.env;
var NS = function(e) {
  var t, n;
  function r(t, n) {
    var r;
    return (r = e.call(this, "Async Validation Error") || this).errors = t,
      r.fields = n,
      r
  }
  return n = e,
    (t = r).prototype = Object.create(n.prototype),
    t.prototype.constructor = t,
    DS(t, n),
    r
}(_S(Error));
function MS(e, t, n, r, o) {
  if (t.first) {
    var a = new Promise((function(t, a) {
        var i = function(e) {
          var t = [];
          return Object.keys(e).forEach((function(n) {
              t.push.apply(t, e[n] || [])
            }
          )),
            t
        }(e);
        BS(i, n, (function(e) {
            return r(e),
              e.length ? a(new NS(e,IS(e))) : t(o)
          }
        ))
      }
    ));
    return a.catch((function(e) {
        return e
      }
    )),
      a
  }
  var i = !0 === t.firstFields ? Object.keys(e) : t.firstFields || []
    , s = Object.keys(e)
    , l = s.length
    , u = 0
    , c = []
    , d = new Promise((function(t, a) {
      var d = function(e) {
        if (c.push.apply(c, e),
        ++u === l)
          return r(c),
            c.length ? a(new NS(c,IS(c))) : t(o)
      };
      s.length || (r(c),
        t(o)),
        s.forEach((function(t) {
            var r = e[t];
            -1 !== i.indexOf(t) ? BS(r, n, d) : function(e, t, n) {
              var r = []
                , o = 0
                , a = e.length;
              function i(e) {
                r.push.apply(r, e || []),
                ++o === a && n(r)
              }
              e.forEach((function(e) {
                  t(e, i)
                }
              ))
            }(r, n, d)
          }
        ))
    }
  ));
  return d.catch((function(e) {
      return e
    }
  )),
    d
}
function jS(e, t) {
  return function(n) {
    var r, o;
    return r = e.fullFields ? function(e, t) {
      for (var n = e, r = 0; r < t.length; r++) {
        if (null == n)
          return n;
        n = n[t[r]]
      }
      return n
    }(t, e.fullFields) : t[n.field || e.fullField],
      (o = n) && void 0 !== o.message ? (n.field = n.field || e.fullField,
        n.fieldValue = r,
        n) : {
        message: "function" == typeof n ? n() : n,
        fieldValue: r,
        field: n.field || e.fullField
      }
  }
}
function VS(e, t) {
  if (t)
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var r = t[n];
        "object" == typeof r && "object" == typeof e[n] ? e[n] = kS({}, e[n], r) : e[n] = r
      }
  return e
}
var US, $S = function(e, t, n, r, o, a) {
  !e.required || n.hasOwnProperty(e.field) && !FS(t, a || e.type) || r.push(PS(o.messages.required, e.fullField))
}, HS = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/, zS = /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i, KS = {
  integer: function(e) {
    return KS.number(e) && parseInt(e, 10) === e
  },
  float: function(e) {
    return KS.number(e) && !KS.integer(e)
  },
  array: function(e) {
    return Array.isArray(e)
  },
  regexp: function(e) {
    if (e instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(e)
    } catch (Y_) {
      return !1
    }
  },
  date: function(e) {
    return "function" == typeof e.getTime && "function" == typeof e.getMonth && "function" == typeof e.getYear && !isNaN(e.getTime())
  },
  number: function(e) {
    return !isNaN(e) && "number" == typeof e
  },
  object: function(e) {
    return "object" == typeof e && !KS.array(e)
  },
  method: function(e) {
    return "function" == typeof e
  },
  email: function(e) {
    return "string" == typeof e && e.length <= 320 && !!e.match(HS)
  },
  url: function(e) {
    return "string" == typeof e && e.length <= 2048 && !!e.match(function() {
      if (US)
        return US;
      var e = "[a-fA-F\\d:]"
        , t = function(t) {
        return t && t.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : ""
      }
        , n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}"
        , r = "[a-fA-F\\d]{1,4}"
        , o = ("\n(?:\n(?:" + r + ":){7}(?:" + r + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + r + ":){6}(?:" + n + "|:" + r + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + r + ":){5}(?::" + n + "|(?::" + r + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + r + ":){4}(?:(?::" + r + "){0,1}:" + n + "|(?::" + r + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + r + ":){3}(?:(?::" + r + "){0,2}:" + n + "|(?::" + r + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + r + ":){2}(?:(?::" + r + "){0,3}:" + n + "|(?::" + r + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + r + ":){1}(?:(?::" + r + "){0,4}:" + n + "|(?::" + r + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + r + "){0,5}:" + n + "|(?::" + r + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim()
        , a = new RegExp("(?:^" + n + "$)|(?:^" + o + "$)")
        , i = new RegExp("^" + n + "$")
        , s = new RegExp("^" + o + "$")
        , l = function(e) {
        return e && e.exact ? a : new RegExp("(?:" + t(e) + n + t(e) + ")|(?:" + t(e) + o + t(e) + ")","g")
      };
      l.v4 = function(e) {
        return e && e.exact ? i : new RegExp("" + t(e) + n + t(e),"g")
      }
        ,
        l.v6 = function(e) {
          return e && e.exact ? s : new RegExp("" + t(e) + o + t(e),"g")
        }
      ;
      var u = l.v4().source
        , c = l.v6().source;
      return US = new RegExp("(?:^(?:(?:(?:[a-z]+:)?//)|www\\.)(?:\\S+(?::\\S*)?@)?(?:localhost|" + u + "|" + c + '|(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:[/?#][^\\s"]*)?$)',"i")
    }())
  },
  hex: function(e) {
    return "string" == typeof e && !!e.match(zS)
  }
}, WS = "enum", GS = {
  required: $S,
  whitespace: function(e, t, n, r, o) {
    (/^\s+$/.test(t) || "" === t) && r.push(PS(o.messages.whitespace, e.fullField))
  },
  type: function(e, t, n, r, o) {
    if (e.required && void 0 === t)
      $S(e, t, n, r, o);
    else {
      var a = e.type;
      ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"].indexOf(a) > -1 ? KS[a](t) || r.push(PS(o.messages.types[a], e.fullField, e.type)) : a && typeof t !== e.type && r.push(PS(o.messages.types[a], e.fullField, e.type))
    }
  },
  range: function(e, t, n, r, o) {
    var a = "number" == typeof e.len
      , i = "number" == typeof e.min
      , s = "number" == typeof e.max
      , l = t
      , u = null
      , c = "number" == typeof t
      , d = "string" == typeof t
      , f = Array.isArray(t);
    if (c ? u = "number" : d ? u = "string" : f && (u = "array"),
      !u)
      return !1;
    f && (l = t.length),
    d && (l = t.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length),
      a ? l !== e.len && r.push(PS(o.messages[u].len, e.fullField, e.len)) : i && !s && l < e.min ? r.push(PS(o.messages[u].min, e.fullField, e.min)) : s && !i && l > e.max ? r.push(PS(o.messages[u].max, e.fullField, e.max)) : i && s && (l < e.min || l > e.max) && r.push(PS(o.messages[u].range, e.fullField, e.min, e.max))
  },
  enum: function(e, t, n, r, o) {
    e[WS] = Array.isArray(e[WS]) ? e[WS] : [],
    -1 === e[WS].indexOf(t) && r.push(PS(o.messages[WS], e.fullField, e[WS].join(", ")))
  },
  pattern: function(e, t, n, r, o) {
    if (e.pattern)
      if (e.pattern instanceof RegExp)
        e.pattern.lastIndex = 0,
        e.pattern.test(t) || r.push(PS(o.messages.pattern.mismatch, e.fullField, t, e.pattern));
      else if ("string" == typeof e.pattern) {
        new RegExp(e.pattern).test(t) || r.push(PS(o.messages.pattern.mismatch, e.fullField, t, e.pattern))
      }
  }
}, qS = function(e, t, n, r, o) {
  var a = e.type
    , i = [];
  if (e.required || !e.required && r.hasOwnProperty(e.field)) {
    if (FS(t, a) && !e.required)
      return n();
    GS.required(e, t, r, i, o, a),
    FS(t, a) || GS.type(e, t, r, i, o)
  }
  n(i)
}, YS = {
  string: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t, "string") && !e.required)
        return n();
      GS.required(e, t, r, a, o, "string"),
      FS(t, "string") || (GS.type(e, t, r, a, o),
        GS.range(e, t, r, a, o),
        GS.pattern(e, t, r, a, o),
      !0 === e.whitespace && GS.whitespace(e, t, r, a, o))
    }
    n(a)
  },
  method: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t) && !e.required)
        return n();
      GS.required(e, t, r, a, o),
      void 0 !== t && GS.type(e, t, r, a, o)
    }
    n(a)
  },
  number: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if ("" === t && (t = void 0),
      FS(t) && !e.required)
        return n();
      GS.required(e, t, r, a, o),
      void 0 !== t && (GS.type(e, t, r, a, o),
        GS.range(e, t, r, a, o))
    }
    n(a)
  },
  boolean: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t) && !e.required)
        return n();
      GS.required(e, t, r, a, o),
      void 0 !== t && GS.type(e, t, r, a, o)
    }
    n(a)
  },
  regexp: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t) && !e.required)
        return n();
      GS.required(e, t, r, a, o),
      FS(t) || GS.type(e, t, r, a, o)
    }
    n(a)
  },
  integer: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t) && !e.required)
        return n();
      GS.required(e, t, r, a, o),
      void 0 !== t && (GS.type(e, t, r, a, o),
        GS.range(e, t, r, a, o))
    }
    n(a)
  },
  float: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t) && !e.required)
        return n();
      GS.required(e, t, r, a, o),
      void 0 !== t && (GS.type(e, t, r, a, o),
        GS.range(e, t, r, a, o))
    }
    n(a)
  },
  array: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (null == t && !e.required)
        return n();
      GS.required(e, t, r, a, o, "array"),
      null != t && (GS.type(e, t, r, a, o),
        GS.range(e, t, r, a, o))
    }
    n(a)
  },
  object: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t) && !e.required)
        return n();
      GS.required(e, t, r, a, o),
      void 0 !== t && GS.type(e, t, r, a, o)
    }
    n(a)
  },
  enum: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t) && !e.required)
        return n();
      GS.required(e, t, r, a, o),
      void 0 !== t && GS.enum(e, t, r, a, o)
    }
    n(a)
  },
  pattern: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t, "string") && !e.required)
        return n();
      GS.required(e, t, r, a, o),
      FS(t, "string") || GS.pattern(e, t, r, a, o)
    }
    n(a)
  },
  date: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t, "date") && !e.required)
        return n();
      var i;
      if (GS.required(e, t, r, a, o),
        !FS(t, "date"))
        i = t instanceof Date ? t : new Date(t),
          GS.type(e, i, r, a, o),
        i && GS.range(e, i.getTime(), r, a, o)
    }
    n(a)
  },
  url: qS,
  hex: qS,
  email: qS,
  required: function(e, t, n, r, o) {
    var a = []
      , i = Array.isArray(t) ? "array" : typeof t;
    GS.required(e, t, r, a, o, i),
      n(a)
  },
  any: function(e, t, n, r, o) {
    var a = [];
    if (e.required || !e.required && r.hasOwnProperty(e.field)) {
      if (FS(t) && !e.required)
        return n();
      GS.required(e, t, r, a, o)
    }
    n(a)
  }
};
function XS() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var e = JSON.parse(JSON.stringify(this));
      return e.clone = this.clone,
        e
    }
  }
}
var QS = XS()
  , JS = function() {
  function e(e) {
    this.rules = null,
      this._messages = QS,
      this.define(e)
  }
  var t = e.prototype;
  return t.define = function(e) {
    var t = this;
    if (!e)
      throw new Error("Cannot configure a schema with no rules");
    if ("object" != typeof e || Array.isArray(e))
      throw new Error("Rules must be an object");
    this.rules = {},
      Object.keys(e).forEach((function(n) {
          var r = e[n];
          t.rules[n] = Array.isArray(r) ? r : [r]
        }
      ))
  }
    ,
    t.messages = function(e) {
      return e && (this._messages = VS(XS(), e)),
        this._messages
    }
    ,
    t.validate = function(t, n, r) {
      var o = this;
      void 0 === n && (n = {}),
      void 0 === r && (r = function() {}
      );
      var a = t
        , i = n
        , s = r;
      if ("function" == typeof i && (s = i,
        i = {}),
      !this.rules || 0 === Object.keys(this.rules).length)
        return s && s(null, a),
          Promise.resolve(a);
      if (i.messages) {
        var l = this.messages();
        l === QS && (l = XS()),
          VS(l, i.messages),
          i.messages = l
      } else
        i.messages = this.messages();
      var u = {};
      (i.keys || Object.keys(this.rules)).forEach((function(e) {
          var n = o.rules[e]
            , r = a[e];
          n.forEach((function(n) {
              var i = n;
              "function" == typeof i.transform && (a === t && (a = kS({}, a)),
                r = a[e] = i.transform(r)),
                (i = "function" == typeof i ? {
                  validator: i
                } : kS({}, i)).validator = o.getValidationMethod(i),
              i.validator && (i.field = e,
                i.fullField = i.fullField || e,
                i.type = o.getType(i),
                u[e] = u[e] || [],
                u[e].push({
                  rule: i,
                  value: r,
                  source: a,
                  field: e
                }))
            }
          ))
        }
      ));
      var c = {};
      return MS(u, i, (function(t, n) {
          var r, o = t.rule, s = !("object" !== o.type && "array" !== o.type || "object" != typeof o.fields && "object" != typeof o.defaultField);
          function l(e, t) {
            return kS({}, t, {
              fullField: o.fullField + "." + e,
              fullFields: o.fullFields ? [].concat(o.fullFields, [e]) : [e]
            })
          }
          function u(r) {
            void 0 === r && (r = []);
            var u = Array.isArray(r) ? r : [r];
            !i.suppressWarning && u.length && e.warning("async-validator:", u),
            u.length && void 0 !== o.message && (u = [].concat(o.message));
            var d = u.map(jS(o, a));
            if (i.first && d.length)
              return c[o.field] = 1,
                n(d);
            if (s) {
              if (o.required && !t.value)
                return void 0 !== o.message ? d = [].concat(o.message).map(jS(o, a)) : i.error && (d = [i.error(o, PS(i.messages.required, o.field))]),
                  n(d);
              var f = {};
              o.defaultField && Object.keys(t.value).map((function(e) {
                  f[e] = o.defaultField
                }
              )),
                f = kS({}, f, t.rule.fields);
              var p = {};
              Object.keys(f).forEach((function(e) {
                  var t = f[e]
                    , n = Array.isArray(t) ? t : [t];
                  p[e] = n.map(l.bind(null, e))
                }
              ));
              var h = new e(p);
              h.messages(i.messages),
              t.rule.options && (t.rule.options.messages = i.messages,
                t.rule.options.error = i.error),
                h.validate(t.value, t.rule.options || i, (function(e) {
                    var t = [];
                    d && d.length && t.push.apply(t, d),
                    e && e.length && t.push.apply(t, e),
                      n(t.length ? t : null)
                  }
                ))
            } else
              n(d)
          }
          if (s = s && (o.required || !o.required && t.value),
            o.field = t.field,
            o.asyncValidator)
            r = o.asyncValidator(o, t.value, u, t.source, i);
          else if (o.validator) {
            try {
              r = o.validator(o, t.value, u, t.source, i)
            } catch (d) {
              null == console.error || console.error(d),
              i.suppressValidatorError || setTimeout((function() {
                  throw d
                }
              ), 0),
                u(d.message)
            }
            !0 === r ? u() : !1 === r ? u("function" == typeof o.message ? o.message(o.fullField || o.field) : o.message || (o.fullField || o.field) + " fails") : r instanceof Array ? u(r) : r instanceof Error && u(r.message)
          }
          r && r.then && r.then((function() {
              return u()
            }
          ), (function(e) {
              return u(e)
            }
          ))
        }
      ), (function(e) {
          !function(e) {
            for (var t, n, r = [], o = {}, i = 0; i < e.length; i++)
              t = e[i],
                n = void 0,
                Array.isArray(t) ? r = (n = r).concat.apply(n, t) : r.push(t);
            r.length ? (o = IS(r),
              s(r, o)) : s(null, a)
          }(e)
        }
      ), a)
    }
    ,
    t.getType = function(e) {
      if (void 0 === e.type && e.pattern instanceof RegExp && (e.type = "pattern"),
      "function" != typeof e.validator && e.type && !YS.hasOwnProperty(e.type))
        throw new Error(PS("Unknown rule type %s", e.type));
      return e.type || "string"
    }
    ,
    t.getValidationMethod = function(e) {
      if ("function" == typeof e.validator)
        return e.validator;
      var t = Object.keys(e)
        , n = t.indexOf("message");
      return -1 !== n && t.splice(n, 1),
        1 === t.length && "required" === t[0] ? YS.required : YS[this.getType(e)] || void 0
    }
    ,
    e
}();
JS.register = function(e, t) {
  if ("function" != typeof t)
    throw new Error("Cannot register a validator by type, validator is not a function");
  YS[e] = t
}
  ,
  JS.warning = LS,
  JS.messages = QS,
  JS.validators = YS;
const ZS = uy({
  label: String,
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  prop: {
    type: [String, Array]
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: [Object, Array]
  },
  error: String,
  validateStatus: {
    type: String,
    values: ["", "error", "validating", "success"]
  },
  for: String,
  inlineMessage: {
    type: [String, Boolean],
    default: ""
  },
  showMessage: {
    type: Boolean,
    default: !0
  },
  size: {
    type: String,
    values: Cy
  }
})
  , eE = "ElLabelWrap";
var tE = vr({
  name: eE,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(e, {slots: t}) {
    const n = jo(fS, void 0)
      , r = jo(pS);
    r || Jg(eE, "usage: <el-form-item><label-wrap /></el-form-item>");
    const o = qy("form")
      , a = Ft()
      , i = Ft(0)
      , s = (r="update")=>{
      hn((()=>{
          t.default && e.isAutoWidth && ("update" === r ? i.value = (()=>{
              var e;
              if (null == (e = a.value) ? void 0 : e.firstElementChild) {
                const e = window.getComputedStyle(a.value.firstElementChild).width;
                return Math.ceil(Number.parseFloat(e))
              }
              return 0
            }
          )() : "remove" === r && (null == n || n.deregisterLabelWidth(i.value)))
        }
      ))
    }
      , l = ()=>s("update");
    return Lr((()=>{
        l()
      }
    )),
      Fr((()=>{
          s("remove")
        }
      )),
      Pr((()=>l())),
      Jn(i, ((t,r)=>{
          e.updateAll && (null == n || n.registerLabelWidth(t, r))
        }
      )),
      Uc(yi((()=>{
          var e, t;
          return null != (t = null == (e = a.value) ? void 0 : e.firstElementChild) ? t : null
        }
      )), l),
      ()=>{
        var s, l;
        if (!t)
          return null;
        const {isAutoWidth: u} = e;
        if (u) {
          const e = null == n ? void 0 : n.autoLabelWidth
            , l = {};
          if ((null == r ? void 0 : r.hasLabel) && e && "auto" !== e) {
            const t = Math.max(0, Number.parseInt(e, 10) - i.value)
              , r = "left" === n.labelPosition ? "marginRight" : "marginLeft";
            t && (l[r] = `${t}px`)
          }
          return ja("div", {
            ref: a,
            class: [o.be("item", "label-wrap")],
            style: l
          }, [null == (s = t.default) ? void 0 : s.call(t)])
        }
        return ja(ba, {
          ref: a
        }, [null == (l = t.default) ? void 0 : l.call(t)])
      }
  }
});
const nE = ["role", "aria-labelledby"]
  , rE = vr({
  name: "ElFormItem"
})
  , oE = vr({
  ...rE,
  props: ZS,
  setup(e, {expose: t}) {
    const n = e
      , r = po()
      , o = jo(fS, void 0)
      , a = jo(pS, void 0)
      , i = hS(void 0, {
      formItem: !1
    })
      , s = qy("form-item")
      , l = Cw().value
      , u = Ft([])
      , c = Ft("")
      , d = function(e, t=200, n={}) {
      const r = Ft(e.value)
        , o = Ac((()=>{
          r.value = e.value
        }
      ), t, n);
      return Jn(e, (()=>o())),
        r
    }(c, 100)
      , f = Ft("")
      , p = Ft();
    let h, v = !1;
    const g = yi((()=>{
          if ("top" === (null == o ? void 0 : o.labelPosition))
            return {};
          const e = om(n.labelWidth || (null == o ? void 0 : o.labelWidth) || "");
          return e ? {
            width: e
          } : {}
        }
      ))
      , m = yi((()=>{
          if ("top" === (null == o ? void 0 : o.labelPosition) || (null == o ? void 0 : o.inline))
            return {};
          if (!n.label && !n.labelWidth && T)
            return {};
          const e = om(n.labelWidth || (null == o ? void 0 : o.labelWidth) || "");
          return n.label || r.label ? {} : {
            marginLeft: e
          }
        }
      ))
      , w = yi((()=>[s.b(), s.m(i.value), s.is("error", "error" === c.value), s.is("validating", "validating" === c.value), s.is("success", "success" === c.value), s.is("required", R.value || n.required), s.is("no-asterisk", null == o ? void 0 : o.hideRequiredAsterisk), "right" === (null == o ? void 0 : o.requireAsteriskPosition) ? "asterisk-right" : "asterisk-left", {
        [s.m("feedback")]: null == o ? void 0 : o.statusIcon
      }]))
      , x = yi((()=>jg(n.inlineMessage) ? n.inlineMessage : (null == o ? void 0 : o.inlineMessage) || !1))
      , S = yi((()=>[s.e("error"), {
        [s.em("error", "inline")]: x.value
      }]))
      , E = yi((()=>n.prop ? b(n.prop) ? n.prop : n.prop.join(".") : ""))
      , A = yi((()=>!(!n.label && !r.label)))
      , C = yi((()=>n.for || (1 === u.value.length ? u.value[0] : void 0)))
      , k = yi((()=>!C.value && A.value))
      , T = !!a
      , D = yi((()=>{
          const e = null == o ? void 0 : o.model;
          if (e && n.prop)
            return Xg(e, n.prop).value
        }
      ))
      , O = yi((()=>{
          const {required: e} = n
            , t = [];
          n.rules && t.push(...Gp(n.rules));
          const r = null == o ? void 0 : o.rules;
          if (r && n.prop) {
            const e = Xg(r, n.prop).value;
            e && t.push(...Gp(e))
          }
          if (void 0 !== e) {
            const n = t.map(((e,t)=>[e, t])).filter((([e])=>Object.keys(e).includes("required")));
            if (n.length > 0)
              for (const [r,o] of n)
                r.required !== e && (t[o] = {
                  ...r,
                  required: e
                });
            else
              t.push({
                required: e
              })
          }
          return t
        }
      ))
      , _ = yi((()=>O.value.length > 0))
      , R = yi((()=>O.value.some((e=>e.required))))
      , L = yi((()=>{
          var e;
          return "error" === d.value && n.showMessage && (null == (e = null == o ? void 0 : o.showMessage) || e)
        }
      ))
      , I = yi((()=>`${n.label || ""}${(null == o ? void 0 : o.labelSuffix) || ""}`))
      , P = e=>{
        c.value = e
      }
      , F = async e=>{
        const t = E.value;
        return new JS({
          [t]: e
        }).validate({
          [t]: D.value
        }, {
          firstFields: !0
        }).then((()=>(P("success"),
        null == o || o.emit("validate", n.prop, !0, ""),
          !0))).catch((e=>((e=>{
            var t, r;
            const {errors: a, fields: i} = e;
            a && i || console.error(e),
              P("error"),
              f.value = a ? null != (r = null == (t = null == a ? void 0 : a[0]) ? void 0 : t.message) ? r : `${n.prop} is required` : "",
            null == o || o.emit("validate", n.prop, !1, f.value)
          }
        )(e),
          Promise.reject(e))))
      }
      , B = async(e,t)=>{
        if (v || !n.prop)
          return !1;
        const r = y(t);
        if (!_.value)
          return null == t || t(!1),
            !1;
        const o = (e=>O.value.filter((t=>!t.trigger || !e || (Array.isArray(t.trigger) ? t.trigger.includes(e) : t.trigger === e))).map((({trigger: e, ...t})=>t)))(e);
        return 0 === o.length ? (null == t || t(!0),
          !0) : (P("validating"),
          F(o).then((()=>(null == t || t(!0),
            !0))).catch((e=>{
              const {fields: n} = e;
              return null == t || t(!1, n),
              !r && Promise.reject(n)
            }
          )))
      }
      , N = ()=>{
        P(""),
          f.value = "",
          v = !1
      }
      , M = async()=>{
        const e = null == o ? void 0 : o.model;
        if (!e || !n.prop)
          return;
        const t = Xg(e, n.prop);
        v = !0,
          t.value = cv(h),
          await hn(),
          N(),
          v = !1
      }
    ;
    Jn((()=>n.error), (e=>{
        f.value = e || "",
          P(e ? "error" : "")
      }
    ), {
      immediate: !0
    }),
      Jn((()=>n.validateStatus), (e=>P(e || "")));
    const j = bt({
      ...Wt(n),
      $el: p,
      size: i,
      validateState: c,
      labelId: l,
      inputIds: u,
      isGroup: k,
      hasLabel: A,
      fieldValue: D,
      addInputId: e=>{
        u.value.includes(e) || u.value.push(e)
      }
      ,
      removeInputId: e=>{
        u.value = u.value.filter((t=>t !== e))
      }
      ,
      resetField: M,
      clearValidate: N,
      validate: B
    });
    return Mo(pS, j),
      Lr((()=>{
          n.prop && (null == o || o.addField(j),
            h = cv(D.value))
        }
      )),
      Fr((()=>{
          null == o || o.removeField(j)
        }
      )),
      t({
        size: i,
        validateMessage: f,
        validateState: c,
        validate: B,
        clearValidate: N,
        resetField: M
      }),
      (e,t)=>{
        var n;
        return Ca(),
          _a("div", {
            ref_key: "formItemRef",
            ref: p,
            class: Y(Vt(w)),
            role: Vt(k) ? "group" : void 0,
            "aria-labelledby": Vt(k) ? Vt(l) : void 0
          }, [ja(Vt(tE), {
            "is-auto-width": "auto" === Vt(g).width,
            "update-all": "auto" === (null == (n = Vt(o)) ? void 0 : n.labelWidth)
          }, {
            default: Fn((()=>[Vt(A) ? (Ca(),
              Ra(Kr(Vt(C) ? "label" : "div"), {
                key: 0,
                id: Vt(l),
                for: Vt(C),
                class: Y(Vt(s).e("label")),
                style: z(Vt(g))
              }, {
                default: Fn((()=>[Qr(e.$slots, "label", {
                  label: Vt(I)
                }, (()=>[$a(te(Vt(I)), 1)]))])),
                _: 3
              }, 8, ["id", "for", "class", "style"])) : za("v-if", !0)])),
            _: 3
          }, 8, ["is-auto-width", "update-all"]), Ma("div", {
            class: Y(Vt(s).e("content")),
            style: z(Vt(m))
          }, [Qr(e.$slots, "default"), ja(bs, {
            name: `${Vt(s).namespace.value}-zoom-in-top`
          }, {
            default: Fn((()=>[Vt(L) ? Qr(e.$slots, "error", {
              key: 0,
              error: f.value
            }, (()=>[Ma("div", {
              class: Y(Vt(S))
            }, te(f.value), 3)])) : za("v-if", !0)])),
            _: 3
          }, 8, ["name"])], 6)], 10, nE)
      }
  }
});
var aE = tS(oE, [["__file", "form-item.vue"]]);
const iE = vy(CS, {
  FormItem: aE
})
  , sE = my(aE);
let lE;
const uE = `\n  height:0 !important;\n  visibility:hidden !important;\n  ${td() ? "" : "overflow:hidden !important;"}\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n`
  , cE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing"];
function dE(e, t=1, n) {
  var r;
  lE || (lE = document.createElement("textarea"),
    document.body.appendChild(lE));
  const {paddingSize: o, borderSize: a, boxSizing: i, contextStyle: s} = function(e) {
    const t = window.getComputedStyle(e)
      , n = t.getPropertyValue("box-sizing")
      , r = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top"))
      , o = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width"));
    return {
      contextStyle: cE.map((e=>`${e}:${t.getPropertyValue(e)}`)).join(";"),
      paddingSize: r,
      borderSize: o,
      boxSizing: n
    }
  }(e);
  lE.setAttribute("style", `${s};${uE}`),
    lE.value = e.value || e.placeholder || "";
  let l = lE.scrollHeight;
  const u = {};
  "border-box" === i ? l += a : "content-box" === i && (l -= o),
    lE.value = "";
  const c = lE.scrollHeight - o;
  if (Vg(t)) {
    let e = c * t;
    "border-box" === i && (e = e + o + a),
      l = Math.max(e, l),
      u.minHeight = `${e}px`
  }
  if (Vg(n)) {
    let e = c * n;
    "border-box" === i && (e = e + o + a),
      l = Math.min(e, l)
  }
  return u.height = `${l}px`,
  null == (r = lE.parentNode) || r.removeChild(lE),
    lE = void 0,
    u
}
const fE = uy({
  id: {
    type: String,
    default: void 0
  },
  size: Ux,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Object],
    default: ""
  },
  maxlength: {
    type: [String, Number]
  },
  minlength: {
    type: [String, Number]
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: [Boolean, Object],
    default: !1
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  showPassword: {
    type: Boolean,
    default: !1
  },
  showWordLimit: {
    type: Boolean,
    default: !1
  },
  suffixIcon: {
    type: cy
  },
  prefixIcon: {
    type: cy
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: [Object, Array, String],
    default: ()=>({})
  },
  autofocus: {
    type: Boolean,
    default: !1
  }
})
  , pE = {
  [xy]: e=>b(e),
  input: e=>b(e),
  change: e=>b(e),
  focus: e=>e instanceof FocusEvent,
  blur: e=>e instanceof FocusEvent,
  clear: ()=>!0,
  mouseleave: e=>e instanceof MouseEvent,
  mouseenter: e=>e instanceof MouseEvent,
  keydown: e=>e instanceof Event,
  compositionstart: e=>e instanceof CompositionEvent,
  compositionupdate: e=>e instanceof CompositionEvent,
  compositionend: e=>e instanceof CompositionEvent
}
  , hE = ["role"]
  , vE = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"]
  , gE = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"]
  , mE = vr({
  name: "ElInput",
  inheritAttrs: !1
});
const yE = vy(tS(vr({
  ...mE,
  props: fE,
  emits: pE,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = ho()
      , i = po()
      , s = yi((()=>{
        const e = {};
        return "combobox" === r.containerRole && (e["aria-haspopup"] = o["aria-haspopup"],
          e["aria-owns"] = o["aria-owns"],
          e["aria-expanded"] = o["aria-expanded"]),
          e
      }
    ))
      , l = yi((()=>["textarea" === r.type ? m.b() : g.b(), g.m(h.value), g.is("disabled", v.value), g.is("exceed", $.value), {
      [g.b("group")]: i.prepend || i.append,
      [g.bm("group", "append")]: i.append,
      [g.bm("group", "prepend")]: i.prepend,
      [g.m("prefix")]: i.prefix || r.prefixIcon,
      [g.m("suffix")]: i.suffix || r.suffixIcon || r.clearable || r.showPassword,
      [g.bm("suffix", "password-clear")]: M.value && j.value,
      [g.b("hidden")]: "hidden" === r.type
    }, o.class]))
      , u = yi((()=>[g.e("wrapper"), g.is("focus", D.value)]))
      , c = By({
      excludeKeys: yi((()=>Object.keys(s.value)))
    })
      , {form: d, formItem: f} = gS()
      , {inputId: p} = mS(r, {
      formItemContext: f
    })
      , h = hS()
      , v = vS()
      , g = qy("input")
      , m = qy("textarea")
      , y = Bt()
      , b = Bt()
      , w = Ft(!1)
      , S = Ft(!1)
      , E = Ft(!1)
      , A = Ft()
      , C = Bt(r.inputStyle)
      , k = yi((()=>y.value || b.value))
      , {wrapperRef: T, isFocused: D, handleFocus: O, handleBlur: _} = Hx(k, {
      afterBlur() {
        var e;
        r.validateEvent && (null == (e = null == f ? void 0 : f.validate) || e.call(f, "blur").catch((e=>{}
        )))
      }
    })
      , R = yi((()=>{
        var e;
        return null != (e = null == d ? void 0 : d.statusIcon) && e
      }
    ))
      , L = yi((()=>(null == f ? void 0 : f.validateState) || ""))
      , I = yi((()=>L.value && hy[L.value]))
      , P = yi((()=>E.value ? ry : Bm))
      , F = yi((()=>[o.style]))
      , B = yi((()=>[r.inputStyle, C.value, {
      resize: r.resize
    }]))
      , N = yi((()=>Cg(r.modelValue) ? "" : String(r.modelValue)))
      , M = yi((()=>r.clearable && !v.value && !r.readonly && !!N.value && (D.value || w.value)))
      , j = yi((()=>r.showPassword && !v.value && !r.readonly && !!N.value && (!!N.value || D.value)))
      , V = yi((()=>r.showWordLimit && !!r.maxlength && ("text" === r.type || "textarea" === r.type) && !v.value && !r.readonly && !r.showPassword))
      , U = yi((()=>N.value.length))
      , $ = yi((()=>!!V.value && U.value > Number(r.maxlength)))
      , H = yi((()=>!!i.suffix || !!r.suffixIcon || M.value || r.showPassword || V.value || !!L.value && R.value))
      , [K,W] = function(e) {
      const t = Ft();
      return [function() {
        if (null == e.value)
          return;
        const {selectionStart: n, selectionEnd: r, value: o} = e.value;
        if (null == n || null == r)
          return;
        const a = o.slice(0, Math.max(0, n))
          , i = o.slice(Math.max(0, r));
        t.value = {
          selectionStart: n,
          selectionEnd: r,
          value: o,
          beforeTxt: a,
          afterTxt: i
        }
      }
        , function() {
          if (null == e.value || null == t.value)
            return;
          const {value: n} = e.value
            , {beforeTxt: r, afterTxt: o, selectionStart: a} = t.value;
          if (null == r || null == o || null == a)
            return;
          let i = n.length;
          if (n.endsWith(o))
            i = n.length - o.length;
          else if (n.startsWith(r))
            i = r.length;
          else {
            const e = r[a - 1]
              , t = n.indexOf(e, a - 1);
            -1 !== t && (i = t + 1)
          }
          e.value.setSelectionRange(i, i)
        }
      ]
    }(y);
    Uc(b, (e=>{
        if (q(),
        !V.value || "both" !== r.resize)
          return;
        const t = e[0]
          , {width: n} = t.contentRect;
        A.value = {
          right: `calc(100% - ${n + 15 + 6}px)`
        }
      }
    ));
    const G = ()=>{
        const {type: e, autosize: t} = r;
        if (mc && "textarea" === e && b.value)
          if (t) {
            const e = x(t) ? t.minRows : void 0
              , n = x(t) ? t.maxRows : void 0
              , r = dE(b.value, e, n);
            C.value = {
              overflowY: "hidden",
              ...r
            },
              hn((()=>{
                  b.value.offsetHeight,
                    C.value = r
                }
              ))
          } else
            C.value = {
              minHeight: dE(b.value).minHeight
            }
      }
      , q = (e=>{
          let t = !1;
          return ()=>{
            var n;
            if (t || !r.autosize)
              return;
            null === (null == (n = b.value) ? void 0 : n.offsetParent) || (e(),
              t = !0)
          }
        }
      )(G)
      , X = ()=>{
        const e = k.value
          , t = r.formatter ? r.formatter(N.value) : N.value;
        e && e.value !== t && (e.value = t)
      }
      , Q = async e=>{
        K();
        let {value: t} = e.target;
        r.formatter && (t = r.parser ? r.parser(t) : t),
        S.value || (t !== N.value ? (n(xy, t),
          n("input", t),
          await hn(),
          X(),
          W()) : X())
      }
      , J = e=>{
        n("change", e.target.value)
      }
      , Z = e=>{
        n("compositionstart", e),
          S.value = !0
      }
      , ee = e=>{
        var t;
        n("compositionupdate", e);
        const r = null == (t = e.target) ? void 0 : t.value
          , o = r[r.length - 1] || "";
        S.value = !Iy(o)
      }
      , ne = e=>{
        n("compositionend", e),
        S.value && (S.value = !1,
          Q(e))
      }
      , re = ()=>{
        E.value = !E.value,
          oe()
      }
      , oe = async()=>{
        var e;
        await hn(),
        null == (e = k.value) || e.focus()
      }
      , ae = e=>{
        w.value = !1,
          n("mouseleave", e)
      }
      , ie = e=>{
        w.value = !0,
          n("mouseenter", e)
      }
      , se = e=>{
        n("keydown", e)
      }
      , le = ()=>{
        n(xy, ""),
          n("change", ""),
          n("clear"),
          n("input", "")
      }
    ;
    return Jn((()=>r.modelValue), (()=>{
        var e;
        hn((()=>G())),
        r.validateEvent && (null == (e = null == f ? void 0 : f.validate) || e.call(f, "change").catch((e=>{}
        )))
      }
    )),
      Jn(N, (()=>X())),
      Jn((()=>r.type), (async()=>{
          await hn(),
            X(),
            G()
        }
      )),
      Lr((()=>{
          !r.formatter && r.parser,
            X(),
            hn(G)
        }
      )),
      t({
        input: y,
        textarea: b,
        ref: k,
        textareaStyle: B,
        autosize: Yt(r, "autosize"),
        focus: oe,
        blur: ()=>{
          var e;
          return null == (e = k.value) ? void 0 : e.blur()
        }
        ,
        select: ()=>{
          var e;
          null == (e = k.value) || e.select()
        }
        ,
        clear: le,
        resizeTextarea: G
      }),
      (e,t)=>(Ca(),
        _a("div", qa(Vt(s), {
          class: Vt(l),
          style: Vt(F),
          role: e.containerRole,
          onMouseenter: ie,
          onMouseleave: ae
        }), [za(" input "), "textarea" !== e.type ? (Ca(),
          _a(ba, {
            key: 0
          }, [za(" prepend slot "), e.$slots.prepend ? (Ca(),
            _a("div", {
              key: 0,
              class: Y(Vt(g).be("group", "prepend"))
            }, [Qr(e.$slots, "prepend")], 2)) : za("v-if", !0), Ma("div", {
            ref_key: "wrapperRef",
            ref: T,
            class: Y(Vt(u))
          }, [za(" prefix slot "), e.$slots.prefix || e.prefixIcon ? (Ca(),
            _a("span", {
              key: 0,
              class: Y(Vt(g).e("prefix"))
            }, [Ma("span", {
              class: Y(Vt(g).e("prefix-inner"))
            }, [Qr(e.$slots, "prefix"), e.prefixIcon ? (Ca(),
              Ra(Vt(sS), {
                key: 0,
                class: Y(Vt(g).e("icon"))
              }, {
                default: Fn((()=>[(Ca(),
                  Ra(Kr(e.prefixIcon)))])),
                _: 1
              }, 8, ["class"])) : za("v-if", !0)], 2)], 2)) : za("v-if", !0), Ma("input", qa({
            id: Vt(p),
            ref_key: "input",
            ref: y,
            class: Vt(g).e("inner")
          }, Vt(c), {
            minlength: e.minlength,
            maxlength: e.maxlength,
            type: e.showPassword ? E.value ? "text" : "password" : e.type,
            disabled: Vt(v),
            readonly: e.readonly,
            autocomplete: e.autocomplete,
            tabindex: e.tabindex,
            "aria-label": e.label,
            placeholder: e.placeholder,
            style: e.inputStyle,
            form: e.form,
            autofocus: e.autofocus,
            onCompositionstart: Z,
            onCompositionupdate: ee,
            onCompositionend: ne,
            onInput: Q,
            onFocus: t[0] || (t[0] = (...e)=>Vt(O) && Vt(O)(...e)),
            onBlur: t[1] || (t[1] = (...e)=>Vt(_) && Vt(_)(...e)),
            onChange: J,
            onKeydown: se
          }), null, 16, vE), za(" suffix slot "), Vt(H) ? (Ca(),
            _a("span", {
              key: 1,
              class: Y(Vt(g).e("suffix"))
            }, [Ma("span", {
              class: Y(Vt(g).e("suffix-inner"))
            }, [Vt(M) && Vt(j) && Vt(V) ? za("v-if", !0) : (Ca(),
              _a(ba, {
                key: 0
              }, [Qr(e.$slots, "suffix"), e.suffixIcon ? (Ca(),
                Ra(Vt(sS), {
                  key: 0,
                  class: Y(Vt(g).e("icon"))
                }, {
                  default: Fn((()=>[(Ca(),
                    Ra(Kr(e.suffixIcon)))])),
                  _: 1
                }, 8, ["class"])) : za("v-if", !0)], 64)), Vt(M) ? (Ca(),
              Ra(Vt(sS), {
                key: 1,
                class: Y([Vt(g).e("icon"), Vt(g).e("clear")]),
                onMousedown: js(Vt(a), ["prevent"]),
                onClick: le
              }, {
                default: Fn((()=>[ja(Vt(km))])),
                _: 1
              }, 8, ["class", "onMousedown"])) : za("v-if", !0), Vt(j) ? (Ca(),
              Ra(Vt(sS), {
                key: 2,
                class: Y([Vt(g).e("icon"), Vt(g).e("password")]),
                onClick: re
              }, {
                default: Fn((()=>[(Ca(),
                  Ra(Kr(Vt(P))))])),
                _: 1
              }, 8, ["class"])) : za("v-if", !0), Vt(V) ? (Ca(),
              _a("span", {
                key: 3,
                class: Y(Vt(g).e("count"))
              }, [Ma("span", {
                class: Y(Vt(g).e("count-inner"))
              }, te(Vt(U)) + " / " + te(e.maxlength), 3)], 2)) : za("v-if", !0), Vt(L) && Vt(I) && Vt(R) ? (Ca(),
              Ra(Vt(sS), {
                key: 4,
                class: Y([Vt(g).e("icon"), Vt(g).e("validateIcon"), Vt(g).is("loading", "validating" === Vt(L))])
              }, {
                default: Fn((()=>[(Ca(),
                  Ra(Kr(Vt(I))))])),
                _: 1
              }, 8, ["class"])) : za("v-if", !0)], 2)], 2)) : za("v-if", !0)], 2), za(" append slot "), e.$slots.append ? (Ca(),
            _a("div", {
              key: 1,
              class: Y(Vt(g).be("group", "append"))
            }, [Qr(e.$slots, "append")], 2)) : za("v-if", !0)], 64)) : (Ca(),
          _a(ba, {
            key: 1
          }, [za(" textarea "), Ma("textarea", qa({
            id: Vt(p),
            ref_key: "textarea",
            ref: b,
            class: Vt(m).e("inner")
          }, Vt(c), {
            minlength: e.minlength,
            maxlength: e.maxlength,
            tabindex: e.tabindex,
            disabled: Vt(v),
            readonly: e.readonly,
            autocomplete: e.autocomplete,
            style: Vt(B),
            "aria-label": e.label,
            placeholder: e.placeholder,
            form: e.form,
            autofocus: e.autofocus,
            onCompositionstart: Z,
            onCompositionupdate: ee,
            onCompositionend: ne,
            onInput: Q,
            onFocus: t[2] || (t[2] = (...e)=>Vt(O) && Vt(O)(...e)),
            onBlur: t[3] || (t[3] = (...e)=>Vt(_) && Vt(_)(...e)),
            onChange: J,
            onKeydown: se
          }), null, 16, gE), Vt(V) ? (Ca(),
            _a("span", {
              key: 0,
              style: z(A.value),
              class: Y(Vt(g).e("count"))
            }, te(Vt(U)) + " / " + te(e.maxlength), 7)) : za("v-if", !0)], 64))], 16, hE))
  }
}), [["__file", "input.vue"]]))
  , bE = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}
  , wE = Symbol("scrollbarContextKey")
  , xE = uy({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: !0
  },
  always: Boolean
})
  , SE = vr({
  __name: "thumb",
  props: xE,
  setup(e) {
    const t = e
      , n = jo(wE)
      , r = qy("scrollbar");
    n || Jg("Thumb", "can not inject scrollbar context");
    const o = Ft()
      , a = Ft()
      , i = Ft({})
      , s = Ft(!1);
    let l = !1
      , u = !1
      , c = mc ? document.onselectstart : null;
    const d = yi((()=>bE[t.vertical ? "vertical" : "horizontal"]))
      , f = yi((()=>(({move: e, size: t, bar: n})=>({
        [n.size]: t,
        transform: `translate${n.axis}(${e}%)`
      }))({
        size: t.size,
        move: t.move,
        bar: d.value
      })))
      , p = yi((()=>o.value[d.value.offset] ** 2 / n.wrapElement[d.value.scrollSize] / t.ratio / a.value[d.value.offset]))
      , h = e=>{
        var t;
        if (e.stopPropagation(),
        e.ctrlKey || [1, 2].includes(e.button))
          return;
        null == (t = window.getSelection()) || t.removeAllRanges(),
          g(e);
        const n = e.currentTarget;
        n && (i.value[d.value.axis] = n[d.value.offset] - (e[d.value.client] - n.getBoundingClientRect()[d.value.direction]))
      }
      , v = e=>{
        if (!a.value || !o.value || !n.wrapElement)
          return;
        const t = 100 * (Math.abs(e.target.getBoundingClientRect()[d.value.direction] - e[d.value.client]) - a.value[d.value.offset] / 2) * p.value / o.value[d.value.offset];
        n.wrapElement[d.value.scroll] = t * n.wrapElement[d.value.scrollSize] / 100
      }
      , g = e=>{
        e.stopImmediatePropagation(),
          l = !0,
          document.addEventListener("mousemove", m),
          document.addEventListener("mouseup", y),
          c = document.onselectstart,
          document.onselectstart = ()=>!1
      }
      , m = e=>{
        if (!o.value || !a.value)
          return;
        if (!1 === l)
          return;
        const t = i.value[d.value.axis];
        if (!t)
          return;
        const r = 100 * (-1 * (o.value.getBoundingClientRect()[d.value.direction] - e[d.value.client]) - (a.value[d.value.offset] - t)) * p.value / o.value[d.value.offset];
        n.wrapElement[d.value.scroll] = r * n.wrapElement[d.value.scrollSize] / 100
      }
      , y = ()=>{
        l = !1,
          i.value[d.value.axis] = 0,
          document.removeEventListener("mousemove", m),
          document.removeEventListener("mouseup", y),
          b(),
        u && (s.value = !1)
      }
    ;
    Fr((()=>{
        b(),
          document.removeEventListener("mouseup", y)
      }
    ));
    const b = ()=>{
        document.onselectstart !== c && (document.onselectstart = c)
      }
    ;
    return Rc(Yt(n, "scrollbarElement"), "mousemove", (()=>{
        u = !1,
          s.value = !!t.size
      }
    )),
      Rc(Yt(n, "scrollbarElement"), "mouseleave", (()=>{
          u = !0,
            s.value = l
        }
      )),
      (e,t)=>(Ca(),
        Ra(es, {
          name: Vt(r).b("fade"),
          persisted: ""
        }, {
          default: Fn((()=>[rr(Ma("div", {
            ref_key: "instance",
            ref: o,
            class: Y([Vt(r).e("bar"), Vt(r).is(Vt(d).key)]),
            onMousedown: v
          }, [Ma("div", {
            ref_key: "thumb",
            ref: a,
            class: Y(Vt(r).e("thumb")),
            style: z(Vt(f)),
            onMousedown: h
          }, null, 38)], 34), [[$s, e.always || s.value]])])),
          _: 1
        }, 8, ["name"]))
  }
});
var EE = tS(SE, [["__file", "thumb.vue"]]);
var AE = tS(vr({
  __name: "bar",
  props: uy({
    always: {
      type: Boolean,
      default: !0
    },
    minSize: {
      type: Number,
      required: !0
    }
  }),
  setup(e, {expose: t}) {
    const n = e
      , r = jo(wE)
      , o = Ft(0)
      , a = Ft(0)
      , i = Ft("")
      , s = Ft("")
      , l = Ft(1)
      , u = Ft(1);
    return t({
      handleScroll: e=>{
        if (e) {
          const t = e.offsetHeight - 4
            , n = e.offsetWidth - 4;
          a.value = 100 * e.scrollTop / t * l.value,
            o.value = 100 * e.scrollLeft / n * u.value
        }
      }
      ,
      update: ()=>{
        const e = null == r ? void 0 : r.wrapElement;
        if (!e)
          return;
        const t = e.offsetHeight - 4
          , o = e.offsetWidth - 4
          , a = t ** 2 / e.scrollHeight
          , c = o ** 2 / e.scrollWidth
          , d = Math.max(a, n.minSize)
          , f = Math.max(c, n.minSize);
        l.value = a / (t - a) / (d / (t - d)),
          u.value = c / (o - c) / (f / (o - f)),
          s.value = d + 4 < t ? `${d}px` : "",
          i.value = f + 4 < o ? `${f}px` : ""
      }
    }),
      (e,t)=>(Ca(),
        _a(ba, null, [ja(EE, {
          move: o.value,
          ratio: u.value,
          size: i.value,
          always: e.always
        }, null, 8, ["move", "ratio", "size", "always"]), ja(EE, {
          move: a.value,
          ratio: l.value,
          size: s.value,
          vertical: "",
          always: e.always
        }, null, 8, ["move", "ratio", "size", "always"])], 64))
  }
}), [["__file", "bar.vue"]]);
const CE = uy({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: !1
  },
  wrapStyle: {
    type: [String, Object, Array],
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  id: String,
  role: String,
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical"]
  }
})
  , kE = {
  scroll: ({scrollTop: e, scrollLeft: t})=>[e, t].every(Vg)
}
  , TE = vr({
  name: "ElScrollbar"
});
const DE = vy(tS(vr({
  ...TE,
  props: CE,
  emits: kE,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = qy("scrollbar");
    let a, i;
    const s = Ft()
      , l = Ft()
      , u = Ft()
      , c = Ft()
      , d = yi((()=>{
          const e = {};
          return r.height && (e.height = om(r.height)),
          r.maxHeight && (e.maxHeight = om(r.maxHeight)),
            [r.wrapStyle, e]
        }
      ))
      , f = yi((()=>[r.wrapClass, o.e("wrap"), {
        [o.em("wrap", "hidden-default")]: !r.native
      }]))
      , p = yi((()=>[o.e("view"), r.viewClass]))
      , h = ()=>{
        var e;
        l.value && (null == (e = c.value) || e.handleScroll(l.value),
          n("scroll", {
            scrollTop: l.value.scrollTop,
            scrollLeft: l.value.scrollLeft
          }))
      }
    ;
    const v = ()=>{
        var e;
        null == (e = c.value) || e.update()
      }
    ;
    return Jn((()=>r.noresize), (e=>{
        e ? (null == a || a(),
        null == i || i()) : (({stop: a} = Uc(u, v)),
          i = Rc("resize", v))
      }
    ), {
      immediate: !0
    }),
      Jn((()=>[r.maxHeight, r.height]), (()=>{
          r.native || hn((()=>{
              var e;
              v(),
              l.value && (null == (e = c.value) || e.handleScroll(l.value))
            }
          ))
        }
      )),
      Mo(wE, bt({
        scrollbarElement: s,
        wrapElement: l
      })),
      Lr((()=>{
          r.native || hn((()=>{
              v()
            }
          ))
        }
      )),
      Pr((()=>v())),
      t({
        wrapRef: l,
        update: v,
        scrollTo: function(e, t) {
          x(e) ? l.value.scrollTo(e) : Vg(e) && Vg(t) && l.value.scrollTo(e, t)
        },
        setScrollTop: e=>{
          Vg(e) && (l.value.scrollTop = e)
        }
        ,
        setScrollLeft: e=>{
          Vg(e) && (l.value.scrollLeft = e)
        }
        ,
        handleScroll: h
      }),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "scrollbarRef",
          ref: s,
          class: Y(Vt(o).b())
        }, [Ma("div", {
          ref_key: "wrapRef",
          ref: l,
          class: Y(Vt(f)),
          style: z(Vt(d)),
          onScroll: h
        }, [(Ca(),
          Ra(Kr(e.tag), {
            id: e.id,
            ref_key: "resizeRef",
            ref: u,
            class: Y(Vt(p)),
            style: z(e.viewStyle),
            role: e.role,
            "aria-label": e.ariaLabel,
            "aria-orientation": e.ariaOrientation
          }, {
            default: Fn((()=>[Qr(e.$slots, "default")])),
            _: 3
          }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))], 38), e.native ? za("v-if", !0) : (Ca(),
          Ra(AE, {
            key: 0,
            ref_key: "barRef",
            ref: c,
            always: e.always,
            "min-size": e.minSize
          }, null, 8, ["always", "min-size"]))], 2))
  }
}), [["__file", "scrollbar.vue"]]))
  , OE = Symbol("popper")
  , _E = Symbol("popperContent")
  , RE = uy({
  role: {
    type: String,
    values: ["dialog", "grid", "group", "listbox", "menu", "navigation", "tooltip", "tree"],
    default: "tooltip"
  }
})
  , LE = vr({
  name: "ElPopper",
  inheritAttrs: !1
});
var IE = tS(vr({
  ...LE,
  props: RE,
  setup(e, {expose: t}) {
    const n = e
      , r = {
      triggerRef: Ft(),
      popperInstanceRef: Ft(),
      contentRef: Ft(),
      referenceRef: Ft(),
      role: yi((()=>n.role))
    };
    return t(r),
      Mo(OE, r),
      (e,t)=>Qr(e.$slots, "default")
  }
}), [["__file", "popper.vue"]]);
const PE = uy({
  arrowOffset: {
    type: Number,
    default: 5
  }
})
  , FE = vr({
  name: "ElPopperArrow",
  inheritAttrs: !1
});
var BE = tS(vr({
  ...FE,
  props: PE,
  setup(e, {expose: t}) {
    const n = e
      , r = qy("popper")
      , {arrowOffset: o, arrowRef: a, arrowStyle: i} = jo(_E, void 0);
    return Jn((()=>n.arrowOffset), (e=>{
        o.value = e
      }
    )),
      Fr((()=>{
          a.value = void 0
        }
      )),
      t({
        arrowRef: a
      }),
      (e,t)=>(Ca(),
        _a("span", {
          ref_key: "arrowRef",
          ref: a,
          class: Y(Vt(r).e("arrow")),
          style: z(Vt(i)),
          "data-popper-arrow": ""
        }, null, 6))
  }
}), [["__file", "arrow.vue"]]);
const NE = vr({
  name: "ElOnlyChild",
  setup(e, {slots: t, attrs: n}) {
    var r;
    const o = jo(Lw)
      , i = (s = null != (r = null == o ? void 0 : o.setForwardRef) ? r : a,
      {
        mounted(e) {
          s(e)
        },
        updated(e) {
          s(e)
        },
        unmounted() {
          s(null)
        }
      });
    var s;
    return ()=>{
      var e;
      const r = null == (e = t.default) ? void 0 : e.call(t, n);
      if (!r)
        return null;
      if (r.length > 1)
        return null;
      const o = ME(r);
      return o ? rr(Ua(o, n), [[i]]) : null
    }
  }
});
function ME(e) {
  if (!e)
    return null;
  const t = e;
  for (const n of t) {
    if (x(n))
      switch (n.type) {
        case xa:
          continue;
        case wa:
        case "svg":
          return jE(n);
        case ba:
          return ME(n.children);
        default:
          return n
      }
    return jE(n)
  }
  return null
}
function jE(e) {
  const t = qy("only-child");
  return ja("span", {
    class: t.e("content")
  }, [e])
}
const VE = uy({
  virtualRef: {
    type: Object
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onClick: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  id: String,
  open: Boolean
})
  , UE = vr({
  name: "ElPopperTrigger",
  inheritAttrs: !1
});
var $E = tS(vr({
  ...UE,
  props: VE,
  setup(e, {expose: t}) {
    const n = e
      , {role: r, triggerRef: o} = jo(OE, void 0);
    var a;
    a = o,
      Mo(Lw, {
        setForwardRef: e=>{
          a.value = e
        }
      });
    const i = yi((()=>l.value ? n.id : void 0))
      , s = yi((()=>{
        if (r && "tooltip" === r.value)
          return n.open && n.id ? n.id : void 0
      }
    ))
      , l = yi((()=>{
        if (r && "tooltip" !== r.value)
          return r.value
      }
    ))
      , u = yi((()=>l.value ? `${n.open}` : void 0));
    let c;
    return Lr((()=>{
        Jn((()=>n.virtualRef), (e=>{
            e && (o.value = Dc(e))
          }
        ), {
          immediate: !0
        }),
          Jn(o, ((e,t)=>{
              null == c || c(),
                c = void 0,
              $g(e) && (["onMouseenter", "onMouseleave", "onClick", "onKeydown", "onFocus", "onBlur", "onContextmenu"].forEach((r=>{
                  var o;
                  const a = n[r];
                  a && (e.addEventListener(r.slice(2).toLowerCase(), a),
                  null == (o = null == t ? void 0 : t.removeEventListener) || o.call(t, r.slice(2).toLowerCase(), a))
                }
              )),
                c = Jn([i, s, l, u], (t=>{
                    ["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach(((n,r)=>{
                        Cg(t[r]) ? e.removeAttribute(n) : e.setAttribute(n, t[r])
                      }
                    ))
                  }
                ), {
                  immediate: !0
                })),
              $g(t) && ["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach((e=>t.removeAttribute(e)))
            }
          ), {
            immediate: !0
          })
      }
    )),
      Fr((()=>{
          null == c || c(),
            c = void 0
        }
      )),
      t({
        triggerRef: o
      }),
      (e,t)=>e.virtualTriggering ? za("v-if", !0) : (Ca(),
        Ra(Vt(NE), qa({
          key: 0
        }, e.$attrs, {
          "aria-controls": Vt(i),
          "aria-describedby": Vt(s),
          "aria-expanded": Vt(u),
          "aria-haspopup": Vt(l)
        }), {
          default: Fn((()=>[Qr(e.$slots, "default")])),
          _: 3
        }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]))
  }
}), [["__file", "trigger.vue"]]);
const HE = "focus-trap.focus-after-trapped"
  , zE = "focus-trap.focus-after-released"
  , KE = {
  cancelable: !0,
  bubbles: !1
}
  , WE = {
  cancelable: !0,
  bubbles: !1
}
  , GE = "focusAfterTrapped"
  , qE = "focusAfterReleased"
  , YE = Symbol("elFocusTrap")
  , XE = Ft()
  , QE = Ft(0)
  , JE = Ft(0);
let ZE = 0;
const eA = e=>{
    const t = []
      , n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: e=>{
        const t = "INPUT" === e.tagName && "hidden" === e.type;
        return e.disabled || e.hidden || t ? NodeFilter.FILTER_SKIP : e.tabIndex >= 0 || e === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      }
    });
    for (; n.nextNode(); )
      t.push(n.currentNode);
    return t
  }
  , tA = (e,t)=>{
    for (const n of e)
      if (!nA(n, t))
        return n
  }
  , nA = (e,t)=>{
    if ("hidden" === getComputedStyle(e).visibility)
      return !0;
    for (; e; ) {
      if (t && e === t)
        return !1;
      if ("none" === getComputedStyle(e).display)
        return !0;
      e = e.parentElement
    }
    return !1
  }
  , rA = (e,t)=>{
    if (e && e.focus) {
      const n = document.activeElement;
      e.focus({
        preventScroll: !0
      }),
        JE.value = window.performance.now(),
      e !== n && (e=>e instanceof HTMLInputElement && "select"in e)(e) && t && e.select()
    }
  }
;
function oA(e, t) {
  const n = [...e]
    , r = e.indexOf(t);
  return -1 !== r && n.splice(r, 1),
    n
}
const aA = (()=>{
    let e = [];
    return {
      push: t=>{
        const n = e[0];
        n && t !== n && n.pause(),
          e = oA(e, t),
          e.unshift(t)
      }
      ,
      remove: t=>{
        var n, r;
        e = oA(e, t),
        null == (r = null == (n = e[0]) ? void 0 : n.resume) || r.call(n)
      }
    }
  }
)()
  , iA = ()=>{
  XE.value = "pointer",
    QE.value = window.performance.now()
}
  , sA = ()=>{
  XE.value = "keyboard",
    QE.value = window.performance.now()
}
  , lA = e=>new CustomEvent("focus-trap.focusout-prevented",{
  ...WE,
  detail: e
})
  , uA = vr({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [GE, qE, "focusin", "focusout", "focusout-prevented", "release-requested"],
  setup(e, {emit: t}) {
    const n = Ft();
    let r, o;
    const {focusReason: a} = (Lr((()=>{
        0 === ZE && (document.addEventListener("mousedown", iA),
          document.addEventListener("touchstart", iA),
          document.addEventListener("keydown", sA)),
          ZE++
      }
    )),
      Fr((()=>{
          ZE--,
          ZE <= 0 && (document.removeEventListener("mousedown", iA),
            document.removeEventListener("touchstart", iA),
            document.removeEventListener("keydown", sA))
        }
      )),
      {
        focusReason: XE,
        lastUserFocusTimestamp: QE,
        lastAutomatedFocusTimestamp: JE
      });
    var i;
    i = n=>{
      e.trapped && !s.paused && t("release-requested", n)
    }
      ,
      Lr((()=>{
          0 === kw.length && document.addEventListener("keydown", Tw),
          mc && kw.push(i)
        }
      )),
      Fr((()=>{
          kw = kw.filter((e=>e !== i)),
          0 === kw.length && mc && document.removeEventListener("keydown", Tw)
        }
      ));
    const s = {
        paused: !1,
        pause() {
          this.paused = !0
        },
        resume() {
          this.paused = !1
        }
      }
      , l = n=>{
        if (!e.loop && !e.trapped)
          return;
        if (s.paused)
          return;
        const {key: r, altKey: o, ctrlKey: i, metaKey: l, currentTarget: u, shiftKey: c} = n
          , {loop: d} = e
          , f = r === by.tab && !o && !i && !l
          , p = document.activeElement;
        if (f && p) {
          const e = u
            , [r,o] = (e=>{
              const t = eA(e);
              return [tA(t, e), tA(t.reverse(), e)]
            }
          )(e);
          if (r && o)
            if (c || p !== o) {
              if (c && [r, e].includes(p)) {
                const e = lA({
                  focusReason: a.value
                });
                t("focusout-prevented", e),
                e.defaultPrevented || (n.preventDefault(),
                d && rA(o, !0))
              }
            } else {
              const e = lA({
                focusReason: a.value
              });
              t("focusout-prevented", e),
              e.defaultPrevented || (n.preventDefault(),
              d && rA(r, !0))
            }
          else if (p === e) {
            const e = lA({
              focusReason: a.value
            });
            t("focusout-prevented", e),
            e.defaultPrevented || n.preventDefault()
          }
        }
      }
    ;
    Mo(YE, {
      focusTrapRef: n,
      onKeydown: l
    }),
      Jn((()=>e.focusTrapEl), (e=>{
          e && (n.value = e)
        }
      ), {
        immediate: !0
      }),
      Jn([n], (([e],[t])=>{
          e && (e.addEventListener("keydown", l),
            e.addEventListener("focusin", d),
            e.addEventListener("focusout", f)),
          t && (t.removeEventListener("keydown", l),
            t.removeEventListener("focusin", d),
            t.removeEventListener("focusout", f))
        }
      ));
    const u = e=>{
        t(GE, e)
      }
      , c = e=>t(qE, e)
      , d = a=>{
        const i = Vt(n);
        if (!i)
          return;
        const l = a.target
          , u = a.relatedTarget
          , c = l && i.contains(l);
        if (!e.trapped) {
          u && i.contains(u) || (r = u)
        }
        c && t("focusin", a),
        s.paused || e.trapped && (c ? o = l : rA(o, !0))
      }
      , f = r=>{
        const i = Vt(n);
        if (!s.paused && i)
          if (e.trapped) {
            const n = r.relatedTarget;
            Cg(n) || i.contains(n) || setTimeout((()=>{
                if (!s.paused && e.trapped) {
                  const e = lA({
                    focusReason: a.value
                  });
                  t("focusout-prevented", e),
                  e.defaultPrevented || rA(o, !0)
                }
              }
            ), 0)
          } else {
            const e = r.target;
            e && i.contains(e) || t("focusout", r)
          }
      }
    ;
    async function p() {
      await hn();
      const t = Vt(n);
      if (t) {
        aA.push(s);
        const n = t.contains(document.activeElement) ? r : document.activeElement;
        r = n;
        if (!t.contains(n)) {
          const r = new Event(HE,KE);
          t.addEventListener(HE, u),
            t.dispatchEvent(r),
          r.defaultPrevented || hn((()=>{
              let r = e.focusStartEl;
              b(r) || (rA(r),
              document.activeElement !== r && (r = "first")),
              "first" === r && ((e,t=!1)=>{
                  const n = document.activeElement;
                  for (const r of e)
                    if (rA(r, t),
                    document.activeElement !== n)
                      return
                }
              )(eA(t), !0),
              document.activeElement !== n && "container" !== r || rA(t)
            }
          ))
        }
      }
    }
    function h() {
      const e = Vt(n);
      if (e) {
        e.removeEventListener(HE, u);
        const t = new CustomEvent(zE,{
          ...KE,
          detail: {
            focusReason: a.value
          }
        });
        e.addEventListener(zE, c),
          e.dispatchEvent(t),
        t.defaultPrevented || "keyboard" != a.value && QE.value > JE.value && !e.contains(document.activeElement) || rA(null != r ? r : document.body),
          e.removeEventListener(zE, c),
          aA.remove(s)
      }
    }
    return Lr((()=>{
        e.trapped && p(),
          Jn((()=>e.trapped), (e=>{
              e ? p() : h()
            }
          ))
      }
    )),
      Fr((()=>{
          e.trapped && h()
        }
      )),
      {
        onKeydown: l
      }
  }
});
var cA = tS(uA, [["render", function(e, t, n, r, o, a) {
  return Qr(e.$slots, "default", {
    handleKeydown: e.onKeydown
  })
}
], ["__file", "focus-trap.vue"]]);
const dA = uy({
    boundariesPadding: {
      type: Number,
      default: 0
    },
    fallbackPlacements: {
      type: Array,
      default: void 0
    },
    gpuAcceleration: {
      type: Boolean,
      default: !0
    },
    offset: {
      type: Number,
      default: 12
    },
    placement: {
      type: String,
      values: pb,
      default: "bottom"
    },
    popperOptions: {
      type: Object,
      default: ()=>({})
    },
    strategy: {
      type: String,
      values: ["fixed", "absolute"],
      default: "absolute"
    }
  })
  , fA = uy({
    ...dA,
    id: String,
    style: {
      type: [String, Array, Object]
    },
    className: {
      type: [String, Array, Object]
    },
    effect: {
      type: String,
      default: "dark"
    },
    visible: Boolean,
    enterable: {
      type: Boolean,
      default: !0
    },
    pure: Boolean,
    focusOnShow: {
      type: Boolean,
      default: !1
    },
    trapping: {
      type: Boolean,
      default: !1
    },
    popperClass: {
      type: [String, Array, Object]
    },
    popperStyle: {
      type: [String, Array, Object]
    },
    referenceEl: {
      type: Object
    },
    triggerTargetEl: {
      type: Object
    },
    stopPopperMouseEvent: {
      type: Boolean,
      default: !0
    },
    ariaLabel: {
      type: String,
      default: void 0
    },
    virtualTriggering: Boolean,
    zIndex: Number
  })
  , pA = {
    mouseenter: e=>e instanceof MouseEvent,
    mouseleave: e=>e instanceof MouseEvent,
    focus: ()=>!0,
    blur: ()=>!0,
    close: ()=>!0
  }
  , hA = (e,t=[])=>{
    const {placement: n, strategy: r, popperOptions: o} = e
      , a = {
      placement: n,
      strategy: r,
      ...o,
      modifiers: [...vA(e), ...t]
    };
    return function(e, t) {
      t && (e.modifiers = [...e.modifiers, ...null != t ? t : []])
    }(a, null == o ? void 0 : o.modifiers),
      a
  }
;
function vA(e) {
  const {offset: t, gpuAcceleration: n, fallbackPlacements: r} = e;
  return [{
    name: "offset",
    options: {
      offset: [0, null != t ? t : 12]
    }
  }, {
    name: "preventOverflow",
    options: {
      padding: {
        top: 2,
        bottom: 2,
        left: 5,
        right: 5
      }
    }
  }, {
    name: "flip",
    options: {
      padding: 5,
      fallbackPlacements: r
    }
  }, {
    name: "computeStyles",
    options: {
      gpuAcceleration: n
    }
  }]
}
const gA = e=>{
  const {popperInstanceRef: t, contentRef: n, triggerRef: r, role: o} = jo(OE, void 0)
    , a = Ft()
    , i = Ft()
    , s = yi((()=>({
    name: "eventListeners",
    enabled: !!e.visible
  })))
    , l = yi((()=>{
      var e;
      const t = Vt(a)
        , n = null != (e = Vt(i)) ? e : 0;
      return {
        name: "arrow",
        enabled: !kg(t),
        options: {
          element: t,
          padding: n
        }
      }
    }
  ))
    , u = yi((()=>({
    onFirstUpdate: ()=>{
      h()
    }
    ,
    ...hA(e, [Vt(l), Vt(s)])
  })))
    , c = yi((()=>(e=>{
      if (mc)
        return Dc(e)
    }
  )(e.referenceEl) || Vt(r)))
    , {attributes: d, state: f, styles: p, update: h, forceUpdate: v, instanceRef: g} = bw(c, n, u);
  return Jn(g, (e=>t.value = e)),
    Lr((()=>{
        Jn((()=>{
            var e;
            return null == (e = Vt(c)) ? void 0 : e.getBoundingClientRect()
          }
        ), (()=>{
            h()
          }
        ))
      }
    )),
    {
      attributes: d,
      arrowRef: a,
      contentRef: n,
      instanceRef: g,
      state: f,
      styles: p,
      role: o,
      forceUpdate: v,
      update: h
    }
}
  , mA = vr({
  name: "ElPopperContent"
})
  , yA = vr({
  ...mA,
  props: fA,
  emits: pA,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , {focusStartRef: o, trapped: i, onFocusAfterReleased: s, onFocusAfterTrapped: l, onFocusInTrap: u, onFocusoutPrevented: c, onReleaseRequested: d} = ((e,t)=>{
        const n = Ft(!1)
          , r = Ft();
        return {
          focusStartRef: r,
          trapped: n,
          onFocusAfterReleased: e=>{
            var n;
            "pointer" !== (null == (n = e.detail) ? void 0 : n.focusReason) && (r.value = "first",
              t("blur"))
          }
          ,
          onFocusAfterTrapped: ()=>{
            t("focus")
          }
          ,
          onFocusInTrap: t=>{
            e.visible && !n.value && (t.target && (r.value = t.target),
              n.value = !0)
          }
          ,
          onFocusoutPrevented: t=>{
            e.trapping || ("pointer" === t.detail.focusReason && t.preventDefault(),
              n.value = !1)
          }
          ,
          onReleaseRequested: ()=>{
            n.value = !1,
              t("close")
          }
        }
      }
    )(r, n)
      , {attributes: f, arrowRef: p, contentRef: h, styles: v, instanceRef: g, role: m, update: y} = gA(r)
      , {ariaModal: b, arrowStyle: w, contentAttrs: x, contentClass: S, contentStyle: E, updateZIndex: A} = ((e,{attributes: t, styles: n, role: r})=>{
        const {nextZIndex: o} = Bw()
          , a = qy("popper")
          , i = yi((()=>Vt(t).popper))
          , s = Ft(Vg(e.zIndex) ? e.zIndex : o())
          , l = yi((()=>[a.b(), a.is("pure", e.pure), a.is(e.effect), e.popperClass]))
          , u = yi((()=>[{
          zIndex: Vt(s)
        }, Vt(n).popper, e.popperStyle || {}]));
        return {
          ariaModal: yi((()=>"dialog" === r.value ? "false" : void 0)),
          arrowStyle: yi((()=>Vt(n).arrow || {})),
          contentAttrs: i,
          contentClass: l,
          contentStyle: u,
          contentZIndex: s,
          updateZIndex: ()=>{
            s.value = Vg(e.zIndex) ? e.zIndex : o()
          }
        }
      }
    )(r, {
      styles: v,
      attributes: f,
      role: m
    })
      , C = jo(pS, void 0)
      , k = Ft();
    let T;
    Mo(_E, {
      arrowStyle: w,
      arrowRef: p,
      arrowOffset: k
    }),
    C && (C.addInputId || C.removeInputId) && Mo(pS, {
      ...C,
      addInputId: a,
      removeInputId: a
    });
    const D = (e=!0)=>{
        y(),
        e && A()
      }
      , O = ()=>{
        D(!1),
          r.visible && r.focusOnShow ? i.value = !0 : !1 === r.visible && (i.value = !1)
      }
    ;
    return Lr((()=>{
        Jn((()=>r.triggerTargetEl), ((e,t)=>{
            null == T || T(),
              T = void 0;
            const n = Vt(e || h.value)
              , o = Vt(t || h.value);
            $g(n) && (T = Jn([m, ()=>r.ariaLabel, b, ()=>r.id], (e=>{
                ["role", "aria-label", "aria-modal", "id"].forEach(((t,r)=>{
                    Cg(e[r]) ? n.removeAttribute(t) : n.setAttribute(t, e[r])
                  }
                ))
              }
            ), {
              immediate: !0
            })),
            o !== n && $g(o) && ["role", "aria-label", "aria-modal", "id"].forEach((e=>{
                o.removeAttribute(e)
              }
            ))
          }
        ), {
          immediate: !0
        }),
          Jn((()=>r.visible), O, {
            immediate: !0
          })
      }
    )),
      Fr((()=>{
          null == T || T(),
            T = void 0
        }
      )),
      t({
        popperContentRef: h,
        popperInstanceRef: g,
        updatePopper: D,
        contentStyle: E
      }),
      (e,t)=>(Ca(),
        _a("div", qa({
          ref_key: "contentRef",
          ref: h
        }, Vt(x), {
          style: Vt(E),
          class: Vt(S),
          tabindex: "-1",
          onMouseenter: t[0] || (t[0] = t=>e.$emit("mouseenter", t)),
          onMouseleave: t[1] || (t[1] = t=>e.$emit("mouseleave", t))
        }), [ja(Vt(cA), {
          trapped: Vt(i),
          "trap-on-focus-in": !0,
          "focus-trap-el": Vt(h),
          "focus-start-el": Vt(o),
          onFocusAfterTrapped: Vt(l),
          onFocusAfterReleased: Vt(s),
          onFocusin: Vt(u),
          onFocusoutPrevented: Vt(c),
          onReleaseRequested: Vt(d)
        }, {
          default: Fn((()=>[Qr(e.$slots, "default")])),
          _: 3
        }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])], 16))
  }
});
var bA = tS(yA, [["__file", "content.vue"]]);
const wA = vy(IE)
  , xA = Symbol("elTooltip")
  , SA = uy({
  ...Rw,
  ...fA,
  appendTo: {
    type: [String, Object]
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: !1
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: Boolean,
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean
})
  , EA = uy({
  ...VE,
  disabled: Boolean,
  trigger: {
    type: [String, Array],
    default: "hover"
  },
  triggerKeys: {
    type: Array,
    default: ()=>[by.enter, by.space]
  }
})
  , {useModelToggleProps: AA, useModelToggleEmits: CA, useModelToggle: kA} = Jy("visible")
  , TA = uy({
  ...RE,
  ...AA,
  ...SA,
  ...EA,
  ...PE,
  showArrow: {
    type: Boolean,
    default: !0
  }
})
  , DA = [...CA, "before-show", "before-hide", "show", "hide", "open", "close"]
  , OA = (e,t,n)=>r=>{
  ((e,t)=>h(e) ? e.includes(t) : e === t)(Vt(e), t) && n(r)
}
  , _A = vr({
  name: "ElTooltipTrigger"
})
  , RA = vr({
  ..._A,
  props: EA,
  setup(e, {expose: t}) {
    const n = e
      , r = qy("tooltip")
      , {controlled: o, id: a, open: i, onOpen: s, onClose: l, onToggle: u} = jo(xA, void 0)
      , c = Ft(null)
      , d = ()=>{
      if (Vt(o) || n.disabled)
        return !0
    }
      , f = Yt(n, "trigger")
      , p = ic(d, OA(f, "hover", s))
      , h = ic(d, OA(f, "hover", l))
      , v = ic(d, OA(f, "click", (e=>{
        0 === e.button && u(e)
      }
    )))
      , g = ic(d, OA(f, "focus", s))
      , m = ic(d, OA(f, "focus", l))
      , y = ic(d, OA(f, "contextmenu", (e=>{
        e.preventDefault(),
          u(e)
      }
    )))
      , b = ic(d, (e=>{
        const {code: t} = e;
        n.triggerKeys.includes(t) && (e.preventDefault(),
          u(e))
      }
    ));
    return t({
      triggerRef: c
    }),
      (e,t)=>(Ca(),
        Ra(Vt($E), {
          id: Vt(a),
          "virtual-ref": e.virtualRef,
          open: Vt(i),
          "virtual-triggering": e.virtualTriggering,
          class: Y(Vt(r).e("trigger")),
          onBlur: Vt(m),
          onClick: Vt(v),
          onContextmenu: Vt(y),
          onFocus: Vt(g),
          onMouseenter: Vt(p),
          onMouseleave: Vt(h),
          onKeydown: Vt(b)
        }, {
          default: Fn((()=>[Qr(e.$slots, "default")])),
          _: 3
        }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]))
  }
});
var LA = tS(RA, [["__file", "trigger.vue"]]);
const IA = vr({
  name: "ElTooltipContent",
  inheritAttrs: !1
});
var PA = tS(vr({
  ...IA,
  props: SA,
  setup(e, {expose: t}) {
    const n = e
      , {selector: r} = Ow()
      , o = qy("tooltip")
      , a = Ft(null)
      , i = Ft(!1)
      , {controlled: s, id: l, open: u, trigger: c, onClose: d, onOpen: f, onShow: p, onHide: h, onBeforeShow: v, onBeforeHide: g} = jo(xA, void 0)
      , m = yi((()=>n.transition || `${o.namespace.value}-fade-in-linear`))
      , y = yi((()=>n.persistent));
    Fr((()=>{
        i.value = !0
      }
    ));
    const b = yi((()=>!!Vt(y) || Vt(u)))
      , w = yi((()=>!n.disabled && Vt(u)))
      , x = yi((()=>n.appendTo || r.value))
      , S = yi((()=>{
          var e;
          return null != (e = n.style) ? e : {}
        }
      ))
      , E = yi((()=>!Vt(u)))
      , A = ()=>{
        h()
      }
      , C = ()=>{
        if (Vt(s))
          return !0
      }
      , k = ic(C, (()=>{
          n.enterable && "hover" === Vt(c) && f()
        }
      ))
      , T = ic(C, (()=>{
          "hover" === Vt(c) && d()
        }
      ))
      , D = ()=>{
        var e, t;
        null == (t = null == (e = a.value) ? void 0 : e.updatePopper) || t.call(e),
        null == v || v()
      }
      , O = ()=>{
        null == g || g()
      }
      , _ = ()=>{
        p(),
          L = Ic(yi((()=>{
              var e;
              return null == (e = a.value) ? void 0 : e.popperContentRef
            }
          )), (()=>{
              if (Vt(s))
                return;
              "hover" !== Vt(c) && d()
            }
          ))
      }
      , R = ()=>{
        n.virtualTriggering || d()
      }
    ;
    let L;
    return Jn((()=>Vt(u)), (e=>{
        e || null == L || L()
      }
    ), {
      flush: "post"
    }),
      Jn((()=>n.content), (()=>{
          var e, t;
          null == (t = null == (e = a.value) ? void 0 : e.updatePopper) || t.call(e)
        }
      )),
      t({
        contentRef: a
      }),
      (e,t)=>(Ca(),
        Ra(ma, {
          disabled: !e.teleported,
          to: Vt(x)
        }, [ja(es, {
          name: Vt(m),
          onAfterLeave: A,
          onBeforeEnter: D,
          onAfterEnter: _,
          onBeforeLeave: O
        }, {
          default: Fn((()=>[Vt(b) ? rr((Ca(),
            Ra(Vt(bA), qa({
              key: 0,
              id: Vt(l),
              ref_key: "contentRef",
              ref: a
            }, e.$attrs, {
              "aria-label": e.ariaLabel,
              "aria-hidden": Vt(E),
              "boundaries-padding": e.boundariesPadding,
              "fallback-placements": e.fallbackPlacements,
              "gpu-acceleration": e.gpuAcceleration,
              offset: e.offset,
              placement: e.placement,
              "popper-options": e.popperOptions,
              strategy: e.strategy,
              effect: e.effect,
              enterable: e.enterable,
              pure: e.pure,
              "popper-class": e.popperClass,
              "popper-style": [e.popperStyle, Vt(S)],
              "reference-el": e.referenceEl,
              "trigger-target-el": e.triggerTargetEl,
              visible: Vt(w),
              "z-index": e.zIndex,
              onMouseenter: Vt(k),
              onMouseleave: Vt(T),
              onBlur: R,
              onClose: Vt(d)
            }), {
              default: Fn((()=>[i.value ? za("v-if", !0) : Qr(e.$slots, "default", {
                key: 0
              })])),
              _: 3
            }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [[$s, Vt(w)]]) : za("v-if", !0)])),
          _: 3
        }, 8, ["name"])], 8, ["disabled", "to"]))
  }
}), [["__file", "content.vue"]]);
const FA = ["innerHTML"]
  , BA = {
  key: 1
}
  , NA = vr({
  name: "ElTooltip"
});
const MA = vy(tS(vr({
  ...NA,
  props: TA,
  emits: DA,
  setup(e, {expose: t, emit: n}) {
    const r = e;
    _w();
    const o = Cw()
      , a = Ft()
      , i = Ft()
      , s = ()=>{
      var e;
      const t = Vt(a);
      t && (null == (e = t.popperInstanceRef) || e.update())
    }
      , l = Ft(!1)
      , u = Ft()
      , {show: c, hide: d, hasUpdateHandler: f} = kA({
      indicator: l,
      toggleReason: u
    })
      , {onOpen: p, onClose: h} = (({showAfter: e, hideAfter: t, autoClose: n, open: r, close: o})=>{
        const {registerTimeout: a} = xw()
          , {registerTimeout: i, cancelTimeout: s} = xw();
        return {
          onOpen: t=>{
            a((()=>{
                r(t);
                const e = Vt(n);
                Vg(e) && e > 0 && i((()=>{
                    o(t)
                  }
                ), e)
              }
            ), Vt(e))
          }
          ,
          onClose: e=>{
            s(),
              a((()=>{
                  o(e)
                }
              ), Vt(t))
          }
        }
      }
    )({
      showAfter: Yt(r, "showAfter"),
      hideAfter: Yt(r, "hideAfter"),
      autoClose: Yt(r, "autoClose"),
      open: c,
      close: d
    })
      , v = yi((()=>jg(r.visible) && !f.value));
    Mo(xA, {
      controlled: v,
      id: o,
      open: xt(l),
      trigger: Yt(r, "trigger"),
      onOpen: e=>{
        p(e)
      }
      ,
      onClose: e=>{
        h(e)
      }
      ,
      onToggle: e=>{
        Vt(l) ? h(e) : p(e)
      }
      ,
      onShow: ()=>{
        n("show", u.value)
      }
      ,
      onHide: ()=>{
        n("hide", u.value)
      }
      ,
      onBeforeShow: ()=>{
        n("before-show", u.value)
      }
      ,
      onBeforeHide: ()=>{
        n("before-hide", u.value)
      }
      ,
      updatePopper: s
    }),
      Jn((()=>r.disabled), (e=>{
          e && l.value && (l.value = !1)
        }
      ));
    return Ar((()=>l.value && d())),
      t({
        popperRef: a,
        contentRef: i,
        isFocusInsideContent: e=>{
          var t, n;
          const r = null == (n = null == (t = i.value) ? void 0 : t.contentRef) ? void 0 : n.popperContentRef
            , o = (null == e ? void 0 : e.relatedTarget) || document.activeElement;
          return r && r.contains(o)
        }
        ,
        updatePopper: s,
        onOpen: p,
        onClose: h,
        hide: d
      }),
      (e,t)=>(Ca(),
        Ra(Vt(wA), {
          ref_key: "popperRef",
          ref: a,
          role: e.role
        }, {
          default: Fn((()=>[ja(LA, {
            disabled: e.disabled,
            trigger: e.trigger,
            "trigger-keys": e.triggerKeys,
            "virtual-ref": e.virtualRef,
            "virtual-triggering": e.virtualTriggering
          }, {
            default: Fn((()=>[e.$slots.default ? Qr(e.$slots, "default", {
              key: 0
            }) : za("v-if", !0)])),
            _: 3
          }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]), ja(PA, {
            ref_key: "contentRef",
            ref: i,
            "aria-label": e.ariaLabel,
            "boundaries-padding": e.boundariesPadding,
            content: e.content,
            disabled: e.disabled,
            effect: e.effect,
            enterable: e.enterable,
            "fallback-placements": e.fallbackPlacements,
            "hide-after": e.hideAfter,
            "gpu-acceleration": e.gpuAcceleration,
            offset: e.offset,
            persistent: e.persistent,
            "popper-class": e.popperClass,
            "popper-style": e.popperStyle,
            placement: e.placement,
            "popper-options": e.popperOptions,
            pure: e.pure,
            "raw-content": e.rawContent,
            "reference-el": e.referenceEl,
            "trigger-target-el": e.triggerTargetEl,
            "show-after": e.showAfter,
            strategy: e.strategy,
            teleported: e.teleported,
            transition: e.transition,
            "virtual-triggering": e.virtualTriggering,
            "z-index": e.zIndex,
            "append-to": e.appendTo
          }, {
            default: Fn((()=>[Qr(e.$slots, "content", {}, (()=>[e.rawContent ? (Ca(),
              _a("span", {
                key: 0,
                innerHTML: e.content
              }, null, 8, FA)) : (Ca(),
              _a("span", BA, te(e.content), 1))])), e.showArrow ? (Ca(),
              Ra(Vt(BE), {
                key: 0,
                "arrow-offset": e.arrowOffset
              }, null, 8, ["arrow-offset"])) : za("v-if", !0)])),
            _: 3
          }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])])),
          _: 3
        }, 8, ["role"]))
  }
}), [["__file", "tooltip.vue"]]))
  , jA = uy({
  valueKey: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: [String, Number],
    default: ""
  },
  debounce: {
    type: Number,
    default: 300
  },
  placement: {
    type: String,
    values: ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end"],
    default: "bottom-start"
  },
  fetchSuggestions: {
    type: [Function, Array],
    default: a
  },
  popperClass: {
    type: String,
    default: ""
  },
  triggerOnFocus: {
    type: Boolean,
    default: !0
  },
  selectWhenUnmatched: {
    type: Boolean,
    default: !1
  },
  hideLoading: {
    type: Boolean,
    default: !1
  },
  label: {
    type: String
  },
  teleported: SA.teleported,
  highlightFirstItem: {
    type: Boolean,
    default: !1
  },
  fitInputWidth: {
    type: Boolean,
    default: !1
  },
  clearable: {
    type: Boolean,
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  name: String
})
  , VA = {
  [xy]: e=>b(e),
  [Ey]: e=>b(e),
  [Sy]: e=>b(e),
  focus: e=>e instanceof FocusEvent,
  blur: e=>e instanceof FocusEvent,
  clear: ()=>!0,
  select: e=>x(e)
}
  , UA = ["aria-expanded", "aria-owns"]
  , $A = {
  key: 0
}
  , HA = ["id", "aria-selected", "onClick"]
  , zA = "ElAutocomplete"
  , KA = vr({
  name: zA,
  inheritAttrs: !1
});
const WA = vy(tS(vr({
  ...KA,
  props: jA,
  emits: VA,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = By()
      , a = ho()
      , i = vS()
      , s = qy("autocomplete")
      , l = Ft()
      , u = Ft()
      , c = Ft()
      , d = Ft();
    let f = !1
      , p = !1;
    const v = Ft([])
      , g = Ft(-1)
      , m = Ft("")
      , y = Ft(!1)
      , b = Ft(!1)
      , w = Ft(!1)
      , x = Cw()
      , S = yi((()=>a.style))
      , E = yi((()=>(v.value.length > 0 || w.value) && y.value))
      , A = yi((()=>!r.hideLoading && w.value))
      , C = yi((()=>l.value ? Array.from(l.value.$el.querySelectorAll("input")) : []))
      , k = ()=>{
        E.value && (m.value = `${l.value.$el.offsetWidth}px`)
      }
      , T = ()=>{
        g.value = -1
      }
      , D = ug((async e=>{
          if (b.value)
            return;
          const t = e=>{
              w.value = !1,
              b.value || (h(e) ? (v.value = e,
                g.value = r.highlightFirstItem ? 0 : -1) : Jg(zA, "autocomplete suggestions must be an array"))
            }
          ;
          if (w.value = !0,
            h(r.fetchSuggestions))
            t(r.fetchSuggestions);
          else {
            const n = await r.fetchSuggestions(e, t);
            h(n) && t(n)
          }
        }
      ), r.debounce)
      , O = e=>{
        const t = !!e;
        if (n(Ey, e),
          n(xy, e),
          b.value = !1,
        y.value || (y.value = t),
        !r.triggerOnFocus && !e)
          return b.value = !0,
            void (v.value = []);
        D(e)
      }
      , _ = e=>{
        var t;
        i.value || ("INPUT" !== (null == (t = e.target) ? void 0 : t.tagName) || C.value.includes(document.activeElement)) && (y.value = !0)
      }
      , R = e=>{
        n(Sy, e)
      }
      , L = e=>{
        p ? p = !1 : (y.value = !0,
          n("focus", e),
        r.triggerOnFocus && !f && D(String(r.modelValue)))
      }
      , I = e=>{
        setTimeout((()=>{
            var t;
            (null == (t = c.value) ? void 0 : t.isFocusInsideContent()) ? p = !0 : (y.value && N(),
              n("blur", e))
          }
        ))
      }
      , P = ()=>{
        y.value = !1,
          n(xy, ""),
          n("clear")
      }
      , F = async()=>{
        E.value && g.value >= 0 && g.value < v.value.length ? M(v.value[g.value]) : r.selectWhenUnmatched && (n("select", {
          value: r.modelValue
        }),
          v.value = [],
          g.value = -1)
      }
      , B = e=>{
        E.value && (e.preventDefault(),
          e.stopPropagation(),
          N())
      }
      , N = ()=>{
        y.value = !1
      }
      , M = async e=>{
        n(Ey, e[r.valueKey]),
          n(xy, e[r.valueKey]),
          n("select", e),
          v.value = [],
          g.value = -1
      }
      , j = e=>{
        if (!E.value || w.value)
          return;
        if (e < 0)
          return void (g.value = -1);
        e >= v.value.length && (e = v.value.length - 1);
        const t = u.value.querySelector(`.${s.be("suggestion", "wrap")}`)
          , n = t.querySelectorAll(`.${s.be("suggestion", "list")} li`)[e]
          , r = t.scrollTop
          , {offsetTop: o, scrollHeight: a} = n;
        o + a > r + t.clientHeight && (t.scrollTop += a),
        o < r && (t.scrollTop -= a),
          g.value = e,
          l.value.ref.setAttribute("aria-activedescendant", `${x.value}-item-${g.value}`)
      }
    ;
    return Ic(d, (()=>{
        E.value && N()
      }
    )),
      Lr((()=>{
          l.value.ref.setAttribute("role", "textbox"),
            l.value.ref.setAttribute("aria-autocomplete", "list"),
            l.value.ref.setAttribute("aria-controls", "id"),
            l.value.ref.setAttribute("aria-activedescendant", `${x.value}-item-${g.value}`),
            f = l.value.ref.hasAttribute("readonly")
        }
      )),
      t({
        highlightedIndex: g,
        activated: y,
        loading: w,
        inputRef: l,
        popperRef: c,
        suggestions: v,
        handleSelect: M,
        handleKeyEnter: F,
        focus: ()=>{
          var e;
          null == (e = l.value) || e.focus()
        }
        ,
        blur: ()=>{
          var e;
          null == (e = l.value) || e.blur()
        }
        ,
        close: N,
        highlight: j
      }),
      (e,t)=>(Ca(),
        Ra(Vt(MA), {
          ref_key: "popperRef",
          ref: c,
          visible: Vt(E),
          placement: e.placement,
          "fallback-placements": ["bottom-start", "top-start"],
          "popper-class": [Vt(s).e("popper"), e.popperClass],
          teleported: e.teleported,
          "gpu-acceleration": !1,
          pure: "",
          "manual-mode": "",
          effect: "light",
          trigger: "click",
          transition: `${Vt(s).namespace.value}-zoom-in-top`,
          persistent: "",
          role: "listbox",
          onBeforeShow: k,
          onHide: T
        }, {
          content: Fn((()=>[Ma("div", {
            ref_key: "regionRef",
            ref: u,
            class: Y([Vt(s).b("suggestion"), Vt(s).is("loading", Vt(A))]),
            style: z({
              [e.fitInputWidth ? "width" : "minWidth"]: m.value,
              outline: "none"
            }),
            role: "region"
          }, [ja(Vt(DE), {
            id: Vt(x),
            tag: "ul",
            "wrap-class": Vt(s).be("suggestion", "wrap"),
            "view-class": Vt(s).be("suggestion", "list"),
            role: "listbox"
          }, {
            default: Fn((()=>[Vt(A) ? (Ca(),
              _a("li", $A, [Qr(e.$slots, "loading", {}, (()=>[ja(Vt(sS), {
                class: Y(Vt(s).is("loading"))
              }, {
                default: Fn((()=>[ja(Vt(Mm))])),
                _: 1
              }, 8, ["class"])]))])) : (Ca(!0),
              _a(ba, {
                key: 1
              }, Yr(v.value, ((t,n)=>(Ca(),
                _a("li", {
                  id: `${Vt(x)}-item-${n}`,
                  key: n,
                  class: Y({
                    highlighted: g.value === n
                  }),
                  role: "option",
                  "aria-selected": g.value === n,
                  onClick: e=>M(t)
                }, [Qr(e.$slots, "default", {
                  item: t
                }, (()=>[$a(te(t[e.valueKey]), 1)]))], 10, HA)))), 128))])),
            _: 3
          }, 8, ["id", "wrap-class", "view-class"])], 6)])),
          default: Fn((()=>[Ma("div", {
            ref_key: "listboxRef",
            ref: d,
            class: Y([Vt(s).b(), e.$attrs.class]),
            style: z(Vt(S)),
            role: "combobox",
            "aria-haspopup": "listbox",
            "aria-expanded": Vt(E),
            "aria-owns": Vt(x)
          }, [ja(Vt(yE), qa({
            ref_key: "inputRef",
            ref: l
          }, Vt(o), {
            clearable: e.clearable,
            disabled: Vt(i),
            name: e.name,
            "model-value": e.modelValue,
            onInput: O,
            onChange: R,
            onFocus: L,
            onBlur: I,
            onClear: P,
            onKeydown: [t[0] || (t[0] = Us(js((e=>j(g.value - 1)), ["prevent"]), ["up"])), t[1] || (t[1] = Us(js((e=>j(g.value + 1)), ["prevent"]), ["down"])), Us(F, ["enter"]), Us(N, ["tab"]), Us(B, ["esc"])],
            onMousedown: _
          }), Xr({
            _: 2
          }, [e.$slots.prepend ? {
            name: "prepend",
            fn: Fn((()=>[Qr(e.$slots, "prepend")]))
          } : void 0, e.$slots.append ? {
            name: "append",
            fn: Fn((()=>[Qr(e.$slots, "append")]))
          } : void 0, e.$slots.prefix ? {
            name: "prefix",
            fn: Fn((()=>[Qr(e.$slots, "prefix")]))
          } : void 0, e.$slots.suffix ? {
            name: "suffix",
            fn: Fn((()=>[Qr(e.$slots, "suffix")]))
          } : void 0]), 1040, ["clearable", "disabled", "name", "model-value", "onKeydown"])], 14, UA)])),
          _: 3
        }, 8, ["visible", "placement", "popper-class", "teleported", "transition"]))
  }
}), [["__file", "autocomplete.vue"]]))
  , GA = uy({
  size: {
    type: [Number, String],
    values: Cy,
    default: "",
    validator: e=>Vg(e)
  },
  shape: {
    type: String,
    values: ["circle", "square"],
    default: "circle"
  },
  icon: {
    type: cy
  },
  src: {
    type: String,
    default: ""
  },
  alt: String,
  srcSet: String,
  fit: {
    type: String,
    default: "cover"
  }
})
  , qA = {
  error: e=>e instanceof Event
}
  , YA = ["src", "alt", "srcset"]
  , XA = vr({
  name: "ElAvatar"
})
  , QA = vr({
  ...XA,
  props: GA,
  emits: qA,
  setup(e, {emit: t}) {
    const n = e
      , r = qy("avatar")
      , o = Ft(!1)
      , a = yi((()=>{
        const {size: e, icon: t, shape: o} = n
          , a = [r.b()];
        return b(e) && a.push(r.m(e)),
        t && a.push(r.m("icon")),
        o && a.push(r.m(o)),
          a
      }
    ))
      , i = yi((()=>{
        const {size: e} = n;
        return Vg(e) ? r.cssVarBlock({
          size: om(e) || ""
        }) : void 0
      }
    ))
      , s = yi((()=>({
      objectFit: n.fit
    })));
    function l(e) {
      o.value = !0,
        t("error", e)
    }
    return Jn((()=>n.src), (()=>o.value = !1)),
      (e,t)=>(Ca(),
        _a("span", {
          class: Y(Vt(a)),
          style: z(Vt(i))
        }, [!e.src && !e.srcSet || o.value ? e.icon ? (Ca(),
          Ra(Vt(sS), {
            key: 1
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(e.icon)))])),
            _: 1
          })) : Qr(e.$slots, "default", {
          key: 2
        }) : (Ca(),
          _a("img", {
            key: 0,
            src: e.src,
            alt: e.alt,
            srcset: e.srcSet,
            style: z(Vt(s)),
            onError: l
          }, null, 44, YA))], 6))
  }
});
const JA = vy(tS(QA, [["__file", "avatar.vue"]]))
  , ZA = {
  visibilityHeight: {
    type: Number,
    default: 200
  },
  target: {
    type: String,
    default: ""
  },
  right: {
    type: Number,
    default: 40
  },
  bottom: {
    type: Number,
    default: 40
  }
}
  , eC = {
  click: e=>e instanceof MouseEvent
}
  , tC = "ElBacktop"
  , nC = vr({
  name: tC
});
const rC = vy(tS(vr({
  ...nC,
  props: ZA,
  emits: eC,
  setup(e, {emit: t}) {
    const n = e
      , r = qy("backtop")
      , {handleClick: o, visible: a} = ((e,t,n)=>{
        const r = Bt()
          , o = Bt()
          , a = Ft(!1)
          , i = ()=>{
          r.value && (a.value = r.value.scrollTop >= e.visibilityHeight)
        }
          , s = Cc(i, 300, !0);
        return Rc(o, "scroll", s),
          Lr((()=>{
              var t;
              o.value = document,
                r.value = document.documentElement,
              e.target && (r.value = null != (t = document.querySelector(e.target)) ? t : void 0,
              r.value || Jg(n, `target does not exist: ${e.target}`),
                o.value = r.value),
                i()
            }
          )),
          {
            visible: a,
            handleClick: e=>{
              var n;
              null == (n = r.value) || n.scrollTo({
                top: 0,
                behavior: "smooth"
              }),
                t("click", e)
            }
          }
      }
    )(n, t, tC)
      , i = yi((()=>({
      right: `${n.right}px`,
      bottom: `${n.bottom}px`
    })));
    return (e,t)=>(Ca(),
      Ra(es, {
        name: `${Vt(r).namespace.value}-fade-in`
      }, {
        default: Fn((()=>[Vt(a) ? (Ca(),
          _a("div", {
            key: 0,
            style: z(Vt(i)),
            class: Y(Vt(r).b()),
            onClick: t[0] || (t[0] = js(((...e)=>Vt(o) && Vt(o)(...e)), ["stop"]))
          }, [Qr(e.$slots, "default", {}, (()=>[ja(Vt(sS), {
            class: Y(Vt(r).e("icon"))
          }, {
            default: Fn((()=>[ja(Vt(xm))])),
            _: 1
          }, 8, ["class"])]))], 6)) : za("v-if", !0)])),
        _: 3
      }, 8, ["name"]))
  }
}), [["__file", "backtop.vue"]]))
  , oC = uy({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  },
  showZero: {
    type: Boolean,
    default: !0
  }
})
  , aC = ["textContent"]
  , iC = vr({
  name: "ElBadge"
});
const sC = vy(tS(vr({
  ...iC,
  props: oC,
  setup(e, {expose: t}) {
    const n = e
      , r = qy("badge")
      , o = yi((()=>n.isDot ? "" : Vg(n.value) && Vg(n.max) ? n.max < n.value ? `${n.max}+` : 0 !== n.value || n.showZero ? `${n.value}` : "" : `${n.value}`));
    return t({
      content: o
    }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y(Vt(r).b())
        }, [Qr(e.$slots, "default"), ja(es, {
          name: `${Vt(r).namespace.value}-zoom-in-center`,
          persisted: ""
        }, {
          default: Fn((()=>[rr(Ma("sup", {
            class: Y([Vt(r).e("content"), Vt(r).em("content", e.type), Vt(r).is("fixed", !!e.$slots.default), Vt(r).is("dot", e.isDot)]),
            textContent: te(Vt(o))
          }, null, 10, aC), [[$s, !e.hidden && (Vt(o) || e.isDot)]])])),
          _: 1
        }, 8, ["name"])], 2))
  }
}), [["__file", "badge.vue"]]))
  , lC = Symbol("breadcrumbKey")
  , uC = uy({
  separator: {
    type: String,
    default: "/"
  },
  separatorIcon: {
    type: cy
  }
})
  , cC = vr({
  name: "ElBreadcrumb"
});
var dC = tS(vr({
  ...cC,
  props: uC,
  setup(e) {
    const t = e
      , n = qy("breadcrumb")
      , r = Ft();
    return Mo(lC, t),
      Lr((()=>{
          const e = r.value.querySelectorAll(`.${n.e("item")}`);
          e.length && e[e.length - 1].setAttribute("aria-current", "page")
        }
      )),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "breadcrumb",
          ref: r,
          class: Y(Vt(n).b()),
          "aria-label": "Breadcrumb",
          role: "navigation"
        }, [Qr(e.$slots, "default")], 2))
  }
}), [["__file", "breadcrumb.vue"]]);
const fC = uy({
  to: {
    type: [String, Object],
    default: ""
  },
  replace: {
    type: Boolean,
    default: !1
  }
})
  , pC = vr({
  name: "ElBreadcrumbItem"
});
var hC = tS(vr({
  ...pC,
  props: fC,
  setup(e) {
    const t = e
      , n = ei()
      , r = jo(lC, void 0)
      , o = qy("breadcrumb")
      , a = n.appContext.config.globalProperties.$router
      , i = Ft()
      , s = ()=>{
        t.to && a && (t.replace ? a.replace(t.to) : a.push(t.to))
      }
    ;
    return (e,t)=>{
      var n, a;
      return Ca(),
        _a("span", {
          class: Y(Vt(o).e("item"))
        }, [Ma("span", {
          ref_key: "link",
          ref: i,
          class: Y([Vt(o).e("inner"), Vt(o).is("link", !!e.to)]),
          role: "link",
          onClick: s
        }, [Qr(e.$slots, "default")], 2), (null == (n = Vt(r)) ? void 0 : n.separatorIcon) ? (Ca(),
          Ra(Vt(sS), {
            key: 0,
            class: Y(Vt(o).e("separator"))
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(Vt(r).separatorIcon)))])),
            _: 1
          }, 8, ["class"])) : (Ca(),
          _a("span", {
            key: 1,
            class: Y(Vt(o).e("separator")),
            role: "presentation"
          }, te(null == (a = Vt(r)) ? void 0 : a.separator), 3))], 2)
    }
  }
}), [["__file", "breadcrumb-item.vue"]]);
const vC = vy(dC, {
  BreadcrumbItem: hC
})
  , gC = my(hC)
  , mC = Symbol("buttonGroupContextKey")
  , yC = ["default", "primary", "success", "warning", "info", "danger", "text", ""]
  , bC = uy({
  size: Ux,
  disabled: Boolean,
  type: {
    type: String,
    values: yC,
    default: ""
  },
  icon: {
    type: cy
  },
  nativeType: {
    type: String,
    values: ["button", "submit", "reset"],
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: cy,
    default: ()=>Mm
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: [String, Object],
    default: "button"
  }
})
  , wC = {
  click: e=>e instanceof MouseEvent
};
function xC(e, t) {
  (function(e) {
      return "string" == typeof e && -1 !== e.indexOf(".") && 1 === parseFloat(e)
    }
  )(e) && (e = "100%");
  var n = function(e) {
    return "string" == typeof e && -1 !== e.indexOf("%")
  }(e);
  return e = 360 === t ? e : Math.min(t, Math.max(0, parseFloat(e))),
  n && (e = parseInt(String(e * t), 10) / 100),
    Math.abs(e - t) < 1e-6 ? 1 : e = 360 === t ? (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e % t / parseFloat(String(t))
}
function SC(e) {
  return Math.min(1, Math.max(0, e))
}
function EC(e) {
  return e = parseFloat(e),
  (isNaN(e) || e < 0 || e > 1) && (e = 1),
    e
}
function AC(e) {
  return e <= 1 ? "".concat(100 * Number(e), "%") : e
}
function CC(e) {
  return 1 === e.length ? "0" + e : String(e)
}
function kC(e, t, n) {
  e = xC(e, 255),
    t = xC(t, 255),
    n = xC(n, 255);
  var r = Math.max(e, t, n)
    , o = Math.min(e, t, n)
    , a = 0
    , i = 0
    , s = (r + o) / 2;
  if (r === o)
    i = 0,
      a = 0;
  else {
    var l = r - o;
    switch (i = s > .5 ? l / (2 - r - o) : l / (r + o),
      r) {
      case e:
        a = (t - n) / l + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - e) / l + 2;
        break;
      case n:
        a = (e - t) / l + 4
    }
    a /= 6
  }
  return {
    h: a,
    s: i,
    l: s
  }
}
function TC(e, t, n) {
  return n < 0 && (n += 1),
  n > 1 && (n -= 1),
    n < 1 / 6 ? e + 6 * n * (t - e) : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
}
function DC(e, t, n) {
  e = xC(e, 255),
    t = xC(t, 255),
    n = xC(n, 255);
  var r = Math.max(e, t, n)
    , o = Math.min(e, t, n)
    , a = 0
    , i = r
    , s = r - o
    , l = 0 === r ? 0 : s / r;
  if (r === o)
    a = 0;
  else {
    switch (r) {
      case e:
        a = (t - n) / s + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - e) / s + 2;
        break;
      case n:
        a = (e - t) / s + 4
    }
    a /= 6
  }
  return {
    h: a,
    s: l,
    v: i
  }
}
function OC(e, t, n, r) {
  var o = [CC(Math.round(e).toString(16)), CC(Math.round(t).toString(16)), CC(Math.round(n).toString(16))];
  return r && o[0].startsWith(o[0].charAt(1)) && o[1].startsWith(o[1].charAt(1)) && o[2].startsWith(o[2].charAt(1)) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) : o.join("")
}
function _C(e) {
  return RC(e) / 255
}
function RC(e) {
  return parseInt(e, 16)
}
var LC = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function IC(e) {
  var t = {
    r: 0,
    g: 0,
    b: 0
  }
    , n = 1
    , r = null
    , o = null
    , a = null
    , i = !1
    , s = !1;
  return "string" == typeof e && (e = function(e) {
    if (e = e.trim().toLowerCase(),
    0 === e.length)
      return !1;
    var t = !1;
    if (LC[e])
      e = LC[e],
        t = !0;
    else if ("transparent" === e)
      return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: "name"
      };
    var n = NC.rgb.exec(e);
    if (n)
      return {
        r: n[1],
        g: n[2],
        b: n[3]
      };
    if (n = NC.rgba.exec(e),
      n)
      return {
        r: n[1],
        g: n[2],
        b: n[3],
        a: n[4]
      };
    if (n = NC.hsl.exec(e),
      n)
      return {
        h: n[1],
        s: n[2],
        l: n[3]
      };
    if (n = NC.hsla.exec(e),
      n)
      return {
        h: n[1],
        s: n[2],
        l: n[3],
        a: n[4]
      };
    if (n = NC.hsv.exec(e),
      n)
      return {
        h: n[1],
        s: n[2],
        v: n[3]
      };
    if (n = NC.hsva.exec(e),
      n)
      return {
        h: n[1],
        s: n[2],
        v: n[3],
        a: n[4]
      };
    if (n = NC.hex8.exec(e),
      n)
      return {
        r: RC(n[1]),
        g: RC(n[2]),
        b: RC(n[3]),
        a: _C(n[4]),
        format: t ? "name" : "hex8"
      };
    if (n = NC.hex6.exec(e),
      n)
      return {
        r: RC(n[1]),
        g: RC(n[2]),
        b: RC(n[3]),
        format: t ? "name" : "hex"
      };
    if (n = NC.hex4.exec(e),
      n)
      return {
        r: RC(n[1] + n[1]),
        g: RC(n[2] + n[2]),
        b: RC(n[3] + n[3]),
        a: _C(n[4] + n[4]),
        format: t ? "name" : "hex8"
      };
    if (n = NC.hex3.exec(e),
      n)
      return {
        r: RC(n[1] + n[1]),
        g: RC(n[2] + n[2]),
        b: RC(n[3] + n[3]),
        format: t ? "name" : "hex"
      };
    return !1
  }(e)),
  "object" == typeof e && (MC(e.r) && MC(e.g) && MC(e.b) ? (t = function(e, t, n) {
    return {
      r: 255 * xC(e, 255),
      g: 255 * xC(t, 255),
      b: 255 * xC(n, 255)
    }
  }(e.r, e.g, e.b),
    i = !0,
    s = "%" === String(e.r).substr(-1) ? "prgb" : "rgb") : MC(e.h) && MC(e.s) && MC(e.v) ? (r = AC(e.s),
    o = AC(e.v),
    t = function(e, t, n) {
      e = 6 * xC(e, 360),
        t = xC(t, 100),
        n = xC(n, 100);
      var r = Math.floor(e)
        , o = e - r
        , a = n * (1 - t)
        , i = n * (1 - o * t)
        , s = n * (1 - (1 - o) * t)
        , l = r % 6;
      return {
        r: 255 * [n, i, a, a, s, n][l],
        g: 255 * [s, n, n, i, a, a][l],
        b: 255 * [a, a, s, n, n, i][l]
      }
    }(e.h, r, o),
    i = !0,
    s = "hsv") : MC(e.h) && MC(e.s) && MC(e.l) && (r = AC(e.s),
    a = AC(e.l),
    t = function(e, t, n) {
      var r, o, a;
      if (e = xC(e, 360),
        t = xC(t, 100),
        n = xC(n, 100),
      0 === t)
        o = n,
          a = n,
          r = n;
      else {
        var i = n < .5 ? n * (1 + t) : n + t - n * t
          , s = 2 * n - i;
        r = TC(s, i, e + 1 / 3),
          o = TC(s, i, e),
          a = TC(s, i, e - 1 / 3)
      }
      return {
        r: 255 * r,
        g: 255 * o,
        b: 255 * a
      }
    }(e.h, r, a),
    i = !0,
    s = "hsl"),
  Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)),
    n = EC(n),
    {
      ok: i,
      format: e.format || s,
      r: Math.min(255, Math.max(t.r, 0)),
      g: Math.min(255, Math.max(t.g, 0)),
      b: Math.min(255, Math.max(t.b, 0)),
      a: n
    }
}
var PC = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat("[-\\+]?\\d+%?", ")")
  , FC = "[\\s|\\(]+(".concat(PC, ")[,|\\s]+(").concat(PC, ")[,|\\s]+(").concat(PC, ")\\s*\\)?")
  , BC = "[\\s|\\(]+(".concat(PC, ")[,|\\s]+(").concat(PC, ")[,|\\s]+(").concat(PC, ")[,|\\s]+(").concat(PC, ")\\s*\\)?")
  , NC = {
  CSS_UNIT: new RegExp(PC),
  rgb: new RegExp("rgb" + FC),
  rgba: new RegExp("rgba" + BC),
  hsl: new RegExp("hsl" + FC),
  hsla: new RegExp("hsla" + BC),
  hsv: new RegExp("hsv" + FC),
  hsva: new RegExp("hsva" + BC),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function MC(e) {
  return Boolean(NC.CSS_UNIT.exec(String(e)))
}
var jC = function() {
  function e(t, n) {
    var r;
    if (void 0 === t && (t = ""),
    void 0 === n && (n = {}),
    t instanceof e)
      return t;
    "number" == typeof t && (t = function(e) {
      return {
        r: e >> 16,
        g: (65280 & e) >> 8,
        b: 255 & e
      }
    }(t)),
      this.originalInput = t;
    var o = IC(t);
    this.originalInput = t,
      this.r = o.r,
      this.g = o.g,
      this.b = o.b,
      this.a = o.a,
      this.roundA = Math.round(100 * this.a) / 100,
      this.format = null !== (r = n.format) && void 0 !== r ? r : o.format,
      this.gradientType = n.gradientType,
    this.r < 1 && (this.r = Math.round(this.r)),
    this.g < 1 && (this.g = Math.round(this.g)),
    this.b < 1 && (this.b = Math.round(this.b)),
      this.isValid = o.ok
  }
  return e.prototype.isDark = function() {
    return this.getBrightness() < 128
  }
    ,
    e.prototype.isLight = function() {
      return !this.isDark()
    }
    ,
    e.prototype.getBrightness = function() {
      var e = this.toRgb();
      return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3
    }
    ,
    e.prototype.getLuminance = function() {
      var e = this.toRgb()
        , t = e.r / 255
        , n = e.g / 255
        , r = e.b / 255;
      return .2126 * (t <= .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)) + .7152 * (n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4)) + .0722 * (r <= .03928 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4))
    }
    ,
    e.prototype.getAlpha = function() {
      return this.a
    }
    ,
    e.prototype.setAlpha = function(e) {
      return this.a = EC(e),
        this.roundA = Math.round(100 * this.a) / 100,
        this
    }
    ,
    e.prototype.isMonochrome = function() {
      return 0 === this.toHsl().s
    }
    ,
    e.prototype.toHsv = function() {
      var e = DC(this.r, this.g, this.b);
      return {
        h: 360 * e.h,
        s: e.s,
        v: e.v,
        a: this.a
      }
    }
    ,
    e.prototype.toHsvString = function() {
      var e = DC(this.r, this.g, this.b)
        , t = Math.round(360 * e.h)
        , n = Math.round(100 * e.s)
        , r = Math.round(100 * e.v);
      return 1 === this.a ? "hsv(".concat(t, ", ").concat(n, "%, ").concat(r, "%)") : "hsva(".concat(t, ", ").concat(n, "%, ").concat(r, "%, ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toHsl = function() {
      var e = kC(this.r, this.g, this.b);
      return {
        h: 360 * e.h,
        s: e.s,
        l: e.l,
        a: this.a
      }
    }
    ,
    e.prototype.toHslString = function() {
      var e = kC(this.r, this.g, this.b)
        , t = Math.round(360 * e.h)
        , n = Math.round(100 * e.s)
        , r = Math.round(100 * e.l);
      return 1 === this.a ? "hsl(".concat(t, ", ").concat(n, "%, ").concat(r, "%)") : "hsla(".concat(t, ", ").concat(n, "%, ").concat(r, "%, ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toHex = function(e) {
      return void 0 === e && (e = !1),
        OC(this.r, this.g, this.b, e)
    }
    ,
    e.prototype.toHexString = function(e) {
      return void 0 === e && (e = !1),
      "#" + this.toHex(e)
    }
    ,
    e.prototype.toHex8 = function(e) {
      return void 0 === e && (e = !1),
        function(e, t, n, r, o) {
          var a, i = [CC(Math.round(e).toString(16)), CC(Math.round(t).toString(16)), CC(Math.round(n).toString(16)), CC((a = r,
            Math.round(255 * parseFloat(a)).toString(16)))];
          return o && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) && i[3].startsWith(i[3].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) + i[3].charAt(0) : i.join("")
        }(this.r, this.g, this.b, this.a, e)
    }
    ,
    e.prototype.toHex8String = function(e) {
      return void 0 === e && (e = !1),
      "#" + this.toHex8(e)
    }
    ,
    e.prototype.toHexShortString = function(e) {
      return void 0 === e && (e = !1),
        1 === this.a ? this.toHexString(e) : this.toHex8String(e)
    }
    ,
    e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      }
    }
    ,
    e.prototype.toRgbString = function() {
      var e = Math.round(this.r)
        , t = Math.round(this.g)
        , n = Math.round(this.b);
      return 1 === this.a ? "rgb(".concat(e, ", ").concat(t, ", ").concat(n, ")") : "rgba(".concat(e, ", ").concat(t, ", ").concat(n, ", ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toPercentageRgb = function() {
      var e = function(e) {
        return "".concat(Math.round(100 * xC(e, 255)), "%")
      };
      return {
        r: e(this.r),
        g: e(this.g),
        b: e(this.b),
        a: this.a
      }
    }
    ,
    e.prototype.toPercentageRgbString = function() {
      var e = function(e) {
        return Math.round(100 * xC(e, 255))
      };
      return 1 === this.a ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")")
    }
    ,
    e.prototype.toName = function() {
      if (0 === this.a)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var e = "#" + OC(this.r, this.g, this.b, !1), t = 0, n = Object.entries(LC); t < n.length; t++) {
        var r = n[t]
          , o = r[0];
        if (e === r[1])
          return o
      }
      return !1
    }
    ,
    e.prototype.toString = function(e) {
      var t = Boolean(e);
      e = null != e ? e : this.format;
      var n = !1
        , r = this.a < 1 && this.a >= 0;
      return t || !r || !e.startsWith("hex") && "name" !== e ? ("rgb" === e && (n = this.toRgbString()),
      "prgb" === e && (n = this.toPercentageRgbString()),
      "hex" !== e && "hex6" !== e || (n = this.toHexString()),
      "hex3" === e && (n = this.toHexString(!0)),
      "hex4" === e && (n = this.toHex8String(!0)),
      "hex8" === e && (n = this.toHex8String()),
      "name" === e && (n = this.toName()),
      "hsl" === e && (n = this.toHslString()),
      "hsv" === e && (n = this.toHsvString()),
      n || this.toHexString()) : "name" === e && 0 === this.a ? this.toName() : this.toRgbString()
    }
    ,
    e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
    }
    ,
    e.prototype.clone = function() {
      return new e(this.toString())
    }
    ,
    e.prototype.lighten = function(t) {
      void 0 === t && (t = 10);
      var n = this.toHsl();
      return n.l += t / 100,
        n.l = SC(n.l),
        new e(n)
    }
    ,
    e.prototype.brighten = function(t) {
      void 0 === t && (t = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(-t / 100 * 255))),
        n.g = Math.max(0, Math.min(255, n.g - Math.round(-t / 100 * 255))),
        n.b = Math.max(0, Math.min(255, n.b - Math.round(-t / 100 * 255))),
        new e(n)
    }
    ,
    e.prototype.darken = function(t) {
      void 0 === t && (t = 10);
      var n = this.toHsl();
      return n.l -= t / 100,
        n.l = SC(n.l),
        new e(n)
    }
    ,
    e.prototype.tint = function(e) {
      return void 0 === e && (e = 10),
        this.mix("white", e)
    }
    ,
    e.prototype.shade = function(e) {
      return void 0 === e && (e = 10),
        this.mix("black", e)
    }
    ,
    e.prototype.desaturate = function(t) {
      void 0 === t && (t = 10);
      var n = this.toHsl();
      return n.s -= t / 100,
        n.s = SC(n.s),
        new e(n)
    }
    ,
    e.prototype.saturate = function(t) {
      void 0 === t && (t = 10);
      var n = this.toHsl();
      return n.s += t / 100,
        n.s = SC(n.s),
        new e(n)
    }
    ,
    e.prototype.greyscale = function() {
      return this.desaturate(100)
    }
    ,
    e.prototype.spin = function(t) {
      var n = this.toHsl()
        , r = (n.h + t) % 360;
      return n.h = r < 0 ? 360 + r : r,
        new e(n)
    }
    ,
    e.prototype.mix = function(t, n) {
      void 0 === n && (n = 50);
      var r = this.toRgb()
        , o = new e(t).toRgb()
        , a = n / 100;
      return new e({
        r: (o.r - r.r) * a + r.r,
        g: (o.g - r.g) * a + r.g,
        b: (o.b - r.b) * a + r.b,
        a: (o.a - r.a) * a + r.a
      })
    }
    ,
    e.prototype.analogous = function(t, n) {
      void 0 === t && (t = 6),
      void 0 === n && (n = 30);
      var r = this.toHsl()
        , o = 360 / n
        , a = [this];
      for (r.h = (r.h - (o * t >> 1) + 720) % 360; --t; )
        r.h = (r.h + o) % 360,
          a.push(new e(r));
      return a
    }
    ,
    e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360,
        new e(t)
    }
    ,
    e.prototype.monochromatic = function(t) {
      void 0 === t && (t = 6);
      for (var n = this.toHsv(), r = n.h, o = n.s, a = n.v, i = [], s = 1 / t; t--; )
        i.push(new e({
          h: r,
          s: o,
          v: a
        })),
          a = (a + s) % 1;
      return i
    }
    ,
    e.prototype.splitcomplement = function() {
      var t = this.toHsl()
        , n = t.h;
      return [this, new e({
        h: (n + 72) % 360,
        s: t.s,
        l: t.l
      }), new e({
        h: (n + 216) % 360,
        s: t.s,
        l: t.l
      })]
    }
    ,
    e.prototype.onBackground = function(t) {
      var n = this.toRgb()
        , r = new e(t).toRgb()
        , o = n.a + r.a * (1 - n.a);
      return new e({
        r: (n.r * n.a + r.r * r.a * (1 - n.a)) / o,
        g: (n.g * n.a + r.g * r.a * (1 - n.a)) / o,
        b: (n.b * n.a + r.b * r.a * (1 - n.a)) / o,
        a: o
      })
    }
    ,
    e.prototype.triad = function() {
      return this.polyad(3)
    }
    ,
    e.prototype.tetrad = function() {
      return this.polyad(4)
    }
    ,
    e.prototype.polyad = function(t) {
      for (var n = this.toHsl(), r = n.h, o = [this], a = 360 / t, i = 1; i < t; i++)
        o.push(new e({
          h: (r + i * a) % 360,
          s: n.s,
          l: n.l
        }));
      return o
    }
    ,
    e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString()
    }
    ,
    e
}();
function VC(e, t=20) {
  return e.mix("#141414", t).toString()
}
const UC = vr({
  name: "ElButton"
});
var $C = tS(vr({
  ...UC,
  props: bC,
  emits: wC,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = function(e) {
      const t = vS()
        , n = qy("button");
      return yi((()=>{
          let r = {};
          const o = e.color;
          if (o) {
            const a = new jC(o)
              , i = e.dark ? a.tint(20).toString() : VC(a, 20);
            if (e.plain)
              r = n.cssVarBlock({
                "bg-color": e.dark ? VC(a, 90) : a.tint(90).toString(),
                "text-color": o,
                "border-color": e.dark ? VC(a, 50) : a.tint(50).toString(),
                "hover-text-color": `var(${n.cssVarName("color-white")})`,
                "hover-bg-color": o,
                "hover-border-color": o,
                "active-bg-color": i,
                "active-text-color": `var(${n.cssVarName("color-white")})`,
                "active-border-color": i
              }),
              t.value && (r[n.cssVarBlockName("disabled-bg-color")] = e.dark ? VC(a, 90) : a.tint(90).toString(),
                r[n.cssVarBlockName("disabled-text-color")] = e.dark ? VC(a, 50) : a.tint(50).toString(),
                r[n.cssVarBlockName("disabled-border-color")] = e.dark ? VC(a, 80) : a.tint(80).toString());
            else {
              const s = e.dark ? VC(a, 30) : a.tint(30).toString()
                , l = a.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
              if (r = n.cssVarBlock({
                "bg-color": o,
                "text-color": l,
                "border-color": o,
                "hover-bg-color": s,
                "hover-text-color": l,
                "hover-border-color": s,
                "active-bg-color": i,
                "active-border-color": i
              }),
                t.value) {
                const t = e.dark ? VC(a, 50) : a.tint(50).toString();
                r[n.cssVarBlockName("disabled-bg-color")] = t,
                  r[n.cssVarBlockName("disabled-text-color")] = e.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`,
                  r[n.cssVarBlockName("disabled-border-color")] = t
              }
            }
          }
          return r
        }
      ))
    }(r)
      , a = qy("button")
      , {_ref: i, _size: s, _type: l, _disabled: u, _props: c, shouldAddSpace: d, handleClick: f} = ((e,t)=>{
        Ny({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, yi((()=>"text" === e.type)));
        const n = jo(mC, void 0)
          , r = Wx("button")
          , {form: o} = gS()
          , a = hS(yi((()=>null == n ? void 0 : n.size)))
          , i = vS()
          , s = Ft()
          , l = po()
          , u = yi((()=>e.type || (null == n ? void 0 : n.type) || ""))
          , c = yi((()=>{
            var t, n, o;
            return null != (o = null != (n = e.autoInsertSpace) ? n : null == (t = r.value) ? void 0 : t.autoInsertSpace) && o
          }
        ))
          , d = yi((()=>"button" === e.tag ? {
          ariaDisabled: i.value || e.loading,
          disabled: i.value || e.loading,
          autofocus: e.autofocus,
          type: e.nativeType
        } : {}))
          , f = yi((()=>{
            var e;
            const t = null == (e = l.default) ? void 0 : e.call(l);
            if (c.value && 1 === (null == t ? void 0 : t.length)) {
              const e = t[0];
              if ((null == e ? void 0 : e.type) === wa) {
                const t = e.children;
                return /^\p{Unified_Ideograph}{2}$/u.test(t.trim())
              }
            }
            return !1
          }
        ));
        return {
          _disabled: i,
          _size: a,
          _type: u,
          _ref: s,
          _props: d,
          shouldAddSpace: f,
          handleClick: n=>{
            "reset" === e.nativeType && (null == o || o.resetFields()),
              t("click", n)
          }
        }
      }
    )(r, n);
    return t({
      ref: i,
      size: s,
      type: l,
      disabled: u,
      shouldAddSpace: d
    }),
      (e,t)=>(Ca(),
        Ra(Kr(e.tag), qa({
          ref_key: "_ref",
          ref: i
        }, Vt(c), {
          class: [Vt(a).b(), Vt(a).m(Vt(l)), Vt(a).m(Vt(s)), Vt(a).is("disabled", Vt(u)), Vt(a).is("loading", e.loading), Vt(a).is("plain", e.plain), Vt(a).is("round", e.round), Vt(a).is("circle", e.circle), Vt(a).is("text", e.text), Vt(a).is("link", e.link), Vt(a).is("has-bg", e.bg)],
          style: Vt(o),
          onClick: Vt(f)
        }), {
          default: Fn((()=>[e.loading ? (Ca(),
            _a(ba, {
              key: 0
            }, [e.$slots.loading ? Qr(e.$slots, "loading", {
              key: 0
            }) : (Ca(),
              Ra(Vt(sS), {
                key: 1,
                class: Y(Vt(a).is("loading"))
              }, {
                default: Fn((()=>[(Ca(),
                  Ra(Kr(e.loadingIcon)))])),
                _: 1
              }, 8, ["class"]))], 64)) : e.icon || e.$slots.icon ? (Ca(),
            Ra(Vt(sS), {
              key: 1
            }, {
              default: Fn((()=>[e.icon ? (Ca(),
                Ra(Kr(e.icon), {
                  key: 0
                })) : Qr(e.$slots, "icon", {
                key: 1
              })])),
              _: 3
            })) : za("v-if", !0), e.$slots.default ? (Ca(),
            _a("span", {
              key: 2,
              class: Y({
                [Vt(a).em("text", "expand")]: Vt(d)
              })
            }, [Qr(e.$slots, "default")], 2)) : za("v-if", !0)])),
          _: 3
        }, 16, ["class", "style", "onClick"]))
  }
}), [["__file", "button.vue"]]);
const HC = {
  size: bC.size,
  type: bC.type
}
  , zC = vr({
  name: "ElButtonGroup"
});
var KC = tS(vr({
  ...zC,
  props: HC,
  setup(e) {
    const t = e;
    Mo(mC, bt({
      size: Yt(t, "size"),
      type: Yt(t, "type")
    }));
    const n = qy("button");
    return (e,t)=>(Ca(),
      _a("div", {
        class: Y(`${Vt(n).b("group")}`)
      }, [Qr(e.$slots, "default")], 2))
  }
}), [["__file", "button-group.vue"]]);
const WC = vy($C, {
  ButtonGroup: KC
})
  , GC = my(KC);
var qC = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function YC(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
function XC(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if ("function" == typeof t) {
    var n = function e() {
      if (this instanceof e) {
        var n = [null];
        return n.push.apply(n, arguments),
          new (Function.bind.apply(t, n))
      }
      return t.apply(this, arguments)
    };
    n.prototype = t.prototype
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", {
    value: !0
  }),
    Object.keys(e).forEach((function(t) {
        var r = Object.getOwnPropertyDescriptor(e, t);
        Object.defineProperty(n, t, r.get ? r : {
          enumerable: !0,
          get: function() {
            return e[t]
          }
        })
      }
    )),
    n
}
var QC = {
  exports: {}
};
QC.exports = function() {
  var e = 1e3
    , t = 6e4
    , n = 36e5
    , r = "millisecond"
    , o = "second"
    , a = "minute"
    , i = "hour"
    , s = "day"
    , l = "week"
    , u = "month"
    , c = "quarter"
    , d = "year"
    , f = "date"
    , p = "Invalid Date"
    , h = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/
    , v = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
    , g = {
    name: "en",
    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    ordinal: function(e) {
      var t = ["th", "st", "nd", "rd"]
        , n = e % 100;
      return "[" + e + (t[(n - 20) % 10] || t[n] || t[0]) + "]"
    }
  }
    , m = function(e, t, n) {
    var r = String(e);
    return !r || r.length >= t ? e : "" + Array(t + 1 - r.length).join(n) + e
  }
    , y = {
    s: m,
    z: function(e) {
      var t = -e.utcOffset()
        , n = Math.abs(t)
        , r = Math.floor(n / 60)
        , o = n % 60;
      return (t <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(o, 2, "0")
    },
    m: function e(t, n) {
      if (t.date() < n.date())
        return -e(n, t);
      var r = 12 * (n.year() - t.year()) + (n.month() - t.month())
        , o = t.clone().add(r, u)
        , a = n - o < 0
        , i = t.clone().add(r + (a ? -1 : 1), u);
      return +(-(r + (n - o) / (a ? o - i : i - o)) || 0)
    },
    a: function(e) {
      return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
    },
    p: function(e) {
      return {
        M: u,
        y: d,
        w: l,
        d: s,
        D: f,
        h: i,
        m: a,
        s: o,
        ms: r,
        Q: c
      }[e] || String(e || "").toLowerCase().replace(/s$/, "")
    },
    u: function(e) {
      return void 0 === e
    }
  }
    , b = "en"
    , w = {};
  w[b] = g;
  var x = function(e) {
    return e instanceof C
  }
    , S = function e(t, n, r) {
    var o;
    if (!t)
      return b;
    if ("string" == typeof t) {
      var a = t.toLowerCase();
      w[a] && (o = a),
      n && (w[a] = n,
        o = a);
      var i = t.split("-");
      if (!o && i.length > 1)
        return e(i[0])
    } else {
      var s = t.name;
      w[s] = t,
        o = s
    }
    return !r && o && (b = o),
    o || !r && b
  }
    , E = function(e, t) {
    if (x(e))
      return e.clone();
    var n = "object" == typeof t ? t : {};
    return n.date = e,
      n.args = arguments,
      new C(n)
  }
    , A = y;
  A.l = S,
    A.i = x,
    A.w = function(e, t) {
      return E(e, {
        locale: t.$L,
        utc: t.$u,
        x: t.$x,
        $offset: t.$offset
      })
    }
  ;
  var C = function() {
    function g(e) {
      this.$L = S(e.locale, null, !0),
        this.parse(e)
    }
    var m = g.prototype;
    return m.parse = function(e) {
      this.$d = function(e) {
        var t = e.date
          , n = e.utc;
        if (null === t)
          return new Date(NaN);
        if (A.u(t))
          return new Date;
        if (t instanceof Date)
          return new Date(t);
        if ("string" == typeof t && !/Z$/i.test(t)) {
          var r = t.match(h);
          if (r) {
            var o = r[2] - 1 || 0
              , a = (r[7] || "0").substring(0, 3);
            return n ? new Date(Date.UTC(r[1], o, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, a)) : new Date(r[1],o,r[3] || 1,r[4] || 0,r[5] || 0,r[6] || 0,a)
          }
        }
        return new Date(t)
      }(e),
        this.$x = e.x || {},
        this.init()
    }
      ,
      m.init = function() {
        var e = this.$d;
        this.$y = e.getFullYear(),
          this.$M = e.getMonth(),
          this.$D = e.getDate(),
          this.$W = e.getDay(),
          this.$H = e.getHours(),
          this.$m = e.getMinutes(),
          this.$s = e.getSeconds(),
          this.$ms = e.getMilliseconds()
      }
      ,
      m.$utils = function() {
        return A
      }
      ,
      m.isValid = function() {
        return !(this.$d.toString() === p)
      }
      ,
      m.isSame = function(e, t) {
        var n = E(e);
        return this.startOf(t) <= n && n <= this.endOf(t)
      }
      ,
      m.isAfter = function(e, t) {
        return E(e) < this.startOf(t)
      }
      ,
      m.isBefore = function(e, t) {
        return this.endOf(t) < E(e)
      }
      ,
      m.$g = function(e, t, n) {
        return A.u(e) ? this[t] : this.set(n, e)
      }
      ,
      m.unix = function() {
        return Math.floor(this.valueOf() / 1e3)
      }
      ,
      m.valueOf = function() {
        return this.$d.getTime()
      }
      ,
      m.startOf = function(e, t) {
        var n = this
          , r = !!A.u(t) || t
          , c = A.p(e)
          , p = function(e, t) {
          var o = A.w(n.$u ? Date.UTC(n.$y, t, e) : new Date(n.$y,t,e), n);
          return r ? o : o.endOf(s)
        }
          , h = function(e, t) {
          return A.w(n.toDate()[e].apply(n.toDate("s"), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)), n)
        }
          , v = this.$W
          , g = this.$M
          , m = this.$D
          , y = "set" + (this.$u ? "UTC" : "");
        switch (c) {
          case d:
            return r ? p(1, 0) : p(31, 11);
          case u:
            return r ? p(1, g) : p(0, g + 1);
          case l:
            var b = this.$locale().weekStart || 0
              , w = (v < b ? v + 7 : v) - b;
            return p(r ? m - w : m + (6 - w), g);
          case s:
          case f:
            return h(y + "Hours", 0);
          case i:
            return h(y + "Minutes", 1);
          case a:
            return h(y + "Seconds", 2);
          case o:
            return h(y + "Milliseconds", 3);
          default:
            return this.clone()
        }
      }
      ,
      m.endOf = function(e) {
        return this.startOf(e, !1)
      }
      ,
      m.$set = function(e, t) {
        var n, l = A.p(e), c = "set" + (this.$u ? "UTC" : ""), p = (n = {},
          n[s] = c + "Date",
          n[f] = c + "Date",
          n[u] = c + "Month",
          n[d] = c + "FullYear",
          n[i] = c + "Hours",
          n[a] = c + "Minutes",
          n[o] = c + "Seconds",
          n[r] = c + "Milliseconds",
          n)[l], h = l === s ? this.$D + (t - this.$W) : t;
        if (l === u || l === d) {
          var v = this.clone().set(f, 1);
          v.$d[p](h),
            v.init(),
            this.$d = v.set(f, Math.min(this.$D, v.daysInMonth())).$d
        } else
          p && this.$d[p](h);
        return this.init(),
          this
      }
      ,
      m.set = function(e, t) {
        return this.clone().$set(e, t)
      }
      ,
      m.get = function(e) {
        return this[A.p(e)]()
      }
      ,
      m.add = function(r, c) {
        var f, p = this;
        r = Number(r);
        var h = A.p(c)
          , v = function(e) {
          var t = E(p);
          return A.w(t.date(t.date() + Math.round(e * r)), p)
        };
        if (h === u)
          return this.set(u, this.$M + r);
        if (h === d)
          return this.set(d, this.$y + r);
        if (h === s)
          return v(1);
        if (h === l)
          return v(7);
        var g = (f = {},
          f[a] = t,
          f[i] = n,
          f[o] = e,
          f)[h] || 1
          , m = this.$d.getTime() + r * g;
        return A.w(m, this)
      }
      ,
      m.subtract = function(e, t) {
        return this.add(-1 * e, t)
      }
      ,
      m.format = function(e) {
        var t = this
          , n = this.$locale();
        if (!this.isValid())
          return n.invalidDate || p;
        var r = e || "YYYY-MM-DDTHH:mm:ssZ"
          , o = A.z(this)
          , a = this.$H
          , i = this.$m
          , s = this.$M
          , l = n.weekdays
          , u = n.months
          , c = n.meridiem
          , d = function(e, n, o, a) {
            return e && (e[n] || e(t, r)) || o[n].slice(0, a)
          }
          , f = function(e) {
            return A.s(a % 12 || 12, e, "0")
          }
          , h = c || function(e, t, n) {
            var r = e < 12 ? "AM" : "PM";
            return n ? r.toLowerCase() : r
          }
        ;
        return r.replace(v, (function(e, r) {
            return r || function(e) {
              switch (e) {
                case "YY":
                  return String(t.$y).slice(-2);
                case "YYYY":
                  return A.s(t.$y, 4, "0");
                case "M":
                  return s + 1;
                case "MM":
                  return A.s(s + 1, 2, "0");
                case "MMM":
                  return d(n.monthsShort, s, u, 3);
                case "MMMM":
                  return d(u, s);
                case "D":
                  return t.$D;
                case "DD":
                  return A.s(t.$D, 2, "0");
                case "d":
                  return String(t.$W);
                case "dd":
                  return d(n.weekdaysMin, t.$W, l, 2);
                case "ddd":
                  return d(n.weekdaysShort, t.$W, l, 3);
                case "dddd":
                  return l[t.$W];
                case "H":
                  return String(a);
                case "HH":
                  return A.s(a, 2, "0");
                case "h":
                  return f(1);
                case "hh":
                  return f(2);
                case "a":
                  return h(a, i, !0);
                case "A":
                  return h(a, i, !1);
                case "m":
                  return String(i);
                case "mm":
                  return A.s(i, 2, "0");
                case "s":
                  return String(t.$s);
                case "ss":
                  return A.s(t.$s, 2, "0");
                case "SSS":
                  return A.s(t.$ms, 3, "0");
                case "Z":
                  return o
              }
              return null
            }(e) || o.replace(":", "")
          }
        ))
      }
      ,
      m.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
      }
      ,
      m.diff = function(r, f, p) {
        var h, v = this, g = A.p(f), m = E(r), y = (m.utcOffset() - this.utcOffset()) * t, b = this - m, w = function() {
          return A.m(v, m)
        };
        switch (g) {
          case d:
            h = w() / 12;
            break;
          case u:
            h = w();
            break;
          case c:
            h = w() / 3;
            break;
          case l:
            h = (b - y) / 6048e5;
            break;
          case s:
            h = (b - y) / 864e5;
            break;
          case i:
            h = b / n;
            break;
          case a:
            h = b / t;
            break;
          case o:
            h = b / e;
            break;
          default:
            h = b
        }
        return p ? h : A.a(h)
      }
      ,
      m.daysInMonth = function() {
        return this.endOf(u).$D
      }
      ,
      m.$locale = function() {
        return w[this.$L]
      }
      ,
      m.locale = function(e, t) {
        if (!e)
          return this.$L;
        var n = this.clone()
          , r = S(e, t, !0);
        return r && (n.$L = r),
          n
      }
      ,
      m.clone = function() {
        return A.w(this.$d, this)
      }
      ,
      m.toDate = function() {
        return new Date(this.valueOf())
      }
      ,
      m.toJSON = function() {
        return this.isValid() ? this.toISOString() : null
      }
      ,
      m.toISOString = function() {
        return this.$d.toISOString()
      }
      ,
      m.toString = function() {
        return this.$d.toUTCString()
      }
      ,
      g
  }()
    , k = C.prototype;
  return E.prototype = k,
    [["$ms", r], ["$s", o], ["$m", a], ["$H", i], ["$W", s], ["$M", u], ["$y", d], ["$D", f]].forEach((function(e) {
        k[e[1]] = function(t) {
          return this.$g(t, e[0], e[1])
        }
      }
    )),
    E.extend = function(e, t) {
      return e.$i || (e(t, C, E),
        e.$i = !0),
        E
    }
    ,
    E.locale = S,
    E.isDayjs = x,
    E.unix = function(e) {
      return E(1e3 * e)
    }
    ,
    E.en = w[b],
    E.Ls = w,
    E.p = {},
    E
}();
const JC = YC(QC.exports);
var ZC = {
  exports: {}
};
ZC.exports = function() {
  var e = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A"
  }
    , t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g
    , n = /\d\d/
    , r = /\d\d?/
    , o = /\d*[^-_:/,()\s\d]+/
    , a = {}
    , i = function(e) {
    return (e = +e) + (e > 68 ? 1900 : 2e3)
  }
    , s = function(e) {
    return function(t) {
      this[e] = +t
    }
  }
    , l = [/[+-]\d\d:?(\d\d)?|Z/, function(e) {
    (this.zone || (this.zone = {})).offset = function(e) {
      if (!e)
        return 0;
      if ("Z" === e)
        return 0;
      var t = e.match(/([+-]|\d\d)/g)
        , n = 60 * t[1] + (+t[2] || 0);
      return 0 === n ? 0 : "+" === t[0] ? -n : n
    }(e)
  }
  ]
    , u = function(e) {
    var t = a[e];
    return t && (t.indexOf ? t : t.s.concat(t.f))
  }
    , c = function(e, t) {
    var n, r = a.meridiem;
    if (r) {
      for (var o = 1; o <= 24; o += 1)
        if (e.indexOf(r(o, 0, t)) > -1) {
          n = o > 12;
          break
        }
    } else
      n = e === (t ? "pm" : "PM");
    return n
  }
    , d = {
    A: [o, function(e) {
      this.afternoon = c(e, !1)
    }
    ],
    a: [o, function(e) {
      this.afternoon = c(e, !0)
    }
    ],
    S: [/\d/, function(e) {
      this.milliseconds = 100 * +e
    }
    ],
    SS: [n, function(e) {
      this.milliseconds = 10 * +e
    }
    ],
    SSS: [/\d{3}/, function(e) {
      this.milliseconds = +e
    }
    ],
    s: [r, s("seconds")],
    ss: [r, s("seconds")],
    m: [r, s("minutes")],
    mm: [r, s("minutes")],
    H: [r, s("hours")],
    h: [r, s("hours")],
    HH: [r, s("hours")],
    hh: [r, s("hours")],
    D: [r, s("day")],
    DD: [n, s("day")],
    Do: [o, function(e) {
      var t = a.ordinal
        , n = e.match(/\d+/);
      if (this.day = n[0],
        t)
        for (var r = 1; r <= 31; r += 1)
          t(r).replace(/\[|\]/g, "") === e && (this.day = r)
    }
    ],
    M: [r, s("month")],
    MM: [n, s("month")],
    MMM: [o, function(e) {
      var t = u("months")
        , n = (u("monthsShort") || t.map((function(e) {
          return e.slice(0, 3)
        }
      ))).indexOf(e) + 1;
      if (n < 1)
        throw new Error;
      this.month = n % 12 || n
    }
    ],
    MMMM: [o, function(e) {
      var t = u("months").indexOf(e) + 1;
      if (t < 1)
        throw new Error;
      this.month = t % 12 || t
    }
    ],
    Y: [/[+-]?\d+/, s("year")],
    YY: [n, function(e) {
      this.year = i(e)
    }
    ],
    YYYY: [/\d{4}/, s("year")],
    Z: l,
    ZZ: l
  };
  function f(n) {
    var r, o;
    r = n,
      o = a && a.formats;
    for (var i = (n = r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(t, n, r) {
        var a = r && r.toUpperCase();
        return n || o[r] || e[r] || o[a].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e, t, n) {
            return t || n.slice(1)
          }
        ))
      }
    ))).match(t), s = i.length, l = 0; l < s; l += 1) {
      var u = i[l]
        , c = d[u]
        , f = c && c[0]
        , p = c && c[1];
      i[l] = p ? {
        regex: f,
        parser: p
      } : u.replace(/^\[|\]$/g, "")
    }
    return function(e) {
      for (var t = {}, n = 0, r = 0; n < s; n += 1) {
        var o = i[n];
        if ("string" == typeof o)
          r += o.length;
        else {
          var a = o.regex
            , l = o.parser
            , u = e.slice(r)
            , c = a.exec(u)[0];
          l.call(t, c),
            e = e.replace(c, "")
        }
      }
      return function(e) {
        var t = e.afternoon;
        if (void 0 !== t) {
          var n = e.hours;
          t ? n < 12 && (e.hours += 12) : 12 === n && (e.hours = 0),
            delete e.afternoon
        }
      }(t),
        t
    }
  }
  return function(e, t, n) {
    n.p.customParseFormat = !0,
    e && e.parseTwoDigitYear && (i = e.parseTwoDigitYear);
    var r = t.prototype
      , o = r.parse;
    r.parse = function(e) {
      var t = e.date
        , r = e.utc
        , i = e.args;
      this.$u = r;
      var s = i[1];
      if ("string" == typeof s) {
        var l = !0 === i[2]
          , u = !0 === i[3]
          , c = l || u
          , d = i[2];
        u && (d = i[2]),
          a = this.$locale(),
        !l && d && (a = n.Ls[d]),
          this.$d = function(e, t, n) {
            try {
              if (["x", "X"].indexOf(t) > -1)
                return new Date(("X" === t ? 1e3 : 1) * e);
              var r = f(t)(e)
                , o = r.year
                , a = r.month
                , i = r.day
                , s = r.hours
                , l = r.minutes
                , u = r.seconds
                , c = r.milliseconds
                , d = r.zone
                , p = new Date
                , h = i || (o || a ? 1 : p.getDate())
                , v = o || p.getFullYear()
                , g = 0;
              o && !a || (g = a > 0 ? a - 1 : p.getMonth());
              var m = s || 0
                , y = l || 0
                , b = u || 0
                , w = c || 0;
              return d ? new Date(Date.UTC(v, g, h, m, y, b, w + 60 * d.offset * 1e3)) : n ? new Date(Date.UTC(v, g, h, m, y, b, w)) : new Date(v,g,h,m,y,b,w)
            } catch (x) {
              return new Date("")
            }
          }(t, s, r),
          this.init(),
        d && !0 !== d && (this.$L = this.locale(d).$L),
        c && t != this.format(s) && (this.$d = new Date("")),
          a = {}
      } else if (s instanceof Array)
        for (var p = s.length, h = 1; h <= p; h += 1) {
          i[1] = s[h - 1];
          var v = n.apply(this, i);
          if (v.isValid()) {
            this.$d = v.$d,
              this.$L = v.$L,
              this.init();
            break
          }
          h === p && (this.$d = new Date(""))
        }
      else
        o.call(this, e)
    }
  }
}();
const ek = YC(ZC.exports)
  , tk = ["hours", "minutes", "seconds"]
  , nk = "HH:mm:ss"
  , rk = "YYYY-MM-DD"
  , ok = {
  date: rk,
  dates: rk,
  week: "gggg[w]ww",
  year: "YYYY",
  years: "YYYY",
  month: "YYYY-MM",
  datetime: `${rk} ${nk}`,
  monthrange: "YYYY-MM",
  daterange: rk,
  datetimerange: `${rk} ${nk}`
}
  , ak = (e,t)=>[e > 0 ? e - 1 : void 0, e, e < t ? e + 1 : void 0]
  , ik = e=>Array.from(Array.from({
  length: e
}).keys())
  , sk = e=>e.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim()
  , lk = e=>e.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim()
  , uk = function(e, t) {
  const n = m(e)
    , r = m(t);
  return n && r ? e.getTime() === t.getTime() : !n && !r && e === t
}
  , ck = function(e, t) {
  const n = h(e)
    , r = h(t);
  return n && r ? e.length === t.length && e.every(((e,n)=>uk(e, t[n]))) : !n && !r && uk(e, t)
}
  , dk = function(e, t, n) {
  const r = Ug(t) || "x" === t ? JC(e).locale(n) : JC(e, t).locale(n);
  return r.isValid() ? r : void 0
}
  , fk = function(e, t, n) {
  return Ug(t) ? e : "x" === t ? +e : JC(e).locale(n).format(t)
}
  , pk = (e,t)=>{
  var n;
  const r = []
    , o = null == t ? void 0 : t();
  for (let a = 0; a < e; a++)
    r.push(null != (n = null == o ? void 0 : o.includes(a)) && n);
  return r
}
  , hk = uy({
  disabledHours: {
    type: Function
  },
  disabledMinutes: {
    type: Function
  },
  disabledSeconds: {
    type: Function
  }
})
  , vk = uy({
  visible: Boolean,
  actualVisible: {
    type: Boolean,
    default: void 0
  },
  format: {
    type: String,
    default: ""
  }
})
  , gk = uy({
  id: {
    type: [Array, String]
  },
  name: {
    type: [Array, String],
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  format: String,
  valueFormat: String,
  dateFormat: String,
  timeFormat: String,
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: !0
  },
  clearIcon: {
    type: [String, Object],
    default: km
  },
  editable: {
    type: Boolean,
    default: !0
  },
  prefixIcon: {
    type: [String, Object],
    default: ""
  },
  size: Ux,
  readonly: Boolean,
  disabled: Boolean,
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: ()=>({})
  },
  modelValue: {
    type: [Date, Array, String, Number],
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: [Date, Array]
  },
  defaultTime: {
    type: [Date, Array]
  },
  isRange: Boolean,
  ...hk,
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: ()=>[]
  },
  arrowControl: Boolean,
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  unlinkPanels: Boolean
})
  , mk = ["id", "name", "placeholder", "value", "disabled", "readonly"]
  , yk = ["id", "name", "placeholder", "value", "disabled", "readonly"]
  , bk = vr({
  name: "Picker"
})
  , wk = vr({
  ...bk,
  props: gk,
  emits: ["update:modelValue", "change", "focus", "blur", "calendar-change", "panel-change", "visible-change", "keydown"],
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = ho()
      , {lang: a} = Hy()
      , i = qy("date")
      , s = qy("input")
      , l = qy("range")
      , {form: u, formItem: c} = gS()
      , d = jo("ElPopperOptions", {})
      , f = Ft()
      , p = Ft()
      , v = Ft(!1)
      , g = Ft(!1)
      , m = Ft(null);
    let y = !1
      , b = !1;
    const w = yi((()=>[i.b("editor"), i.bm("editor", r.type), s.e("wrapper"), i.is("disabled", F.value), i.is("active", v.value), l.b("editor"), Z ? l.bm("editor", Z.value) : "", o.class]))
      , x = yi((()=>[s.e("icon"), l.e("close-icon"), H.value ? "" : l.e("close-icon--hidden")]));
    Jn(v, (e=>{
        e ? hn((()=>{
            e && (m.value = r.modelValue)
          }
        )) : (re.value = null,
          hn((()=>{
              S(r.modelValue)
            }
          )))
      }
    ));
    const S = (e,t)=>{
        !t && ck(e, m.value) || (n("change", e),
        r.validateEvent && (null == c || c.validate("change").catch((e=>{}
        ))))
      }
      , E = e=>{
        if (!ck(r.modelValue, e)) {
          let t;
          h(e) ? t = e.map((e=>fk(e, r.valueFormat, a.value))) : e && (t = fk(e, r.valueFormat, a.value)),
            n("update:modelValue", e ? t : e, a.value)
        }
      }
      , A = yi((()=>{
          if (p.value) {
            const e = J.value ? p.value : p.value.$el;
            return Array.from(e.querySelectorAll("input"))
          }
          return []
        }
      ))
      , C = (e,t,n)=>{
        const r = A.value;
        r.length && (n && "min" !== n ? "max" === n && (r[1].setSelectionRange(e, t),
          r[1].focus()) : (r[0].setSelectionRange(e, t),
          r[0].focus()))
      }
      , k = (e="",t=!1)=>{
        let n;
        t || (b = !0),
          v.value = t,
          n = h(e) ? e.map((e=>e.toDate())) : e ? e.toDate() : e,
          re.value = null,
          E(n)
      }
      , T = ()=>{
        g.value = !0
      }
      , D = ()=>{
        n("visible-change", !0)
      }
      , O = e=>{
        (null == e ? void 0 : e.key) === by.esc && R(!0, !0)
      }
      , _ = ()=>{
        g.value = !1,
          v.value = !1,
          b = !1,
          n("visible-change", !1)
      }
      , R = (e=!0,t=!1)=>{
        b = t;
        const [n,r] = Vt(A);
        let o = n;
        !e && J.value && (o = r),
        o && o.focus()
      }
      , L = e=>{
        r.readonly || F.value || v.value || b || (v.value = !0,
          n("focus", e))
      }
    ;
    let I;
    const P = e=>{
      const t = async()=>{
          setTimeout((()=>{
              var o;
              I === t && ((null == (o = f.value) ? void 0 : o.isFocusInsideContent()) && !y || 0 !== A.value.filter((e=>e.contains(document.activeElement))).length || (oe(),
                v.value = !1,
                n("blur", e),
              r.validateEvent && (null == c || c.validate("blur").catch((e=>{}
              )))),
                y = !1)
            }
          ), 0)
        }
      ;
      I = t,
        t()
    }
      , F = yi((()=>r.disabled || (null == u ? void 0 : u.disabled)))
      , B = yi((()=>{
        let e;
        if (W.value ? he.value.getDefaultValue && (e = he.value.getDefaultValue()) : e = h(r.modelValue) ? r.modelValue.map((e=>dk(e, r.valueFormat, a.value))) : dk(r.modelValue, r.valueFormat, a.value),
          he.value.getRangeAvailableTime) {
          const t = he.value.getRangeAvailableTime(e);
          Ag(t, e) || (e = t,
            E(h(e) ? e.map((e=>e.toDate())) : e.toDate()))
        }
        return h(e) && e.some((e=>!e)) && (e = []),
          e
      }
    ))
      , N = yi((()=>{
        if (!he.value.panelReady)
          return "";
        const e = ie(B.value);
        return h(re.value) ? [re.value[0] || e && e[0] || "", re.value[1] || e && e[1] || ""] : null !== re.value ? re.value : !j.value && W.value || !v.value && W.value ? "" : e ? V.value || U.value ? e.join(", ") : e : ""
      }
    ))
      , M = yi((()=>r.type.includes("time")))
      , j = yi((()=>r.type.startsWith("time")))
      , V = yi((()=>"dates" === r.type))
      , U = yi((()=>"years" === r.type))
      , $ = yi((()=>r.prefixIcon || (M.value ? Tm : bm)))
      , H = Ft(!1)
      , K = e=>{
      r.readonly || F.value || H.value && (e.stopPropagation(),
        R(!0, !0),
        hn((()=>{
            b = !1
          }
        )),
        E(null),
        S(null, !0),
        H.value = !1,
        v.value = !1,
      he.value.handleClear && he.value.handleClear())
    }
      , W = yi((()=>{
        const {modelValue: e} = r;
        return !e || h(e) && !e.filter(Boolean).length
      }
    ))
      , G = async e=>{
      var t;
      r.readonly || F.value || ("INPUT" !== (null == (t = e.target) ? void 0 : t.tagName) || A.value.includes(document.activeElement)) && (v.value = !0)
    }
      , q = ()=>{
      r.readonly || F.value || !W.value && r.clearable && (H.value = !0)
    }
      , X = ()=>{
      H.value = !1
    }
      , Q = e=>{
      var t;
      r.readonly || F.value || ("INPUT" !== (null == (t = e.touches[0].target) ? void 0 : t.tagName) || A.value.includes(document.activeElement)) && (v.value = !0)
    }
      , J = yi((()=>r.type.includes("range")))
      , Z = hS()
      , ee = yi((()=>{
        var e, t;
        return null == (t = null == (e = Vt(f)) ? void 0 : e.popperRef) ? void 0 : t.contentRef
      }
    ))
      , ne = yi((()=>{
        var e;
        return Vt(J) ? Vt(p) : null == (e = Vt(p)) ? void 0 : e.$el
      }
    ));
    Ic(ne, (e=>{
        const t = Vt(ee)
          , n = Vt(ne);
        t && (e.target === t || e.composedPath().includes(t)) || e.target === n || e.composedPath().includes(n) || (v.value = !1)
      }
    ));
    const re = Ft(null)
      , oe = ()=>{
        if (re.value) {
          const e = ae(N.value);
          e && se(e) && (E(h(e) ? e.map((e=>e.toDate())) : e.toDate()),
            re.value = null)
        }
        "" === re.value && (E(null),
          S(null),
          re.value = null)
      }
      , ae = e=>e ? he.value.parseUserInput(e) : null
      , ie = e=>e ? he.value.formatToString(e) : null
      , se = e=>he.value.isValidValue(e)
      , le = async e=>{
        if (r.readonly || F.value)
          return;
        const {code: t} = e;
        if (n("keydown", e),
        t !== by.esc)
          if (t === by.down && (he.value.handleFocusPicker && (e.preventDefault(),
            e.stopPropagation()),
          !1 === v.value && (v.value = !0,
            await hn()),
            he.value.handleFocusPicker))
            he.value.handleFocusPicker();
          else {
            if (t !== by.tab)
              return t === by.enter || t === by.numpadEnter ? ((null === re.value || "" === re.value || se(ae(N.value))) && (oe(),
                v.value = !1),
                void e.stopPropagation()) : void (re.value ? e.stopPropagation() : he.value.handleKeydownInput && he.value.handleKeydownInput(e));
            y = !0
          }
        else
          !0 === v.value && (v.value = !1,
            e.preventDefault(),
            e.stopPropagation())
      }
      , ue = e=>{
        re.value = e,
        v.value || (v.value = !0)
      }
      , ce = e=>{
        const t = e.target;
        re.value ? re.value = [t.value, re.value[1]] : re.value = [t.value, null]
      }
      , de = e=>{
        const t = e.target;
        re.value ? re.value = [re.value[0], t.value] : re.value = [null, t.value]
      }
      , fe = ()=>{
        var e;
        const t = re.value
          , n = ae(t && t[0])
          , r = Vt(B);
        if (n && n.isValid()) {
          re.value = [ie(n), (null == (e = N.value) ? void 0 : e[1]) || null];
          const t = [n, r && (r[1] || null)];
          se(t) && (E(t),
            re.value = null)
        }
      }
      , pe = ()=>{
        var e;
        const t = Vt(re)
          , n = ae(t && t[1])
          , r = Vt(B);
        if (n && n.isValid()) {
          re.value = [(null == (e = Vt(N)) ? void 0 : e[0]) || null, ie(n)];
          const t = [r && r[0], n];
          se(t) && (E(t),
            re.value = null)
        }
      }
      , he = Ft({})
      , ve = e=>{
        he.value[e[0]] = e[1],
          he.value.panelReady = !0
      }
      , ge = e=>{
        n("calendar-change", e)
      }
      , me = (e,t,r)=>{
        n("panel-change", e, t, r)
      }
    ;
    return Mo("EP_PICKER_BASE", {
      props: r
    }),
      t({
        focus: R,
        handleFocusInput: L,
        handleBlurInput: P,
        handleOpen: ()=>{
          v.value = !0
        }
        ,
        handleClose: ()=>{
          v.value = !1
        }
        ,
        onPick: k
      }),
      (e,t)=>(Ca(),
        Ra(Vt(MA), qa({
          ref_key: "refPopper",
          ref: f,
          visible: v.value,
          effect: "light",
          pure: "",
          trigger: "click"
        }, e.$attrs, {
          role: "dialog",
          teleported: "",
          transition: `${Vt(i).namespace.value}-zoom-in-top`,
          "popper-class": [`${Vt(i).namespace.value}-picker__popper`, e.popperClass],
          "popper-options": Vt(d),
          "fallback-placements": ["bottom", "top", "right", "left"],
          "gpu-acceleration": !1,
          "stop-popper-mouse-event": !1,
          "hide-after": 0,
          persistent: "",
          onBeforeShow: T,
          onShow: D,
          onHide: _
        }), {
          default: Fn((()=>[Vt(J) ? (Ca(),
            _a("div", {
              key: 1,
              ref_key: "inputRef",
              ref: p,
              class: Y(Vt(w)),
              style: z(e.$attrs.style),
              onClick: L,
              onMouseenter: q,
              onMouseleave: X,
              onTouchstart: Q,
              onKeydown: le
            }, [Vt($) ? (Ca(),
              Ra(Vt(sS), {
                key: 0,
                class: Y([Vt(s).e("icon"), Vt(l).e("icon")]),
                onMousedown: js(G, ["prevent"]),
                onTouchstart: Q
              }, {
                default: Fn((()=>[(Ca(),
                  Ra(Kr(Vt($))))])),
                _: 1
              }, 8, ["class", "onMousedown"])) : za("v-if", !0), Ma("input", {
              id: e.id && e.id[0],
              autocomplete: "off",
              name: e.name && e.name[0],
              placeholder: e.startPlaceholder,
              value: Vt(N) && Vt(N)[0],
              disabled: Vt(F),
              readonly: !e.editable || e.readonly,
              class: Y(Vt(l).b("input")),
              onMousedown: G,
              onInput: ce,
              onChange: fe,
              onFocus: L,
              onBlur: P
            }, null, 42, mk), Qr(e.$slots, "range-separator", {}, (()=>[Ma("span", {
              class: Y(Vt(l).b("separator"))
            }, te(e.rangeSeparator), 3)])), Ma("input", {
              id: e.id && e.id[1],
              autocomplete: "off",
              name: e.name && e.name[1],
              placeholder: e.endPlaceholder,
              value: Vt(N) && Vt(N)[1],
              disabled: Vt(F),
              readonly: !e.editable || e.readonly,
              class: Y(Vt(l).b("input")),
              onMousedown: G,
              onFocus: L,
              onBlur: P,
              onInput: de,
              onChange: pe
            }, null, 42, yk), e.clearIcon ? (Ca(),
              Ra(Vt(sS), {
                key: 1,
                class: Y(Vt(x)),
                onClick: K
              }, {
                default: Fn((()=>[(Ca(),
                  Ra(Kr(e.clearIcon)))])),
                _: 1
              }, 8, ["class"])) : za("v-if", !0)], 38)) : (Ca(),
            Ra(Vt(yE), {
              key: 0,
              id: e.id,
              ref_key: "inputRef",
              ref: p,
              "container-role": "combobox",
              "model-value": Vt(N),
              name: e.name,
              size: Vt(Z),
              disabled: Vt(F),
              placeholder: e.placeholder,
              class: Y([Vt(i).b("editor"), Vt(i).bm("editor", e.type), e.$attrs.class]),
              style: z(e.$attrs.style),
              readonly: !e.editable || e.readonly || Vt(V) || Vt(U) || "week" === e.type,
              label: e.label,
              tabindex: e.tabindex,
              "validate-event": !1,
              onInput: ue,
              onFocus: L,
              onBlur: P,
              onKeydown: le,
              onChange: oe,
              onMousedown: G,
              onMouseenter: q,
              onMouseleave: X,
              onTouchstart: Q,
              onClick: t[0] || (t[0] = js((()=>{}
              ), ["stop"]))
            }, {
              prefix: Fn((()=>[Vt($) ? (Ca(),
                Ra(Vt(sS), {
                  key: 0,
                  class: Y(Vt(s).e("icon")),
                  onMousedown: js(G, ["prevent"]),
                  onTouchstart: Q
                }, {
                  default: Fn((()=>[(Ca(),
                    Ra(Kr(Vt($))))])),
                  _: 1
                }, 8, ["class", "onMousedown"])) : za("v-if", !0)])),
              suffix: Fn((()=>[H.value && e.clearIcon ? (Ca(),
                Ra(Vt(sS), {
                  key: 0,
                  class: Y(`${Vt(s).e("icon")} clear-icon`),
                  onClick: js(K, ["stop"])
                }, {
                  default: Fn((()=>[(Ca(),
                    Ra(Kr(e.clearIcon)))])),
                  _: 1
                }, 8, ["class", "onClick"])) : za("v-if", !0)])),
              _: 1
            }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onKeydown"]))])),
          content: Fn((()=>[Qr(e.$slots, "default", {
            visible: v.value,
            actualVisible: g.value,
            parsedValue: Vt(B),
            format: e.format,
            dateFormat: e.dateFormat,
            timeFormat: e.timeFormat,
            unlinkPanels: e.unlinkPanels,
            type: e.type,
            defaultValue: e.defaultValue,
            onPick: k,
            onSelectRange: C,
            onSetPickerOption: ve,
            onCalendarChange: ge,
            onPanelChange: me,
            onKeydown: O,
            onMousedown: t[1] || (t[1] = js((()=>{}
            ), ["stop"]))
          })])),
          _: 3
        }, 16, ["visible", "transition", "popper-class", "popper-options"]))
  }
});
var xk = tS(wk, [["__file", "picker.vue"]]);
const Sk = uy({
  ...vk,
  datetimeRole: String,
  parsedValue: {
    type: Object
  }
})
  , Ek = ({getAvailableHours: e, getAvailableMinutes: t, getAvailableSeconds: n})=>{
  const r = {};
  return {
    timePickerOptions: r,
    getAvailableTime: (r,o,a,i)=>{
      const s = {
        hour: e,
        minute: t,
        second: n
      };
      let l = r;
      return ["hour", "minute", "second"].forEach((e=>{
          if (s[e]) {
            let t;
            const n = s[e];
            switch (e) {
              case "minute":
                t = n(l.hour(), o, i);
                break;
              case "second":
                t = n(l.hour(), l.minute(), o, i);
                break;
              default:
                t = n(o, i)
            }
            if ((null == t ? void 0 : t.length) && !t.includes(l[e]())) {
              const n = a ? 0 : t.length - 1;
              l = l[e](t[n])
            }
          }
        }
      )),
        l
    }
    ,
    onSetOption: ([e,t])=>{
      r[e] = t
    }
  }
}
  , Ak = e=>e.map(((e,t)=>e || t)).filter((e=>!0 !== e))
  , Ck = (e,t,n)=>({
  getHoursList: (t,n)=>pk(24, e && (()=>null == e ? void 0 : e(t, n))),
  getMinutesList: (e,n,r)=>pk(60, t && (()=>null == t ? void 0 : t(e, n, r))),
  getSecondsList: (e,t,r,o)=>pk(60, n && (()=>null == n ? void 0 : n(e, t, r, o)))
})
  , kk = (e,t,n)=>{
  const {getHoursList: r, getMinutesList: o, getSecondsList: a} = Ck(e, t, n);
  return {
    getAvailableHours: (e,t)=>Ak(r(e, t)),
    getAvailableMinutes: (e,t,n)=>Ak(o(e, t, n)),
    getAvailableSeconds: (e,t,n,r)=>Ak(a(e, t, n, r))
  }
}
  , Tk = e=>{
  const t = Ft(e.parsedValue);
  return Jn((()=>e.visible), (n=>{
      n || (t.value = e.parsedValue)
    }
  )),
    t
}
  , Dk = new Map;
let Ok;
function _k(e, t) {
  let n = [];
  return Array.isArray(t.arg) ? n = t.arg : $g(t.arg) && n.push(t.arg),
    function(r, o) {
      const a = t.instance.popperRef
        , i = r.target
        , s = null == o ? void 0 : o.target
        , l = !t || !t.instance
        , u = !i || !s
        , c = e.contains(i) || e.contains(s)
        , d = e === i
        , f = n.length && n.some((e=>null == e ? void 0 : e.contains(i))) || n.length && n.includes(s)
        , p = a && (a.contains(i) || a.contains(s));
      l || u || c || d || f || p || t.value(r, o)
    }
}
mc && (document.addEventListener("mousedown", (e=>Ok = e)),
  document.addEventListener("mouseup", (e=>{
      for (const t of Dk.values())
        for (const {documentHandler: n} of t)
          n(e, Ok)
    }
  )));
const Rk = {
  beforeMount(e, t) {
    Dk.has(e) || Dk.set(e, []),
      Dk.get(e).push({
        documentHandler: _k(e, t),
        bindingFn: t.value
      })
  },
  updated(e, t) {
    Dk.has(e) || Dk.set(e, []);
    const n = Dk.get(e)
      , r = n.findIndex((e=>e.bindingFn === t.oldValue))
      , o = {
      documentHandler: _k(e, t),
      bindingFn: t.value
    };
    r >= 0 ? n.splice(r, 1, o) : n.push(o)
  },
  unmounted(e) {
    Dk.delete(e)
  }
}
  , Lk = 100
  , Ik = 600
  , Pk = {
  beforeMount(e, t) {
    const n = t.value
      , {interval: r=Lk, delay: o=Ik} = y(n) ? {} : n;
    let a, i;
    const s = ()=>y(n) ? n() : n.handler()
      , l = ()=>{
        i && (clearTimeout(i),
          i = void 0),
        a && (clearInterval(a),
          a = void 0)
      }
    ;
    e.addEventListener("mousedown", (e=>{
        0 === e.button && (l(),
          s(),
          document.addEventListener("mouseup", (()=>l()), {
            once: !0
          }),
          i = setTimeout((()=>{
              a = setInterval((()=>{
                  s()
                }
              ), r)
            }
          ), o))
      }
    ))
  }
}
  , Fk = "_trap-focus-children"
  , Bk = []
  , Nk = e=>{
  if (0 === Bk.length)
    return;
  const t = Bk[Bk.length - 1][Fk];
  if (t.length > 0 && e.code === by.tab) {
    if (1 === t.length)
      return e.preventDefault(),
        void (document.activeElement !== t[0] && t[0].focus());
    const n = e.shiftKey
      , r = e.target === t[0]
      , o = e.target === t[t.length - 1];
    r && n && (e.preventDefault(),
      t[t.length - 1].focus()),
    o && !n && (e.preventDefault(),
      t[0].focus())
  }
}
  , Mk = {
  beforeMount(e) {
    e[Fk] = ec(e),
      Bk.push(e),
    Bk.length <= 1 && document.addEventListener("keydown", Nk)
  },
  updated(e) {
    hn((()=>{
        e[Fk] = ec(e)
      }
    ))
  },
  unmounted() {
    Bk.shift(),
    0 === Bk.length && document.removeEventListener("keydown", Nk)
  }
};
var jk, Vk, Uk, $k, Hk, zk, Kk, Wk, Gk, qk, Yk, Xk, Qk, Jk, Zk, eT = !1;
function tT() {
  if (!eT) {
    eT = !0;
    var e = navigator.userAgent
      , t = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e)
      , n = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
    if (Xk = /\b(iPhone|iP[ao]d)/.exec(e),
      Qk = /\b(iP[ao]d)/.exec(e),
      qk = /Android/i.exec(e),
      Jk = /FBAN\/\w+;/i.exec(e),
      Zk = /Mobile/i.exec(e),
      Yk = !!/Win64/.exec(e),
      t) {
      (jk = t[1] ? parseFloat(t[1]) : t[5] ? parseFloat(t[5]) : NaN) && document && document.documentMode && (jk = document.documentMode);
      var r = /(?:Trident\/(\d+.\d+))/.exec(e);
      zk = r ? parseFloat(r[1]) + 4 : jk,
        Vk = t[2] ? parseFloat(t[2]) : NaN,
        Uk = t[3] ? parseFloat(t[3]) : NaN,
        ($k = t[4] ? parseFloat(t[4]) : NaN) ? (t = /(?:Chrome\/(\d+\.\d+))/.exec(e),
          Hk = t && t[1] ? parseFloat(t[1]) : NaN) : Hk = NaN
    } else
      jk = Vk = Uk = Hk = $k = NaN;
    if (n) {
      if (n[1]) {
        var o = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
        Kk = !o || parseFloat(o[1].replace("_", "."))
      } else
        Kk = !1;
      Wk = !!n[2],
        Gk = !!n[3]
    } else
      Kk = Wk = Gk = !1
  }
}
var nT, rT = {
  ie: function() {
    return tT() || jk
  },
  ieCompatibilityMode: function() {
    return tT() || zk > jk
  },
  ie64: function() {
    return rT.ie() && Yk
  },
  firefox: function() {
    return tT() || Vk
  },
  opera: function() {
    return tT() || Uk
  },
  webkit: function() {
    return tT() || $k
  },
  safari: function() {
    return rT.webkit()
  },
  chrome: function() {
    return tT() || Hk
  },
  windows: function() {
    return tT() || Wk
  },
  osx: function() {
    return tT() || Kk
  },
  linux: function() {
    return tT() || Gk
  },
  iphone: function() {
    return tT() || Xk
  },
  mobile: function() {
    return tT() || Xk || Qk || qk || Zk
  },
  nativeApp: function() {
    return tT() || Jk
  },
  android: function() {
    return tT() || qk
  },
  ipad: function() {
    return tT() || Qk
  }
}, oT = rT, aT = !!(typeof window < "u" && window.document && window.document.createElement), iT = {
  canUseDOM: aT,
  canUseWorkers: typeof Worker < "u",
  canUseEventListeners: aT && !(!window.addEventListener && !window.attachEvent),
  canUseViewport: aT && !!window.screen,
  isInWorker: !aT
};
iT.canUseDOM && (nT = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", ""));
var sT = function(e, t) {
  if (!iT.canUseDOM || t && !("addEventListener"in document))
    return !1;
  var n = "on" + e
    , r = n in document;
  if (!r) {
    var o = document.createElement("div");
    o.setAttribute(n, "return;"),
      r = "function" == typeof o[n]
  }
  return !r && nT && "wheel" === e && (r = document.implementation.hasFeature("Events.wheel", "3.0")),
    r
};
function lT(e) {
  var t = 0
    , n = 0
    , r = 0
    , o = 0;
  return "detail"in e && (n = e.detail),
  "wheelDelta"in e && (n = -e.wheelDelta / 120),
  "wheelDeltaY"in e && (n = -e.wheelDeltaY / 120),
  "wheelDeltaX"in e && (t = -e.wheelDeltaX / 120),
  "axis"in e && e.axis === e.HORIZONTAL_AXIS && (t = n,
    n = 0),
    r = 10 * t,
    o = 10 * n,
  "deltaY"in e && (o = e.deltaY),
  "deltaX"in e && (r = e.deltaX),
  (r || o) && e.deltaMode && (1 == e.deltaMode ? (r *= 40,
    o *= 40) : (r *= 800,
    o *= 800)),
  r && !t && (t = r < 1 ? -1 : 1),
  o && !n && (n = o < 1 ? -1 : 1),
    {
      spinX: t,
      spinY: n,
      pixelX: r,
      pixelY: o
    }
}
lT.getEventType = function() {
  return oT.firefox() ? "DOMMouseScroll" : sT("wheel") ? "wheel" : "mousewheel"
}
;
var uT = lT;
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
const cT = {
  beforeMount(e, t) {
    !function(e, t) {
      if (e && e.addEventListener) {
        const n = function(e) {
          const n = uT(e);
          t && Reflect.apply(t, this, [e, n])
        };
        e.addEventListener("wheel", n, {
          passive: !0
        })
      }
    }(e, t.value)
  }
}
  , dT = uy({
  role: {
    type: String,
    required: !0
  },
  spinnerDate: {
    type: Object,
    required: !0
  },
  showSeconds: {
    type: Boolean,
    default: !0
  },
  arrowControl: Boolean,
  amPmMode: {
    type: String,
    default: ""
  },
  ...hk
})
  , fT = ["onClick"]
  , pT = ["onMouseenter"];
var hT = tS(vr({
  __name: "basic-time-spinner",
  props: dT,
  emits: ["change", "select-range", "set-option"],
  setup(e, {emit: t}) {
    const n = e
      , r = qy("time")
      , {getHoursList: o, getMinutesList: a, getSecondsList: i} = Ck(n.disabledHours, n.disabledMinutes, n.disabledSeconds);
    let s = !1;
    const l = Ft()
      , u = {
        hours: Ft(),
        minutes: Ft(),
        seconds: Ft()
      }
      , c = yi((()=>n.showSeconds ? tk : tk.slice(0, 2)))
      , d = yi((()=>{
          const {spinnerDate: e} = n;
          return {
            hours: e.hour(),
            minutes: e.minute(),
            seconds: e.second()
          }
        }
      ))
      , f = yi((()=>{
          const {hours: e, minutes: t} = Vt(d);
          return {
            hours: o(n.role),
            minutes: a(e, n.role),
            seconds: i(e, t, n.role)
          }
        }
      ))
      , p = yi((()=>{
          const {hours: e, minutes: t, seconds: n} = Vt(d);
          return {
            hours: ak(e, 23),
            minutes: ak(t, 59),
            seconds: ak(n, 59)
          }
        }
      ))
      , h = ug((e=>{
          s = !1,
            m(e)
        }
      ), 200)
      , v = e=>{
        if (!!!n.amPmMode)
          return "";
        let t = e < 12 ? " am" : " pm";
        return "A" === n.amPmMode && (t = t.toUpperCase()),
          t
      }
      , g = e=>{
        let n;
        switch (e) {
          case "hours":
            n = [0, 2];
            break;
          case "minutes":
            n = [3, 5];
            break;
          case "seconds":
            n = [6, 8]
        }
        const [r,o] = n;
        t("select-range", r, o),
          l.value = e
      }
      , m = e=>{
        w(e, Vt(d)[e])
      }
      , y = ()=>{
        m("hours"),
          m("minutes"),
          m("seconds")
      }
      , b = e=>e.querySelector(`.${r.namespace.value}-scrollbar__wrap`)
      , w = (e,t)=>{
        if (n.arrowControl)
          return;
        const r = Vt(u[e]);
        r && r.$el && (b(r.$el).scrollTop = Math.max(0, t * x(e)))
      }
      , x = e=>{
        const t = Vt(u[e])
          , n = null == t ? void 0 : t.$el.querySelector("li");
        return n && Number.parseFloat(rm(n, "height")) || 0
      }
      , S = ()=>{
        A(1)
      }
      , E = ()=>{
        A(-1)
      }
      , A = e=>{
        l.value || g("hours");
        const t = l.value
          , n = Vt(d)[t]
          , r = "hours" === l.value ? 24 : 60
          , o = C(t, n, e, r);
        k(t, o),
          w(t, o),
          hn((()=>g(t)))
      }
      , C = (e,t,n,r)=>{
        let o = (t + n + r) % r;
        const a = Vt(f)[e];
        for (; a[o] && o !== t; )
          o = (o + n + r) % r;
        return o
      }
      , k = (e,r)=>{
        if (Vt(f)[e][r])
          return;
        const {hours: o, minutes: a, seconds: i} = Vt(d);
        let s;
        switch (e) {
          case "hours":
            s = n.spinnerDate.hour(r).minute(a).second(i);
            break;
          case "minutes":
            s = n.spinnerDate.hour(o).minute(r).second(i);
            break;
          case "seconds":
            s = n.spinnerDate.hour(o).minute(a).second(r)
        }
        t("change", s)
      }
      , T = e=>Vt(u[e]).$el.offsetHeight
      , D = ()=>{
        const e = e=>{
            const t = Vt(u[e]);
            t && t.$el && (b(t.$el).onscroll = ()=>{
                (e=>{
                    s = !0,
                      h(e);
                    const t = Math.min(Math.round((b(Vt(u[e]).$el).scrollTop - (.5 * T(e) - 10) / x(e) + 3) / x(e)), "hours" === e ? 23 : 59);
                    k(e, t)
                  }
                )(e)
              }
            )
          }
        ;
        e("hours"),
          e("minutes"),
          e("seconds")
      }
    ;
    Lr((()=>{
        hn((()=>{
            !n.arrowControl && D(),
              y(),
            "start" === n.role && g("hours")
          }
        ))
      }
    ));
    return t("set-option", [`${n.role}_scrollDown`, A]),
      t("set-option", [`${n.role}_emitSelectRange`, g]),
      Jn((()=>n.spinnerDate), (()=>{
          s || y()
        }
      )),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y([Vt(r).b("spinner"), {
            "has-seconds": e.showSeconds
          }])
        }, [e.arrowControl ? za("v-if", !0) : (Ca(!0),
          _a(ba, {
            key: 0
          }, Yr(Vt(c), (t=>(Ca(),
            Ra(Vt(DE), {
              key: t,
              ref_for: !0,
              ref: e=>((e,t)=>{
                  u[t].value = e
                }
              )(e, t),
              class: Y(Vt(r).be("spinner", "wrapper")),
              "wrap-style": "max-height: inherit;",
              "view-class": Vt(r).be("spinner", "list"),
              noresize: "",
              tag: "ul",
              onMouseenter: e=>g(t),
              onMousemove: e=>m(t)
            }, {
              default: Fn((()=>[(Ca(!0),
                _a(ba, null, Yr(Vt(f)[t], ((n,o)=>(Ca(),
                  _a("li", {
                    key: o,
                    class: Y([Vt(r).be("spinner", "item"), Vt(r).is("active", o === Vt(d)[t]), Vt(r).is("disabled", n)]),
                    onClick: e=>((e,{value: t, disabled: n})=>{
                        n || (k(e, t),
                          g(e),
                          w(e, t))
                      }
                    )(t, {
                      value: o,
                      disabled: n
                    })
                  }, ["hours" === t ? (Ca(),
                    _a(ba, {
                      key: 0
                    }, [$a(te(("0" + (e.amPmMode ? o % 12 || 12 : o)).slice(-2)) + te(v(o)), 1)], 64)) : (Ca(),
                    _a(ba, {
                      key: 1
                    }, [$a(te(("0" + o).slice(-2)), 1)], 64))], 10, fT)))), 128))])),
              _: 2
            }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"])))), 128)), e.arrowControl ? (Ca(!0),
          _a(ba, {
            key: 1
          }, Yr(Vt(c), (t=>(Ca(),
            _a("div", {
              key: t,
              class: Y([Vt(r).be("spinner", "wrapper"), Vt(r).is("arrow")]),
              onMouseenter: e=>g(t)
            }, [rr((Ca(),
              Ra(Vt(sS), {
                class: Y(["arrow-up", Vt(r).be("spinner", "arrow")])
              }, {
                default: Fn((()=>[ja(Vt(mm))])),
                _: 1
              }, 8, ["class"])), [[Vt(Pk), E]]), rr((Ca(),
              Ra(Vt(sS), {
                class: Y(["arrow-down", Vt(r).be("spinner", "arrow")])
              }, {
                default: Fn((()=>[ja(Vt(hm))])),
                _: 1
              }, 8, ["class"])), [[Vt(Pk), S]]), Ma("ul", {
              class: Y(Vt(r).be("spinner", "list"))
            }, [(Ca(!0),
              _a(ba, null, Yr(Vt(p)[t], ((n,o)=>(Ca(),
                _a("li", {
                  key: o,
                  class: Y([Vt(r).be("spinner", "item"), Vt(r).is("active", n === Vt(d)[t]), Vt(r).is("disabled", Vt(f)[t][n])])
                }, ["number" == typeof n ? (Ca(),
                  _a(ba, {
                    key: 0
                  }, ["hours" === t ? (Ca(),
                    _a(ba, {
                      key: 0
                    }, [$a(te(("0" + (e.amPmMode ? n % 12 || 12 : n)).slice(-2)) + te(v(n)), 1)], 64)) : (Ca(),
                    _a(ba, {
                      key: 1
                    }, [$a(te(("0" + n).slice(-2)), 1)], 64))], 64)) : za("v-if", !0)], 2)))), 128))], 2)], 42, pT)))), 128)) : za("v-if", !0)], 2))
  }
}), [["__file", "basic-time-spinner.vue"]]);
const vT = vr({
  __name: "panel-time-pick",
  props: Sk,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(e, {emit: t}) {
    const n = e
      , r = jo("EP_PICKER_BASE")
      , {arrowControl: o, disabledHours: a, disabledMinutes: i, disabledSeconds: s, defaultValue: l} = r.props
      , {getAvailableHours: u, getAvailableMinutes: c, getAvailableSeconds: d} = kk(a, i, s)
      , f = qy("time")
      , {t: p, lang: h} = Hy()
      , v = Ft([0, 2])
      , g = Tk(n)
      , m = yi((()=>Mg(n.actualVisible) ? `${f.namespace.value}-zoom-in-top` : ""))
      , y = yi((()=>n.format.includes("ss")))
      , b = yi((()=>n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""))
      , w = ()=>{
      t("pick", g.value, !1)
    }
      , x = e=>{
      if (!n.visible)
        return;
      const r = k(e).millisecond(0);
      t("pick", r, !0)
    }
      , S = (e,n)=>{
      t("select-range", e, n),
        v.value = [e, n]
    }
      , {timePickerOptions: E, onSetOption: A, getAvailableTime: C} = Ek({
      getAvailableHours: u,
      getAvailableMinutes: c,
      getAvailableSeconds: d
    })
      , k = e=>C(e, n.datetimeRole || "", !0);
    return t("set-picker-option", ["isValidValue", e=>{
      const t = JC(e).locale(h.value)
        , n = k(t);
      return t.isSame(n)
    }
    ]),
      t("set-picker-option", ["formatToString", e=>e ? e.format(n.format) : null]),
      t("set-picker-option", ["parseUserInput", e=>e ? JC(e, n.format).locale(h.value) : null]),
      t("set-picker-option", ["handleKeydownInput", e=>{
        const t = e.code
          , {left: n, right: r, up: o, down: a} = by;
        if ([n, r].includes(t)) {
          return (e=>{
              const t = [0, 3].concat(y.value ? [6] : [])
                , n = ["hours", "minutes"].concat(y.value ? ["seconds"] : [])
                , r = (t.indexOf(v.value[0]) + e + t.length) % t.length;
              E.start_emitSelectRange(n[r])
            }
          )(t === n ? -1 : 1),
            void e.preventDefault()
        }
        if ([o, a].includes(t)) {
          const n = t === o ? -1 : 1;
          return E.start_scrollDown(n),
            void e.preventDefault()
        }
      }
      ]),
      t("set-picker-option", ["getRangeAvailableTime", k]),
      t("set-picker-option", ["getDefaultValue", ()=>JC(l).locale(h.value)]),
      (e,r)=>(Ca(),
        Ra(es, {
          name: Vt(m)
        }, {
          default: Fn((()=>[e.actualVisible || e.visible ? (Ca(),
            _a("div", {
              key: 0,
              class: Y(Vt(f).b("panel"))
            }, [Ma("div", {
              class: Y([Vt(f).be("panel", "content"), {
                "has-seconds": Vt(y)
              }])
            }, [ja(hT, {
              ref: "spinner",
              role: e.datetimeRole || "start",
              "arrow-control": Vt(o),
              "show-seconds": Vt(y),
              "am-pm-mode": Vt(b),
              "spinner-date": e.parsedValue,
              "disabled-hours": Vt(a),
              "disabled-minutes": Vt(i),
              "disabled-seconds": Vt(s),
              onChange: x,
              onSetOption: Vt(A),
              onSelectRange: S
            }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])], 2), Ma("div", {
              class: Y(Vt(f).be("panel", "footer"))
            }, [Ma("button", {
              type: "button",
              class: Y([Vt(f).be("panel", "btn"), "cancel"]),
              onClick: w
            }, te(Vt(p)("el.datepicker.cancel")), 3), Ma("button", {
              type: "button",
              class: Y([Vt(f).be("panel", "btn"), "confirm"]),
              onClick: r[0] || (r[0] = e=>((e=!1,r=!1)=>{
                  r || t("pick", n.parsedValue, e)
                }
              )())
            }, te(Vt(p)("el.datepicker.confirm")), 3)], 2)], 2)) : za("v-if", !0)])),
          _: 1
        }, 8, ["name"]))
  }
});
var gT = tS(vT, [["__file", "panel-time-pick.vue"]]);
const mT = uy({
  ...vk,
  parsedValue: {
    type: Array
  }
})
  , yT = ["disabled"]
  , bT = vr({
  __name: "panel-time-range",
  props: mT,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(e, {emit: t}) {
    const n = e
      , r = (e,t)=>{
      const n = [];
      for (let r = e; r <= t; r++)
        n.push(r);
      return n
    }
      , {t: o, lang: a} = Hy()
      , i = qy("time")
      , s = qy("picker")
      , l = jo("EP_PICKER_BASE")
      , {arrowControl: u, disabledHours: c, disabledMinutes: d, disabledSeconds: f, defaultValue: p} = l.props
      , v = yi((()=>[i.be("range-picker", "body"), i.be("panel", "content"), i.is("arrow", u), w.value ? "has-seconds" : ""]))
      , g = yi((()=>[i.be("range-picker", "body"), i.be("panel", "content"), i.is("arrow", u), w.value ? "has-seconds" : ""]))
      , m = yi((()=>n.parsedValue[0]))
      , y = yi((()=>n.parsedValue[1]))
      , b = Tk(n)
      , w = yi((()=>n.format.includes("ss")))
      , x = yi((()=>n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""))
      , S = e=>{
      A(e.millisecond(0), y.value)
    }
      , E = e=>{
      A(m.value, e.millisecond(0))
    }
      , A = (e,n)=>{
      t("pick", [e, n], !0)
    }
      , C = yi((()=>m.value > y.value))
      , k = Ft([0, 2])
      , T = (e,n)=>{
      t("select-range", e, n, "min"),
        k.value = [e, n]
    }
      , D = yi((()=>w.value ? 11 : 8))
      , O = (e,n)=>{
      t("select-range", e, n, "max");
      const r = Vt(D);
      k.value = [e + r, n + r]
    }
      , _ = (e,t)=>{
      const n = c ? c(e) : []
        , o = "start" === e
        , a = (t || (o ? y.value : m.value)).hour()
        , i = o ? r(a + 1, 23) : r(0, a - 1);
      return Ng(n, i)
    }
      , R = (e,t,n)=>{
      const o = d ? d(e, t) : []
        , a = "start" === t
        , i = n || (a ? y.value : m.value);
      if (e !== i.hour())
        return o;
      const s = i.minute()
        , l = a ? r(s + 1, 59) : r(0, s - 1);
      return Ng(o, l)
    }
      , L = (e,t,n,o)=>{
      const a = f ? f(e, t, n) : []
        , i = "start" === n
        , s = o || (i ? y.value : m.value)
        , l = s.hour()
        , u = s.minute();
      if (e !== l || t !== u)
        return a;
      const c = s.second()
        , d = i ? r(c + 1, 59) : r(0, c - 1);
      return Ng(a, d)
    }
      , I = ([e,t])=>[M(e, "start", !0, t), M(t, "end", !1, e)]
      , {getAvailableHours: P, getAvailableMinutes: F, getAvailableSeconds: B} = kk(_, R, L)
      , {timePickerOptions: N, getAvailableTime: M, onSetOption: j} = Ek({
      getAvailableHours: P,
      getAvailableMinutes: F,
      getAvailableSeconds: B
    });
    return t("set-picker-option", ["formatToString", e=>e ? h(e) ? e.map((e=>e.format(n.format))) : e.format(n.format) : null]),
      t("set-picker-option", ["parseUserInput", e=>e ? h(e) ? e.map((e=>JC(e, n.format).locale(a.value))) : JC(e, n.format).locale(a.value) : null]),
      t("set-picker-option", ["isValidValue", e=>{
        const t = e.map((e=>JC(e).locale(a.value)))
          , n = I(t);
        return t[0].isSame(n[0]) && t[1].isSame(n[1])
      }
      ]),
      t("set-picker-option", ["handleKeydownInput", e=>{
        const t = e.code
          , {left: n, right: r, up: o, down: a} = by;
        if ([n, r].includes(t)) {
          return (e=>{
              const t = w.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11]
                , n = ["hours", "minutes"].concat(w.value ? ["seconds"] : [])
                , r = (t.indexOf(k.value[0]) + e + t.length) % t.length
                , o = t.length / 2;
              r < o ? N.start_emitSelectRange(n[r]) : N.end_emitSelectRange(n[r - o])
            }
          )(t === n ? -1 : 1),
            void e.preventDefault()
        }
        if ([o, a].includes(t)) {
          const n = t === o ? -1 : 1
            , r = k.value[0] < D.value ? "start" : "end";
          return N[`${r}_scrollDown`](n),
            void e.preventDefault()
        }
      }
      ]),
      t("set-picker-option", ["getDefaultValue", ()=>{
        if (h(p))
          return p.map((e=>JC(e).locale(a.value)));
        const e = JC(p).locale(a.value);
        return [e, e.add(60, "m")]
      }
      ]),
      t("set-picker-option", ["getRangeAvailableTime", I]),
      (e,n)=>e.actualVisible ? (Ca(),
        _a("div", {
          key: 0,
          class: Y([Vt(i).b("range-picker"), Vt(s).b("panel")])
        }, [Ma("div", {
          class: Y(Vt(i).be("range-picker", "content"))
        }, [Ma("div", {
          class: Y(Vt(i).be("range-picker", "cell"))
        }, [Ma("div", {
          class: Y(Vt(i).be("range-picker", "header"))
        }, te(Vt(o)("el.datepicker.startTime")), 3), Ma("div", {
          class: Y(Vt(v))
        }, [ja(hT, {
          ref: "minSpinner",
          role: "start",
          "show-seconds": Vt(w),
          "am-pm-mode": Vt(x),
          "arrow-control": Vt(u),
          "spinner-date": Vt(m),
          "disabled-hours": _,
          "disabled-minutes": R,
          "disabled-seconds": L,
          onChange: S,
          onSetOption: Vt(j),
          onSelectRange: T
        }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])], 2)], 2), Ma("div", {
          class: Y(Vt(i).be("range-picker", "cell"))
        }, [Ma("div", {
          class: Y(Vt(i).be("range-picker", "header"))
        }, te(Vt(o)("el.datepicker.endTime")), 3), Ma("div", {
          class: Y(Vt(g))
        }, [ja(hT, {
          ref: "maxSpinner",
          role: "end",
          "show-seconds": Vt(w),
          "am-pm-mode": Vt(x),
          "arrow-control": Vt(u),
          "spinner-date": Vt(y),
          "disabled-hours": _,
          "disabled-minutes": R,
          "disabled-seconds": L,
          onChange: E,
          onSetOption: Vt(j),
          onSelectRange: O
        }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])], 2)], 2)], 2), Ma("div", {
          class: Y(Vt(i).be("panel", "footer"))
        }, [Ma("button", {
          type: "button",
          class: Y([Vt(i).be("panel", "btn"), "cancel"]),
          onClick: n[0] || (n[0] = e=>{
              t("pick", b.value, !1)
            }
          )
        }, te(Vt(o)("el.datepicker.cancel")), 3), Ma("button", {
          type: "button",
          class: Y([Vt(i).be("panel", "btn"), "confirm"]),
          disabled: Vt(C),
          onClick: n[1] || (n[1] = e=>((e=!1)=>{
              t("pick", [m.value, y.value], e)
            }
          )())
        }, te(Vt(o)("el.datepicker.confirm")), 11, yT)], 2)], 2)) : za("v-if", !0)
  }
});
var wT = tS(bT, [["__file", "panel-time-range.vue"]]);
JC.extend(ek);
var xT = vr({
  name: "ElTimePicker",
  install: null,
  props: {
    ...gk,
    isRange: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, t) {
    const n = Ft()
      , [r,o] = e.isRange ? ["timerange", wT] : ["time", gT]
      , a = e=>t.emit("update:modelValue", e);
    return Mo("ElPopperOptions", e.popperOptions),
      t.expose({
        focus: e=>{
          var t;
          null == (t = n.value) || t.handleFocusInput(e)
        }
        ,
        blur: e=>{
          var t;
          null == (t = n.value) || t.handleBlurInput(e)
        }
        ,
        handleOpen: ()=>{
          var e;
          null == (e = n.value) || e.handleOpen()
        }
        ,
        handleClose: ()=>{
          var e;
          null == (e = n.value) || e.handleClose()
        }
      }),
      ()=>{
        var t;
        const i = null != (t = e.format) ? t : nk;
        return ja(xk, qa(e, {
          ref: n,
          type: r,
          format: i,
          "onUpdate:modelValue": a
        }), {
          default: e=>ja(o, e, null)
        })
      }
  }
});
const ST = xT;
ST.install = e=>{
  e.component(ST.name, ST)
}
;
const ET = ST
  , AT = uy({
  selectedDay: {
    type: Object
  },
  range: {
    type: Array
  },
  date: {
    type: Object,
    required: !0
  },
  hideHeader: {
    type: Boolean
  }
})
  , CT = {
  pick: e=>x(e)
};
var kT = {
  exports: {}
};
kT.exports = function(e, t, n) {
  var r = t.prototype
    , o = function(e) {
    return e && (e.indexOf ? e : e.s)
  }
    , a = function(e, t, n, r, a) {
    var i = e.name ? e : e.$locale()
      , s = o(i[t])
      , l = o(i[n])
      , u = s || l.map((function(e) {
        return e.slice(0, r)
      }
    ));
    if (!a)
      return u;
    var c = i.weekStart;
    return u.map((function(e, t) {
        return u[(t + (c || 0)) % 7]
      }
    ))
  }
    , i = function() {
    return n.Ls[n.locale()]
  }
    , s = function(e, t) {
    return e.formats[t] || e.formats[t.toUpperCase()].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e, t, n) {
        return t || n.slice(1)
      }
    ))
  }
    , l = function() {
    var e = this;
    return {
      months: function(t) {
        return t ? t.format("MMMM") : a(e, "months")
      },
      monthsShort: function(t) {
        return t ? t.format("MMM") : a(e, "monthsShort", "months", 3)
      },
      firstDayOfWeek: function() {
        return e.$locale().weekStart || 0
      },
      weekdays: function(t) {
        return t ? t.format("dddd") : a(e, "weekdays")
      },
      weekdaysMin: function(t) {
        return t ? t.format("dd") : a(e, "weekdaysMin", "weekdays", 2)
      },
      weekdaysShort: function(t) {
        return t ? t.format("ddd") : a(e, "weekdaysShort", "weekdays", 3)
      },
      longDateFormat: function(t) {
        return s(e.$locale(), t)
      },
      meridiem: this.$locale().meridiem,
      ordinal: this.$locale().ordinal
    }
  };
  r.localeData = function() {
    return l.bind(this)()
  }
    ,
    n.localeData = function() {
      var e = i();
      return {
        firstDayOfWeek: function() {
          return e.weekStart || 0
        },
        weekdays: function() {
          return n.weekdays()
        },
        weekdaysShort: function() {
          return n.weekdaysShort()
        },
        weekdaysMin: function() {
          return n.weekdaysMin()
        },
        months: function() {
          return n.months()
        },
        monthsShort: function() {
          return n.monthsShort()
        },
        longDateFormat: function(t) {
          return s(e, t)
        },
        meridiem: e.meridiem,
        ordinal: e.ordinal
      }
    }
    ,
    n.months = function() {
      return a(i(), "months")
    }
    ,
    n.monthsShort = function() {
      return a(i(), "monthsShort", "months", 3)
    }
    ,
    n.weekdays = function(e) {
      return a(i(), "weekdays", null, null, e)
    }
    ,
    n.weekdaysShort = function(e) {
      return a(i(), "weekdaysShort", "weekdays", 3, e)
    }
    ,
    n.weekdaysMin = function(e) {
      return a(i(), "weekdaysMin", "weekdays", 2, e)
    }
}
;
const TT = YC(kT.exports)
  , DT = (e,t)=>{
  JC.extend(TT);
  const n = JC.localeData().firstDayOfWeek()
    , {t: r, lang: o} = Hy()
    , a = JC().locale(o.value)
    , i = yi((()=>!!e.range && !!e.range.length))
    , s = yi((()=>{
        let t = [];
        if (i.value) {
          const [n,r] = e.range
            , o = ik(r.date() - n.date() + 1).map((e=>({
            text: n.date() + e,
            type: "current"
          })));
          let a = o.length % 7;
          a = 0 === a ? 0 : 7 - a;
          const i = ik(a).map(((e,t)=>({
            text: t + 1,
            type: "next"
          })));
          t = o.concat(i)
        } else {
          const r = e.date.startOf("month").day()
            , o = ((e,t)=>{
              const n = e.subtract(1, "month").endOf("month").date();
              return ik(t).map(((e,r)=>n - (t - r - 1)))
            }
          )(e.date, (r - n + 7) % 7).map((e=>({
            text: e,
            type: "prev"
          })))
            , a = (e=>{
              const t = e.daysInMonth();
              return ik(t).map(((e,t)=>t + 1))
            }
          )(e.date).map((e=>({
            text: e,
            type: "current"
          })));
          t = [...o, ...a];
          const i = 7 - (t.length % 7 || 7)
            , s = ik(i).map(((e,t)=>({
            text: t + 1,
            type: "next"
          })));
          t = t.concat(s)
        }
        return (e=>ik(e.length / 7).map((t=>{
            const n = 7 * t;
            return e.slice(n, n + 7)
          }
        )))(t)
      }
    ))
    , l = yi((()=>{
        const e = n;
        return 0 === e ? wy.map((e=>r(`el.datepicker.weeks.${e}`))) : wy.slice(e).concat(wy.slice(0, e)).map((e=>r(`el.datepicker.weeks.${e}`)))
      }
    ))
    , u = (t,n)=>{
      switch (n) {
        case "prev":
          return e.date.startOf("month").subtract(1, "month").date(t);
        case "next":
          return e.date.startOf("month").add(1, "month").date(t);
        case "current":
          return e.date.date(t)
      }
    }
  ;
  return {
    now: a,
    isInRange: i,
    rows: s,
    weekDays: l,
    getFormattedDate: u,
    handlePickDay: ({text: e, type: n})=>{
      const r = u(e, n);
      t("pick", r)
    }
    ,
    getSlotData: ({text: t, type: n})=>{
      const r = u(t, n);
      return {
        isSelected: r.isSame(e.selectedDay),
        type: `${n}-month`,
        day: r.format("YYYY-MM-DD"),
        date: r.toDate()
      }
    }
  }
}
  , OT = {
  key: 0
}
  , _T = ["onClick"]
  , RT = vr({
  name: "DateTable"
});
var LT = tS(vr({
  ...RT,
  props: AT,
  emits: CT,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , {isInRange: o, now: a, rows: i, weekDays: s, getFormattedDate: l, handlePickDay: u, getSlotData: c} = DT(r, n)
      , d = qy("calendar-table")
      , f = qy("calendar-day")
      , p = ({text: e, type: t})=>{
        const n = [t];
        if ("current" === t) {
          const o = l(e, t);
          o.isSame(r.selectedDay, "day") && n.push(f.is("selected")),
          o.isSame(a, "day") && n.push(f.is("today"))
        }
        return n
      }
    ;
    return t({
      getFormattedDate: l
    }),
      (e,t)=>(Ca(),
        _a("table", {
          class: Y([Vt(d).b(), Vt(d).is("range", Vt(o))]),
          cellspacing: "0",
          cellpadding: "0"
        }, [e.hideHeader ? za("v-if", !0) : (Ca(),
          _a("thead", OT, [(Ca(!0),
            _a(ba, null, Yr(Vt(s), (e=>(Ca(),
              _a("th", {
                key: e
              }, te(e), 1)))), 128))])), Ma("tbody", null, [(Ca(!0),
          _a(ba, null, Yr(Vt(i), ((t,n)=>(Ca(),
            _a("tr", {
              key: n,
              class: Y({
                [Vt(d).e("row")]: !0,
                [Vt(d).em("row", "hide-border")]: 0 === n && e.hideHeader
              })
            }, [(Ca(!0),
              _a(ba, null, Yr(t, ((t,n)=>(Ca(),
                _a("td", {
                  key: n,
                  class: Y(p(t)),
                  onClick: e=>Vt(u)(t)
                }, [Ma("div", {
                  class: Y(Vt(f).b())
                }, [Qr(e.$slots, "date-cell", {
                  data: Vt(c)(t)
                }, (()=>[Ma("span", null, te(t.text), 1)]))], 2)], 10, _T)))), 128))], 2)))), 128))])], 2))
  }
}), [["__file", "date-table.vue"]]);
const IT = uy({
  modelValue: {
    type: Date
  },
  range: {
    type: Array,
    validator: e=>h(e) && 2 === e.length && e.every((e=>m(e)))
  }
})
  , PT = {
  [xy]: e=>m(e),
  [Ey]: e=>m(e)
}
  , FT = vr({
  name: "ElCalendar"
})
  , BT = vr({
  ...FT,
  props: IT,
  emits: PT,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = qy("calendar")
      , {calculateValidatedDateRange: a, date: i, pickDay: s, realSelectedDay: l, selectDate: u, validatedRange: c} = ((e,t,n)=>{
        const {lang: r} = Hy()
          , o = Ft()
          , a = JC().locale(r.value)
          , i = yi({
            get: ()=>e.modelValue ? l.value : o.value,
            set(e) {
              if (!e)
                return;
              o.value = e;
              const n = e.toDate();
              t(Ey, n),
                t(xy, n)
            }
          })
          , s = yi((()=>{
              if (!e.range)
                return [];
              const t = e.range.map((e=>JC(e).locale(r.value)))
                , [n,o] = t;
              return n.isAfter(o) ? [] : n.isSame(o, "month") ? p(n, o) : n.add(1, "month").month() !== o.month() ? [] : p(n, o)
            }
          ))
          , l = yi((()=>e.modelValue ? JC(e.modelValue).locale(r.value) : i.value || (s.value.length ? s.value[0][0] : a)))
          , u = yi((()=>l.value.subtract(1, "month").date(1)))
          , c = yi((()=>l.value.add(1, "month").date(1)))
          , d = yi((()=>l.value.subtract(1, "year").date(1)))
          , f = yi((()=>l.value.add(1, "year").date(1)))
          , p = (e,t)=>{
            const n = e.startOf("week")
              , r = t.endOf("week")
              , o = n.get("month")
              , a = r.get("month");
            return o === a ? [[n, r]] : (o + 1) % 12 === a ? ((e,t)=>{
                const n = e.endOf("month")
                  , r = t.startOf("month")
                  , o = n.isSame(r, "week");
                return [[e, n], [(o ? r.add(1, "week") : r).startOf("week"), t]]
              }
            )(n, r) : o + 2 === a || (o + 1) % 11 === a ? ((e,t)=>{
                const n = e.endOf("month")
                  , r = e.add(1, "month").startOf("month")
                  , o = n.isSame(r, "week") ? r.add(1, "week") : r
                  , a = o.endOf("month")
                  , i = t.startOf("month")
                  , s = a.isSame(i, "week") ? i.add(1, "week") : i;
                return [[e, n], [o.startOf("week"), a], [s.startOf("week"), t]]
              }
            )(n, r) : []
          }
          , h = e=>{
            i.value = e
          }
        ;
        return {
          calculateValidatedDateRange: p,
          date: l,
          realSelectedDay: i,
          pickDay: h,
          selectDate: e=>{
            const t = {
              "prev-month": u.value,
              "next-month": c.value,
              "prev-year": d.value,
              "next-year": f.value,
              today: a
            }[e];
            t.isSame(l.value, "day") || h(t)
          }
          ,
          validatedRange: s
        }
      }
    )(r, n)
      , {t: d} = Hy()
      , f = yi((()=>{
        const e = `el.datepicker.month${i.value.format("M")}`;
        return `${i.value.year()} ${d("el.datepicker.year")} ${d(e)}`
      }
    ));
    return t({
      selectedDay: l,
      pickDay: s,
      selectDate: u,
      calculateValidatedDateRange: a
    }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y(Vt(o).b())
        }, [Ma("div", {
          class: Y(Vt(o).e("header"))
        }, [Qr(e.$slots, "header", {
          date: Vt(f)
        }, (()=>[Ma("div", {
          class: Y(Vt(o).e("title"))
        }, te(Vt(f)), 3), 0 === Vt(c).length ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(o).e("button-group"))
          }, [ja(Vt(GC), null, {
            default: Fn((()=>[ja(Vt(WC), {
              size: "small",
              onClick: t[0] || (t[0] = e=>Vt(u)("prev-month"))
            }, {
              default: Fn((()=>[$a(te(Vt(d)("el.datepicker.prevMonth")), 1)])),
              _: 1
            }), ja(Vt(WC), {
              size: "small",
              onClick: t[1] || (t[1] = e=>Vt(u)("today"))
            }, {
              default: Fn((()=>[$a(te(Vt(d)("el.datepicker.today")), 1)])),
              _: 1
            }), ja(Vt(WC), {
              size: "small",
              onClick: t[2] || (t[2] = e=>Vt(u)("next-month"))
            }, {
              default: Fn((()=>[$a(te(Vt(d)("el.datepicker.nextMonth")), 1)])),
              _: 1
            })])),
            _: 1
          })], 2)) : za("v-if", !0)]))], 2), 0 === Vt(c).length ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(o).e("body"))
          }, [ja(LT, {
            date: Vt(i),
            "selected-day": Vt(l),
            onPick: Vt(s)
          }, Xr({
            _: 2
          }, [e.$slots["date-cell"] ? {
            name: "date-cell",
            fn: Fn((t=>[Qr(e.$slots, "date-cell", X(Va(t)))]))
          } : void 0]), 1032, ["date", "selected-day", "onPick"])], 2)) : (Ca(),
          _a("div", {
            key: 1,
            class: Y(Vt(o).e("body"))
          }, [(Ca(!0),
            _a(ba, null, Yr(Vt(c), ((t,n)=>(Ca(),
              Ra(LT, {
                key: n,
                date: t[0],
                "selected-day": Vt(l),
                range: t,
                "hide-header": 0 !== n,
                onPick: Vt(s)
              }, Xr({
                _: 2
              }, [e.$slots["date-cell"] ? {
                name: "date-cell",
                fn: Fn((t=>[Qr(e.$slots, "date-cell", X(Va(t)))]))
              } : void 0]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"])))), 128))], 2))], 2))
  }
});
const NT = vy(tS(BT, [["__file", "calendar.vue"]]))
  , MT = uy({
  header: {
    type: String,
    default: ""
  },
  footer: {
    type: String,
    default: ""
  },
  bodyStyle: {
    type: [String, Object, Array],
    default: ""
  },
  bodyClass: String,
  shadow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "always"
  }
})
  , jT = vr({
  name: "ElCard"
});
const VT = vy(tS(vr({
  ...jT,
  props: MT,
  setup(e) {
    const t = qy("card");
    return (e,n)=>(Ca(),
      _a("div", {
        class: Y([Vt(t).b(), Vt(t).is(`${e.shadow}-shadow`)])
      }, [e.$slots.header || e.header ? (Ca(),
        _a("div", {
          key: 0,
          class: Y(Vt(t).e("header"))
        }, [Qr(e.$slots, "header", {}, (()=>[$a(te(e.header), 1)]))], 2)) : za("v-if", !0), Ma("div", {
        class: Y([Vt(t).e("body"), e.bodyClass]),
        style: z(e.bodyStyle)
      }, [Qr(e.$slots, "default")], 6), e.$slots.footer || e.footer ? (Ca(),
        _a("div", {
          key: 1,
          class: Y(Vt(t).e("footer"))
        }, [Qr(e.$slots, "footer", {}, (()=>[$a(te(e.footer), 1)]))], 2)) : za("v-if", !0)], 2))
  }
}), [["__file", "card.vue"]]))
  , UT = uy({
  initialIndex: {
    type: Number,
    default: 0
  },
  height: {
    type: String,
    default: ""
  },
  trigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  autoplay: {
    type: Boolean,
    default: !0
  },
  interval: {
    type: Number,
    default: 3e3
  },
  indicatorPosition: {
    type: String,
    values: ["", "none", "outside"],
    default: ""
  },
  arrow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "hover"
  },
  type: {
    type: String,
    values: ["", "card"],
    default: ""
  },
  loop: {
    type: Boolean,
    default: !0
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  pauseOnHover: {
    type: Boolean,
    default: !0
  },
  motionBlur: {
    type: Boolean,
    default: !1
  }
})
  , $T = {
  change: (e,t)=>[e, t].every(Vg)
}
  , HT = Symbol("carouselContextKey")
  , zT = (e,t,n)=>{
  const {children: r, addChild: o, removeChild: a} = Vx(ei(), "ElCarouselItem")
    , i = po()
    , s = Ft(-1)
    , l = Ft(null)
    , u = Ft(!1)
    , c = Ft()
    , d = Ft(0)
    , f = Ft(!0)
    , p = Ft(!0)
    , h = Ft(!1)
    , v = yi((()=>"never" !== e.arrow && !Vt(y)))
    , g = yi((()=>r.value.some((e=>e.props.label.toString().length > 0))))
    , m = yi((()=>"card" === e.type))
    , y = yi((()=>"vertical" === e.direction))
    , w = yi((()=>"auto" !== e.height ? {
    height: e.height
  } : {
    height: `${d.value}px`,
    overflow: "hidden"
  }))
    , x = Pg((e=>{
      k(e)
    }
  ), 300, {
    trailing: !0
  })
    , S = Pg((t=>{
      !function(t) {
        "hover" === e.trigger && t !== s.value && (s.value = t,
        p.value || (h.value = !0))
      }(t)
    }
  ), 300);
  function E() {
    l.value && (clearInterval(l.value),
      l.value = null)
  }
  function A() {
    e.interval <= 0 || !e.autoplay || l.value || (l.value = setInterval((()=>C()), e.interval))
  }
  const C = ()=>{
      p.value || (h.value = !0),
        p.value = !1,
        s.value < r.value.length - 1 ? s.value = s.value + 1 : e.loop && (s.value = 0)
    }
  ;
  function k(t) {
    if (p.value || (h.value = !0),
      p.value = !1,
      b(t)) {
      const e = r.value.filter((e=>e.props.name === t));
      e.length > 0 && (t = r.value.indexOf(e[0]))
    }
    if (t = Number(t),
    Number.isNaN(t) || t !== Math.floor(t))
      return;
    const n = r.value.length
      , o = s.value;
    s.value = t < 0 ? e.loop ? n - 1 : 0 : t >= n ? e.loop ? 0 : n - 1 : t,
    o === s.value && T(o),
      D()
  }
  function T(e) {
    r.value.forEach(((t,n)=>{
        t.translateItem(n, s.value, e)
      }
    ))
  }
  function D() {
    E(),
    e.pauseOnHover || A()
  }
  Jn((()=>s.value), ((e,n)=>{
      T(n),
      f.value && (e %= 2,
        n %= 2),
      n > -1 && t("change", e, n)
    }
  )),
    Jn((()=>e.autoplay), (e=>{
        e ? A() : E()
      }
    )),
    Jn((()=>e.loop), (()=>{
        k(s.value)
      }
    )),
    Jn((()=>e.interval), (()=>{
        D()
      }
    ));
  const O = Bt();
  return Lr((()=>{
      Jn((()=>r.value), (()=>{
          r.value.length > 0 && k(e.initialIndex)
        }
      ), {
        immediate: !0
      }),
        O.value = Uc(c.value, (()=>{
            T()
          }
        )),
        A()
    }
  )),
    Fr((()=>{
        E(),
        c.value && O.value && O.value.stop()
      }
    )),
    Mo(HT, {
      root: c,
      isCardType: m,
      isVertical: y,
      items: r,
      loop: e.loop,
      addItem: o,
      removeItem: a,
      setActiveItem: k,
      setContainerHeight: function(t) {
        "auto" === e.height && (d.value = t)
      }
    }),
    {
      root: c,
      activeIndex: s,
      arrowDisplay: v,
      hasLabel: g,
      hover: u,
      isCardType: m,
      isTransitioning: h,
      items: r,
      isVertical: y,
      containerStyle: w,
      isItemsTwoLength: f,
      handleButtonEnter: function(e) {
        Vt(y) || r.value.forEach(((t,n)=>{
            e === function(e, t) {
              var n, o, a, i;
              const s = Vt(r)
                , l = s.length;
              if (0 === l || !e.states.inStage)
                return !1;
              const u = t + 1
                , c = t - 1
                , d = l - 1
                , f = s[d].states.active
                , p = s[0].states.active
                , h = null == (o = null == (n = s[u]) ? void 0 : n.states) ? void 0 : o.active
                , v = null == (i = null == (a = s[c]) ? void 0 : a.states) ? void 0 : i.active;
              return t === d && p || h ? "left" : !!(0 === t && f || v) && "right"
            }(t, n) && (t.states.hover = !0)
          }
        ))
      },
      handleTransitionEnd: function() {
        h.value = !1
      },
      handleButtonLeave: function() {
        Vt(y) || r.value.forEach((e=>{
            e.states.hover = !1
          }
        ))
      },
      handleIndicatorClick: function(e) {
        e !== s.value && (p.value || (h.value = !0)),
          s.value = e
      },
      handleMouseEnter: function() {
        u.value = !0,
        e.pauseOnHover && E()
      },
      handleMouseLeave: function() {
        u.value = !1,
          A()
      },
      setActiveItem: k,
      prev: function() {
        k(s.value - 1)
      },
      next: function() {
        k(s.value + 1)
      },
      PlaceholderItem: function() {
        var t;
        const n = null == (t = i.default) ? void 0 : t.call(i);
        if (!n)
          return null;
        const r = _y(n).filter((e=>La(e) && "ElCarouselItem" === e.type.name));
        return 2 === (null == r ? void 0 : r.length) && e.loop && !m.value ? (f.value = !0,
          r) : (f.value = !1,
          null)
      },
      isTwoLengthShow: e=>!f.value || (s.value <= 1 ? e <= 1 : e > 1),
      throttledArrowClick: x,
      throttledIndicatorHover: S
    }
}
  , KT = ["aria-label"]
  , WT = ["aria-label"]
  , GT = ["onMouseenter", "onClick"]
  , qT = ["aria-label"]
  , YT = {
  key: 0
}
  , XT = {
  key: 3,
  xmlns: "http://www.w3.org/2000/svg",
  version: "1.1",
  style: {
    display: "none"
  }
}
  , QT = [Ma("defs", null, [Ma("filter", {
  id: "elCarouselHorizontal"
}, [Ma("feGaussianBlur", {
  in: "SourceGraphic",
  stdDeviation: "12,0"
})]), Ma("filter", {
  id: "elCarouselVertical"
}, [Ma("feGaussianBlur", {
  in: "SourceGraphic",
  stdDeviation: "0,10"
})])], -1)]
  , JT = vr({
  name: "ElCarousel"
})
  , ZT = vr({
  ...JT,
  props: UT,
  emits: $T,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , {root: o, activeIndex: a, arrowDisplay: i, hasLabel: s, hover: l, isCardType: u, items: c, isVertical: d, containerStyle: f, handleButtonEnter: p, handleButtonLeave: h, isTransitioning: v, handleIndicatorClick: g, handleMouseEnter: m, handleMouseLeave: y, handleTransitionEnd: b, setActiveItem: w, prev: x, next: S, PlaceholderItem: E, isTwoLengthShow: A, throttledArrowClick: C, throttledIndicatorHover: k} = zT(r, n)
      , T = qy("carousel")
      , {t: D} = Hy()
      , O = yi((()=>{
        const e = [T.b(), T.m(r.direction)];
        return Vt(u) && e.push(T.m("card")),
          e
      }
    ))
      , _ = yi((()=>{
        const e = [T.e("container")];
        return r.motionBlur && Vt(v) && e.push(Vt(d) ? `${T.namespace.value}-transitioning-vertical` : `${T.namespace.value}-transitioning`),
          e
      }
    ))
      , R = yi((()=>{
        const e = [T.e("indicators"), T.em("indicators", r.direction)];
        return Vt(s) && e.push(T.em("indicators", "labels")),
        "outside" === r.indicatorPosition && e.push(T.em("indicators", "outside")),
        Vt(d) && e.push(T.em("indicators", "right")),
          e
      }
    ));
    return t({
      setActiveItem: w,
      prev: x,
      next: S
    }),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "root",
          ref: o,
          class: Y(Vt(O)),
          onMouseenter: t[7] || (t[7] = js(((...e)=>Vt(m) && Vt(m)(...e)), ["stop"])),
          onMouseleave: t[8] || (t[8] = js(((...e)=>Vt(y) && Vt(y)(...e)), ["stop"]))
        }, [Vt(i) ? (Ca(),
          Ra(es, {
            key: 0,
            name: "carousel-arrow-left",
            persisted: ""
          }, {
            default: Fn((()=>[rr(Ma("button", {
              type: "button",
              class: Y([Vt(T).e("arrow"), Vt(T).em("arrow", "left")]),
              "aria-label": Vt(D)("el.carousel.leftArrow"),
              onMouseenter: t[0] || (t[0] = e=>Vt(p)("left")),
              onMouseleave: t[1] || (t[1] = (...e)=>Vt(h) && Vt(h)(...e)),
              onClick: t[2] || (t[2] = js((e=>Vt(C)(Vt(a) - 1)), ["stop"]))
            }, [ja(Vt(sS), null, {
              default: Fn((()=>[ja(Vt(vm))])),
              _: 1
            })], 42, KT), [[$s, ("always" === e.arrow || Vt(l)) && (r.loop || Vt(a) > 0)]])])),
            _: 1
          })) : za("v-if", !0), Vt(i) ? (Ca(),
          Ra(es, {
            key: 1,
            name: "carousel-arrow-right",
            persisted: ""
          }, {
            default: Fn((()=>[rr(Ma("button", {
              type: "button",
              class: Y([Vt(T).e("arrow"), Vt(T).em("arrow", "right")]),
              "aria-label": Vt(D)("el.carousel.rightArrow"),
              onMouseenter: t[3] || (t[3] = e=>Vt(p)("right")),
              onMouseleave: t[4] || (t[4] = (...e)=>Vt(h) && Vt(h)(...e)),
              onClick: t[5] || (t[5] = js((e=>Vt(C)(Vt(a) + 1)), ["stop"]))
            }, [ja(Vt(sS), null, {
              default: Fn((()=>[ja(Vt(gm))])),
              _: 1
            })], 42, WT), [[$s, ("always" === e.arrow || Vt(l)) && (r.loop || Vt(a) < Vt(c).length - 1)]])])),
            _: 1
          })) : za("v-if", !0), Ma("div", {
          class: Y(Vt(_)),
          style: z(Vt(f)),
          onTransitionend: t[6] || (t[6] = (...e)=>Vt(b) && Vt(b)(...e))
        }, [ja(Vt(E)), Qr(e.$slots, "default")], 38), "none" !== e.indicatorPosition ? (Ca(),
          _a("ul", {
            key: 2,
            class: Y(Vt(R))
          }, [(Ca(!0),
            _a(ba, null, Yr(Vt(c), ((t,n)=>rr((Ca(),
              _a("li", {
                key: n,
                class: Y([Vt(T).e("indicator"), Vt(T).em("indicator", e.direction), Vt(T).is("active", n === Vt(a))]),
                onMouseenter: e=>Vt(k)(n),
                onClick: js((e=>Vt(g)(n)), ["stop"])
              }, [Ma("button", {
                class: Y(Vt(T).e("button")),
                "aria-label": Vt(D)("el.carousel.indicator", {
                  index: n + 1
                })
              }, [Vt(s) ? (Ca(),
                _a("span", YT, te(t.props.label), 1)) : za("v-if", !0)], 10, qT)], 42, GT)), [[$s, Vt(A)(n)]]))), 128))], 2)) : za("v-if", !0), r.motionBlur ? (Ca(),
          _a("svg", XT, QT)) : za("v-if", !0)], 34))
  }
});
var eD = tS(ZT, [["__file", "carousel.vue"]]);
const tD = uy({
  name: {
    type: String,
    default: ""
  },
  label: {
    type: [String, Number],
    default: ""
  }
})
  , nD = (e,t)=>{
  const n = jo(HT)
    , r = ei()
    , o = .83
    , a = Ft()
    , i = Ft(!1)
    , s = Ft(0)
    , l = Ft(1)
    , u = Ft(!1)
    , c = Ft(!1)
    , d = Ft(!1)
    , f = Ft(!1)
    , {isCardType: p, isVertical: h} = n;
  const v = (e,t,r)=>{
      var i;
      const v = Vt(p)
        , g = null != (i = n.items.value.length) ? i : Number.NaN
        , m = e === t;
      v || Mg(r) || (f.value = m || e === r),
      !m && g > 2 && n.loop && (e = function(e, t, n) {
        const r = n - 1
          , o = n / 2;
        return 0 === t && e === r ? -1 : t === r && 0 === e ? n : e < t - 1 && t - e >= o ? n + 1 : e > t + 1 && e - t >= o ? -2 : e
      }(e, t, g));
      const y = Vt(h);
      u.value = m,
        v ? (d.value = Math.round(Math.abs(e - t)) <= 1,
          s.value = function(e, t) {
            var r, o;
            const a = Vt(h) ? (null == (r = n.root.value) ? void 0 : r.offsetHeight) || 0 : (null == (o = n.root.value) ? void 0 : o.offsetWidth) || 0;
            return d.value ? a * (1.17 * (e - t) + 1) / 4 : e < t ? -1.83 * a / 4 : 3.83 * a / 4
          }(e, t),
          l.value = Vt(u) ? 1 : o) : s.value = function(e, t, r) {
          const o = n.root.value;
          return o ? ((r ? o.offsetHeight : o.offsetWidth) || 0) * (e - t) : 0
        }(e, t, y),
        c.value = !0,
      m && a.value && n.setContainerHeight(a.value.offsetHeight)
    }
  ;
  return Lr((()=>{
      n.addItem({
        props: e,
        states: bt({
          hover: i,
          translate: s,
          scale: l,
          active: u,
          ready: c,
          inStage: d,
          animating: f
        }),
        uid: r.uid,
        translateItem: v
      })
    }
  )),
    Br((()=>{
        n.removeItem(r.uid)
      }
    )),
    {
      carouselItemRef: a,
      active: u,
      animating: f,
      hover: i,
      inStage: d,
      isVertical: h,
      translate: s,
      isCardType: p,
      scale: l,
      ready: c,
      handleItemClick: function() {
        if (n && Vt(p)) {
          const e = n.items.value.findIndex((({uid: e})=>e === r.uid));
          n.setActiveItem(e)
        }
      }
    }
}
  , rD = vr({
  name: "ElCarouselItem"
});
var oD = tS(vr({
  ...rD,
  props: tD,
  setup(e) {
    const t = e
      , n = qy("carousel")
      , {carouselItemRef: r, active: o, animating: a, hover: i, inStage: s, isVertical: l, translate: u, isCardType: c, scale: d, ready: f, handleItemClick: p} = nD(t)
      , h = yi((()=>[n.e("item"), n.is("active", o.value), n.is("in-stage", s.value), n.is("hover", i.value), n.is("animating", a.value), {
      [n.em("item", "card")]: c.value,
      [n.em("item", "card-vertical")]: c.value && l.value
    }]))
      , v = yi((()=>({
      transform: [`${"translate" + (Vt(l) ? "Y" : "X")}(${Vt(u)}px)`, `scale(${Vt(d)})`].join(" ")
    })));
    return (e,t)=>rr((Ca(),
      _a("div", {
        ref_key: "carouselItemRef",
        ref: r,
        class: Y(Vt(h)),
        style: z(Vt(v)),
        onClick: t[0] || (t[0] = (...e)=>Vt(p) && Vt(p)(...e))
      }, [Vt(c) ? rr((Ca(),
        _a("div", {
          key: 0,
          class: Y(Vt(n).e("mask"))
        }, null, 2)), [[$s, !Vt(o)]]) : za("v-if", !0), Qr(e.$slots, "default")], 6)), [[$s, Vt(f)]])
  }
}), [["__file", "carousel-item.vue"]]);
const aD = vy(eD, {
  CarouselItem: oD
})
  , iD = my(oD)
  , sD = {
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  value: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueValue: {
    type: [String, Number],
    default: void 0
  },
  falseValue: {
    type: [String, Number],
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: Ux,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: !0
  }
}
  , lD = {
  [xy]: e=>b(e) || Vg(e) || jg(e),
  change: e=>b(e) || Vg(e) || jg(e)
}
  , uD = Symbol("checkboxGroupContextKey")
  , cD = (e,{model: t, isLimitExceeded: n, hasOwnLabel: r, isDisabled: o, isLabeledByFormItem: a})=>{
  const i = jo(uD, void 0)
    , {formItem: s} = gS()
    , {emit: l} = ei();
  function u(t) {
    var n, r;
    return [!0, e.trueValue, e.trueLabel].includes(t) ? null == (n = e.trueValue || e.trueLabel) || n : null != (r = e.falseValue || e.falseLabel) && r
  }
  const c = yi((()=>(null == i ? void 0 : i.validateEvent) || e.validateEvent));
  return Jn((()=>e.modelValue), (()=>{
      c.value && (null == s || s.validate("change").catch((e=>{}
      )))
    }
  )),
    {
      handleChange: function(e) {
        if (n.value)
          return;
        const t = e.target;
        l("change", u(t.checked), e)
      },
      onClickRoot: async function(i) {
        if (!n.value && !r.value && !o.value && a.value) {
          i.composedPath().some((e=>"LABEL" === e.tagName)) || (t.value = u([!1, e.falseValue, e.falseLabel].includes(t.value)),
            await hn(),
            function(e, t) {
              l("change", u(e), t)
            }(t.value, i))
        }
      }
    }
}
  , dD = (e,t)=>{
  const {formItem: n} = gS()
    , {model: r, isGroup: o, isLimitExceeded: a} = (e=>{
      const t = Ft(!1)
        , {emit: n} = ei()
        , r = jo(uD, void 0)
        , o = yi((()=>!1 === Mg(r)))
        , a = Ft(!1)
        , i = yi({
        get() {
          var n, a;
          return o.value ? null == (n = null == r ? void 0 : r.modelValue) ? void 0 : n.value : null != (a = e.modelValue) ? a : t.value
        },
        set(e) {
          var s, l;
          o.value && h(e) ? (a.value = void 0 !== (null == (s = null == r ? void 0 : r.max) ? void 0 : s.value) && e.length > (null == r ? void 0 : r.max.value) && e.length > i.value.length,
          !1 === a.value && (null == (l = null == r ? void 0 : r.changeEvent) || l.call(r, e))) : (n(xy, e),
            t.value = e)
        }
      });
      return {
        model: i,
        isGroup: o,
        isLimitExceeded: a
      }
    }
  )(e)
    , {isFocused: i, isChecked: s, checkboxButtonSize: l, checkboxSize: u, hasOwnLabel: c, actualValue: d} = ((e,t,{model: n})=>{
      const r = jo(uD, void 0)
        , o = Ft(!1)
        , a = yi((()=>Hg(e.value) ? e.label : e.value))
        , i = yi((()=>{
          const t = n.value;
          return jg(t) ? t : h(t) ? x(a.value) ? t.map(Dt).some((e=>Ag(e, a.value))) : t.map(Dt).includes(a.value) : null != t ? t === e.trueValue || t === e.trueLabel : !!t
        }
      ));
      return {
        checkboxButtonSize: hS(yi((()=>{
            var e;
            return null == (e = null == r ? void 0 : r.size) ? void 0 : e.value
          }
        )), {
          prop: !0
        }),
        isChecked: i,
        isFocused: o,
        checkboxSize: hS(yi((()=>{
            var e;
            return null == (e = null == r ? void 0 : r.size) ? void 0 : e.value
          }
        ))),
        hasOwnLabel: yi((()=>!!t.default || !Hg(a.value))),
        actualValue: a
      }
    }
  )(e, t, {
    model: r
  })
    , {isDisabled: f} = (({model: e, isChecked: t})=>{
      const n = jo(uD, void 0)
        , r = yi((()=>{
          var r, o;
          const a = null == (r = null == n ? void 0 : n.max) ? void 0 : r.value
            , i = null == (o = null == n ? void 0 : n.min) ? void 0 : o.value;
          return !Mg(a) && e.value.length >= a && !t.value || !Mg(i) && e.value.length <= i && t.value
        }
      ));
      return {
        isDisabled: vS(yi((()=>(null == n ? void 0 : n.disabled.value) || r.value))),
        isLimitDisabled: r
      }
    }
  )({
    model: r,
    isChecked: s
  })
    , {inputId: p, isLabeledByFormItem: v} = mS(e, {
    formItemContext: n,
    disableIdGeneration: c,
    disableIdManagement: o
  })
    , {handleChange: g, onClickRoot: m} = cD(e, {
    model: r,
    isLimitExceeded: a,
    hasOwnLabel: c,
    isDisabled: f,
    isLabeledByFormItem: v
  });
  return e.checked && (h(r.value) && !r.value.includes(d.value) ? r.value.push(d.value) : r.value = e.trueValue || e.trueLabel || !0),
    Ny({
      from: "label act as value",
      replacement: "value",
      version: "3.0.0",
      scope: "el-checkbox",
      ref: "https://element-plus.org/en-US/component/checkbox.html"
    }, yi((()=>o.value && Hg(e.value)))),
    Ny({
      from: "true-label",
      replacement: "true-value",
      version: "3.0.0",
      scope: "el-checkbox",
      ref: "https://element-plus.org/en-US/component/checkbox.html"
    }, yi((()=>!!e.trueLabel))),
    Ny({
      from: "false-label",
      replacement: "false-value",
      version: "3.0.0",
      scope: "el-checkbox",
      ref: "https://element-plus.org/en-US/component/checkbox.html"
    }, yi((()=>!!e.falseLabel))),
    {
      inputId: p,
      isLabeledByFormItem: v,
      isChecked: s,
      isDisabled: f,
      isFocused: i,
      checkboxButtonSize: l,
      checkboxSize: u,
      hasOwnLabel: c,
      model: r,
      actualValue: d,
      handleChange: g,
      onClickRoot: m
    }
}
  , fD = ["id", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value"]
  , pD = ["id", "indeterminate", "disabled", "value", "name", "tabindex"]
  , hD = vr({
  name: "ElCheckbox"
});
var vD = tS(vr({
  ...hD,
  props: sD,
  emits: lD,
  setup(e) {
    const t = e
      , n = po()
      , {inputId: r, isLabeledByFormItem: o, isChecked: a, isDisabled: i, isFocused: s, checkboxSize: l, hasOwnLabel: u, model: c, actualValue: d, handleChange: f, onClickRoot: p} = dD(t, n)
      , h = qy("checkbox")
      , v = yi((()=>[h.b(), h.m(l.value), h.is("disabled", i.value), h.is("bordered", t.border), h.is("checked", a.value)]))
      , g = yi((()=>[h.e("input"), h.is("disabled", i.value), h.is("checked", a.value), h.is("indeterminate", t.indeterminate), h.is("focus", s.value)]));
    return (e,t)=>(Ca(),
      Ra(Kr(!Vt(u) && Vt(o) ? "span" : "label"), {
        class: Y(Vt(v)),
        "aria-controls": e.indeterminate ? e.controls : null,
        onClick: Vt(p)
      }, {
        default: Fn((()=>[Ma("span", {
          class: Y(Vt(g))
        }, [e.trueValue || e.falseValue || e.trueLabel || e.falseLabel ? rr((Ca(),
          _a("input", {
            key: 0,
            id: Vt(r),
            "onUpdate:modelValue": t[0] || (t[0] = e=>Pt(c) ? c.value = e : null),
            class: Y(Vt(h).e("original")),
            type: "checkbox",
            indeterminate: e.indeterminate,
            name: e.name,
            tabindex: e.tabindex,
            disabled: Vt(i),
            "true-value": e.trueValue || e.trueLabel,
            "false-value": e.falseValue || e.falseLabel,
            onChange: t[1] || (t[1] = (...e)=>Vt(f) && Vt(f)(...e)),
            onFocus: t[2] || (t[2] = e=>s.value = !0),
            onBlur: t[3] || (t[3] = e=>s.value = !1),
            onClick: t[4] || (t[4] = js((()=>{}
            ), ["stop"]))
          }, null, 42, fD)), [[Ts, Vt(c)]]) : rr((Ca(),
          _a("input", {
            key: 1,
            id: Vt(r),
            "onUpdate:modelValue": t[5] || (t[5] = e=>Pt(c) ? c.value = e : null),
            class: Y(Vt(h).e("original")),
            type: "checkbox",
            indeterminate: e.indeterminate,
            disabled: Vt(i),
            value: Vt(d),
            name: e.name,
            tabindex: e.tabindex,
            onChange: t[6] || (t[6] = (...e)=>Vt(f) && Vt(f)(...e)),
            onFocus: t[7] || (t[7] = e=>s.value = !0),
            onBlur: t[8] || (t[8] = e=>s.value = !1),
            onClick: t[9] || (t[9] = js((()=>{}
            ), ["stop"]))
          }, null, 42, pD)), [[Ts, Vt(c)]]), Ma("span", {
          class: Y(Vt(h).e("inner"))
        }, null, 2)], 2), Vt(u) ? (Ca(),
          _a("span", {
            key: 0,
            class: Y(Vt(h).e("label"))
          }, [Qr(e.$slots, "default"), e.$slots.default ? za("v-if", !0) : (Ca(),
            _a(ba, {
              key: 0
            }, [$a(te(e.label), 1)], 64))], 2)) : za("v-if", !0)])),
        _: 3
      }, 8, ["class", "aria-controls", "onClick"]))
  }
}), [["__file", "checkbox.vue"]]);
const gD = ["name", "tabindex", "disabled", "true-value", "false-value"]
  , mD = ["name", "tabindex", "disabled", "value"]
  , yD = vr({
  name: "ElCheckboxButton"
});
var bD = tS(vr({
  ...yD,
  props: sD,
  emits: lD,
  setup(e) {
    const t = e
      , n = po()
      , {isFocused: r, isChecked: o, isDisabled: a, checkboxButtonSize: i, model: s, actualValue: l, handleChange: u} = dD(t, n)
      , c = jo(uD, void 0)
      , d = qy("checkbox")
      , f = yi((()=>{
        var e, t, n, r;
        const o = null != (t = null == (e = null == c ? void 0 : c.fill) ? void 0 : e.value) ? t : "";
        return {
          backgroundColor: o,
          borderColor: o,
          color: null != (r = null == (n = null == c ? void 0 : c.textColor) ? void 0 : n.value) ? r : "",
          boxShadow: o ? `-1px 0 0 0 ${o}` : void 0
        }
      }
    ))
      , p = yi((()=>[d.b("button"), d.bm("button", i.value), d.is("disabled", a.value), d.is("checked", o.value), d.is("focus", r.value)]));
    return (e,t)=>(Ca(),
      _a("label", {
        class: Y(Vt(p))
      }, [e.trueValue || e.falseValue || e.trueLabel || e.falseLabel ? rr((Ca(),
        _a("input", {
          key: 0,
          "onUpdate:modelValue": t[0] || (t[0] = e=>Pt(s) ? s.value = e : null),
          class: Y(Vt(d).be("button", "original")),
          type: "checkbox",
          name: e.name,
          tabindex: e.tabindex,
          disabled: Vt(a),
          "true-value": e.trueValue || e.trueLabel,
          "false-value": e.falseValue || e.falseLabel,
          onChange: t[1] || (t[1] = (...e)=>Vt(u) && Vt(u)(...e)),
          onFocus: t[2] || (t[2] = e=>r.value = !0),
          onBlur: t[3] || (t[3] = e=>r.value = !1),
          onClick: t[4] || (t[4] = js((()=>{}
          ), ["stop"]))
        }, null, 42, gD)), [[Ts, Vt(s)]]) : rr((Ca(),
        _a("input", {
          key: 1,
          "onUpdate:modelValue": t[5] || (t[5] = e=>Pt(s) ? s.value = e : null),
          class: Y(Vt(d).be("button", "original")),
          type: "checkbox",
          name: e.name,
          tabindex: e.tabindex,
          disabled: Vt(a),
          value: Vt(l),
          onChange: t[6] || (t[6] = (...e)=>Vt(u) && Vt(u)(...e)),
          onFocus: t[7] || (t[7] = e=>r.value = !0),
          onBlur: t[8] || (t[8] = e=>r.value = !1),
          onClick: t[9] || (t[9] = js((()=>{}
          ), ["stop"]))
        }, null, 42, mD)), [[Ts, Vt(s)]]), e.$slots.default || e.label ? (Ca(),
        _a("span", {
          key: 2,
          class: Y(Vt(d).be("button", "inner")),
          style: z(Vt(o) ? Vt(f) : void 0)
        }, [Qr(e.$slots, "default", {}, (()=>[$a(te(e.label), 1)]))], 6)) : za("v-if", !0)], 2))
  }
}), [["__file", "checkbox-button.vue"]]);
const wD = uy({
  modelValue: {
    type: Array,
    default: ()=>[]
  },
  disabled: Boolean,
  min: Number,
  max: Number,
  size: Ux,
  label: String,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
})
  , xD = {
  [xy]: e=>h(e),
  change: e=>h(e)
}
  , SD = vr({
  name: "ElCheckboxGroup"
});
var ED = tS(vr({
  ...SD,
  props: wD,
  emits: xD,
  setup(e, {emit: t}) {
    const n = e
      , r = qy("checkbox")
      , {formItem: o} = gS()
      , {inputId: a, isLabeledByFormItem: i} = mS(n, {
      formItemContext: o
    })
      , s = async e=>{
      t(xy, e),
        await hn(),
        t("change", e)
    }
      , l = yi({
      get: ()=>n.modelValue,
      set(e) {
        s(e)
      }
    });
    return Mo(uD, {
      ...Ig(Wt(n), ["size", "min", "max", "disabled", "validateEvent", "fill", "textColor"]),
      modelValue: l,
      changeEvent: s
    }),
      Jn((()=>n.modelValue), (()=>{
          n.validateEvent && (null == o || o.validate("change").catch((e=>{}
          )))
        }
      )),
      (e,t)=>{
        var n;
        return Ca(),
          Ra(Kr(e.tag), {
            id: Vt(a),
            class: Y(Vt(r).b("group")),
            role: "group",
            "aria-label": Vt(i) ? void 0 : e.label || "checkbox-group",
            "aria-labelledby": Vt(i) ? null == (n = Vt(o)) ? void 0 : n.labelId : void 0
          }, {
            default: Fn((()=>[Qr(e.$slots, "default")])),
            _: 3
          }, 8, ["id", "class", "aria-label", "aria-labelledby"])
      }
  }
}), [["__file", "checkbox-group.vue"]]);
const AD = vy(vD, {
  CheckboxButton: bD,
  CheckboxGroup: ED
})
  , CD = my(bD)
  , kD = my(ED)
  , TD = uy({
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  size: Ux,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: void 0
  },
  value: {
    type: [String, Number, Boolean],
    default: void 0
  },
  name: {
    type: String,
    default: void 0
  }
})
  , DD = uy({
  ...TD,
  border: Boolean
})
  , OD = {
  [xy]: e=>b(e) || Vg(e) || jg(e),
  [Sy]: e=>b(e) || Vg(e) || jg(e)
}
  , _D = Symbol("radioGroupKey")
  , RD = (e,t)=>{
  const n = Ft()
    , r = jo(_D, void 0)
    , o = yi((()=>!!r))
    , a = yi((()=>Hg(e.value) ? e.label : e.value))
    , i = yi({
    get: ()=>o.value ? r.modelValue : e.modelValue,
    set(i) {
      o.value ? r.changeEvent(i) : t && t(xy, i),
        n.value.checked = e.modelValue === a.value
    }
  })
    , s = hS(yi((()=>null == r ? void 0 : r.size)))
    , l = vS(yi((()=>null == r ? void 0 : r.disabled)))
    , u = Ft(!1)
    , c = yi((()=>l.value || o.value && i.value !== a.value ? -1 : 0));
  return Ny({
    from: "label act as value",
    replacement: "value",
    version: "3.0.0",
    scope: "el-radio",
    ref: "https://element-plus.org/en-US/component/radio.html"
  }, yi((()=>o.value && Hg(e.value)))),
    {
      radioRef: n,
      isGroup: o,
      radioGroup: r,
      focus: u,
      size: s,
      disabled: l,
      tabIndex: c,
      modelValue: i,
      actualValue: a
    }
}
  , LD = ["value", "name", "disabled"]
  , ID = vr({
  name: "ElRadio"
});
var PD = tS(vr({
  ...ID,
  props: DD,
  emits: OD,
  setup(e, {emit: t}) {
    const n = e
      , r = qy("radio")
      , {radioRef: o, radioGroup: a, focus: i, size: s, disabled: l, modelValue: u, actualValue: c} = RD(n, t);
    function d() {
      hn((()=>t("change", u.value)))
    }
    return (e,t)=>{
      var n;
      return Ca(),
        _a("label", {
          class: Y([Vt(r).b(), Vt(r).is("disabled", Vt(l)), Vt(r).is("focus", Vt(i)), Vt(r).is("bordered", e.border), Vt(r).is("checked", Vt(u) === Vt(c)), Vt(r).m(Vt(s))])
        }, [Ma("span", {
          class: Y([Vt(r).e("input"), Vt(r).is("disabled", Vt(l)), Vt(r).is("checked", Vt(u) === Vt(c))])
        }, [rr(Ma("input", {
          ref_key: "radioRef",
          ref: o,
          "onUpdate:modelValue": t[0] || (t[0] = e=>Pt(u) ? u.value = e : null),
          class: Y(Vt(r).e("original")),
          value: Vt(c),
          name: e.name || (null == (n = Vt(a)) ? void 0 : n.name),
          disabled: Vt(l),
          type: "radio",
          onFocus: t[1] || (t[1] = e=>i.value = !0),
          onBlur: t[2] || (t[2] = e=>i.value = !1),
          onChange: d,
          onClick: t[3] || (t[3] = js((()=>{}
          ), ["stop"]))
        }, null, 42, LD), [[Os, Vt(u)]]), Ma("span", {
          class: Y(Vt(r).e("inner"))
        }, null, 2)], 2), Ma("span", {
          class: Y(Vt(r).e("label")),
          onKeydown: t[4] || (t[4] = js((()=>{}
          ), ["stop"]))
        }, [Qr(e.$slots, "default", {}, (()=>[$a(te(e.label), 1)]))], 34)], 2)
    }
  }
}), [["__file", "radio.vue"]]);
const FD = uy({
  ...TD
})
  , BD = ["value", "name", "disabled"]
  , ND = vr({
  name: "ElRadioButton"
});
var MD = tS(vr({
  ...ND,
  props: FD,
  setup(e) {
    const t = e
      , n = qy("radio")
      , {radioRef: r, focus: o, size: a, disabled: i, modelValue: s, radioGroup: l, actualValue: u} = RD(t)
      , c = yi((()=>({
      backgroundColor: (null == l ? void 0 : l.fill) || "",
      borderColor: (null == l ? void 0 : l.fill) || "",
      boxShadow: (null == l ? void 0 : l.fill) ? `-1px 0 0 0 ${l.fill}` : "",
      color: (null == l ? void 0 : l.textColor) || ""
    })));
    return (e,t)=>{
      var d;
      return Ca(),
        _a("label", {
          class: Y([Vt(n).b("button"), Vt(n).is("active", Vt(s) === Vt(u)), Vt(n).is("disabled", Vt(i)), Vt(n).is("focus", Vt(o)), Vt(n).bm("button", Vt(a))])
        }, [rr(Ma("input", {
          ref_key: "radioRef",
          ref: r,
          "onUpdate:modelValue": t[0] || (t[0] = e=>Pt(s) ? s.value = e : null),
          class: Y(Vt(n).be("button", "original-radio")),
          value: Vt(u),
          type: "radio",
          name: e.name || (null == (d = Vt(l)) ? void 0 : d.name),
          disabled: Vt(i),
          onFocus: t[1] || (t[1] = e=>o.value = !0),
          onBlur: t[2] || (t[2] = e=>o.value = !1),
          onClick: t[3] || (t[3] = js((()=>{}
          ), ["stop"]))
        }, null, 42, BD), [[Os, Vt(s)]]), Ma("span", {
          class: Y(Vt(n).be("button", "inner")),
          style: z(Vt(s) === Vt(u) ? Vt(c) : {}),
          onKeydown: t[4] || (t[4] = js((()=>{}
          ), ["stop"]))
        }, [Qr(e.$slots, "default", {}, (()=>[$a(te(e.label), 1)]))], 38)], 2)
    }
  }
}), [["__file", "radio-button.vue"]]);
const jD = uy({
  id: {
    type: String,
    default: void 0
  },
  size: Ux,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  fill: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
})
  , VD = OD
  , UD = ["id", "aria-label", "aria-labelledby"]
  , $D = vr({
  name: "ElRadioGroup"
})
  , HD = vr({
  ...$D,
  props: jD,
  emits: VD,
  setup(e, {emit: t}) {
    const n = e
      , r = qy("radio")
      , o = Cw()
      , a = Ft()
      , {formItem: i} = gS()
      , {inputId: s, isLabeledByFormItem: l} = mS(n, {
      formItemContext: i
    });
    Lr((()=>{
        const e = a.value.querySelectorAll("[type=radio]")
          , t = e[0];
        !Array.from(e).some((e=>e.checked)) && t && (t.tabIndex = 0)
      }
    ));
    const u = yi((()=>n.name || o.value));
    return Mo(_D, bt({
      ...Wt(n),
      changeEvent: e=>{
        t(xy, e),
          hn((()=>t("change", e)))
      }
      ,
      name: u
    })),
      Jn((()=>n.modelValue), (()=>{
          n.validateEvent && (null == i || i.validate("change").catch((e=>{}
          )))
        }
      )),
      (e,t)=>(Ca(),
        _a("div", {
          id: Vt(s),
          ref_key: "radioGroupRef",
          ref: a,
          class: Y(Vt(r).b("group")),
          role: "radiogroup",
          "aria-label": Vt(l) ? void 0 : e.label || "radio-group",
          "aria-labelledby": Vt(l) ? Vt(i).labelId : void 0
        }, [Qr(e.$slots, "default")], 10, UD))
  }
});
var zD = tS(HD, [["__file", "radio-group.vue"]]);
const KD = vy(PD, {
  RadioButton: MD,
  RadioGroup: zD
})
  , WD = my(zD)
  , GD = my(MD);
var qD = vr({
  name: "NodeContent",
  setup: ()=>({
    ns: qy("cascader-node")
  }),
  render() {
    const {ns: e} = this
      , {node: t, panel: n} = this.$parent
      , {data: r, label: o} = t
      , {renderLabelFn: a} = n;
    return bi("span", {
      class: e.e("label")
    }, a ? a({
      node: t,
      data: r
    }) : o)
  }
});
const YD = Symbol()
  , XD = vr({
  name: "ElCascaderNode",
  components: {
    ElCheckbox: AD,
    ElRadio: KD,
    NodeContent: qD,
    ElIcon: sS,
    Check: Sm,
    Loading: Mm,
    ArrowRight: gm
  },
  props: {
    node: {
      type: Object,
      required: !0
    },
    menuId: String
  },
  emits: ["expand"],
  setup(e, {emit: t}) {
    const n = jo(YD)
      , r = qy("cascader-node")
      , o = yi((()=>n.isHoverMenu))
      , a = yi((()=>n.config.multiple))
      , i = yi((()=>n.config.checkStrictly))
      , s = yi((()=>{
          var e;
          return null == (e = n.checkedNodes[0]) ? void 0 : e.uid
        }
      ))
      , l = yi((()=>e.node.isDisabled))
      , u = yi((()=>e.node.isLeaf))
      , c = yi((()=>i.value && !u.value || !l.value))
      , d = yi((()=>p(n.expandingNode)))
      , f = yi((()=>i.value && n.checkedNodes.some(p)))
      , p = t=>{
        var n;
        const {level: r, uid: o} = e.node;
        return (null == (n = null == t ? void 0 : t.pathNodes[r - 1]) ? void 0 : n.uid) === o
      }
      , h = ()=>{
        d.value || n.expandNode(e.node)
      }
      , v = t=>{
        const {node: r} = e;
        t !== r.checked && n.handleCheckChange(r, t)
      }
      , g = ()=>{
        n.lazyLoad(e.node, (()=>{
            u.value || h()
          }
        ))
      }
      , m = ()=>{
        const {node: t} = e;
        c.value && !t.loading && (t.loaded ? h() : g())
      }
      , y = t=>{
        e.node.loaded ? (v(t),
        !i.value && h()) : g()
      }
    ;
    return {
      panel: n,
      isHoverMenu: o,
      multiple: a,
      checkStrictly: i,
      checkedNodeId: s,
      isDisabled: l,
      isLeaf: u,
      expandable: c,
      inExpandingPath: d,
      inCheckedPath: f,
      ns: r,
      handleHoverExpand: e=>{
        o.value && (m(),
        !u.value && t("expand", e))
      }
      ,
      handleExpand: m,
      handleClick: ()=>{
        o.value && !u.value || (!u.value || l.value || i.value || a.value ? m() : y(!0))
      }
      ,
      handleCheck: y,
      handleSelectCheck: t=>{
        i.value ? (v(t),
        e.node.loaded && h()) : y(t)
      }
    }
  }
})
  , QD = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"]
  , JD = Ma("span", null, null, -1);
const ZD = vr({
  name: "ElCascaderMenu",
  components: {
    Loading: Mm,
    ElIcon: sS,
    ElScrollbar: DE,
    ElCascaderNode: tS(XD, [["render", function(e, t, n, r, o, a) {
      const i = Hr("el-checkbox")
        , s = Hr("el-radio")
        , l = Hr("check")
        , u = Hr("el-icon")
        , c = Hr("node-content")
        , d = Hr("loading")
        , f = Hr("arrow-right");
      return Ca(),
        _a("li", {
          id: `${e.menuId}-${e.node.uid}`,
          role: "menuitem",
          "aria-haspopup": !e.isLeaf,
          "aria-owns": e.isLeaf ? null : e.menuId,
          "aria-expanded": e.inExpandingPath,
          tabindex: e.expandable ? -1 : void 0,
          class: Y([e.ns.b(), e.ns.is("selectable", e.checkStrictly), e.ns.is("active", e.node.checked), e.ns.is("disabled", !e.expandable), e.inExpandingPath && "in-active-path", e.inCheckedPath && "in-checked-path"]),
          onMouseenter: t[2] || (t[2] = (...t)=>e.handleHoverExpand && e.handleHoverExpand(...t)),
          onFocus: t[3] || (t[3] = (...t)=>e.handleHoverExpand && e.handleHoverExpand(...t)),
          onClick: t[4] || (t[4] = (...t)=>e.handleClick && e.handleClick(...t))
        }, [za(" prefix "), e.multiple ? (Ca(),
          Ra(i, {
            key: 0,
            "model-value": e.node.checked,
            indeterminate: e.node.indeterminate,
            disabled: e.isDisabled,
            onClick: t[0] || (t[0] = js((()=>{}
            ), ["stop"])),
            "onUpdate:modelValue": e.handleSelectCheck
          }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : e.checkStrictly ? (Ca(),
          Ra(s, {
            key: 1,
            "model-value": e.checkedNodeId,
            label: e.node.uid,
            disabled: e.isDisabled,
            "onUpdate:modelValue": e.handleSelectCheck,
            onClick: t[1] || (t[1] = js((()=>{}
            ), ["stop"]))
          }, {
            default: Fn((()=>[za("\n        Add an empty element to avoid render label,\n        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n      "), JD])),
            _: 1
          }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : e.isLeaf && e.node.checked ? (Ca(),
          Ra(u, {
            key: 2,
            class: Y(e.ns.e("prefix"))
          }, {
            default: Fn((()=>[ja(l)])),
            _: 1
          }, 8, ["class"])) : za("v-if", !0), za(" content "), ja(c), za(" postfix "), e.isLeaf ? za("v-if", !0) : (Ca(),
          _a(ba, {
            key: 3
          }, [e.node.loading ? (Ca(),
            Ra(u, {
              key: 0,
              class: Y([e.ns.is("loading"), e.ns.e("postfix")])
            }, {
              default: Fn((()=>[ja(d)])),
              _: 1
            }, 8, ["class"])) : (Ca(),
            Ra(u, {
              key: 1,
              class: Y(["arrow-right", e.ns.e("postfix")])
            }, {
              default: Fn((()=>[ja(f)])),
              _: 1
            }, 8, ["class"]))], 64))], 42, QD)
    }
    ], ["__file", "node.vue"]])
  },
  props: {
    nodes: {
      type: Array,
      required: !0
    },
    index: {
      type: Number,
      required: !0
    }
  },
  setup(e) {
    const t = ei()
      , n = qy("cascader-menu")
      , {t: r} = Hy()
      , o = Cw();
    let a = null
      , i = null;
    const s = jo(YD)
      , l = Ft(null)
      , u = yi((()=>!e.nodes.length))
      , c = yi((()=>!s.initialLoaded))
      , d = yi((()=>`${o.value}-${e.index}`))
      , f = ()=>{
        i && (clearTimeout(i),
          i = null)
      }
      , p = ()=>{
        l.value && (l.value.innerHTML = "",
          f())
      }
    ;
    return {
      ns: n,
      panel: s,
      hoverZone: l,
      isEmpty: u,
      isLoading: c,
      menuId: d,
      t: r,
      handleExpand: e=>{
        a = e.target
      }
      ,
      handleMouseMove: e=>{
        if (s.isHoverMenu && a && l.value)
          if (a.contains(e.target)) {
            f();
            const n = t.vnode.el
              , {left: r} = n.getBoundingClientRect()
              , {offsetWidth: o, offsetHeight: i} = n
              , s = e.clientX - r
              , u = a.offsetTop
              , c = u + a.offsetHeight;
            l.value.innerHTML = `\n          <path style="pointer-events: auto;" fill="transparent" d="M${s} ${u} L${o} 0 V${u} Z" />\n          <path style="pointer-events: auto;" fill="transparent" d="M${s} ${c} L${o} ${i} V${c} Z" />\n        `
          } else
            i || (i = window.setTimeout(p, s.config.hoverThreshold))
      }
      ,
      clearHoverZone: p
    }
  }
});
var eO = tS(ZD, [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-cascader-node")
    , s = Hr("loading")
    , l = Hr("el-icon")
    , u = Hr("el-scrollbar");
  return Ca(),
    Ra(u, {
      key: e.menuId,
      tag: "ul",
      role: "menu",
      class: Y(e.ns.b()),
      "wrap-class": e.ns.e("wrap"),
      "view-class": [e.ns.e("list"), e.ns.is("empty", e.isEmpty)],
      onMousemove: e.handleMouseMove,
      onMouseleave: e.clearHoverZone
    }, {
      default: Fn((()=>{
          var t;
          return [(Ca(!0),
            _a(ba, null, Yr(e.nodes, (t=>(Ca(),
              Ra(i, {
                key: t.uid,
                node: t,
                "menu-id": e.menuId,
                onExpand: e.handleExpand
              }, null, 8, ["node", "menu-id", "onExpand"])))), 128)), e.isLoading ? (Ca(),
            _a("div", {
              key: 0,
              class: Y(e.ns.e("empty-text"))
            }, [ja(l, {
              size: "14",
              class: Y(e.ns.is("loading"))
            }, {
              default: Fn((()=>[ja(s)])),
              _: 1
            }, 8, ["class"]), $a(" " + te(e.t("el.cascader.loading")), 1)], 2)) : e.isEmpty ? (Ca(),
            _a("div", {
              key: 1,
              class: Y(e.ns.e("empty-text"))
            }, te(e.t("el.cascader.noData")), 3)) : (null == (t = e.panel) ? void 0 : t.isHoverMenu) ? (Ca(),
            _a("svg", {
              key: 2,
              ref: "hoverZone",
              class: Y(e.ns.e("hover-zone"))
            }, null, 2)) : za("v-if", !0)]
        }
      )),
      _: 1
    }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"])
}
], ["__file", "menu.vue"]]);
let tO = 0;
let nO = class e {
    constructor(t, n, r, o=!1) {
      this.data = t,
        this.config = n,
        this.parent = r,
        this.root = o,
        this.uid = tO++,
        this.checked = !1,
        this.indeterminate = !1,
        this.loading = !1;
      const {value: a, label: i, children: s} = n
        , l = t[s]
        , u = (e=>{
          const t = [e];
          let {parent: n} = e;
          for (; n; )
            t.unshift(n),
              n = n.parent;
          return t
        }
      )(this);
      this.level = o ? 0 : r ? r.level + 1 : 1,
        this.value = t[a],
        this.label = t[i],
        this.pathNodes = u,
        this.pathValues = u.map((e=>e.value)),
        this.pathLabels = u.map((e=>e.label)),
        this.childrenData = l,
        this.children = (l || []).map((t=>new e(t,n,this))),
        this.loaded = !n.lazy || this.isLeaf || !Ug(l)
    }
    get isDisabled() {
      const {data: e, parent: t, config: n} = this
        , {disabled: r, checkStrictly: o} = n;
      return (y(r) ? r(e, this) : !!e[r]) || !o && (null == t ? void 0 : t.isDisabled)
    }
    get isLeaf() {
      const {data: e, config: t, childrenData: n, loaded: r} = this
        , {lazy: o, leaf: a} = t
        , i = y(a) ? a(e, this) : e[a];
      return Mg(i) ? !(o && !r) && !(Array.isArray(n) && n.length) : !!i
    }
    get valueByOption() {
      return this.config.emitPath ? this.pathValues : this.value
    }
    appendChild(t) {
      const {childrenData: n, children: r} = this
        , o = new e(t,this.config,this);
      return Array.isArray(n) ? n.push(t) : this.childrenData = [t],
        r.push(o),
        o
    }
    calcText(e, t) {
      const n = e ? this.pathLabels.join(t) : this.label;
      return this.text = n,
        n
    }
    broadcast(e, ...t) {
      const n = `onParent${qg(e)}`;
      this.children.forEach((r=>{
          r && (r.broadcast(e, ...t),
          r[n] && r[n](...t))
        }
      ))
    }
    emit(e, ...t) {
      const {parent: n} = this
        , r = `onChild${qg(e)}`;
      n && (n[r] && n[r](...t),
        n.emit(e, ...t))
    }
    onParentCheck(e) {
      this.isDisabled || this.setCheckState(e)
    }
    onChildCheck() {
      const {children: e} = this
        , t = e.filter((e=>!e.isDisabled))
        , n = !!t.length && t.every((e=>e.checked));
      this.setCheckState(n)
    }
    setCheckState(e) {
      const t = this.children.length
        , n = this.children.reduce(((e,t)=>e + (t.checked ? 1 : t.indeterminate ? .5 : 0)), 0);
      this.checked = this.loaded && this.children.filter((e=>!e.isDisabled)).every((e=>e.loaded && e.checked)) && e,
        this.indeterminate = this.loaded && n !== t && n > 0
    }
    doCheck(e) {
      if (this.checked === e)
        return;
      const {checkStrictly: t, multiple: n} = this.config;
      t || !n ? this.checked = e : (this.broadcast("check", e),
        this.setCheckState(e),
        this.emit("check"))
    }
  }
;
const rO = (e,t)=>e.reduce(((e,n)=>(n.isLeaf ? e.push(n) : (!t && e.push(n),
  e = e.concat(rO(n.children, t))),
  e)), []);
class oO {
  constructor(e, t) {
    this.config = t;
    const n = (e || []).map((e=>new nO(e,this.config)));
    this.nodes = n,
      this.allNodes = rO(n, !1),
      this.leafNodes = rO(n, !0)
  }
  getNodes() {
    return this.nodes
  }
  getFlattedNodes(e) {
    return e ? this.leafNodes : this.allNodes
  }
  appendNode(e, t) {
    const n = t ? t.appendChild(e) : new nO(e,this.config);
    t || this.nodes.push(n),
      this.allNodes.push(n),
    n.isLeaf && this.leafNodes.push(n)
  }
  appendNodes(e, t) {
    e.forEach((e=>this.appendNode(e, t)))
  }
  getNodeByValue(e, t=!1) {
    if (!e && 0 !== e)
      return null;
    return this.getFlattedNodes(t).find((t=>Ag(t.value, e) || Ag(t.pathValues, e))) || null
  }
  getSameNode(e) {
    if (!e)
      return null;
    return this.getFlattedNodes(!1).find((({value: t, level: n})=>Ag(e.value, t) && e.level === n)) || null
  }
}
const aO = uy({
  modelValue: {
    type: [Number, String, Array]
  },
  options: {
    type: Array,
    default: ()=>[]
  },
  props: {
    type: Object,
    default: ()=>({})
  }
})
  , iO = {
  expandTrigger: "click",
  multiple: !1,
  checkStrictly: !1,
  emitPath: !0,
  lazy: !1,
  lazyLoad: a,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
}
  , sO = e=>{
  if (!e)
    return 0;
  const t = e.id.split("-");
  return Number(t[t.length - 2])
}
  , lO = vr({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu: eO
  },
  props: {
    ...aO,
    border: {
      type: Boolean,
      default: !0
    },
    renderLabel: Function
  },
  emits: [xy, Sy, "close", "expand-change"],
  setup(e, {emit: t, slots: n}) {
    let r = !1;
    const o = qy("cascader")
      , a = (e=>yi((()=>({
      ...iO,
      ...e.props
    }))))(e);
    let i = null;
    const s = Ft(!0)
      , l = Ft([])
      , u = Ft(null)
      , c = Ft([])
      , d = Ft(null)
      , f = Ft([])
      , p = yi((()=>"hover" === a.value.expandTrigger))
      , h = yi((()=>e.renderLabel || n.default))
      , v = (e,t)=>{
        const n = a.value;
        (e = e || new nO({},n,void 0,!0)).loading = !0;
        n.lazyLoad(e, (n=>{
            const r = e
              , o = r.root ? null : r;
            n && (null == i || i.appendNodes(n, o)),
              r.loading = !1,
              r.loaded = !0,
              r.childrenData = r.childrenData || [],
            t && t(n)
          }
        ))
      }
      , g = (e,n)=>{
        var r;
        const {level: o} = e
          , a = c.value.slice(0, o);
        let i;
        e.isLeaf ? i = e.pathNodes[o - 2] : (i = e,
          a.push(e.children)),
        (null == (r = d.value) ? void 0 : r.uid) !== (null == i ? void 0 : i.uid) && (d.value = e,
          c.value = a,
        !n && t("expand-change", (null == e ? void 0 : e.pathValues) || []))
      }
      , m = (e,n,o=!0)=>{
        const {checkStrictly: i, multiple: s} = a.value
          , l = f.value[0];
        r = !0,
        !s && (null == l || l.doCheck(!1)),
          e.doCheck(n),
          x(),
        o && !s && !i && t("close"),
        !o && !s && !i && y(e)
      }
      , y = e=>{
        e && (e = e.parent,
          y(e),
        e && g(e))
      }
      , b = e=>null == i ? void 0 : i.getFlattedNodes(e)
      , w = e=>{
        var t;
        return null == (t = b(e)) ? void 0 : t.filter((e=>!1 !== e.checked))
      }
      , x = ()=>{
        var e;
        const {checkStrictly: t, multiple: n} = a.value
          , r = ((e,t)=>{
            const n = t.slice(0)
              , r = n.map((e=>e.uid))
              , o = e.reduce(((e,t)=>{
                const o = r.indexOf(t.uid);
                return o > -1 && (e.push(t),
                  n.splice(o, 1),
                  r.splice(o, 1)),
                  e
              }
            ), []);
            return o.push(...n),
              o
          }
        )(f.value, w(!t))
          , o = r.map((e=>e.valueByOption));
        f.value = r,
          u.value = n ? o : null != (e = o[0]) ? e : null
      }
      , S = (t=!1,n=!1)=>{
        const {modelValue: o} = e
          , {lazy: l, multiple: c, checkStrictly: d} = a.value
          , f = !d;
        var p;
        if (s.value && !r && (n || !Ag(o, u.value)))
          if (l && !t) {
            const e = Ry(null != (p = Ly(o)) && p.length ? Bp(p, 1 / 0) : []).map((e=>null == i ? void 0 : i.getNodeByValue(e))).filter((e=>!!e && !e.loaded && !e.loading));
            e.length ? e.forEach((e=>{
                v(e, (()=>S(!1, n)))
              }
            )) : S(!0, n)
          } else {
            const e = c ? Ly(o) : [o]
              , t = Ry(e.map((e=>null == i ? void 0 : i.getNodeByValue(e, f))));
            E(t, n),
              u.value = dv(o)
          }
      }
      , E = (t,n=!0)=>{
        const {checkStrictly: r} = a.value
          , o = f.value
          , s = t.filter((e=>!!e && (r || e.isLeaf)))
          , l = null == i ? void 0 : i.getSameNode(d.value)
          , u = n && l || s[0];
        u ? u.pathNodes.forEach((e=>g(e, !0))) : d.value = null,
          o.forEach((e=>e.doCheck(!1))),
          e.props.multiple ? bt(s).forEach((e=>e.doCheck(!0))) : s.forEach((e=>e.doCheck(!0))),
          f.value = s,
          hn(A)
      }
      , A = ()=>{
        mc && l.value.forEach((e=>{
            const t = null == e ? void 0 : e.$el;
            if (t) {
              um(t.querySelector(`.${o.namespace.value}-scrollbar__wrap`), t.querySelector(`.${o.b("node")}.${o.is("active")}`) || t.querySelector(`.${o.b("node")}.in-active-path`))
            }
          }
        ))
      }
    ;
    return Mo(YD, bt({
      config: a,
      expandingNode: d,
      checkedNodes: f,
      isHoverMenu: p,
      initialLoaded: s,
      renderLabelFn: h,
      lazyLoad: v,
      expandNode: g,
      handleCheckChange: m
    })),
      Jn([a, ()=>e.options], (()=>{
          const {options: t} = e
            , n = a.value;
          r = !1,
            i = new oO(t,n),
            c.value = [i.getNodes()],
            n.lazy && Ug(e.options) ? (s.value = !1,
              v(void 0, (e=>{
                  e && (i = new oO(e,n),
                    c.value = [i.getNodes()]),
                    s.value = !0,
                    S(!1, !0)
                }
              ))) : S(!1, !0)
        }
      ), {
        deep: !0,
        immediate: !0
      }),
      Jn((()=>e.modelValue), (()=>{
          r = !1,
            S()
        }
      ), {
        deep: !0
      }),
      Jn((()=>u.value), (n=>{
          Ag(n, e.modelValue) || (t(xy, n),
            t(Sy, n))
        }
      )),
      Ir((()=>l.value = [])),
      Lr((()=>!Ug(e.modelValue) && S())),
      {
        ns: o,
        menuList: l,
        menus: c,
        checkedNodes: f,
        handleKeyDown: e=>{
          const t = e.target
            , {code: n} = e;
          switch (n) {
            case by.up:
            case by.down:
            {
              e.preventDefault();
              const r = n === by.up ? -1 : 1;
              ac(oc(t, r, `.${o.b("node")}[tabindex="-1"]`));
              break
            }
            case by.left:
            {
              e.preventDefault();
              const n = l.value[sO(t) - 1]
                , r = null == n ? void 0 : n.$el.querySelector(`.${o.b("node")}[aria-expanded="true"]`);
              ac(r);
              break
            }
            case by.right:
            {
              e.preventDefault();
              const n = l.value[sO(t) + 1]
                , r = null == n ? void 0 : n.$el.querySelector(`.${o.b("node")}[tabindex="-1"]`);
              ac(r);
              break
            }
            case by.enter:
              (e=>{
                  if (!e)
                    return;
                  const t = e.querySelector("input");
                  t ? t.click() : rc(e) && e.click()
                }
              )(t)
          }
        }
        ,
        handleCheckChange: m,
        getFlattedNodes: b,
        getCheckedNodes: w,
        clearCheckedNodes: ()=>{
          f.value.forEach((e=>e.doCheck(!1))),
            x(),
            c.value = c.value.slice(0, 1),
            d.value = null,
            t("expand-change", [])
        }
        ,
        calculateCheckedValue: x,
        scrollToExpandingNode: A
      }
  }
});
var uO = tS(lO, [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-cascader-menu");
  return Ca(),
    _a("div", {
      class: Y([e.ns.b("panel"), e.ns.is("bordered", e.border)]),
      onKeydown: t[0] || (t[0] = (...t)=>e.handleKeyDown && e.handleKeyDown(...t))
    }, [(Ca(!0),
      _a(ba, null, Yr(e.menus, ((t,n)=>(Ca(),
        Ra(i, {
          key: n,
          ref_for: !0,
          ref: t=>e.menuList[n] = t,
          index: n,
          nodes: [...t]
        }, null, 8, ["index", "nodes"])))), 128))], 34)
}
], ["__file", "index.vue"]]);
uO.install = e=>{
  e.component(uO.name, uO)
}
;
const cO = uO
  , dO = cO
  , fO = uy({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: String,
  size: {
    type: String,
    values: Cy
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
})
  , pO = {
  close: e=>e instanceof MouseEvent,
  click: e=>e instanceof MouseEvent
}
  , hO = vr({
  name: "ElTag"
});
const vO = vy(tS(vr({
  ...hO,
  props: fO,
  emits: pO,
  setup(e, {emit: t}) {
    const n = e
      , r = hS()
      , o = qy("tag")
      , a = yi((()=>{
          const {type: e, hit: t, effect: a, closable: i, round: s} = n;
          return [o.b(), o.is("closable", i), o.m(e || "primary"), o.m(r.value), o.m(a), o.is("hit", t), o.is("round", s)]
        }
      ))
      , i = e=>{
        t("close", e)
      }
      , s = e=>{
        t("click", e)
      }
    ;
    return (e,t)=>e.disableTransitions ? (Ca(),
      _a("span", {
        key: 0,
        class: Y(Vt(a)),
        style: z({
          backgroundColor: e.color
        }),
        onClick: s
      }, [Ma("span", {
        class: Y(Vt(o).e("content"))
      }, [Qr(e.$slots, "default")], 2), e.closable ? (Ca(),
        Ra(Vt(sS), {
          key: 0,
          class: Y(Vt(o).e("close")),
          onClick: js(i, ["stop"])
        }, {
          default: Fn((()=>[ja(Vt(Dm))])),
          _: 1
        }, 8, ["class", "onClick"])) : za("v-if", !0)], 6)) : (Ca(),
      Ra(es, {
        key: 1,
        name: `${Vt(o).namespace.value}-zoom-in-center`,
        appear: ""
      }, {
        default: Fn((()=>[Ma("span", {
          class: Y(Vt(a)),
          style: z({
            backgroundColor: e.color
          }),
          onClick: s
        }, [Ma("span", {
          class: Y(Vt(o).e("content"))
        }, [Qr(e.$slots, "default")], 2), e.closable ? (Ca(),
          Ra(Vt(sS), {
            key: 0,
            class: Y(Vt(o).e("close")),
            onClick: js(i, ["stop"])
          }, {
            default: Fn((()=>[ja(Vt(Dm))])),
            _: 1
          }, 8, ["class", "onClick"])) : za("v-if", !0)], 6)])),
        _: 3
      }, 8, ["name"]))
  }
}), [["__file", "tag.vue"]]))
  , gO = uy({
  ...aO,
  size: Ux,
  placeholder: String,
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  filterMethod: {
    type: Function,
    default: (e,t)=>e.text.includes(t)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: !0
  },
  collapseTags: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  collapseTagsTooltip: {
    type: Boolean,
    default: !1
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: Function,
    default: ()=>!0
  },
  popperClass: {
    type: String,
    default: ""
  },
  teleported: SA.teleported,
  tagType: {
    ...fO.type,
    default: "info"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
})
  , mO = {
  [xy]: e=>!!e || null === e,
  [Sy]: e=>!!e || null === e,
  focus: e=>e instanceof FocusEvent,
  blur: e=>e instanceof FocusEvent,
  visibleChange: e=>jg(e),
  expandChange: e=>!!e,
  removeTag: e=>!!e
}
  , yO = {
  key: 0
}
  , bO = ["placeholder", "onKeydown"]
  , wO = ["onClick"]
  , xO = vr({
  name: "ElCascader"
})
  , SO = vr({
  ...xO,
  props: gO,
  emits: mO,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = {
      modifiers: [{
        name: "arrowPosition",
        enabled: !0,
        phase: "main",
        fn: ({state: e})=>{
          const {modifiersData: t, placement: n} = e;
          ["right", "left", "bottom", "top"].includes(n) || (t.arrow.x = 35)
        }
        ,
        requires: ["arrow"]
      }]
    }
      , a = ho();
    let i = 0
      , s = 0;
    const l = qy("cascader")
      , u = qy("input")
      , {t: c} = Hy()
      , {form: d, formItem: f} = gS()
      , p = Ft(null)
      , h = Ft(null)
      , v = Ft(null)
      , g = Ft(null)
      , m = Ft(null)
      , y = Ft(!1)
      , b = Ft(!1)
      , w = Ft(!1)
      , x = Ft(!1)
      , E = Ft("")
      , A = Ft("")
      , C = Ft([])
      , k = Ft([])
      , T = Ft([])
      , D = Ft(!1)
      , O = yi((()=>a.style))
      , _ = yi((()=>r.disabled || (null == d ? void 0 : d.disabled)))
      , R = yi((()=>r.placeholder || c("el.cascader.placeholder")))
      , L = yi((()=>A.value || C.value.length > 0 || D.value ? "" : R.value))
      , I = hS()
      , P = yi((()=>["small"].includes(I.value) ? "small" : "default"))
      , F = yi((()=>!!r.props.multiple))
      , B = yi((()=>!r.filterable || F.value))
      , N = yi((()=>F.value ? A.value : E.value))
      , M = yi((()=>{
        var e;
        return (null == (e = g.value) ? void 0 : e.checkedNodes) || []
      }
    ))
      , j = yi((()=>!(!r.clearable || _.value || w.value || !b.value) && !!M.value.length))
      , V = yi((()=>{
        const {showAllLevels: e, separator: t} = r
          , n = M.value;
        return n.length ? F.value ? "" : n[0].calcText(e, t) : ""
      }
    ))
      , U = yi({
      get: ()=>dv(r.modelValue),
      set(e) {
        n(xy, e),
          n(Sy, e),
        r.validateEvent && (null == f || f.validate("change").catch((e=>{}
        )))
      }
    })
      , $ = yi((()=>[l.b(), l.m(I.value), l.is("disabled", _.value), a.class]))
      , H = yi((()=>[u.e("icon"), "icon-arrow-down", l.is("reverse", y.value)]))
      , K = yi((()=>l.is("focus", y.value || x.value)))
      , W = yi((()=>{
        var e, t;
        return null == (t = null == (e = p.value) ? void 0 : e.popperRef) ? void 0 : t.contentRef
      }
    ))
      , G = e=>{
      var t, o, a;
      _.value || (e = null != e ? e : !y.value) !== y.value && (y.value = e,
      null == (o = null == (t = h.value) ? void 0 : t.input) || o.setAttribute("aria-expanded", `${e}`),
        e ? (q(),
          hn(null == (a = g.value) ? void 0 : a.scrollToExpandingNode)) : r.filterable && se(),
        n("visibleChange", e))
    }
      , q = ()=>{
      hn((()=>{
          var e;
          null == (e = p.value) || e.updatePopper()
        }
      ))
    }
      , X = ()=>{
      w.value = !1
    }
      , Q = e=>{
      const {showAllLevels: t, separator: n} = r;
      return {
        node: e,
        key: e.uid,
        text: e.calcText(t, n),
        hitState: !1,
        closable: !_.value && !e.isDisabled,
        isCollapseTag: !1
      }
    }
      , J = e=>{
      var t;
      const r = e.node;
      r.doCheck(!1),
      null == (t = g.value) || t.calculateCheckedValue(),
        n("removeTag", r.valueByOption)
    }
      , Z = ()=>{
      var e, t;
      const {filterMethod: n, showAllLevels: o, separator: a} = r
        , i = null == (t = null == (e = g.value) ? void 0 : e.getFlattedNodes(!r.props.checkStrictly)) ? void 0 : t.filter((e=>!e.isDisabled && (e.calcText(o, a),
        n(e, N.value))));
      F.value && (C.value.forEach((e=>{
          e.hitState = !1
        }
      )),
        k.value.forEach((e=>{
            e.hitState = !1
          }
        ))),
        w.value = !0,
        T.value = i,
        q()
    }
      , ee = ()=>{
      var e;
      let t;
      t = w.value && m.value ? m.value.$el.querySelector(`.${l.e("suggestion-item")}`) : null == (e = g.value) ? void 0 : e.$el.querySelector(`.${l.b("node")}[tabindex="-1"]`),
      t && (t.focus(),
      !w.value && t.click())
    }
      , ne = ()=>{
      var e, t;
      const n = null == (e = h.value) ? void 0 : e.input
        , r = v.value
        , o = null == (t = m.value) ? void 0 : t.$el;
      if (mc && n) {
        if (o) {
          o.querySelector(`.${l.e("suggestion-list")}`).style.minWidth = `${n.offsetWidth}px`
        }
        if (r) {
          const {offsetHeight: e} = r
            , t = C.value.length > 0 ? `${Math.max(e + 6, i)}px` : `${i}px`;
          n.style.height = t,
            q()
        }
      }
    }
      , re = e=>{
      q(),
        n("expandChange", e)
    }
      , oe = e=>{
      var t;
      const n = null == (t = e.target) ? void 0 : t.value;
      if ("compositionend" === e.type)
        D.value = !1,
          hn((()=>pe(n)));
      else {
        const e = n[n.length - 1] || "";
        D.value = !Iy(e)
      }
    }
      , ae = e=>{
      if (!D.value)
        switch (e.code) {
          case by.enter:
            G();
            break;
          case by.down:
            G(!0),
              hn(ee),
              e.preventDefault();
            break;
          case by.esc:
            !0 === y.value && (e.preventDefault(),
              e.stopPropagation(),
              G(!1));
            break;
          case by.tab:
            G(!1)
        }
    }
      , ie = ()=>{
      var e;
      null == (e = g.value) || e.clearCheckedNodes(),
      !y.value && r.filterable && se(),
        G(!1)
    }
      , se = ()=>{
      const {value: e} = V;
      E.value = e,
        A.value = e
    }
      , le = e=>{
      const t = e.target
        , {code: n} = e;
      switch (n) {
        case by.up:
        case by.down:
        {
          const e = n === by.up ? -1 : 1;
          ac(oc(t, e, `.${l.e("suggestion-item")}[tabindex="-1"]`));
          break
        }
        case by.enter:
          t.click()
      }
    }
      , ue = ()=>{
      const e = C.value
        , t = e[e.length - 1];
      s = A.value ? 0 : s + 1,
      !t || !s || r.collapseTags && e.length > 1 || (t.hitState ? J(t) : t.hitState = !0)
    }
      , ce = e=>{
      const t = e.target
        , r = l.e("search-input");
      t.className === r && (x.value = !0),
        n("focus", e)
    }
      , de = e=>{
      x.value = !1,
        n("blur", e)
    }
      , fe = ug((()=>{
        const {value: e} = N;
        if (!e)
          return;
        const t = r.beforeFilter(e);
        S(t) ? t.then(Z).catch((()=>{}
        )) : !1 !== t ? Z() : X()
      }
    ), r.debounce)
      , pe = (e,t)=>{
      !y.value && G(!0),
      (null == t ? void 0 : t.isComposing) || (e ? fe() : X())
    }
      , he = e=>Number.parseFloat(function(e, t, {window: n=Oc, initialValue: r=""}={}) {
      const o = Ft(r)
        , a = yi((()=>{
          var e;
          return Dc(t) || (null == (e = null == n ? void 0 : n.document) ? void 0 : e.documentElement)
        }
      ));
      return Jn([a, ()=>xc(e)], (([e,t])=>{
          var a;
          if (e && n) {
            const i = null == (a = n.getComputedStyle(e).getPropertyValue(t)) ? void 0 : a.trim();
            o.value = i || r
          }
        }
      ), {
        immediate: !0
      }),
        Jn(o, (t=>{
            var n;
            (null == (n = a.value) ? void 0 : n.style) && a.value.style.setProperty(xc(e), t)
          }
        )),
        o
    }(u.cssVarName("input-height"), e).value) - 2;
    return Jn(w, q),
      Jn([M, _], (()=>{
          if (!F.value)
            return;
          const e = M.value
            , t = []
            , n = [];
          if (e.forEach((e=>n.push(Q(e)))),
            k.value = n,
            e.length) {
            e.slice(0, r.maxCollapseTags).forEach((e=>t.push(Q(e))));
            const n = e.slice(r.maxCollapseTags)
              , o = n.length;
            o && (r.collapseTags ? t.push({
              key: -1,
              text: `+ ${o}`,
              closable: !1,
              isCollapseTag: !0
            }) : n.forEach((e=>t.push(Q(e)))))
          }
          C.value = t
        }
      )),
      Jn(C, (()=>{
          hn((()=>ne()))
        }
      )),
      Jn(I, (async()=>{
          await hn();
          const e = h.value.input;
          i = he(e) || i,
            ne()
        }
      )),
      Jn(V, se, {
        immediate: !0
      }),
      Lr((()=>{
          const e = h.value.input
            , t = he(e);
          i = e.offsetHeight || t,
            Uc(e, ne)
        }
      )),
      t({
        getCheckedNodes: e=>{
          var t;
          return null == (t = g.value) ? void 0 : t.getCheckedNodes(e)
        }
        ,
        cascaderPanelRef: g,
        togglePopperVisible: G,
        contentRef: W
      }),
      (e,t)=>(Ca(),
        Ra(Vt(MA), {
          ref_key: "tooltipRef",
          ref: p,
          visible: y.value,
          teleported: e.teleported,
          "popper-class": [Vt(l).e("dropdown"), e.popperClass],
          "popper-options": o,
          "fallback-placements": ["bottom-start", "bottom", "top-start", "top", "right", "left"],
          "stop-popper-mouse-event": !1,
          "gpu-acceleration": !1,
          placement: "bottom-start",
          transition: `${Vt(l).namespace.value}-zoom-in-top`,
          effect: "light",
          pure: "",
          persistent: "",
          onHide: X
        }, {
          default: Fn((()=>[rr((Ca(),
            _a("div", {
              class: Y(Vt($)),
              style: z(Vt(O)),
              onClick: t[5] || (t[5] = ()=>G(!Vt(B) || void 0)),
              onKeydown: ae,
              onMouseenter: t[6] || (t[6] = e=>b.value = !0),
              onMouseleave: t[7] || (t[7] = e=>b.value = !1)
            }, [ja(Vt(yE), {
              ref_key: "input",
              ref: h,
              modelValue: E.value,
              "onUpdate:modelValue": t[1] || (t[1] = e=>E.value = e),
              placeholder: Vt(L),
              readonly: Vt(B),
              disabled: Vt(_),
              "validate-event": !1,
              size: Vt(I),
              class: Y(Vt(K)),
              tabindex: Vt(F) && e.filterable && !Vt(_) ? -1 : void 0,
              onCompositionstart: oe,
              onCompositionupdate: oe,
              onCompositionend: oe,
              onFocus: ce,
              onBlur: de,
              onInput: pe
            }, {
              suffix: Fn((()=>[Vt(j) ? (Ca(),
                Ra(Vt(sS), {
                  key: "clear",
                  class: Y([Vt(u).e("icon"), "icon-circle-close"]),
                  onClick: js(ie, ["stop"])
                }, {
                  default: Fn((()=>[ja(Vt(km))])),
                  _: 1
                }, 8, ["class", "onClick"])) : (Ca(),
                Ra(Vt(sS), {
                  key: "arrow-down",
                  class: Y(Vt(H)),
                  onClick: t[0] || (t[0] = js((e=>G()), ["stop"]))
                }, {
                  default: Fn((()=>[ja(Vt(hm))])),
                  _: 1
                }, 8, ["class"]))])),
              _: 1
            }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex"]), Vt(F) ? (Ca(),
              _a("div", {
                key: 0,
                ref_key: "tagWrapper",
                ref: v,
                class: Y(Vt(l).e("tags"))
              }, [(Ca(!0),
                _a(ba, null, Yr(C.value, (t=>(Ca(),
                  Ra(Vt(vO), {
                    key: t.key,
                    type: e.tagType,
                    size: Vt(P),
                    hit: t.hitState,
                    closable: t.closable,
                    "disable-transitions": "",
                    onClose: e=>J(t)
                  }, {
                    default: Fn((()=>[!1 === t.isCollapseTag ? (Ca(),
                      _a("span", yO, te(t.text), 1)) : (Ca(),
                      Ra(Vt(MA), {
                        key: 1,
                        disabled: y.value || !e.collapseTagsTooltip,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        placement: "bottom",
                        effect: "light"
                      }, {
                        default: Fn((()=>[Ma("span", null, te(t.text), 1)])),
                        content: Fn((()=>[Ma("div", {
                          class: Y(Vt(l).e("collapse-tags"))
                        }, [(Ca(!0),
                          _a(ba, null, Yr(k.value.slice(e.maxCollapseTags), ((t,n)=>(Ca(),
                            _a("div", {
                              key: n,
                              class: Y(Vt(l).e("collapse-tag"))
                            }, [(Ca(),
                              Ra(Vt(vO), {
                                key: t.key,
                                class: "in-tooltip",
                                type: e.tagType,
                                size: Vt(P),
                                hit: t.hitState,
                                closable: t.closable,
                                "disable-transitions": "",
                                onClose: e=>J(t)
                              }, {
                                default: Fn((()=>[Ma("span", null, te(t.text), 1)])),
                                _: 2
                              }, 1032, ["type", "size", "hit", "closable", "onClose"]))], 2)))), 128))], 2)])),
                        _: 2
                      }, 1032, ["disabled"]))])),
                    _: 2
                  }, 1032, ["type", "size", "hit", "closable", "onClose"])))), 128)), e.filterable && !Vt(_) ? rr((Ca(),
                _a("input", {
                  key: 0,
                  "onUpdate:modelValue": t[2] || (t[2] = e=>A.value = e),
                  type: "text",
                  class: Y(Vt(l).e("search-input")),
                  placeholder: Vt(V) ? "" : Vt(R),
                  onInput: t[3] || (t[3] = e=>pe(A.value, e)),
                  onClick: t[4] || (t[4] = js((e=>G(!0)), ["stop"])),
                  onKeydown: Us(ue, ["delete"]),
                  onCompositionstart: oe,
                  onCompositionupdate: oe,
                  onCompositionend: oe,
                  onFocus: ce,
                  onBlur: de
                }, null, 42, bO)), [[ks, A.value]]) : za("v-if", !0)], 2)) : za("v-if", !0)], 38)), [[Vt(Rk), ()=>G(!1), Vt(W)]])])),
          content: Fn((()=>[rr(ja(Vt(cO), {
            ref_key: "cascaderPanelRef",
            ref: g,
            modelValue: Vt(U),
            "onUpdate:modelValue": t[8] || (t[8] = e=>Pt(U) ? U.value = e : null),
            options: e.options,
            props: r.props,
            border: !1,
            "render-label": e.$slots.default,
            onExpandChange: re,
            onClose: t[9] || (t[9] = t=>e.$nextTick((()=>G(!1))))
          }, null, 8, ["modelValue", "options", "props", "render-label"]), [[$s, !w.value]]), e.filterable ? rr((Ca(),
            Ra(Vt(DE), {
              key: 0,
              ref_key: "suggestionPanel",
              ref: m,
              tag: "ul",
              class: Y(Vt(l).e("suggestion-panel")),
              "view-class": Vt(l).e("suggestion-list"),
              onKeydown: le
            }, {
              default: Fn((()=>[T.value.length ? (Ca(!0),
                _a(ba, {
                  key: 0
                }, Yr(T.value, (e=>(Ca(),
                  _a("li", {
                    key: e.uid,
                    class: Y([Vt(l).e("suggestion-item"), Vt(l).is("checked", e.checked)]),
                    tabindex: -1,
                    onClick: t=>(e=>{
                        var t, n;
                        const {checked: r} = e;
                        F.value ? null == (t = g.value) || t.handleCheckChange(e, !r, !1) : (!r && (null == (n = g.value) || n.handleCheckChange(e, !0, !1)),
                          G(!1))
                      }
                    )(e)
                  }, [Ma("span", null, te(e.text), 1), e.checked ? (Ca(),
                    Ra(Vt(sS), {
                      key: 0
                    }, {
                      default: Fn((()=>[ja(Vt(Sm))])),
                      _: 1
                    })) : za("v-if", !0)], 10, wO)))), 128)) : Qr(e.$slots, "empty", {
                key: 1
              }, (()=>[Ma("li", {
                class: Y(Vt(l).e("empty-text"))
              }, te(Vt(c)("el.cascader.noMatch")), 3)]))])),
              _: 3
            }, 8, ["class", "view-class"])), [[$s, w.value]]) : za("v-if", !0)])),
          _: 3
        }, 8, ["visible", "teleported", "popper-class", "transition"]))
  }
});
var EO = tS(SO, [["__file", "cascader.vue"]]);
EO.install = e=>{
  e.component(EO.name, EO)
}
;
const AO = EO
  , CO = uy({
  checked: {
    type: Boolean,
    default: !1
  },
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  }
})
  , kO = {
  "update:checked": e=>jg(e),
  [Sy]: e=>jg(e)
}
  , TO = vr({
  name: "ElCheckTag"
});
const DO = vy(tS(vr({
  ...TO,
  props: CO,
  emits: kO,
  setup(e, {emit: t}) {
    const n = e
      , r = qy("check-tag")
      , o = yi((()=>[r.b(), r.is("checked", n.checked), r.m(n.type || "primary")]))
      , a = ()=>{
        const e = !n.checked;
        t(Sy, e),
          t("update:checked", e)
      }
    ;
    return (e,t)=>(Ca(),
      _a("span", {
        class: Y(Vt(o)),
        onClick: a
      }, [Qr(e.$slots, "default")], 2))
  }
}), [["__file", "check-tag.vue"]]))
  , OO = Symbol("rowContextKey")
  , _O = uy({
  tag: {
    type: String,
    default: "div"
  },
  gutter: {
    type: Number,
    default: 0
  },
  justify: {
    type: String,
    values: ["start", "center", "end", "space-around", "space-between", "space-evenly"],
    default: "start"
  },
  align: {
    type: String,
    values: ["top", "middle", "bottom"]
  }
})
  , RO = vr({
  name: "ElRow"
});
const LO = vy(tS(vr({
  ...RO,
  props: _O,
  setup(e) {
    const t = e
      , n = qy("row")
      , r = yi((()=>t.gutter));
    Mo(OO, {
      gutter: r
    });
    const o = yi((()=>{
        const e = {};
        return t.gutter ? (e.marginRight = e.marginLeft = `-${t.gutter / 2}px`,
          e) : e
      }
    ))
      , a = yi((()=>[n.b(), n.is(`justify-${t.justify}`, "start" !== t.justify), n.is(`align-${t.align}`, !!t.align)]));
    return (e,t)=>(Ca(),
      Ra(Kr(e.tag), {
        class: Y(Vt(a)),
        style: z(Vt(o))
      }, {
        default: Fn((()=>[Qr(e.$slots, "default")])),
        _: 3
      }, 8, ["class", "style"]))
  }
}), [["__file", "row.vue"]]))
  , IO = uy({
  tag: {
    type: String,
    default: "div"
  },
  span: {
    type: Number,
    default: 24
  },
  offset: {
    type: Number,
    default: 0
  },
  pull: {
    type: Number,
    default: 0
  },
  push: {
    type: Number,
    default: 0
  },
  xs: {
    type: [Number, Object],
    default: ()=>({})
  },
  sm: {
    type: [Number, Object],
    default: ()=>({})
  },
  md: {
    type: [Number, Object],
    default: ()=>({})
  },
  lg: {
    type: [Number, Object],
    default: ()=>({})
  },
  xl: {
    type: [Number, Object],
    default: ()=>({})
  }
})
  , PO = vr({
  name: "ElCol"
});
const FO = vy(tS(vr({
  ...PO,
  props: IO,
  setup(e) {
    const t = e
      , {gutter: n} = jo(OO, {
      gutter: yi((()=>0))
    })
      , r = qy("col")
      , o = yi((()=>{
        const e = {};
        return n.value && (e.paddingLeft = e.paddingRight = n.value / 2 + "px"),
          e
      }
    ))
      , a = yi((()=>{
        const e = [];
        ["span", "offset", "pull", "push"].forEach((n=>{
            const o = t[n];
            Vg(o) && ("span" === n ? e.push(r.b(`${t[n]}`)) : o > 0 && e.push(r.b(`${n}-${t[n]}`)))
          }
        ));
        return ["xs", "sm", "md", "lg", "xl"].forEach((n=>{
            Vg(t[n]) ? e.push(r.b(`${n}-${t[n]}`)) : x(t[n]) && Object.entries(t[n]).forEach((([t,o])=>{
                e.push("span" !== t ? r.b(`${n}-${t}-${o}`) : r.b(`${n}-${o}`))
              }
            ))
          }
        )),
        n.value && e.push(r.is("guttered")),
          [r.b(), e]
      }
    ));
    return (e,t)=>(Ca(),
      Ra(Kr(e.tag), {
        class: Y(Vt(a)),
        style: z(Vt(o))
      }, {
        default: Fn((()=>[Qr(e.$slots, "default")])),
        _: 3
      }, 8, ["class", "style"]))
  }
}), [["__file", "col.vue"]]))
  , BO = e=>Vg(e) || b(e) || h(e)
  , NO = uy({
  accordion: Boolean,
  modelValue: {
    type: [Array, String, Number],
    default: ()=>[]
  }
})
  , MO = {
  [xy]: BO,
  [Sy]: BO
}
  , jO = Symbol("collapseContextKey")
  , VO = vr({
  name: "ElCollapse"
})
  , UO = vr({
  ...VO,
  props: NO,
  emits: MO,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , {activeNames: o, setActiveNames: a} = ((e,t)=>{
        const n = Ft(Gp(e.modelValue))
          , r = r=>{
            n.value = r;
            const o = e.accordion ? n.value[0] : n.value;
            t(xy, o),
              t(Sy, o)
          }
        ;
        return Jn((()=>e.modelValue), (()=>n.value = Gp(e.modelValue)), {
          deep: !0
        }),
          Mo(jO, {
            activeNames: n,
            handleItemClick: t=>{
              if (e.accordion)
                r([n.value[0] === t ? "" : t]);
              else {
                const e = [...n.value]
                  , o = e.indexOf(t);
                o > -1 ? e.splice(o, 1) : e.push(t),
                  r(e)
              }
            }
          }),
          {
            activeNames: n,
            setActiveNames: r
          }
      }
    )(r, n)
      , {rootKls: i} = (()=>{
        const e = qy("collapse");
        return {
          rootKls: yi((()=>e.b()))
        }
      }
    )();
    return t({
      activeNames: o,
      setActiveNames: a
    }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y(Vt(i))
        }, [Qr(e.$slots, "default")], 2))
  }
});
var $O = tS(UO, [["__file", "collapse.vue"]]);
const HO = vr({
  name: "ElCollapseTransition"
});
var zO = tS(vr({
  ...HO,
  setup(e) {
    const t = qy("collapse-transition")
      , n = e=>{
      e.style.maxHeight = "",
        e.style.overflow = e.dataset.oldOverflow,
        e.style.paddingTop = e.dataset.oldPaddingTop,
        e.style.paddingBottom = e.dataset.oldPaddingBottom
    }
      , r = {
      beforeEnter(e) {
        e.dataset || (e.dataset = {}),
          e.dataset.oldPaddingTop = e.style.paddingTop,
          e.dataset.oldPaddingBottom = e.style.paddingBottom,
        e.style.height && (e.dataset.elExistsHeight = e.style.height),
          e.style.maxHeight = 0,
          e.style.paddingTop = 0,
          e.style.paddingBottom = 0
      },
      enter(e) {
        requestAnimationFrame((()=>{
            e.dataset.oldOverflow = e.style.overflow,
              e.dataset.elExistsHeight ? e.style.maxHeight = e.dataset.elExistsHeight : 0 !== e.scrollHeight ? e.style.maxHeight = `${e.scrollHeight}px` : e.style.maxHeight = 0,
              e.style.paddingTop = e.dataset.oldPaddingTop,
              e.style.paddingBottom = e.dataset.oldPaddingBottom,
              e.style.overflow = "hidden"
          }
        ))
      },
      afterEnter(e) {
        e.style.maxHeight = "",
          e.style.overflow = e.dataset.oldOverflow
      },
      enterCancelled(e) {
        n(e)
      },
      beforeLeave(e) {
        e.dataset || (e.dataset = {}),
          e.dataset.oldPaddingTop = e.style.paddingTop,
          e.dataset.oldPaddingBottom = e.style.paddingBottom,
          e.dataset.oldOverflow = e.style.overflow,
          e.style.maxHeight = `${e.scrollHeight}px`,
          e.style.overflow = "hidden"
      },
      leave(e) {
        0 !== e.scrollHeight && (e.style.maxHeight = 0,
          e.style.paddingTop = 0,
          e.style.paddingBottom = 0)
      },
      afterLeave(e) {
        n(e)
      },
      leaveCancelled(e) {
        n(e)
      }
    };
    return (e,n)=>(Ca(),
      Ra(es, qa({
        name: Vt(t).b()
      }, Zr(r)), {
        default: Fn((()=>[Qr(e.$slots, "default")])),
        _: 3
      }, 16, ["name"]))
  }
}), [["__file", "collapse-transition.vue"]]);
zO.install = e=>{
  e.component(zO.name, zO)
}
;
const KO = zO
  , WO = KO
  , GO = uy({
  title: {
    type: String,
    default: ""
  },
  name: {
    type: [String, Number],
    default: void 0
  },
  disabled: Boolean
})
  , qO = ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex"]
  , YO = ["id", "aria-hidden", "aria-labelledby"]
  , XO = vr({
  name: "ElCollapseItem"
})
  , QO = vr({
  ...XO,
  props: GO,
  setup(e, {expose: t}) {
    const n = e
      , {focusing: r, id: o, isActive: a, handleFocus: i, handleHeaderClick: s, handleEnterClick: l} = (e=>{
        const t = jo(jO)
          , {namespace: n} = qy("collapse")
          , r = Ft(!1)
          , o = Ft(!1)
          , a = Aw()
          , i = yi((()=>a.current++))
          , s = yi((()=>{
            var t;
            return null != (t = e.name) ? t : `${n.value}-id-${a.prefix}-${Vt(i)}`
          }
        ))
          , l = yi((()=>null == t ? void 0 : t.activeNames.value.includes(Vt(s))));
        return {
          focusing: r,
          id: i,
          isActive: l,
          handleFocus: ()=>{
            setTimeout((()=>{
                o.value ? o.value = !1 : r.value = !0
              }
            ), 50)
          }
          ,
          handleHeaderClick: ()=>{
            e.disabled || (null == t || t.handleItemClick(Vt(s)),
              r.value = !1,
              o.value = !0)
          }
          ,
          handleEnterClick: ()=>{
            null == t || t.handleItemClick(Vt(s))
          }
        }
      }
    )(n)
      , {arrowKls: u, headKls: c, rootKls: d, itemWrapperKls: f, itemContentKls: p, scopedContentId: h, scopedHeadId: v} = ((e,{focusing: t, isActive: n, id: r})=>{
        const o = qy("collapse")
          , a = yi((()=>[o.b("item"), o.is("active", Vt(n)), o.is("disabled", e.disabled)]))
          , i = yi((()=>[o.be("item", "header"), o.is("active", Vt(n)), {
          focusing: Vt(t) && !e.disabled
        }]));
        return {
          arrowKls: yi((()=>[o.be("item", "arrow"), o.is("active", Vt(n))])),
          headKls: i,
          rootKls: a,
          itemWrapperKls: yi((()=>o.be("item", "wrap"))),
          itemContentKls: yi((()=>o.be("item", "content"))),
          scopedContentId: yi((()=>o.b(`content-${Vt(r)}`))),
          scopedHeadId: yi((()=>o.b(`head-${Vt(r)}`)))
        }
      }
    )(n, {
      focusing: r,
      isActive: a,
      id: o
    });
    return t({
      isActive: a
    }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y(Vt(d))
        }, [Ma("button", {
          id: Vt(v),
          class: Y(Vt(c)),
          "aria-expanded": Vt(a),
          "aria-controls": Vt(h),
          "aria-describedby": Vt(h),
          tabindex: e.disabled ? -1 : 0,
          type: "button",
          onClick: t[0] || (t[0] = (...e)=>Vt(s) && Vt(s)(...e)),
          onKeydown: t[1] || (t[1] = Us(js(((...e)=>Vt(l) && Vt(l)(...e)), ["stop", "prevent"]), ["space", "enter"])),
          onFocus: t[2] || (t[2] = (...e)=>Vt(i) && Vt(i)(...e)),
          onBlur: t[3] || (t[3] = e=>r.value = !1)
        }, [Qr(e.$slots, "title", {}, (()=>[$a(te(e.title), 1)])), ja(Vt(sS), {
          class: Y(Vt(u))
        }, {
          default: Fn((()=>[ja(Vt(gm))])),
          _: 1
        }, 8, ["class"])], 42, qO), ja(Vt(KO), null, {
          default: Fn((()=>[rr(Ma("div", {
            id: Vt(h),
            role: "region",
            class: Y(Vt(f)),
            "aria-hidden": !Vt(a),
            "aria-labelledby": Vt(v)
          }, [Ma("div", {
            class: Y(Vt(p))
          }, [Qr(e.$slots, "default")], 2)], 10, YO), [[$s, Vt(a)]])])),
          _: 3
        })], 2))
  }
});
var JO = tS(QO, [["__file", "collapse-item.vue"]]);
const ZO = vy($O, {
  CollapseItem: JO
})
  , e_ = my(JO)
  , t_ = uy({
  color: {
    type: Object,
    required: !0
  },
  vertical: {
    type: Boolean,
    default: !1
  }
});
let n_ = !1;
function r_(e, t) {
  if (!mc)
    return;
  const n = function(e) {
    var n;
    null == (n = t.drag) || n.call(t, e)
  }
    , r = function(e) {
    var o;
    document.removeEventListener("mousemove", n),
      document.removeEventListener("mouseup", r),
      document.removeEventListener("touchmove", n),
      document.removeEventListener("touchend", r),
      document.onselectstart = null,
      document.ondragstart = null,
      n_ = !1,
    null == (o = t.end) || o.call(t, e)
  }
    , o = function(e) {
    var o;
    n_ || (e.preventDefault(),
      document.onselectstart = ()=>!1,
      document.ondragstart = ()=>!1,
      document.addEventListener("mousemove", n),
      document.addEventListener("mouseup", r),
      document.addEventListener("touchmove", n),
      document.addEventListener("touchend", r),
      n_ = !0,
    null == (o = t.start) || o.call(t, e))
  };
  e.addEventListener("mousedown", o),
    e.addEventListener("touchstart", o)
}
const o_ = (e,{bar: t, thumb: n, handleDrag: r})=>{
  const o = ei()
    , a = qy("color-alpha-slider")
    , i = Ft(0)
    , s = Ft(0)
    , l = Ft();
  function u() {
    i.value = function() {
      if (!n.value)
        return 0;
      if (e.vertical)
        return 0;
      const t = o.vnode.el
        , r = e.color.get("alpha");
      return t ? Math.round(r * (t.offsetWidth - n.value.offsetWidth / 2) / 100) : 0
    }(),
      s.value = function() {
        if (!n.value)
          return 0;
        const t = o.vnode.el;
        if (!e.vertical)
          return 0;
        const r = e.color.get("alpha");
        return t ? Math.round(r * (t.offsetHeight - n.value.offsetHeight / 2) / 100) : 0
      }(),
      l.value = function() {
        if (e.color && e.color.value) {
          const {r: t, g: n, b: r} = e.color.toRgb();
          return `linear-gradient(to right, rgba(${t}, ${n}, ${r}, 0) 0%, rgba(${t}, ${n}, ${r}, 1) 100%)`
        }
        return ""
      }()
  }
  Lr((()=>{
      if (!t.value || !n.value)
        return;
      const e = {
        drag: e=>{
          r(e)
        }
        ,
        end: e=>{
          r(e)
        }
      };
      r_(t.value, e),
        r_(n.value, e),
        u()
    }
  )),
    Jn((()=>e.color.get("alpha")), (()=>u())),
    Jn((()=>e.color.value), (()=>u()));
  const c = yi((()=>[a.b(), a.is("vertical", e.vertical)]))
    , d = yi((()=>a.e("bar")))
    , f = yi((()=>a.e("thumb")));
  return {
    rootKls: c,
    barKls: d,
    barStyle: yi((()=>({
      background: l.value
    }))),
    thumbKls: f,
    thumbStyle: yi((()=>({
      left: om(i.value),
      top: om(s.value)
    }))),
    update: u
  }
}
  , a_ = vr({
  name: "ElColorAlphaSlider"
});
var i_ = tS(vr({
  ...a_,
  props: t_,
  setup(e, {expose: t}) {
    const n = e
      , {bar: r, thumb: o, handleDrag: a, handleClick: i} = (e=>{
        const t = ei()
          , n = Bt()
          , r = Bt();
        function o(o) {
          if (!r.value || !n.value)
            return;
          const a = t.vnode.el.getBoundingClientRect()
            , {clientX: i, clientY: s} = od(o);
          if (e.vertical) {
            let t = s - a.top;
            t = Math.max(n.value.offsetHeight / 2, t),
              t = Math.min(t, a.height - n.value.offsetHeight / 2),
              e.color.set("alpha", Math.round((t - n.value.offsetHeight / 2) / (a.height - n.value.offsetHeight) * 100))
          } else {
            let t = i - a.left;
            t = Math.max(n.value.offsetWidth / 2, t),
              t = Math.min(t, a.width - n.value.offsetWidth / 2),
              e.color.set("alpha", Math.round((t - n.value.offsetWidth / 2) / (a.width - n.value.offsetWidth) * 100))
          }
        }
        return {
          thumb: n,
          bar: r,
          handleDrag: o,
          handleClick: function(e) {
            e.target !== n.value && o(e)
          }
        }
      }
    )(n)
      , {rootKls: s, barKls: l, barStyle: u, thumbKls: c, thumbStyle: d, update: f} = o_(n, {
      bar: r,
      thumb: o,
      handleDrag: a
    });
    return t({
      update: f,
      bar: r,
      thumb: o
    }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y(Vt(s))
        }, [Ma("div", {
          ref_key: "bar",
          ref: r,
          class: Y(Vt(l)),
          style: z(Vt(u)),
          onClick: t[0] || (t[0] = (...e)=>Vt(i) && Vt(i)(...e))
        }, null, 6), Ma("div", {
          ref_key: "thumb",
          ref: o,
          class: Y(Vt(c)),
          style: z(Vt(d))
        }, null, 6)], 2))
  }
}), [["__file", "alpha-slider.vue"]]);
var s_ = tS(vr({
  name: "ElColorHueSlider",
  props: {
    color: {
      type: Object,
      required: !0
    },
    vertical: Boolean
  },
  setup(e) {
    const t = qy("color-hue-slider")
      , n = ei()
      , r = Ft()
      , o = Ft()
      , a = Ft(0)
      , i = Ft(0)
      , s = yi((()=>e.color.get("hue")));
    function l(t) {
      if (!o.value || !r.value)
        return;
      const a = n.vnode.el.getBoundingClientRect()
        , {clientX: i, clientY: s} = od(t);
      let l;
      if (e.vertical) {
        let e = s - a.top;
        e = Math.min(e, a.height - r.value.offsetHeight / 2),
          e = Math.max(r.value.offsetHeight / 2, e),
          l = Math.round((e - r.value.offsetHeight / 2) / (a.height - r.value.offsetHeight) * 360)
      } else {
        let e = i - a.left;
        e = Math.min(e, a.width - r.value.offsetWidth / 2),
          e = Math.max(r.value.offsetWidth / 2, e),
          l = Math.round((e - r.value.offsetWidth / 2) / (a.width - r.value.offsetWidth) * 360)
      }
      e.color.set("hue", l)
    }
    function u() {
      a.value = function() {
        if (!r.value)
          return 0;
        const t = n.vnode.el;
        if (e.vertical)
          return 0;
        const o = e.color.get("hue");
        return t ? Math.round(o * (t.offsetWidth - r.value.offsetWidth / 2) / 360) : 0
      }(),
        i.value = function() {
          if (!r.value)
            return 0;
          const t = n.vnode.el;
          if (!e.vertical)
            return 0;
          const o = e.color.get("hue");
          return t ? Math.round(o * (t.offsetHeight - r.value.offsetHeight / 2) / 360) : 0
        }()
    }
    return Jn((()=>s.value), (()=>{
        u()
      }
    )),
      Lr((()=>{
          if (!o.value || !r.value)
            return;
          const e = {
            drag: e=>{
              l(e)
            }
            ,
            end: e=>{
              l(e)
            }
          };
          r_(o.value, e),
            r_(r.value, e),
            u()
        }
      )),
      {
        bar: o,
        thumb: r,
        thumbLeft: a,
        thumbTop: i,
        hueValue: s,
        handleClick: function(e) {
          e.target !== r.value && l(e)
        },
        update: u,
        ns: t
      }
  }
}), [["render", function(e, t, n, r, o, a) {
  return Ca(),
    _a("div", {
      class: Y([e.ns.b(), e.ns.is("vertical", e.vertical)])
    }, [Ma("div", {
      ref: "bar",
      class: Y(e.ns.e("bar")),
      onClick: t[0] || (t[0] = (...t)=>e.handleClick && e.handleClick(...t))
    }, null, 2), Ma("div", {
      ref: "thumb",
      class: Y(e.ns.e("thumb")),
      style: z({
        left: e.thumbLeft + "px",
        top: e.thumbTop + "px"
      })
    }, null, 6)], 2)
}
], ["__file", "hue-slider.vue"]]);
const l_ = uy({
  modelValue: String,
  id: String,
  showAlpha: Boolean,
  colorFormat: String,
  disabled: Boolean,
  size: Ux,
  popperClass: {
    type: String,
    default: ""
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  predefine: {
    type: Array
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
})
  , u_ = {
  [xy]: e=>b(e) || Cg(e),
  [Sy]: e=>b(e) || Cg(e),
  activeChange: e=>b(e) || Cg(e),
  focus: e=>e instanceof FocusEvent,
  blur: e=>e instanceof FocusEvent
}
  , c_ = Symbol("colorPickerContextKey")
  , d_ = function(e, t, n) {
  return [e, t * n / ((e = (2 - t) * n) < 1 ? e : 2 - e) || 0, e / 2]
}
  , f_ = function(e, t) {
  var n;
  "string" == typeof (n = e) && n.includes(".") && 1 === Number.parseFloat(n) && (e = "100%");
  const r = function(e) {
    return "string" == typeof e && e.includes("%")
  }(e);
  return e = Math.min(t, Math.max(0, Number.parseFloat(`${e}`))),
  r && (e = Number.parseInt("" + e * t, 10) / 100),
    Math.abs(e - t) < 1e-6 ? 1 : e % t / Number.parseFloat(t)
}
  , p_ = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F"
}
  , h_ = e=>{
  e = Math.min(Math.round(e), 255);
  const t = Math.floor(e / 16)
    , n = e % 16;
  return `${p_[t] || t}${p_[n] || n}`
}
  , v_ = function({r: e, g: t, b: n}) {
  return Number.isNaN(+e) || Number.isNaN(+t) || Number.isNaN(+n) ? "" : `#${h_(e)}${h_(t)}${h_(n)}`
}
  , g_ = {
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}
  , m_ = function(e) {
  return 2 === e.length ? 16 * (g_[e[0].toUpperCase()] || +e[0]) + (g_[e[1].toUpperCase()] || +e[1]) : g_[e[1].toUpperCase()] || +e[1]
}
  , y_ = (e,t,n)=>{
  e = f_(e, 255),
    t = f_(t, 255),
    n = f_(n, 255);
  const r = Math.max(e, t, n)
    , o = Math.min(e, t, n);
  let a;
  const i = r
    , s = r - o
    , l = 0 === r ? 0 : s / r;
  if (r === o)
    a = 0;
  else {
    switch (r) {
      case e:
        a = (t - n) / s + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - e) / s + 2;
        break;
      case n:
        a = (e - t) / s + 4
    }
    a /= 6
  }
  return {
    h: 360 * a,
    s: 100 * l,
    v: 100 * i
  }
}
  , b_ = function(e, t, n) {
  e = 6 * f_(e, 360),
    t = f_(t, 100),
    n = f_(n, 100);
  const r = Math.floor(e)
    , o = e - r
    , a = n * (1 - t)
    , i = n * (1 - o * t)
    , s = n * (1 - (1 - o) * t)
    , l = r % 6
    , u = [n, i, a, a, s, n][l]
    , c = [s, n, n, i, a, a][l]
    , d = [a, a, s, n, n, i][l];
  return {
    r: Math.round(255 * u),
    g: Math.round(255 * c),
    b: Math.round(255 * d)
  }
};
class w_ {
  constructor(e={}) {
    this._hue = 0,
      this._saturation = 100,
      this._value = 100,
      this._alpha = 100,
      this.enableAlpha = !1,
      this.format = "hex",
      this.value = "";
    for (const t in e)
      p(e, t) && (this[t] = e[t]);
    e.value ? this.fromString(e.value) : this.doOnChange()
  }
  set(e, t) {
    if (1 !== arguments.length || "object" != typeof e)
      this[`_${e}`] = t,
        this.doOnChange();
    else
      for (const n in e)
        p(e, n) && this.set(n, e[n])
  }
  get(e) {
    return "alpha" === e ? Math.floor(this[`_${e}`]) : this[`_${e}`]
  }
  toRgb() {
    return b_(this._hue, this._saturation, this._value)
  }
  fromString(e) {
    if (!e)
      return this._hue = 0,
        this._saturation = 100,
        this._value = 100,
        void this.doOnChange();
    const t = (e,t,n)=>{
        this._hue = Math.max(0, Math.min(360, e)),
          this._saturation = Math.max(0, Math.min(100, t)),
          this._value = Math.max(0, Math.min(100, n)),
          this.doOnChange()
      }
    ;
    if (e.includes("hsl")) {
      const n = e.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((e=>"" !== e)).map(((e,t)=>t > 2 ? Number.parseFloat(e) : Number.parseInt(e, 10)));
      if (4 === n.length ? this._alpha = 100 * Number.parseFloat(n[3]) : 3 === n.length && (this._alpha = 100),
      n.length >= 3) {
        const {h: e, s: r, v: o} = function(e, t, n) {
          n /= 100;
          let r = t /= 100;
          const o = Math.max(n, .01);
          return t *= (n *= 2) <= 1 ? n : 2 - n,
            r *= o <= 1 ? o : 2 - o,
            {
              h: e,
              s: 100 * (0 === n ? 2 * r / (o + r) : 2 * t / (n + t)),
              v: (n + t) / 2 * 100
            }
        }(n[0], n[1], n[2]);
        t(e, r, o)
      }
    } else if (e.includes("hsv")) {
      const n = e.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((e=>"" !== e)).map(((e,t)=>t > 2 ? Number.parseFloat(e) : Number.parseInt(e, 10)));
      4 === n.length ? this._alpha = 100 * Number.parseFloat(n[3]) : 3 === n.length && (this._alpha = 100),
      n.length >= 3 && t(n[0], n[1], n[2])
    } else if (e.includes("rgb")) {
      const n = e.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((e=>"" !== e)).map(((e,t)=>t > 2 ? Number.parseFloat(e) : Number.parseInt(e, 10)));
      if (4 === n.length ? this._alpha = 100 * Number.parseFloat(n[3]) : 3 === n.length && (this._alpha = 100),
      n.length >= 3) {
        const {h: e, s: r, v: o} = y_(n[0], n[1], n[2]);
        t(e, r, o)
      }
    } else if (e.includes("#")) {
      const n = e.replace("#", "").trim();
      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(n))
        return;
      let r, o, a;
      3 === n.length ? (r = m_(n[0] + n[0]),
        o = m_(n[1] + n[1]),
        a = m_(n[2] + n[2])) : 6 !== n.length && 8 !== n.length || (r = m_(n.slice(0, 2)),
        o = m_(n.slice(2, 4)),
        a = m_(n.slice(4, 6))),
        8 === n.length ? this._alpha = m_(n.slice(6)) / 255 * 100 : 3 !== n.length && 6 !== n.length || (this._alpha = 100);
      const {h: i, s: s, v: l} = y_(r, o, a);
      t(i, s, l)
    }
  }
  compare(e) {
    return Math.abs(e._hue - this._hue) < 2 && Math.abs(e._saturation - this._saturation) < 1 && Math.abs(e._value - this._value) < 1 && Math.abs(e._alpha - this._alpha) < 1
  }
  doOnChange() {
    const {_hue: e, _saturation: t, _value: n, _alpha: r, format: o} = this;
    if (this.enableAlpha)
      switch (o) {
        case "hsl":
        {
          const r = d_(e, t / 100, n / 100);
          this.value = `hsla(${e}, ${Math.round(100 * r[1])}%, ${Math.round(100 * r[2])}%, ${this.get("alpha") / 100})`;
          break
        }
        case "hsv":
          this.value = `hsva(${e}, ${Math.round(t)}%, ${Math.round(n)}%, ${this.get("alpha") / 100})`;
          break;
        case "hex":
          this.value = `${v_(b_(e, t, n))}${h_(255 * r / 100)}`;
          break;
        default:
        {
          const {r: r, g: o, b: a} = b_(e, t, n);
          this.value = `rgba(${r}, ${o}, ${a}, ${this.get("alpha") / 100})`
        }
      }
    else
      switch (o) {
        case "hsl":
        {
          const r = d_(e, t / 100, n / 100);
          this.value = `hsl(${e}, ${Math.round(100 * r[1])}%, ${Math.round(100 * r[2])}%)`;
          break
        }
        case "hsv":
          this.value = `hsv(${e}, ${Math.round(t)}%, ${Math.round(n)}%)`;
          break;
        case "rgb":
        {
          const {r: r, g: o, b: a} = b_(e, t, n);
          this.value = `rgb(${r}, ${o}, ${a})`;
          break
        }
        default:
          this.value = v_(b_(e, t, n))
      }
  }
}
const x_ = vr({
  props: {
    colors: {
      type: Array,
      required: !0
    },
    color: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = qy("color-predefine")
      , {currentColor: n} = jo(c_)
      , r = Ft(o(e.colors, e.color));
    function o(e, t) {
      return e.map((e=>{
          const n = new w_;
          return n.enableAlpha = !0,
            n.format = "rgba",
            n.fromString(e),
            n.selected = n.value === t.value,
            n
        }
      ))
    }
    return Jn((()=>n.value), (e=>{
        const t = new w_;
        t.fromString(e),
          r.value.forEach((e=>{
              e.selected = t.compare(e)
            }
          ))
      }
    )),
      qn((()=>{
          r.value = o(e.colors, e.color)
        }
      )),
      {
        rgbaColors: r,
        handleSelect: function(t) {
          e.color.fromString(e.colors[t])
        },
        ns: t
      }
  }
})
  , S_ = ["onClick"];
var E_ = tS(x_, [["render", function(e, t, n, r, o, a) {
  return Ca(),
    _a("div", {
      class: Y(e.ns.b())
    }, [Ma("div", {
      class: Y(e.ns.e("colors"))
    }, [(Ca(!0),
      _a(ba, null, Yr(e.rgbaColors, ((t,n)=>(Ca(),
        _a("div", {
          key: e.colors[n],
          class: Y([e.ns.e("color-selector"), e.ns.is("alpha", t._alpha < 100), {
            selected: t.selected
          }]),
          onClick: t=>e.handleSelect(n)
        }, [Ma("div", {
          style: z({
            backgroundColor: t.value
          })
        }, null, 4)], 10, S_)))), 128))], 2)], 2)
}
], ["__file", "predefine.vue"]]);
const A_ = vr({
  name: "ElSlPanel",
  props: {
    color: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = qy("color-svpanel")
      , n = ei()
      , r = Ft(0)
      , o = Ft(0)
      , a = Ft("hsl(0, 100%, 50%)")
      , i = yi((()=>({
      hue: e.color.get("hue"),
      value: e.color.get("value")
    })));
    function s() {
      const t = e.color.get("saturation")
        , i = e.color.get("value")
        , s = n.vnode.el
        , {clientWidth: l, clientHeight: u} = s;
      o.value = t * l / 100,
        r.value = (100 - i) * u / 100,
        a.value = `hsl(${e.color.get("hue")}, 100%, 50%)`
    }
    function l(t) {
      const a = n.vnode.el.getBoundingClientRect()
        , {clientX: i, clientY: s} = od(t);
      let l = i - a.left
        , u = s - a.top;
      l = Math.max(0, l),
        l = Math.min(l, a.width),
        u = Math.max(0, u),
        u = Math.min(u, a.height),
        o.value = l,
        r.value = u,
        e.color.set({
          saturation: l / a.width * 100,
          value: 100 - u / a.height * 100
        })
    }
    return Jn((()=>i.value), (()=>{
        s()
      }
    )),
      Lr((()=>{
          r_(n.vnode.el, {
            drag: e=>{
              l(e)
            }
            ,
            end: e=>{
              l(e)
            }
          }),
            s()
        }
      )),
      {
        cursorTop: r,
        cursorLeft: o,
        background: a,
        colorValue: i,
        handleDrag: l,
        update: s,
        ns: t
      }
  }
})
  , C_ = [Ma("div", null, null, -1)];
var k_ = tS(A_, [["render", function(e, t, n, r, o, a) {
  return Ca(),
    _a("div", {
      class: Y(e.ns.b()),
      style: z({
        backgroundColor: e.background
      })
    }, [Ma("div", {
      class: Y(e.ns.e("white"))
    }, null, 2), Ma("div", {
      class: Y(e.ns.e("black"))
    }, null, 2), Ma("div", {
      class: Y(e.ns.e("cursor")),
      style: z({
        top: e.cursorTop + "px",
        left: e.cursorLeft + "px"
      })
    }, C_, 6)], 6)
}
], ["__file", "sv-panel.vue"]]);
const T_ = ["onKeydown"]
  , D_ = ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex"]
  , O_ = vr({
  name: "ElColorPicker"
})
  , __ = vr({
  ...O_,
  props: l_,
  emits: u_,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , {t: o} = Hy()
      , a = qy("color")
      , {formItem: i} = gS()
      , s = hS()
      , l = vS()
      , {inputId: u, isLabeledByFormItem: c} = mS(r, {
        formItemContext: i
      })
      , d = Ft()
      , f = Ft()
      , p = Ft()
      , h = Ft()
      , v = Ft()
      , g = Ft()
      , {isFocused: m, handleFocus: y, handleBlur: b} = Hx(v, {
        beforeBlur(e) {
          var t;
          return null == (t = h.value) ? void 0 : t.isFocusInsideContent(e)
        },
        afterBlur() {
          R(!1),
            F()
        }
      })
      , w = e=>{
        if (l.value)
          return H();
        y(e)
      }
    ;
    let x = !0;
    const S = bt(new w_({
      enableAlpha: r.showAlpha,
      format: r.colorFormat || "",
      value: r.modelValue
    }))
      , E = Ft(!1)
      , A = Ft(!1)
      , C = Ft("")
      , k = yi((()=>r.modelValue || A.value ? function(e, t) {
      if (!(e instanceof w_))
        throw new TypeError("color should be instance of _color Class");
      const {r: n, g: r, b: o} = e.toRgb();
      return t ? `rgba(${n}, ${r}, ${o}, ${e.get("alpha") / 100})` : `rgb(${n}, ${r}, ${o})`
    }(S, r.showAlpha) : "transparent"))
      , T = yi((()=>r.modelValue || A.value ? S.value : ""))
      , D = yi((()=>c.value ? void 0 : r.label || o("el.colorpicker.defaultLabel")))
      , O = yi((()=>c.value ? null == i ? void 0 : i.labelId : void 0))
      , _ = yi((()=>[a.b("picker"), a.is("disabled", l.value), a.bm("picker", s.value), a.is("focused", m.value)]));
    function R(e) {
      E.value = e
    }
    const L = ug(R, 100, {
      leading: !0
    });
    function I() {
      l.value || R(!0)
    }
    function P() {
      L(!1),
        F()
    }
    function F() {
      hn((()=>{
          r.modelValue ? S.fromString(r.modelValue) : (S.value = "",
            hn((()=>{
                A.value = !1
              }
            )))
        }
      ))
    }
    function B() {
      l.value || L(!E.value)
    }
    function N() {
      S.fromString(C.value)
    }
    function M() {
      const e = S.value;
      n(xy, e),
        n("change", e),
      r.validateEvent && (null == i || i.validate("change").catch((e=>{}
      ))),
        L(!1),
        hn((()=>{
            const e = new w_({
              enableAlpha: r.showAlpha,
              format: r.colorFormat || "",
              value: r.modelValue
            });
            S.compare(e) || F()
          }
        ))
    }
    function j() {
      L(!1),
        n(xy, null),
        n("change", null),
      null !== r.modelValue && r.validateEvent && (null == i || i.validate("change").catch((e=>{}
      ))),
        F()
    }
    function V(e) {
      if (E.value && (P(),
        m.value)) {
        const t = new FocusEvent("focus",e);
        b(t)
      }
    }
    function U(e) {
      e.preventDefault(),
        e.stopPropagation(),
        R(!1),
        F()
    }
    function $(e) {
      switch (e.code) {
        case by.enter:
        case by.space:
          e.preventDefault(),
            e.stopPropagation(),
            I(),
            g.value.focus();
          break;
        case by.esc:
          U(e)
      }
    }
    function H() {
      v.value.blur()
    }
    return Lr((()=>{
        r.modelValue && (C.value = T.value)
      }
    )),
      Jn((()=>r.modelValue), (e=>{
          e ? e && e !== S.value && (x = !1,
            S.fromString(e)) : A.value = !1
        }
      )),
      Jn((()=>T.value), (e=>{
          C.value = e,
          x && n("activeChange", e),
            x = !0
        }
      )),
      Jn((()=>S.value), (()=>{
          r.modelValue || A.value || (A.value = !0)
        }
      )),
      Jn((()=>E.value), (()=>{
          hn((()=>{
              var e, t, n;
              null == (e = d.value) || e.update(),
              null == (t = f.value) || t.update(),
              null == (n = p.value) || n.update()
            }
          ))
        }
      )),
      Mo(c_, {
        currentColor: T
      }),
      t({
        color: S,
        show: I,
        hide: P,
        focus: function() {
          v.value.focus()
        },
        blur: H
      }),
      (e,t)=>(Ca(),
        Ra(Vt(MA), {
          ref_key: "popper",
          ref: h,
          visible: E.value,
          "show-arrow": !1,
          "fallback-placements": ["bottom", "top", "right", "left"],
          offset: 0,
          "gpu-acceleration": !1,
          "popper-class": [Vt(a).be("picker", "panel"), Vt(a).b("dropdown"), e.popperClass],
          "stop-popper-mouse-event": !1,
          effect: "light",
          trigger: "click",
          transition: `${Vt(a).namespace.value}-zoom-in-top`,
          persistent: "",
          onHide: t[2] || (t[2] = e=>R(!1))
        }, {
          content: Fn((()=>[rr((Ca(),
            _a("div", {
              onKeydown: Us(U, ["esc"])
            }, [Ma("div", {
              class: Y(Vt(a).be("dropdown", "main-wrapper"))
            }, [ja(s_, {
              ref_key: "hue",
              ref: d,
              class: "hue-slider",
              color: Vt(S),
              vertical: ""
            }, null, 8, ["color"]), ja(k_, {
              ref_key: "sv",
              ref: f,
              color: Vt(S)
            }, null, 8, ["color"])], 2), e.showAlpha ? (Ca(),
              Ra(i_, {
                key: 0,
                ref_key: "alpha",
                ref: p,
                color: Vt(S)
              }, null, 8, ["color"])) : za("v-if", !0), e.predefine ? (Ca(),
              Ra(E_, {
                key: 1,
                ref: "predefine",
                color: Vt(S),
                colors: e.predefine
              }, null, 8, ["color", "colors"])) : za("v-if", !0), Ma("div", {
              class: Y(Vt(a).be("dropdown", "btns"))
            }, [Ma("span", {
              class: Y(Vt(a).be("dropdown", "value"))
            }, [ja(Vt(yE), {
              ref_key: "inputRef",
              ref: g,
              modelValue: C.value,
              "onUpdate:modelValue": t[0] || (t[0] = e=>C.value = e),
              "validate-event": !1,
              size: "small",
              onKeyup: Us(N, ["enter"]),
              onBlur: N
            }, null, 8, ["modelValue", "onKeyup"])], 2), ja(Vt(WC), {
              class: Y(Vt(a).be("dropdown", "link-btn")),
              text: "",
              size: "small",
              onClick: j
            }, {
              default: Fn((()=>[$a(te(Vt(o)("el.colorpicker.clear")), 1)])),
              _: 1
            }, 8, ["class"]), ja(Vt(WC), {
              plain: "",
              size: "small",
              class: Y(Vt(a).be("dropdown", "btn")),
              onClick: M
            }, {
              default: Fn((()=>[$a(te(Vt(o)("el.colorpicker.confirm")), 1)])),
              _: 1
            }, 8, ["class"])], 2)], 40, T_)), [[Vt(Rk), V]])])),
          default: Fn((()=>[Ma("div", {
            id: Vt(u),
            ref_key: "triggerRef",
            ref: v,
            class: Y(Vt(_)),
            role: "button",
            "aria-label": Vt(D),
            "aria-labelledby": Vt(O),
            "aria-description": Vt(o)("el.colorpicker.description", {
              color: e.modelValue || ""
            }),
            "aria-disabled": Vt(l),
            tabindex: Vt(l) ? -1 : e.tabindex,
            onKeydown: $,
            onFocus: w,
            onBlur: t[1] || (t[1] = (...e)=>Vt(b) && Vt(b)(...e))
          }, [Vt(l) ? (Ca(),
            _a("div", {
              key: 0,
              class: Y(Vt(a).be("picker", "mask"))
            }, null, 2)) : za("v-if", !0), Ma("div", {
            class: Y(Vt(a).be("picker", "trigger")),
            onClick: B
          }, [Ma("span", {
            class: Y([Vt(a).be("picker", "color"), Vt(a).is("alpha", e.showAlpha)])
          }, [Ma("span", {
            class: Y(Vt(a).be("picker", "color-inner")),
            style: z({
              backgroundColor: Vt(k)
            })
          }, [rr(ja(Vt(sS), {
            class: Y([Vt(a).be("picker", "icon"), Vt(a).is("icon-arrow-down")])
          }, {
            default: Fn((()=>[ja(Vt(hm))])),
            _: 1
          }, 8, ["class"]), [[$s, e.modelValue || A.value]]), rr(ja(Vt(sS), {
            class: Y([Vt(a).be("picker", "empty"), Vt(a).is("icon-close")])
          }, {
            default: Fn((()=>[ja(Vt(Dm))])),
            _: 1
          }, 8, ["class"]), [[$s, !e.modelValue && !A.value]])], 6)], 2)], 2)], 42, D_)])),
          _: 1
        }, 8, ["visible", "popper-class", "transition"]))
  }
});
const R_ = vy(tS(__, [["__file", "color-picker.vue"]]))
  , L_ = vr({
  name: "ElContainer"
});
var I_ = tS(vr({
  ...L_,
  props: {
    direction: {
      type: String
    }
  },
  setup(e) {
    const t = e
      , n = po()
      , r = qy("container")
      , o = yi((()=>{
        if ("vertical" === t.direction)
          return !0;
        if ("horizontal" === t.direction)
          return !1;
        if (n && n.default) {
          return n.default().some((e=>{
              const t = e.type.name;
              return "ElHeader" === t || "ElFooter" === t
            }
          ))
        }
        return !1
      }
    ));
    return (e,t)=>(Ca(),
      _a("section", {
        class: Y([Vt(r).b(), Vt(r).is("vertical", Vt(o))])
      }, [Qr(e.$slots, "default")], 2))
  }
}), [["__file", "container.vue"]]);
const P_ = vr({
  name: "ElAside"
});
var F_ = tS(vr({
  ...P_,
  props: {
    width: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e
      , n = qy("aside")
      , r = yi((()=>t.width ? n.cssVarBlock({
      width: t.width
    }) : {}));
    return (e,t)=>(Ca(),
      _a("aside", {
        class: Y(Vt(n).b()),
        style: z(Vt(r))
      }, [Qr(e.$slots, "default")], 6))
  }
}), [["__file", "aside.vue"]]);
const B_ = vr({
  name: "ElFooter"
});
var N_ = tS(vr({
  ...B_,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e
      , n = qy("footer")
      , r = yi((()=>t.height ? n.cssVarBlock({
      height: t.height
    }) : {}));
    return (e,t)=>(Ca(),
      _a("footer", {
        class: Y(Vt(n).b()),
        style: z(Vt(r))
      }, [Qr(e.$slots, "default")], 6))
  }
}), [["__file", "footer.vue"]]);
const M_ = vr({
  name: "ElHeader"
});
var j_ = tS(vr({
  ...M_,
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e
      , n = qy("header")
      , r = yi((()=>t.height ? n.cssVarBlock({
      height: t.height
    }) : {}));
    return (e,t)=>(Ca(),
      _a("header", {
        class: Y(Vt(n).b()),
        style: z(Vt(r))
      }, [Qr(e.$slots, "default")], 6))
  }
}), [["__file", "header.vue"]]);
const V_ = vr({
  name: "ElMain"
});
var U_ = tS(vr({
  ...V_,
  setup(e) {
    const t = qy("main");
    return (e,n)=>(Ca(),
      _a("main", {
        class: Y(Vt(t).b())
      }, [Qr(e.$slots, "default")], 2))
  }
}), [["__file", "main.vue"]]);
const $_ = vy(I_, {
  Aside: F_,
  Footer: N_,
  Header: j_,
  Main: U_
})
  , H_ = my(F_)
  , z_ = my(N_)
  , K_ = my(j_)
  , W_ = my(U_);
var G_ = {
  exports: {}
};
G_.exports = function(e, t) {
  var n = t.prototype
    , r = n.format;
  n.format = function(e) {
    var t = this
      , n = this.$locale();
    if (!this.isValid())
      return r.bind(this)(e);
    var o = this.$utils()
      , a = (e || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, (function(e) {
        switch (e) {
          case "Q":
            return Math.ceil((t.$M + 1) / 3);
          case "Do":
            return n.ordinal(t.$D);
          case "gggg":
            return t.weekYear();
          case "GGGG":
            return t.isoWeekYear();
          case "wo":
            return n.ordinal(t.week(), "W");
          case "w":
          case "ww":
            return o.s(t.week(), "w" === e ? 1 : 2, "0");
          case "W":
          case "WW":
            return o.s(t.isoWeek(), "W" === e ? 1 : 2, "0");
          case "k":
          case "kk":
            return o.s(String(0 === t.$H ? 24 : t.$H), "k" === e ? 1 : 2, "0");
          case "X":
            return Math.floor(t.$d.getTime() / 1e3);
          case "x":
            return t.$d.getTime();
          case "z":
            return "[" + t.offsetName() + "]";
          case "zzz":
            return "[" + t.offsetName("long") + "]";
          default:
            return e
        }
      }
    ));
    return r.bind(this)(a)
  }
}
;
const q_ = YC(G_.exports);
var Y_, X_, Q_ = {
  exports: {}
};
Q_.exports = (Y_ = "week",
    X_ = "year",
    function(e, t, n) {
      var r = t.prototype;
      r.week = function(e) {
        if (void 0 === e && (e = null),
        null !== e)
          return this.add(7 * (e - this.week()), "day");
        var t = this.$locale().yearStart || 1;
        if (11 === this.month() && this.date() > 25) {
          var r = n(this).startOf(X_).add(1, X_).date(t)
            , o = n(this).endOf(Y_);
          if (r.isBefore(o))
            return 1
        }
        var a = n(this).startOf(X_).date(t).startOf(Y_).subtract(1, "millisecond")
          , i = this.diff(a, Y_, !0);
        return i < 0 ? n(this).startOf("week").week() : Math.ceil(i)
      }
        ,
        r.weeks = function(e) {
          return void 0 === e && (e = null),
            this.week(e)
        }
    }
);
const J_ = YC(Q_.exports);
var Z_ = {
  exports: {}
};
Z_.exports = function(e, t) {
  t.prototype.weekYear = function() {
    var e = this.month()
      , t = this.week()
      , n = this.year();
    return 1 === t && 11 === e ? n + 1 : 0 === e && t >= 52 ? n - 1 : n
  }
}
;
const eR = YC(Z_.exports);
var tR = {
  exports: {}
};
tR.exports = function(e, t, n) {
  t.prototype.dayOfYear = function(e) {
    var t = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
    return null == e ? t : this.add(e - t, "day")
  }
}
;
const nR = YC(tR.exports);
var rR = {
  exports: {}
};
rR.exports = function(e, t) {
  t.prototype.isSameOrAfter = function(e, t) {
    return this.isSame(e, t) || this.isAfter(e, t)
  }
}
;
const oR = YC(rR.exports);
var aR = {
  exports: {}
};
aR.exports = function(e, t) {
  t.prototype.isSameOrBefore = function(e, t) {
    return this.isSame(e, t) || this.isBefore(e, t)
  }
}
;
const iR = YC(aR.exports)
  , sR = Symbol()
  , lR = uy({
    ...gk,
    type: {
      type: String,
      default: "date"
    }
  })
  , uR = ["date", "dates", "year", "years", "month", "week", "range"]
  , cR = uy({
    disabledDate: {
      type: Function
    },
    date: {
      type: Object,
      required: !0
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    parsedValue: {
      type: [Object, Array]
    },
    rangeState: {
      type: Object,
      default: ()=>({
        endDate: null,
        selecting: !1
      })
    }
  })
  , dR = uy({
    type: {
      type: String,
      required: !0,
      values: ["year", "years", "month", "date", "dates", "week", "datetime", "datetimerange", "daterange", "monthrange"]
    },
    dateFormat: String,
    timeFormat: String
  })
  , fR = uy({
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    }
  })
  , pR = e=>({
    type: String,
    values: uR,
    default: e
  })
  , hR = uy({
    ...dR,
    parsedValue: {
      type: [Object, Array]
    },
    visible: {
      type: Boolean
    },
    format: {
      type: String,
      default: ""
    }
  })
  , vR = uy({
    ...cR,
    cellClassName: {
      type: Function
    },
    showWeekNumber: Boolean,
    selectionMode: pR("date")
  })
  , gR = e=>{
    if (!h(e))
      return !1;
    const [t,n] = e;
    return JC.isDayjs(t) && JC.isDayjs(n) && t.isSameOrBefore(n)
  }
  , mR = (e,{lang: t, unit: n, unlinkPanels: r})=>{
    let o;
    if (h(e)) {
      let[o,a] = e.map((e=>JC(e).locale(t)));
      return r || (a = o.add(1, n)),
        [o, a]
    }
    return o = e ? JC(e) : JC(),
      o = o.locale(t),
      [o, o.add(1, n)]
  }
  , yR = (e="")=>["normal", "today"].includes(e)
  , bR = (e,t)=>{
    const {lang: n} = Hy()
      , r = Ft()
      , o = Ft()
      , a = Ft()
      , i = Ft()
      , s = Ft([[], [], [], [], [], []]);
    let l = !1;
    const u = e.date.$locale().weekStart || 7
      , c = e.date.locale("en").localeData().weekdaysShort().map((e=>e.toLowerCase()))
      , d = yi((()=>u > 3 ? 7 - u : -u))
      , f = yi((()=>{
        const t = e.date.startOf("month");
        return t.subtract(t.day() || 7, "day")
      }
    ))
      , p = yi((()=>c.concat(c).slice(u, u + 7)))
      , h = yi((()=>Np(Vt(b)).some((e=>e.isCurrent))))
      , v = yi((()=>{
        const t = e.date.startOf("month");
        return {
          startOfMonthDay: t.day() || 7,
          dateCountOfMonth: t.daysInMonth(),
          dateCountOfLastMonth: t.subtract(1, "month").daysInMonth()
        }
      }
    ))
      , g = yi((()=>"dates" === e.selectionMode ? Ly(e.parsedValue) : []))
      , m = (t,{columnIndex: n, rowIndex: r},o)=>{
      const {disabledDate: a, cellClassName: i} = e
        , s = Vt(g)
        , l = ((e,{count: t, rowIndex: n, columnIndex: r})=>{
          const {startOfMonthDay: o, dateCountOfMonth: a, dateCountOfLastMonth: i} = Vt(v)
            , s = Vt(d);
          if (!(n >= 0 && n <= 1))
            return t <= a ? e.text = t : (e.text = t - a,
              e.type = "next-month"),
              !0;
          {
            const a = o + s < 0 ? 7 + o + s : o + s;
            if (r + 7 * n >= a)
              return e.text = t,
                !0;
            e.text = i - (a - r % 7) + 1 + 7 * n,
              e.type = "prev-month"
          }
          return !1
        }
      )(t, {
        count: o,
        rowIndex: r,
        columnIndex: n
      })
        , u = t.dayjs.toDate();
      return t.selected = s.find((e=>e.isSame(t.dayjs, "day"))),
        t.isSelected = !!t.selected,
        t.isCurrent = x(t),
        t.disabled = null == a ? void 0 : a(u),
        t.customClass = null == i ? void 0 : i(u),
        l
    }
      , y = t=>{
      if ("week" === e.selectionMode) {
        const [n,r] = e.showWeekNumber ? [1, 7] : [0, 6]
          , o = C(t[n + 1]);
        t[n].inRange = o,
          t[n].start = o,
          t[r].inRange = o,
          t[r].end = o
      }
    }
      , b = yi((()=>{
        const {minDate: t, maxDate: r, rangeState: o, showWeekNumber: a} = e
          , i = Vt(d)
          , l = Vt(s)
          , u = "day";
        let c = 1;
        if (a)
          for (let e = 0; e < 6; e++)
            l[e][0] || (l[e][0] = {
              type: "week",
              text: Vt(f).add(7 * e + 1, u).week()
            });
        return ((e,t,{columnIndexOffset: n, startDate: r, nextEndDate: o, now: a, unit: i, relativeDateGetter: s, setCellMetadata: l, setRowMetadata: u})=>{
            for (let c = 0; c < e.row; c++) {
              const d = t[c];
              for (let t = 0; t < e.column; t++) {
                let u = d[t + n];
                u || (u = {
                  row: c,
                  column: t,
                  type: "normal",
                  inRange: !1,
                  start: !1,
                  end: !1
                });
                const f = s(c * e.column + t);
                u.dayjs = f,
                  u.date = f.toDate(),
                  u.timestamp = f.valueOf(),
                  u.type = "normal",
                  u.inRange = !!(r && f.isSameOrAfter(r, i) && o && f.isSameOrBefore(o, i)) || !!(r && f.isSameOrBefore(r, i) && o && f.isSameOrAfter(o, i)),
                  (null == r ? void 0 : r.isSameOrAfter(o)) ? (u.start = !!o && f.isSame(o, i),
                    u.end = r && f.isSame(r, i)) : (u.start = !!r && f.isSame(r, i),
                    u.end = !!o && f.isSame(o, i)),
                f.isSame(a, i) && (u.type = "today"),
                null == l || l(u, {
                  rowIndex: c,
                  columnIndex: t
                }),
                  d[t + n] = u
              }
              null == u || u(d)
            }
          }
        )({
          row: 6,
          column: 7
        }, l, {
          startDate: t,
          columnIndexOffset: a ? 1 : 0,
          nextEndDate: o.endDate || r || o.selecting && t || null,
          now: JC().locale(Vt(n)).startOf(u),
          unit: u,
          relativeDateGetter: e=>Vt(f).add(e - i, u),
          setCellMetadata: (...e)=>{
            m(...e, c) && (c += 1)
          }
          ,
          setRowMetadata: y
        }),
          l
      }
    ));
    Jn((()=>e.date), (async()=>{
        var e;
        (null == (e = Vt(r)) ? void 0 : e.contains(document.activeElement)) && (await hn(),
          await w())
      }
    ));
    const w = async()=>{
        var e;
        return null == (e = Vt(o)) ? void 0 : e.focus()
      }
      , x = t=>"date" === e.selectionMode && yR(t.type) && S(t, e.parsedValue)
      , S = (t,r)=>!!r && JC(r).locale(Vt(n)).isSame(e.date.date(Number(t.text)), "day")
      , E = (t,n)=>{
        const r = 7 * t + (n - (e.showWeekNumber ? 1 : 0)) - Vt(d);
        return Vt(f).add(r, "day")
      }
      , A = (n,r=!1)=>{
        const o = n.target.closest("td");
        if (!o)
          return;
        const a = o.parentNode.rowIndex - 1
          , i = o.cellIndex
          , s = Vt(b)[a][i];
        if (s.disabled || "week" === s.type)
          return;
        const l = E(a, i);
        switch (e.selectionMode) {
          case "range":
            (n=>{
                e.rangeState.selecting && e.minDate ? (n >= e.minDate ? t("pick", {
                  minDate: e.minDate,
                  maxDate: n
                }) : t("pick", {
                  minDate: n,
                  maxDate: e.minDate
                }),
                  t("select", !1)) : (t("pick", {
                  minDate: n,
                  maxDate: null
                }),
                  t("select", !0))
              }
            )(l);
            break;
          case "date":
            t("pick", l, r);
            break;
          case "week":
            (e=>{
                const n = e.week()
                  , r = `${e.year()}w${n}`;
                t("pick", {
                  year: e.year(),
                  week: n,
                  value: r,
                  date: e.startOf("week")
                })
              }
            )(l);
            break;
          case "dates":
            ((n,r)=>{
                const o = r ? Ly(e.parsedValue).filter((e=>(null == e ? void 0 : e.valueOf()) !== n.valueOf())) : Ly(e.parsedValue).concat([n]);
                t("pick", o)
              }
            )(l, !!s.selected)
        }
      }
      , C = t=>{
        if ("week" !== e.selectionMode)
          return !1;
        let n = e.date.startOf("day");
        if ("prev-month" === t.type && (n = n.subtract(1, "month")),
        "next-month" === t.type && (n = n.add(1, "month")),
          n = n.date(Number.parseInt(t.text, 10)),
        e.parsedValue && !Array.isArray(e.parsedValue)) {
          const t = (e.parsedValue.day() - u + 7) % 7 - 1;
          return e.parsedValue.subtract(t, "day").isSame(n, "day")
        }
        return !1
      }
    ;
    return {
      WEEKS: p,
      rows: b,
      tbodyRef: r,
      currentCellRef: o,
      focus: w,
      isCurrent: x,
      isWeekActive: C,
      isSelectedCell: e=>!Vt(h) && 1 === (null == e ? void 0 : e.text) && "normal" === e.type || e.isCurrent,
      handlePickDate: A,
      handleMouseUp: e=>{
        e.target.closest("td") && (l = !1)
      }
      ,
      handleMouseDown: e=>{
        e.target.closest("td") && (l = !0)
      }
      ,
      handleMouseMove: n=>{
        var r;
        if (!e.rangeState.selecting)
          return;
        let o = n.target;
        if ("SPAN" === o.tagName && (o = null == (r = o.parentNode) ? void 0 : r.parentNode),
        "DIV" === o.tagName && (o = o.parentNode),
        "TD" !== o.tagName)
          return;
        const s = o.parentNode.rowIndex - 1
          , l = o.cellIndex;
        Vt(b)[s][l].disabled || s === Vt(a) && l === Vt(i) || (a.value = s,
          i.value = l,
          t("changerange", {
            selecting: !0,
            endDate: E(s, l)
          }))
      }
      ,
      handleFocus: t=>{
        l || Vt(h) || "date" !== e.selectionMode || A(t, !0)
      }
    }
  }
;
var wR = vr({
  name: "ElDatePickerCell",
  props: uy({
    cell: {
      type: Object
    }
  }),
  setup(e) {
    const t = qy("date-table-cell")
      , {slots: n} = jo(sR);
    return ()=>{
      const {cell: r} = e;
      return Qr(n, "default", {
        ...r
      }, (()=>[ja("div", {
        class: t.b()
      }, [ja("span", {
        class: t.e("text")
      }, [null == r ? void 0 : r.text])])]))
    }
  }
});
const xR = ["aria-label"]
  , SR = {
  key: 0,
  scope: "col"
}
  , ER = ["aria-label"]
  , AR = ["aria-current", "aria-selected", "tabindex"]
  , CR = vr({
  __name: "basic-date-table",
  props: vR,
  emits: ["changerange", "pick", "select"],
  setup(e, {expose: t, emit: n}) {
    const r = e
      , {WEEKS: o, rows: a, tbodyRef: i, currentCellRef: s, focus: l, isCurrent: u, isWeekActive: c, isSelectedCell: d, handlePickDate: f, handleMouseUp: p, handleMouseDown: h, handleMouseMove: v, handleFocus: g} = bR(r, n)
      , {tableLabel: m, tableKls: y, weekLabel: b, getCellClasses: w, getRowKls: x, t: S} = ((e,{isCurrent: t, isWeekActive: n})=>{
        const r = qy("date-table")
          , {t: o} = Hy();
        return {
          tableKls: yi((()=>[r.b(), {
            "is-week-mode": "week" === e.selectionMode
          }])),
          tableLabel: yi((()=>o("el.datepicker.dateTablePrompt"))),
          weekLabel: yi((()=>o("el.datepicker.week"))),
          getCellClasses: n=>{
            const r = [];
            return yR(n.type) && !n.disabled ? (r.push("available"),
            "today" === n.type && r.push("today")) : r.push(n.type),
            t(n) && r.push("current"),
            n.inRange && (yR(n.type) || "week" === e.selectionMode) && (r.push("in-range"),
            n.start && r.push("start-date"),
            n.end && r.push("end-date")),
            n.disabled && r.push("disabled"),
            n.selected && r.push("selected"),
            n.customClass && r.push(n.customClass),
              r.join(" ")
          }
          ,
          getRowKls: e=>[r.e("row"), {
            current: n(e)
          }],
          t: o
        }
      }
    )(r, {
      isCurrent: u,
      isWeekActive: c
    });
    return t({
      focus: l
    }),
      (e,t)=>(Ca(),
        _a("table", {
          "aria-label": Vt(m),
          class: Y(Vt(y)),
          cellspacing: "0",
          cellpadding: "0",
          role: "grid",
          onClick: t[1] || (t[1] = (...e)=>Vt(f) && Vt(f)(...e)),
          onMousemove: t[2] || (t[2] = (...e)=>Vt(v) && Vt(v)(...e)),
          onMousedown: t[3] || (t[3] = js(((...e)=>Vt(h) && Vt(h)(...e)), ["prevent"])),
          onMouseup: t[4] || (t[4] = (...e)=>Vt(p) && Vt(p)(...e))
        }, [Ma("tbody", {
          ref_key: "tbodyRef",
          ref: i
        }, [Ma("tr", null, [e.showWeekNumber ? (Ca(),
          _a("th", SR, te(Vt(b)), 1)) : za("v-if", !0), (Ca(!0),
          _a(ba, null, Yr(Vt(o), ((e,t)=>(Ca(),
            _a("th", {
              key: t,
              "aria-label": Vt(S)("el.datepicker.weeksFull." + e),
              scope: "col"
            }, te(Vt(S)("el.datepicker.weeks." + e)), 9, ER)))), 128))]), (Ca(!0),
          _a(ba, null, Yr(Vt(a), ((e,n)=>(Ca(),
            _a("tr", {
              key: n,
              class: Y(Vt(x)(e[1]))
            }, [(Ca(!0),
              _a(ba, null, Yr(e, ((e,r)=>(Ca(),
                _a("td", {
                  key: `${n}.${r}`,
                  ref_for: !0,
                  ref: t=>Vt(d)(e) && (s.value = t),
                  class: Y(Vt(w)(e)),
                  "aria-current": e.isCurrent ? "date" : void 0,
                  "aria-selected": e.isCurrent,
                  tabindex: Vt(d)(e) ? 0 : -1,
                  onFocus: t[0] || (t[0] = (...e)=>Vt(g) && Vt(g)(...e))
                }, [ja(Vt(wR), {
                  cell: e
                }, null, 8, ["cell"])], 42, AR)))), 128))], 2)))), 128))], 512)], 42, xR))
  }
});
var kR = tS(CR, [["__file", "basic-date-table.vue"]]);
const TR = uy({
  ...cR,
  selectionMode: pR("month")
})
  , DR = ["aria-label"]
  , OR = ["aria-selected", "aria-label", "tabindex", "onKeydown"]
  , _R = {
  class: "cell"
}
  , RR = vr({
  __name: "basic-month-table",
  props: TR,
  emits: ["changerange", "pick", "select"],
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = qy("month-table")
      , {t: a, lang: i} = Hy()
      , s = Ft()
      , l = Ft()
      , u = Ft(r.date.locale("en").localeData().monthsShort().map((e=>e.toLowerCase())))
      , c = Ft([[], [], []])
      , d = Ft()
      , f = Ft()
      , p = yi((()=>{
          var e, t;
          const n = c.value
            , o = JC().locale(i.value).startOf("month");
          for (let a = 0; a < 3; a++) {
            const i = n[a];
            for (let n = 0; n < 4; n++) {
              const s = i[n] || (i[n] = {
                row: a,
                column: n,
                type: "normal",
                inRange: !1,
                start: !1,
                end: !1,
                text: -1,
                disabled: !1
              });
              s.type = "normal";
              const l = 4 * a + n
                , u = r.date.startOf("year").month(l)
                , c = r.rangeState.endDate || r.maxDate || r.rangeState.selecting && r.minDate || null;
              s.inRange = !!(r.minDate && u.isSameOrAfter(r.minDate, "month") && c && u.isSameOrBefore(c, "month")) || !!(r.minDate && u.isSameOrBefore(r.minDate, "month") && c && u.isSameOrAfter(c, "month")),
                (null == (e = r.minDate) ? void 0 : e.isSameOrAfter(c)) ? (s.start = !(!c || !u.isSame(c, "month")),
                  s.end = r.minDate && u.isSame(r.minDate, "month")) : (s.start = !(!r.minDate || !u.isSame(r.minDate, "month")),
                  s.end = !(!c || !u.isSame(c, "month")));
              o.isSame(u) && (s.type = "today"),
                s.text = l,
                s.disabled = (null == (t = r.disabledDate) ? void 0 : t.call(r, u.toDate())) || !1
            }
          }
          return n
        }
      ))
      , h = e=>{
        const t = {}
          , n = r.date.year()
          , o = new Date
          , a = e.text;
        return t.disabled = !!r.disabledDate && ((e,t,n)=>{
            const r = JC().locale(n).startOf("month").month(t).year(e)
              , o = r.daysInMonth();
            return ik(o).map((e=>r.add(e, "day").toDate()))
          }
        )(n, a, i.value).every(r.disabledDate),
          t.current = Ly(r.parsedValue).findIndex((e=>JC.isDayjs(e) && e.year() === n && e.month() === a)) >= 0,
          t.today = o.getFullYear() === n && o.getMonth() === a,
        e.inRange && (t["in-range"] = !0,
        e.start && (t["start-date"] = !0),
        e.end && (t["end-date"] = !0)),
          t
      }
      , v = e=>{
        const t = r.date.year()
          , n = e.text;
        return Ly(r.date).findIndex((e=>e.year() === t && e.month() === n)) >= 0
      }
      , g = e=>{
        var t;
        if (!r.rangeState.selecting)
          return;
        let o = e.target;
        if ("SPAN" === o.tagName && (o = null == (t = o.parentNode) ? void 0 : t.parentNode),
        "DIV" === o.tagName && (o = o.parentNode),
        "TD" !== o.tagName)
          return;
        const a = o.parentNode.rowIndex
          , i = o.cellIndex;
        p.value[a][i].disabled || a === d.value && i === f.value || (d.value = a,
          f.value = i,
          n("changerange", {
            selecting: !0,
            endDate: r.date.startOf("year").month(4 * a + i)
          }))
      }
      , m = e=>{
        var t;
        const o = null == (t = e.target) ? void 0 : t.closest("td");
        if ("TD" !== (null == o ? void 0 : o.tagName))
          return;
        if (em(o, "disabled"))
          return;
        const a = o.cellIndex
          , i = 4 * o.parentNode.rowIndex + a
          , s = r.date.startOf("year").month(i);
        "range" === r.selectionMode ? r.rangeState.selecting ? (r.minDate && s >= r.minDate ? n("pick", {
          minDate: r.minDate,
          maxDate: s
        }) : n("pick", {
          minDate: s,
          maxDate: r.minDate
        }),
          n("select", !1)) : (n("pick", {
          minDate: s,
          maxDate: null
        }),
          n("select", !0)) : n("pick", i)
      }
    ;
    return Jn((()=>r.date), (async()=>{
        var e, t;
        (null == (e = s.value) ? void 0 : e.contains(document.activeElement)) && (await hn(),
        null == (t = l.value) || t.focus())
      }
    )),
      t({
        focus: ()=>{
          var e;
          null == (e = l.value) || e.focus()
        }
      }),
      (e,t)=>(Ca(),
        _a("table", {
          role: "grid",
          "aria-label": Vt(a)("el.datepicker.monthTablePrompt"),
          class: Y(Vt(o).b()),
          onClick: m,
          onMousemove: g
        }, [Ma("tbody", {
          ref_key: "tbodyRef",
          ref: s
        }, [(Ca(!0),
          _a(ba, null, Yr(Vt(p), ((e,t)=>(Ca(),
            _a("tr", {
              key: t
            }, [(Ca(!0),
              _a(ba, null, Yr(e, ((e,t)=>(Ca(),
                _a("td", {
                  key: t,
                  ref_for: !0,
                  ref: t=>v(e) && (l.value = t),
                  class: Y(h(e)),
                  "aria-selected": `${v(e)}`,
                  "aria-label": Vt(a)("el.datepicker.month" + (+e.text + 1)),
                  tabindex: v(e) ? 0 : -1,
                  onKeydown: [Us(js(m, ["prevent", "stop"]), ["space"]), Us(js(m, ["prevent", "stop"]), ["enter"])]
                }, [Ma("div", null, [Ma("span", _R, te(Vt(a)("el.datepicker.months." + u.value[e.text])), 1)])], 42, OR)))), 128))])))), 128))], 512)], 42, DR))
  }
});
var LR = tS(RR, [["__file", "basic-month-table.vue"]]);
const {date: IR, disabledDate: PR, parsedValue: FR} = cR
  , BR = uy({
  date: IR,
  disabledDate: PR,
  parsedValue: FR,
  selectionMode: pR("year")
})
  , NR = ["aria-label"]
  , MR = ["aria-selected", "tabindex", "onKeydown"]
  , jR = {
  class: "cell"
}
  , VR = {
  key: 1
}
  , UR = vr({
  __name: "basic-year-table",
  props: BR,
  emits: ["pick"],
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = qy("year-table")
      , {t: a, lang: i} = Hy()
      , s = Ft()
      , l = Ft()
      , u = yi((()=>10 * Math.floor(r.date.year() / 10)))
      , c = e=>{
        const t = {}
          , n = JC().locale(i.value);
        return t.disabled = !!r.disabledDate && ((e,t)=>{
            const n = JC(String(e)).locale(t).startOf("year")
              , r = n.endOf("year").dayOfYear();
            return ik(r).map((e=>n.add(e, "day").toDate()))
          }
        )(e, i.value).every(r.disabledDate),
          t.current = Ly(r.parsedValue).findIndex((t=>t.year() === e)) >= 0,
          t.today = n.year() === e,
          t
      }
      , d = e=>e === u.value && r.date.year() < u.value && r.date.year() > u.value + 9 || Ly(r.date).findIndex((t=>t.year() === e)) >= 0 || Ly(r.parsedValue).findIndex((t=>(null == t ? void 0 : t.year()) === e)) >= 0
      , f = e=>{
        const t = e.target.closest("td");
        if (t && t.textContent) {
          if (em(t, "disabled"))
            return;
          const o = t.textContent || t.innerText;
          if ("years" === r.selectionMode) {
            if ("keydown" === e.type)
              return void n("pick", Ly(r.parsedValue), !1);
            const a = em(t, "current") ? Ly(r.parsedValue).filter((e=>(null == e ? void 0 : e.year()) !== Number(o))) : Ly(r.parsedValue).concat([JC(o)]);
            n("pick", a)
          } else
            n("pick", Number(o))
        }
      }
    ;
    return Jn((()=>r.date), (async()=>{
        var e, t;
        (null == (e = s.value) ? void 0 : e.contains(document.activeElement)) && (await hn(),
        null == (t = l.value) || t.focus())
      }
    )),
      t({
        focus: ()=>{
          var e;
          null == (e = l.value) || e.focus()
        }
      }),
      (e,t)=>(Ca(),
        _a("table", {
          role: "grid",
          "aria-label": Vt(a)("el.datepicker.yearTablePrompt"),
          class: Y(Vt(o).b()),
          onClick: f
        }, [Ma("tbody", {
          ref_key: "tbodyRef",
          ref: s
        }, [(Ca(),
          _a(ba, null, Yr(3, ((e,t)=>Ma("tr", {
            key: t
          }, [(Ca(),
            _a(ba, null, Yr(4, ((e,n)=>(Ca(),
              _a(ba, {
                key: t + "_" + n
              }, [4 * t + n < 10 ? (Ca(),
                _a("td", {
                  key: 0,
                  ref_for: !0,
                  ref: e=>d(Vt(u) + 4 * t + n) && (l.value = e),
                  class: Y(["available", c(Vt(u) + 4 * t + n)]),
                  "aria-selected": `${d(Vt(u) + 4 * t + n)}`,
                  tabindex: d(Vt(u) + 4 * t + n) ? 0 : -1,
                  onKeydown: [Us(js(f, ["prevent", "stop"]), ["space"]), Us(js(f, ["prevent", "stop"]), ["enter"])]
                }, [Ma("div", null, [Ma("span", jR, te(Vt(u) + 4 * t + n), 1)])], 42, MR)) : (Ca(),
                _a("td", VR))], 64)))), 64))]))), 64))], 512)], 10, NR))
  }
});
var $R = tS(UR, [["__file", "basic-year-table.vue"]]);
const HR = ["onClick"]
  , zR = ["aria-label"]
  , KR = ["aria-label"]
  , WR = ["aria-label"]
  , GR = ["aria-label"]
  , qR = vr({
  __name: "panel-date-pick",
  props: hR,
  emits: ["pick", "set-picker-option", "panel-change"],
  setup(e, {emit: t}) {
    const n = e
      , r = qy("picker-panel")
      , o = qy("date-picker")
      , a = ho()
      , i = po()
      , {t: s, lang: l} = Hy()
      , u = jo("EP_PICKER_BASE")
      , c = jo(xA)
      , {shortcuts: d, disabledDate: f, cellClassName: p, defaultTime: v} = u.props
      , g = Yt(u.props, "defaultValue")
      , m = Ft()
      , b = Ft(JC().locale(l.value))
      , w = Ft(!1);
    let x = !1;
    const S = yi((()=>JC(v).locale(l.value)))
      , E = yi((()=>b.value.month()))
      , A = yi((()=>b.value.year()))
      , C = Ft([])
      , k = Ft(null)
      , T = Ft(null)
      , D = e=>!(C.value.length > 0) || (C.value,
        n.format,
        !0)
      , O = e=>!v || Q.value || w.value || x ? $.value ? e.millisecond(0) : e.startOf("day") : S.value.year(e.year()).month(e.month()).date(e.date())
      , _ = (e,...n)=>{
        if (e)
          if (h(e)) {
            const r = e.map(O);
            t("pick", r, ...n)
          } else
            t("pick", O(e), ...n);
        else
          t("pick", e, ...n);
        k.value = null,
          T.value = null,
          w.value = !1,
          x = !1
      }
      , R = async(e,t)=>{
        if ("date" === B.value) {
          let r = n.parsedValue ? n.parsedValue.year(e.year()).month(e.month()).date(e.date()) : e;
          D() || (r = C.value[0][0].year(e.year()).month(e.month()).date(e.date())),
            b.value = r,
            _(r, $.value || t),
          "datetime" === n.type && (await hn(),
            le())
        } else
          "week" === B.value ? _(e.date) : "dates" === B.value && _(e, !0)
      }
      , L = e=>{
        const t = e ? "add" : "subtract";
        b.value = b.value[t](1, "month"),
          de("month")
      }
      , I = e=>{
        const t = b.value
          , n = e ? "add" : "subtract";
        b.value = "year" === P.value ? t[n](10, "year") : t[n](1, "year"),
          de("year")
      }
      , P = Ft("date")
      , F = yi((()=>{
          const e = s("el.datepicker.year");
          if ("year" === P.value) {
            const t = 10 * Math.floor(A.value / 10);
            return e ? `${t} ${e} - ${t + 9} ${e}` : `${t} - ${t + 9}`
          }
          return `${A.value} ${e}`
        }
      ))
      , B = yi((()=>{
          const {type: e} = n;
          return ["week", "month", "year", "years", "dates"].includes(e) ? e : "date"
        }
      ))
      , N = yi((()=>"date" === B.value ? P.value : B.value))
      , M = yi((()=>!!d.length))
      , j = async e=>{
        b.value = b.value.startOf("month").month(e),
          "month" === B.value ? _(b.value, !1) : (P.value = "date",
          ["month", "year", "date", "week"].includes(B.value) && (_(b.value, !0),
            await hn(),
            le())),
          de("month")
      }
      , V = async(e,t)=>{
        "year" === B.value ? (b.value = b.value.startOf("year").year(e),
          _(b.value, !1)) : "years" === B.value ? _(e, null == t || t) : (b.value = b.value.year(e),
          P.value = "month",
        ["month", "year", "date", "week"].includes(B.value) && (_(b.value, !0),
          await hn(),
          le())),
          de("year")
      }
      , U = async e=>{
        P.value = e,
          await hn(),
          le()
      }
      , $ = yi((()=>"datetime" === n.type || "datetimerange" === n.type))
      , H = yi((()=>{
          const e = $.value || "dates" === B.value
            , t = "years" === B.value
            , n = "date" === P.value
            , r = "year" === P.value;
          return e && n || t && r
        }
      ))
      , z = yi((()=>!!f && (!n.parsedValue || (h(n.parsedValue) ? f(n.parsedValue[0].toDate()) : f(n.parsedValue.toDate())))))
      , K = ()=>{
        if ("dates" === B.value || "years" === B.value)
          _(n.parsedValue);
        else {
          let e = n.parsedValue;
          if (!e) {
            const t = JC(v).locale(l.value)
              , n = se();
            e = t.year(n.year()).month(n.month()).date(n.date())
          }
          b.value = e,
            _(e)
        }
      }
      , W = yi((()=>!!f && f(JC().locale(l.value).toDate())))
      , G = ()=>{
        const e = JC().locale(l.value).toDate();
        w.value = !0,
        f && f(e) || !D() || (b.value = JC().locale(l.value),
          _(b.value))
      }
      , q = yi((()=>n.timeFormat || lk(n.format)))
      , X = yi((()=>n.dateFormat || sk(n.format)))
      , Q = yi((()=>T.value ? T.value : n.parsedValue || g.value ? (n.parsedValue || b.value).format(q.value) : void 0))
      , J = yi((()=>k.value ? k.value : n.parsedValue || g.value ? (n.parsedValue || b.value).format(X.value) : void 0))
      , Z = Ft(!1)
      , ee = ()=>{
        Z.value = !0
      }
      , ne = ()=>{
        Z.value = !1
      }
      , re = e=>({
        hour: e.hour(),
        minute: e.minute(),
        second: e.second(),
        year: e.year(),
        month: e.month(),
        date: e.date()
      })
      , oe = (e,t,r)=>{
        const {hour: o, minute: a, second: i} = re(e)
          , s = n.parsedValue ? n.parsedValue.hour(o).minute(a).second(i) : e;
        b.value = s,
          _(b.value, !0),
        r || (Z.value = t)
      }
      , ae = e=>{
        const t = JC(e, q.value).locale(l.value);
        if (t.isValid() && D()) {
          const {year: e, month: n, date: r} = re(b.value);
          b.value = t.year(e).month(n).date(r),
            T.value = null,
            Z.value = !1,
            _(b.value, !0)
        }
      }
      , ie = e=>{
        const t = JC(e, X.value).locale(l.value);
        if (t.isValid()) {
          if (f && f(t.toDate()))
            return;
          const {hour: e, minute: n, second: r} = re(b.value);
          b.value = t.hour(e).minute(n).second(r),
            k.value = null,
            _(b.value, !0)
        }
      }
      , se = ()=>{
        const e = JC(g.value).locale(l.value);
        if (!g.value) {
          const e = S.value;
          return JC().hour(e.hour()).minute(e.minute()).second(e.second()).locale(l.value)
        }
        return e
      }
      , le = async()=>{
        var e;
        ["week", "month", "year", "date"].includes(B.value) && (null == (e = m.value) || e.focus(),
        "week" === B.value && ce(by.down))
      }
      , ue = e=>{
        const {code: t} = e;
        [by.up, by.down, by.left, by.right, by.home, by.end, by.pageUp, by.pageDown].includes(t) && (ce(t),
          e.stopPropagation(),
          e.preventDefault()),
        [by.enter, by.space, by.numpadEnter].includes(t) && null === k.value && null === T.value && (e.preventDefault(),
          _(b.value, !1))
      }
      , ce = e=>{
        var n;
        const {up: r, down: o, left: a, right: i, home: s, end: u, pageUp: c, pageDown: d} = by
          , p = {
          year: {
            [r]: -4,
            [o]: 4,
            [a]: -1,
            [i]: 1,
            offset: (e,t)=>e.setFullYear(e.getFullYear() + t)
          },
          month: {
            [r]: -4,
            [o]: 4,
            [a]: -1,
            [i]: 1,
            offset: (e,t)=>e.setMonth(e.getMonth() + t)
          },
          week: {
            [r]: -1,
            [o]: 1,
            [a]: -1,
            [i]: 1,
            offset: (e,t)=>e.setDate(e.getDate() + 7 * t)
          },
          date: {
            [r]: -7,
            [o]: 7,
            [a]: -1,
            [i]: 1,
            [s]: e=>-e.getDay(),
            [u]: e=>6 - e.getDay(),
            [c]: e=>-new Date(e.getFullYear(),e.getMonth(),0).getDate(),
            [d]: e=>new Date(e.getFullYear(),e.getMonth() + 1,0).getDate(),
            offset: (e,t)=>e.setDate(e.getDate() + t)
          }
        }
          , h = b.value.toDate();
        for (; Math.abs(b.value.diff(h, "year", !0)) < 1; ) {
          const r = p[N.value];
          if (!r)
            return;
          if (r.offset(h, y(r[e]) ? r[e](h) : null != (n = r[e]) ? n : 0),
          f && f(h))
            break;
          const o = JC(h).locale(l.value);
          b.value = o,
            t("pick", o, !0);
          break
        }
      }
      , de = e=>{
        t("panel-change", b.value.toDate(), e, P.value)
      }
    ;
    return Jn((()=>B.value), (e=>{
        ["month", "year"].includes(e) ? P.value = e : P.value = "years" !== e ? "date" : "year"
      }
    ), {
      immediate: !0
    }),
      Jn((()=>P.value), (()=>{
          null == c || c.updatePopper()
        }
      )),
      Jn((()=>g.value), (e=>{
          e && (b.value = se())
        }
      ), {
        immediate: !0
      }),
      Jn((()=>n.parsedValue), (e=>{
          if (e) {
            if ("dates" === B.value || "years" === B.value)
              return;
            if (Array.isArray(e))
              return;
            b.value = e
          } else
            b.value = se()
        }
      ), {
        immediate: !0
      }),
      t("set-picker-option", ["isValidValue", e=>JC.isDayjs(e) && e.isValid() && (!f || !f(e.toDate()))]),
      t("set-picker-option", ["formatToString", e=>Array.isArray(e) ? e.map((e=>e.format(n.format))) : e.format(n.format)]),
      t("set-picker-option", ["parseUserInput", e=>JC(e, n.format).locale(l.value)]),
      t("set-picker-option", ["handleFocusPicker", le]),
      (e,n)=>(Ca(),
        _a("div", {
          class: Y([Vt(r).b(), Vt(o).b(), {
            "has-sidebar": e.$slots.sidebar || Vt(M),
            "has-time": Vt($)
          }])
        }, [Ma("div", {
          class: Y(Vt(r).e("body-wrapper"))
        }, [Qr(e.$slots, "sidebar", {
          class: Y(Vt(r).e("sidebar"))
        }), Vt(M) ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(r).e("sidebar"))
          }, [(Ca(!0),
            _a(ba, null, Yr(Vt(d), ((e,n)=>(Ca(),
              _a("button", {
                key: n,
                type: "button",
                class: Y(Vt(r).e("shortcut")),
                onClick: n=>(e=>{
                    const n = y(e.value) ? e.value() : e.value;
                    if (n)
                      return x = !0,
                        void _(JC(n).locale(l.value));
                    e.onClick && e.onClick({
                      attrs: a,
                      slots: i,
                      emit: t
                    })
                  }
                )(e)
              }, te(e.text), 11, HR)))), 128))], 2)) : za("v-if", !0), Ma("div", {
          class: Y(Vt(r).e("body"))
        }, [Vt($) ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(o).e("time-header"))
          }, [Ma("span", {
            class: Y(Vt(o).e("editor-wrap"))
          }, [ja(Vt(yE), {
            placeholder: Vt(s)("el.datepicker.selectDate"),
            "model-value": Vt(J),
            size: "small",
            "validate-event": !1,
            onInput: n[0] || (n[0] = e=>k.value = e),
            onChange: ie
          }, null, 8, ["placeholder", "model-value"])], 2), rr((Ca(),
            _a("span", {
              class: Y(Vt(o).e("editor-wrap"))
            }, [ja(Vt(yE), {
              placeholder: Vt(s)("el.datepicker.selectTime"),
              "model-value": Vt(Q),
              size: "small",
              "validate-event": !1,
              onFocus: ee,
              onInput: n[1] || (n[1] = e=>T.value = e),
              onChange: ae
            }, null, 8, ["placeholder", "model-value"]), ja(Vt(gT), {
              visible: Z.value,
              format: Vt(q),
              "parsed-value": b.value,
              onPick: oe
            }, null, 8, ["visible", "format", "parsed-value"])], 2)), [[Vt(Rk), ne]])], 2)) : za("v-if", !0), rr(Ma("div", {
          class: Y([Vt(o).e("header"), ("year" === P.value || "month" === P.value) && Vt(o).e("header--bordered")])
        }, [Ma("span", {
          class: Y(Vt(o).e("prev-btn"))
        }, [Ma("button", {
          type: "button",
          "aria-label": Vt(s)("el.datepicker.prevYear"),
          class: Y(["d-arrow-left", Vt(r).e("icon-btn")]),
          onClick: n[2] || (n[2] = e=>I(!1))
        }, [ja(Vt(sS), null, {
          default: Fn((()=>[ja(Vt(Om))])),
          _: 1
        })], 10, zR), rr(Ma("button", {
          type: "button",
          "aria-label": Vt(s)("el.datepicker.prevMonth"),
          class: Y([Vt(r).e("icon-btn"), "arrow-left"]),
          onClick: n[3] || (n[3] = e=>L(!1))
        }, [ja(Vt(sS), null, {
          default: Fn((()=>[ja(Vt(vm))])),
          _: 1
        })], 10, KR), [[$s, "date" === P.value]])], 2), Ma("span", {
          role: "button",
          class: Y(Vt(o).e("header-label")),
          "aria-live": "polite",
          tabindex: "0",
          onKeydown: n[4] || (n[4] = Us((e=>U("year")), ["enter"])),
          onClick: n[5] || (n[5] = e=>U("year"))
        }, te(Vt(F)), 35), rr(Ma("span", {
          role: "button",
          "aria-live": "polite",
          tabindex: "0",
          class: Y([Vt(o).e("header-label"), {
            active: "month" === P.value
          }]),
          onKeydown: n[6] || (n[6] = Us((e=>U("month")), ["enter"])),
          onClick: n[7] || (n[7] = e=>U("month"))
        }, te(Vt(s)(`el.datepicker.month${Vt(E) + 1}`)), 35), [[$s, "date" === P.value]]), Ma("span", {
          class: Y(Vt(o).e("next-btn"))
        }, [rr(Ma("button", {
          type: "button",
          "aria-label": Vt(s)("el.datepicker.nextMonth"),
          class: Y([Vt(r).e("icon-btn"), "arrow-right"]),
          onClick: n[8] || (n[8] = e=>L(!0))
        }, [ja(Vt(sS), null, {
          default: Fn((()=>[ja(Vt(gm))])),
          _: 1
        })], 10, WR), [[$s, "date" === P.value]]), Ma("button", {
          type: "button",
          "aria-label": Vt(s)("el.datepicker.nextYear"),
          class: Y([Vt(r).e("icon-btn"), "d-arrow-right"]),
          onClick: n[9] || (n[9] = e=>I(!0))
        }, [ja(Vt(sS), null, {
          default: Fn((()=>[ja(Vt(_m))])),
          _: 1
        })], 10, GR)], 2)], 2), [[$s, "time" !== P.value]]), Ma("div", {
          class: Y(Vt(r).e("content")),
          onKeydown: ue
        }, ["date" === P.value ? (Ca(),
          Ra(kR, {
            key: 0,
            ref_key: "currentViewRef",
            ref: m,
            "selection-mode": Vt(B),
            date: b.value,
            "parsed-value": e.parsedValue,
            "disabled-date": Vt(f),
            "cell-class-name": Vt(p),
            onPick: R
          }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name"])) : za("v-if", !0), "year" === P.value ? (Ca(),
          Ra($R, {
            key: 1,
            ref_key: "currentViewRef",
            ref: m,
            "selection-mode": Vt(B),
            date: b.value,
            "disabled-date": Vt(f),
            "parsed-value": e.parsedValue,
            onPick: V
          }, null, 8, ["selection-mode", "date", "disabled-date", "parsed-value"])) : za("v-if", !0), "month" === P.value ? (Ca(),
          Ra(LR, {
            key: 2,
            ref_key: "currentViewRef",
            ref: m,
            date: b.value,
            "parsed-value": e.parsedValue,
            "disabled-date": Vt(f),
            onPick: j
          }, null, 8, ["date", "parsed-value", "disabled-date"])) : za("v-if", !0)], 34)], 2)], 2), rr(Ma("div", {
          class: Y(Vt(r).e("footer"))
        }, [rr(ja(Vt(WC), {
          text: "",
          size: "small",
          class: Y(Vt(r).e("link-btn")),
          disabled: Vt(W),
          onClick: G
        }, {
          default: Fn((()=>[$a(te(Vt(s)("el.datepicker.now")), 1)])),
          _: 1
        }, 8, ["class", "disabled"]), [[$s, "dates" !== Vt(B) && "years" !== Vt(B)]]), ja(Vt(WC), {
          plain: "",
          size: "small",
          class: Y(Vt(r).e("link-btn")),
          disabled: Vt(z),
          onClick: K
        }, {
          default: Fn((()=>[$a(te(Vt(s)("el.datepicker.confirm")), 1)])),
          _: 1
        }, 8, ["class", "disabled"])], 2), [[$s, Vt(H)]])], 2))
  }
});
var YR = tS(qR, [["__file", "panel-date-pick.vue"]]);
const XR = uy({
  ...dR,
  ...fR
})
  , QR = (e,{defaultValue: t, leftDate: n, rightDate: r, unit: o, onParsedValueChanged: a})=>{
  const {emit: i} = ei()
    , {pickerNs: s} = jo(sR)
    , l = qy("date-range-picker")
    , {t: u, lang: c} = Hy()
    , d = (e=>{
        const {emit: t} = ei()
          , n = ho()
          , r = po();
        return o=>{
          const a = y(o.value) ? o.value() : o.value;
          a ? t("pick", [JC(a[0]).locale(e.value), JC(a[1]).locale(e.value)]) : o.onClick && o.onClick({
            attrs: n,
            slots: r,
            emit: t
          })
        }
      }
    )(c)
    , f = Ft()
    , p = Ft()
    , v = Ft({
      endDate: null,
      selecting: !1
    })
    , g = ()=>{
      const [a,i] = mR(Vt(t), {
        lang: Vt(c),
        unit: o,
        unlinkPanels: e.unlinkPanels
      });
      f.value = void 0,
        p.value = void 0,
        n.value = a,
        r.value = i
    }
  ;
  return Jn(t, (e=>{
      e && g()
    }
  ), {
    immediate: !0
  }),
    Jn((()=>e.parsedValue), (e=>{
        if (h(e) && 2 === e.length) {
          const [t,r] = e;
          f.value = t,
            n.value = t,
            p.value = r,
            a(Vt(f), Vt(p))
        } else
          g()
      }
    ), {
      immediate: !0
    }),
    {
      minDate: f,
      maxDate: p,
      rangeState: v,
      lang: c,
      ppNs: s,
      drpNs: l,
      handleChangeRange: e=>{
        v.value = e
      }
      ,
      handleRangeConfirm: (e=!1)=>{
        const t = Vt(f)
          , n = Vt(p);
        gR([t, n]) && i("pick", [t, n], e)
      }
      ,
      handleShortcutClick: d,
      onSelect: e=>{
        v.value.selecting = e,
        e || (v.value.endDate = null)
      }
      ,
      t: u
    }
}
  , JR = ["onClick"]
  , ZR = ["aria-label"]
  , eL = ["aria-label"]
  , tL = ["disabled", "aria-label"]
  , nL = ["disabled", "aria-label"]
  , rL = ["disabled", "aria-label"]
  , oL = ["disabled", "aria-label"]
  , aL = ["aria-label"]
  , iL = ["aria-label"]
  , sL = "month"
  , lL = vr({
  __name: "panel-date-range",
  props: XR,
  emits: ["pick", "set-picker-option", "calendar-change", "panel-change"],
  setup(e, {emit: t}) {
    const n = e
      , r = jo("EP_PICKER_BASE")
      , {disabledDate: o, cellClassName: a, format: i, defaultTime: s, clearable: l} = r.props
      , u = Yt(r.props, "shortcuts")
      , c = Yt(r.props, "defaultValue")
      , {lang: d} = Hy()
      , f = Ft(JC().locale(d.value))
      , p = Ft(JC().locale(d.value).add(1, sL))
      , {minDate: v, maxDate: g, rangeState: m, ppNs: y, drpNs: b, handleChangeRange: w, handleRangeConfirm: x, handleShortcutClick: S, onSelect: E, t: A} = QR(n, {
        defaultValue: c,
        leftDate: f,
        rightDate: p,
        unit: sL,
        onParsedValueChanged: function(e, t) {
          if (n.unlinkPanels && t) {
            const n = (null == e ? void 0 : e.year()) || 0
              , r = (null == e ? void 0 : e.month()) || 0
              , o = t.year()
              , a = t.month();
            p.value = n === o && r === a ? t.add(1, sL) : t
          } else
            p.value = f.value.add(1, sL),
            t && (p.value = p.value.hour(t.hour()).minute(t.minute()).second(t.second()))
        }
      })
      , C = Ft({
        min: null,
        max: null
      })
      , k = Ft({
        min: null,
        max: null
      })
      , T = yi((()=>`${f.value.year()} ${A("el.datepicker.year")} ${A(`el.datepicker.month${f.value.month() + 1}`)}`))
      , D = yi((()=>`${p.value.year()} ${A("el.datepicker.year")} ${A(`el.datepicker.month${p.value.month() + 1}`)}`))
      , O = yi((()=>f.value.year()))
      , _ = yi((()=>f.value.month()))
      , R = yi((()=>p.value.year()))
      , L = yi((()=>p.value.month()))
      , I = yi((()=>!!u.value.length))
      , P = yi((()=>null !== C.value.min ? C.value.min : v.value ? v.value.format(j.value) : ""))
      , F = yi((()=>null !== C.value.max ? C.value.max : g.value || v.value ? (g.value || v.value).format(j.value) : ""))
      , B = yi((()=>null !== k.value.min ? k.value.min : v.value ? v.value.format(M.value) : ""))
      , N = yi((()=>null !== k.value.max ? k.value.max : g.value || v.value ? (g.value || v.value).format(M.value) : ""))
      , M = yi((()=>n.timeFormat || lk(i)))
      , j = yi((()=>n.dateFormat || sk(i)))
      , V = ()=>{
        f.value = f.value.subtract(1, "year"),
        n.unlinkPanels || (p.value = f.value.add(1, "month")),
          q("year")
      }
      , U = ()=>{
        f.value = f.value.subtract(1, "month"),
        n.unlinkPanels || (p.value = f.value.add(1, "month")),
          q("month")
      }
      , $ = ()=>{
        n.unlinkPanels ? p.value = p.value.add(1, "year") : (f.value = f.value.add(1, "year"),
          p.value = f.value.add(1, "month")),
          q("year")
      }
      , H = ()=>{
        n.unlinkPanels ? p.value = p.value.add(1, "month") : (f.value = f.value.add(1, "month"),
          p.value = f.value.add(1, "month")),
          q("month")
      }
      , z = ()=>{
        f.value = f.value.add(1, "year"),
          q("year")
      }
      , K = ()=>{
        f.value = f.value.add(1, "month"),
          q("month")
      }
      , W = ()=>{
        p.value = p.value.subtract(1, "year"),
          q("year")
      }
      , G = ()=>{
        p.value = p.value.subtract(1, "month"),
          q("month")
      }
      , q = e=>{
        t("panel-change", [f.value.toDate(), p.value.toDate()], e)
      }
      , X = yi((()=>{
          const e = (_.value + 1) % 12
            , t = _.value + 1 >= 12 ? 1 : 0;
          return n.unlinkPanels && new Date(O.value + t,e) < new Date(R.value,L.value)
        }
      ))
      , Q = yi((()=>n.unlinkPanels && 12 * R.value + L.value - (12 * O.value + _.value + 1) >= 12))
      , J = yi((()=>!(v.value && g.value && !m.value.selecting && gR([v.value, g.value]))))
      , Z = yi((()=>"datetime" === n.type || "datetimerange" === n.type))
      , ee = (e,t)=>{
        if (e) {
          if (s) {
            return JC(s[t] || s).locale(d.value).year(e.year()).month(e.month()).date(e.date())
          }
          return e
        }
      }
      , ne = (e,n=!0)=>{
        const r = e.minDate
          , o = e.maxDate
          , a = ee(r, 0)
          , i = ee(o, 1);
        g.value === i && v.value === a || (t("calendar-change", [r.toDate(), o && o.toDate()]),
          g.value = i,
          v.value = a,
        n && !Z.value && x())
      }
      , re = Ft(!1)
      , oe = Ft(!1)
      , ae = ()=>{
        re.value = !1
      }
      , ie = ()=>{
        oe.value = !1
      }
      , se = (e,t)=>{
        C.value[t] = e;
        const r = JC(e, j.value).locale(d.value);
        if (r.isValid()) {
          if (o && o(r.toDate()))
            return;
          "min" === t ? (f.value = r,
            v.value = (v.value || f.value).year(r.year()).month(r.month()).date(r.date()),
          n.unlinkPanels || g.value && !g.value.isBefore(v.value) || (p.value = r.add(1, "month"),
            g.value = v.value.add(1, "month"))) : (p.value = r,
            g.value = (g.value || p.value).year(r.year()).month(r.month()).date(r.date()),
          n.unlinkPanels || v.value && !v.value.isAfter(g.value) || (f.value = r.subtract(1, "month"),
            v.value = g.value.subtract(1, "month")))
        }
      }
      , le = (e,t)=>{
        C.value[t] = null
      }
      , ue = (e,t)=>{
        k.value[t] = e;
        const n = JC(e, M.value).locale(d.value);
        n.isValid() && ("min" === t ? (re.value = !0,
          v.value = (v.value || f.value).hour(n.hour()).minute(n.minute()).second(n.second()),
        g.value && !g.value.isBefore(v.value) || (g.value = v.value)) : (oe.value = !0,
          g.value = (g.value || p.value).hour(n.hour()).minute(n.minute()).second(n.second()),
          p.value = g.value,
        g.value && g.value.isBefore(v.value) && (v.value = g.value)))
      }
      , ce = (e,t)=>{
        k.value[t] = null,
          "min" === t ? (f.value = v.value,
            re.value = !1) : (p.value = g.value,
            oe.value = !1)
      }
      , de = (e,t,n)=>{
        k.value.min || (e && (f.value = e,
          v.value = (v.value || f.value).hour(e.hour()).minute(e.minute()).second(e.second())),
        n || (re.value = t),
        g.value && !g.value.isBefore(v.value) || (g.value = v.value,
          p.value = e))
      }
      , fe = (e,t,n)=>{
        k.value.max || (e && (p.value = e,
          g.value = (g.value || p.value).hour(e.hour()).minute(e.minute()).second(e.second())),
        n || (oe.value = t),
        g.value && g.value.isBefore(v.value) && (v.value = g.value))
      }
      , pe = ()=>{
        f.value = mR(Vt(c), {
          lang: Vt(d),
          unit: "month",
          unlinkPanels: n.unlinkPanels
        })[0],
          p.value = f.value.add(1, "month"),
          t("pick", null)
      }
    ;
    return t("set-picker-option", ["isValidValue", e=>gR(e) && (!o || !o(e[0].toDate()) && !o(e[1].toDate()))]),
      t("set-picker-option", ["parseUserInput", e=>h(e) ? e.map((e=>JC(e, i).locale(d.value))) : JC(e, i).locale(d.value)]),
      t("set-picker-option", ["formatToString", e=>h(e) ? e.map((e=>e.format(i))) : e.format(i)]),
      t("set-picker-option", ["handleClear", pe]),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y([Vt(y).b(), Vt(b).b(), {
            "has-sidebar": e.$slots.sidebar || Vt(I),
            "has-time": Vt(Z)
          }])
        }, [Ma("div", {
          class: Y(Vt(y).e("body-wrapper"))
        }, [Qr(e.$slots, "sidebar", {
          class: Y(Vt(y).e("sidebar"))
        }), Vt(I) ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(y).e("sidebar"))
          }, [(Ca(!0),
            _a(ba, null, Yr(Vt(u), ((e,t)=>(Ca(),
              _a("button", {
                key: t,
                type: "button",
                class: Y(Vt(y).e("shortcut")),
                onClick: t=>Vt(S)(e)
              }, te(e.text), 11, JR)))), 128))], 2)) : za("v-if", !0), Ma("div", {
          class: Y(Vt(y).e("body"))
        }, [Vt(Z) ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(b).e("time-header"))
          }, [Ma("span", {
            class: Y(Vt(b).e("editors-wrap"))
          }, [Ma("span", {
            class: Y(Vt(b).e("time-picker-wrap"))
          }, [ja(Vt(yE), {
            size: "small",
            disabled: Vt(m).selecting,
            placeholder: Vt(A)("el.datepicker.startDate"),
            class: Y(Vt(b).e("editor")),
            "model-value": Vt(P),
            "validate-event": !1,
            onInput: t[0] || (t[0] = e=>se(e, "min")),
            onChange: t[1] || (t[1] = e=>le(0, "min"))
          }, null, 8, ["disabled", "placeholder", "class", "model-value"])], 2), rr((Ca(),
            _a("span", {
              class: Y(Vt(b).e("time-picker-wrap"))
            }, [ja(Vt(yE), {
              size: "small",
              class: Y(Vt(b).e("editor")),
              disabled: Vt(m).selecting,
              placeholder: Vt(A)("el.datepicker.startTime"),
              "model-value": Vt(B),
              "validate-event": !1,
              onFocus: t[2] || (t[2] = e=>re.value = !0),
              onInput: t[3] || (t[3] = e=>ue(e, "min")),
              onChange: t[4] || (t[4] = e=>ce(0, "min"))
            }, null, 8, ["class", "disabled", "placeholder", "model-value"]), ja(Vt(gT), {
              visible: re.value,
              format: Vt(M),
              "datetime-role": "start",
              "parsed-value": f.value,
              onPick: de
            }, null, 8, ["visible", "format", "parsed-value"])], 2)), [[Vt(Rk), ae]])], 2), Ma("span", null, [ja(Vt(sS), null, {
            default: Fn((()=>[ja(Vt(gm))])),
            _: 1
          })]), Ma("span", {
            class: Y([Vt(b).e("editors-wrap"), "is-right"])
          }, [Ma("span", {
            class: Y(Vt(b).e("time-picker-wrap"))
          }, [ja(Vt(yE), {
            size: "small",
            class: Y(Vt(b).e("editor")),
            disabled: Vt(m).selecting,
            placeholder: Vt(A)("el.datepicker.endDate"),
            "model-value": Vt(F),
            readonly: !Vt(v),
            "validate-event": !1,
            onInput: t[5] || (t[5] = e=>se(e, "max")),
            onChange: t[6] || (t[6] = e=>le(0, "max"))
          }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"])], 2), rr((Ca(),
            _a("span", {
              class: Y(Vt(b).e("time-picker-wrap"))
            }, [ja(Vt(yE), {
              size: "small",
              class: Y(Vt(b).e("editor")),
              disabled: Vt(m).selecting,
              placeholder: Vt(A)("el.datepicker.endTime"),
              "model-value": Vt(N),
              readonly: !Vt(v),
              "validate-event": !1,
              onFocus: t[7] || (t[7] = e=>Vt(v) && (oe.value = !0)),
              onInput: t[8] || (t[8] = e=>ue(e, "max")),
              onChange: t[9] || (t[9] = e=>ce(0, "max"))
            }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"]), ja(Vt(gT), {
              "datetime-role": "end",
              visible: oe.value,
              format: Vt(M),
              "parsed-value": p.value,
              onPick: fe
            }, null, 8, ["visible", "format", "parsed-value"])], 2)), [[Vt(Rk), ie]])], 2)], 2)) : za("v-if", !0), Ma("div", {
          class: Y([[Vt(y).e("content"), Vt(b).e("content")], "is-left"])
        }, [Ma("div", {
          class: Y(Vt(b).e("header"))
        }, [Ma("button", {
          type: "button",
          class: Y([Vt(y).e("icon-btn"), "d-arrow-left"]),
          "aria-label": Vt(A)("el.datepicker.prevYear"),
          onClick: V
        }, [ja(Vt(sS), null, {
          default: Fn((()=>[ja(Vt(Om))])),
          _: 1
        })], 10, ZR), Ma("button", {
          type: "button",
          class: Y([Vt(y).e("icon-btn"), "arrow-left"]),
          "aria-label": Vt(A)("el.datepicker.prevMonth"),
          onClick: U
        }, [ja(Vt(sS), null, {
          default: Fn((()=>[ja(Vt(vm))])),
          _: 1
        })], 10, eL), e.unlinkPanels ? (Ca(),
          _a("button", {
            key: 0,
            type: "button",
            disabled: !Vt(Q),
            class: Y([[Vt(y).e("icon-btn"), {
              "is-disabled": !Vt(Q)
            }], "d-arrow-right"]),
            "aria-label": Vt(A)("el.datepicker.nextYear"),
            onClick: z
          }, [ja(Vt(sS), null, {
            default: Fn((()=>[ja(Vt(_m))])),
            _: 1
          })], 10, tL)) : za("v-if", !0), e.unlinkPanels ? (Ca(),
          _a("button", {
            key: 1,
            type: "button",
            disabled: !Vt(X),
            class: Y([[Vt(y).e("icon-btn"), {
              "is-disabled": !Vt(X)
            }], "arrow-right"]),
            "aria-label": Vt(A)("el.datepicker.nextMonth"),
            onClick: K
          }, [ja(Vt(sS), null, {
            default: Fn((()=>[ja(Vt(gm))])),
            _: 1
          })], 10, nL)) : za("v-if", !0), Ma("div", null, te(Vt(T)), 1)], 2), ja(kR, {
          "selection-mode": "range",
          date: f.value,
          "min-date": Vt(v),
          "max-date": Vt(g),
          "range-state": Vt(m),
          "disabled-date": Vt(o),
          "cell-class-name": Vt(a),
          onChangerange: Vt(w),
          onPick: ne,
          onSelect: Vt(E)
        }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])], 2), Ma("div", {
          class: Y([[Vt(y).e("content"), Vt(b).e("content")], "is-right"])
        }, [Ma("div", {
          class: Y(Vt(b).e("header"))
        }, [e.unlinkPanels ? (Ca(),
          _a("button", {
            key: 0,
            type: "button",
            disabled: !Vt(Q),
            class: Y([[Vt(y).e("icon-btn"), {
              "is-disabled": !Vt(Q)
            }], "d-arrow-left"]),
            "aria-label": Vt(A)("el.datepicker.prevYear"),
            onClick: W
          }, [ja(Vt(sS), null, {
            default: Fn((()=>[ja(Vt(Om))])),
            _: 1
          })], 10, rL)) : za("v-if", !0), e.unlinkPanels ? (Ca(),
          _a("button", {
            key: 1,
            type: "button",
            disabled: !Vt(X),
            class: Y([[Vt(y).e("icon-btn"), {
              "is-disabled": !Vt(X)
            }], "arrow-left"]),
            "aria-label": Vt(A)("el.datepicker.prevMonth"),
            onClick: G
          }, [ja(Vt(sS), null, {
            default: Fn((()=>[ja(Vt(vm))])),
            _: 1
          })], 10, oL)) : za("v-if", !0), Ma("button", {
          type: "button",
          "aria-label": Vt(A)("el.datepicker.nextYear"),
          class: Y([Vt(y).e("icon-btn"), "d-arrow-right"]),
          onClick: $
        }, [ja(Vt(sS), null, {
          default: Fn((()=>[ja(Vt(_m))])),
          _: 1
        })], 10, aL), Ma("button", {
          type: "button",
          class: Y([Vt(y).e("icon-btn"), "arrow-right"]),
          "aria-label": Vt(A)("el.datepicker.nextMonth"),
          onClick: H
        }, [ja(Vt(sS), null, {
          default: Fn((()=>[ja(Vt(gm))])),
          _: 1
        })], 10, iL), Ma("div", null, te(Vt(D)), 1)], 2), ja(kR, {
          "selection-mode": "range",
          date: p.value,
          "min-date": Vt(v),
          "max-date": Vt(g),
          "range-state": Vt(m),
          "disabled-date": Vt(o),
          "cell-class-name": Vt(a),
          onChangerange: Vt(w),
          onPick: ne,
          onSelect: Vt(E)
        }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])], 2)], 2)], 2), Vt(Z) ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(y).e("footer"))
          }, [Vt(l) ? (Ca(),
            Ra(Vt(WC), {
              key: 0,
              text: "",
              size: "small",
              class: Y(Vt(y).e("link-btn")),
              onClick: pe
            }, {
              default: Fn((()=>[$a(te(Vt(A)("el.datepicker.clear")), 1)])),
              _: 1
            }, 8, ["class"])) : za("v-if", !0), ja(Vt(WC), {
            plain: "",
            size: "small",
            class: Y(Vt(y).e("link-btn")),
            disabled: Vt(J),
            onClick: t[10] || (t[10] = e=>Vt(x)(!1))
          }, {
            default: Fn((()=>[$a(te(Vt(A)("el.datepicker.confirm")), 1)])),
            _: 1
          }, 8, ["class", "disabled"])], 2)) : za("v-if", !0)], 2))
  }
});
var uL = tS(lL, [["__file", "panel-date-range.vue"]]);
const cL = uy({
  ...fR
})
  , dL = ["onClick"]
  , fL = ["disabled"]
  , pL = ["disabled"]
  , hL = "year"
  , vL = vr({
  name: "DatePickerMonthRange"
})
  , gL = vr({
  ...vL,
  props: cL,
  emits: ["pick", "set-picker-option", "calendar-change"],
  setup(e, {emit: t}) {
    const n = e
      , {lang: r} = Hy()
      , o = jo("EP_PICKER_BASE")
      , {shortcuts: a, disabledDate: i, format: s} = o.props
      , l = Yt(o.props, "defaultValue")
      , u = Ft(JC().locale(r.value))
      , c = Ft(JC().locale(r.value).add(1, hL))
      , {minDate: d, maxDate: f, rangeState: p, ppNs: h, drpNs: v, handleChangeRange: g, handleRangeConfirm: m, handleShortcutClick: y, onSelect: b} = QR(n, {
        defaultValue: l,
        leftDate: u,
        rightDate: c,
        unit: hL,
        onParsedValueChanged: function(e, t) {
          if (n.unlinkPanels && t) {
            const n = (null == e ? void 0 : e.year()) || 0
              , r = t.year();
            c.value = n === r ? t.add(1, hL) : t
          } else
            c.value = u.value.add(1, hL)
        }
      })
      , w = yi((()=>!!a.length))
      , {leftPrevYear: x, rightNextYear: S, leftNextYear: E, rightPrevYear: A, leftLabel: C, rightLabel: k, leftYear: T, rightYear: D} = (({unlinkPanels: e, leftDate: t, rightDate: n})=>{
          const {t: r} = Hy();
          return {
            leftPrevYear: ()=>{
              t.value = t.value.subtract(1, "year"),
              e.value || (n.value = n.value.subtract(1, "year"))
            }
            ,
            rightNextYear: ()=>{
              e.value || (t.value = t.value.add(1, "year")),
                n.value = n.value.add(1, "year")
            }
            ,
            leftNextYear: ()=>{
              t.value = t.value.add(1, "year")
            }
            ,
            rightPrevYear: ()=>{
              n.value = n.value.subtract(1, "year")
            }
            ,
            leftLabel: yi((()=>`${t.value.year()} ${r("el.datepicker.year")}`)),
            rightLabel: yi((()=>`${n.value.year()} ${r("el.datepicker.year")}`)),
            leftYear: yi((()=>t.value.year())),
            rightYear: yi((()=>n.value.year() === t.value.year() ? t.value.year() + 1 : n.value.year()))
          }
        }
      )({
        unlinkPanels: Yt(n, "unlinkPanels"),
        leftDate: u,
        rightDate: c
      })
      , O = yi((()=>n.unlinkPanels && D.value > T.value + 1))
      , _ = (e,n=!0)=>{
        const r = e.minDate
          , o = e.maxDate;
        f.value === o && d.value === r || (t("calendar-change", [r.toDate(), o && o.toDate()]),
          f.value = o,
          d.value = r,
        n && m())
      }
    ;
    return t("set-picker-option", ["formatToString", e=>e.map((e=>e.format(s)))]),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y([Vt(h).b(), Vt(v).b(), {
            "has-sidebar": Boolean(e.$slots.sidebar) || Vt(w)
          }])
        }, [Ma("div", {
          class: Y(Vt(h).e("body-wrapper"))
        }, [Qr(e.$slots, "sidebar", {
          class: Y(Vt(h).e("sidebar"))
        }), Vt(w) ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(h).e("sidebar"))
          }, [(Ca(!0),
            _a(ba, null, Yr(Vt(a), ((e,t)=>(Ca(),
              _a("button", {
                key: t,
                type: "button",
                class: Y(Vt(h).e("shortcut")),
                onClick: t=>Vt(y)(e)
              }, te(e.text), 11, dL)))), 128))], 2)) : za("v-if", !0), Ma("div", {
          class: Y(Vt(h).e("body"))
        }, [Ma("div", {
          class: Y([[Vt(h).e("content"), Vt(v).e("content")], "is-left"])
        }, [Ma("div", {
          class: Y(Vt(v).e("header"))
        }, [Ma("button", {
          type: "button",
          class: Y([Vt(h).e("icon-btn"), "d-arrow-left"]),
          onClick: t[0] || (t[0] = (...e)=>Vt(x) && Vt(x)(...e))
        }, [ja(Vt(sS), null, {
          default: Fn((()=>[ja(Vt(Om))])),
          _: 1
        })], 2), e.unlinkPanels ? (Ca(),
          _a("button", {
            key: 0,
            type: "button",
            disabled: !Vt(O),
            class: Y([[Vt(h).e("icon-btn"), {
              [Vt(h).is("disabled")]: !Vt(O)
            }], "d-arrow-right"]),
            onClick: t[1] || (t[1] = (...e)=>Vt(E) && Vt(E)(...e))
          }, [ja(Vt(sS), null, {
            default: Fn((()=>[ja(Vt(_m))])),
            _: 1
          })], 10, fL)) : za("v-if", !0), Ma("div", null, te(Vt(C)), 1)], 2), ja(LR, {
          "selection-mode": "range",
          date: u.value,
          "min-date": Vt(d),
          "max-date": Vt(f),
          "range-state": Vt(p),
          "disabled-date": Vt(i),
          onChangerange: Vt(g),
          onPick: _,
          onSelect: Vt(b)
        }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])], 2), Ma("div", {
          class: Y([[Vt(h).e("content"), Vt(v).e("content")], "is-right"])
        }, [Ma("div", {
          class: Y(Vt(v).e("header"))
        }, [e.unlinkPanels ? (Ca(),
          _a("button", {
            key: 0,
            type: "button",
            disabled: !Vt(O),
            class: Y([[Vt(h).e("icon-btn"), {
              "is-disabled": !Vt(O)
            }], "d-arrow-left"]),
            onClick: t[2] || (t[2] = (...e)=>Vt(A) && Vt(A)(...e))
          }, [ja(Vt(sS), null, {
            default: Fn((()=>[ja(Vt(Om))])),
            _: 1
          })], 10, pL)) : za("v-if", !0), Ma("button", {
          type: "button",
          class: Y([Vt(h).e("icon-btn"), "d-arrow-right"]),
          onClick: t[3] || (t[3] = (...e)=>Vt(S) && Vt(S)(...e))
        }, [ja(Vt(sS), null, {
          default: Fn((()=>[ja(Vt(_m))])),
          _: 1
        })], 2), Ma("div", null, te(Vt(k)), 1)], 2), ja(LR, {
          "selection-mode": "range",
          date: c.value,
          "min-date": Vt(d),
          "max-date": Vt(f),
          "range-state": Vt(p),
          "disabled-date": Vt(i),
          onChangerange: Vt(g),
          onPick: _,
          onSelect: Vt(b)
        }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])], 2)], 2)], 2)], 2))
  }
});
var mL = tS(gL, [["__file", "panel-month-range.vue"]]);
JC.extend(TT),
  JC.extend(q_),
  JC.extend(ek),
  JC.extend(J_),
  JC.extend(eR),
  JC.extend(nR),
  JC.extend(oR),
  JC.extend(iR);
const yL = vr({
  name: "ElDatePicker",
  install: null,
  props: lR,
  emits: ["update:modelValue"],
  setup(e, {expose: t, emit: n, slots: r}) {
    const o = qy("picker-panel");
    Mo("ElPopperOptions", bt(Yt(e, "popperOptions"))),
      Mo(sR, {
        slots: r,
        pickerNs: o
      });
    const a = Ft();
    t({
      focus: (e=!0)=>{
        var t;
        null == (t = a.value) || t.focus(e)
      }
      ,
      handleOpen: ()=>{
        var e;
        null == (e = a.value) || e.handleOpen()
      }
      ,
      handleClose: ()=>{
        var e;
        null == (e = a.value) || e.handleClose()
      }
    });
    const i = e=>{
        n("update:modelValue", e)
      }
    ;
    return ()=>{
      var t;
      const n = null != (t = e.format) ? t : ok[e.type] || rk
        , o = function(e) {
        switch (e) {
          case "daterange":
          case "datetimerange":
            return uL;
          case "monthrange":
            return mL;
          default:
            return YR
        }
      }(e.type);
      return ja(xk, qa(e, {
        format: n,
        type: e.type,
        ref: a,
        "onUpdate:modelValue": i
      }), {
        default: e=>ja(o, e, null),
        "range-separator": r["range-separator"]
      })
    }
  }
});
yL.install = e=>{
  e.component(yL.name, yL)
}
;
const bL = yL
  , wL = Symbol("elDescriptions");
var xL = vr({
  name: "ElDescriptionsCell",
  props: {
    cell: {
      type: Object
    },
    tag: {
      type: String,
      default: "td"
    },
    type: {
      type: String
    }
  },
  setup: ()=>({
    descriptions: jo(wL, {})
  }),
  render() {
    var e, t, n, r, o, a, i;
    const s = (e=>{
        if (!La(e))
          return {};
        const t = e.props || {}
          , n = (La(e.type) ? e.type.props : void 0) || {}
          , r = {};
        return Object.keys(n).forEach((e=>{
            p(n[e], "default") && (r[e] = n[e].default)
          }
        )),
          Object.keys(t).forEach((e=>{
              r[R(e)] = t[e]
            }
          )),
          r
      }
    )(this.cell)
      , l = ((null == (e = this.cell) ? void 0 : e.dirs) || []).map((e=>{
        const {dir: t, arg: n, modifiers: r, value: o} = e;
        return [t, o, n, r]
      }
    ))
      , {border: u, direction: c} = this.descriptions
      , d = "vertical" === c
      , f = (null == (r = null == (n = null == (t = this.cell) ? void 0 : t.children) ? void 0 : n.label) ? void 0 : r.call(n)) || s.label
      , h = null == (i = null == (a = null == (o = this.cell) ? void 0 : o.children) ? void 0 : a.default) ? void 0 : i.call(a)
      , v = s.span
      , g = s.align ? `is-${s.align}` : ""
      , m = s.labelAlign ? `is-${s.labelAlign}` : g
      , y = s.className
      , b = s.labelClassName
      , w = {
      width: om(s.width),
      minWidth: om(s.minWidth)
    }
      , x = qy("descriptions");
    switch (this.type) {
      case "label":
        return rr(bi(this.tag, {
          style: w,
          class: [x.e("cell"), x.e("label"), x.is("bordered-label", u), x.is("vertical-label", d), m, b],
          colSpan: d ? v : 1
        }, f), l);
      case "content":
        return rr(bi(this.tag, {
          style: w,
          class: [x.e("cell"), x.e("content"), x.is("bordered-content", u), x.is("vertical-content", d), g, y],
          colSpan: d ? v : 2 * v - 1
        }, h), l);
      default:
        return rr(bi("td", {
          style: w,
          class: [x.e("cell"), g],
          colSpan: v
        }, [Cg(f) ? void 0 : bi("span", {
          class: [x.e("label"), b]
        }, f), bi("span", {
          class: [x.e("content"), y]
        }, h)]), l)
    }
  }
});
const SL = uy({
  row: {
    type: Array,
    default: ()=>[]
  }
})
  , EL = {
  key: 1
}
  , AL = vr({
  name: "ElDescriptionsRow"
});
var CL = tS(vr({
  ...AL,
  props: SL,
  setup(e) {
    const t = jo(wL, {});
    return (e,n)=>"vertical" === Vt(t).direction ? (Ca(),
      _a(ba, {
        key: 0
      }, [Ma("tr", null, [(Ca(!0),
        _a(ba, null, Yr(e.row, ((e,t)=>(Ca(),
          Ra(Vt(xL), {
            key: `tr1-${t}`,
            cell: e,
            tag: "th",
            type: "label"
          }, null, 8, ["cell"])))), 128))]), Ma("tr", null, [(Ca(!0),
        _a(ba, null, Yr(e.row, ((e,t)=>(Ca(),
          Ra(Vt(xL), {
            key: `tr2-${t}`,
            cell: e,
            tag: "td",
            type: "content"
          }, null, 8, ["cell"])))), 128))])], 64)) : (Ca(),
      _a("tr", EL, [(Ca(!0),
        _a(ba, null, Yr(e.row, ((e,n)=>(Ca(),
          _a(ba, {
            key: `tr3-${n}`
          }, [Vt(t).border ? (Ca(),
            _a(ba, {
              key: 0
            }, [ja(Vt(xL), {
              cell: e,
              tag: "td",
              type: "label"
            }, null, 8, ["cell"]), ja(Vt(xL), {
              cell: e,
              tag: "td",
              type: "content"
            }, null, 8, ["cell"])], 64)) : (Ca(),
            Ra(Vt(xL), {
              key: 1,
              cell: e,
              tag: "td",
              type: "both"
            }, null, 8, ["cell"]))], 64)))), 128))]))
  }
}), [["__file", "descriptions-row.vue"]]);
const kL = uy({
  border: {
    type: Boolean,
    default: !1
  },
  column: {
    type: Number,
    default: 3
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  size: Ux,
  title: {
    type: String,
    default: ""
  },
  extra: {
    type: String,
    default: ""
  }
})
  , TL = vr({
  name: "ElDescriptions"
})
  , DL = vr({
  ...TL,
  props: kL,
  setup(e) {
    const t = e
      , n = qy("descriptions")
      , r = hS()
      , o = po();
    Mo(wL, t);
    const a = yi((()=>[n.b(), n.m(r.value)]))
      , i = (e,t,n,r=!1)=>(e.props || (e.props = {}),
      t > n && (e.props.span = n),
      r && (e.props.span = t),
        e)
      , s = ()=>{
        if (!o.default)
          return [];
        const e = _y(o.default()).filter((e=>{
            var t;
            return "ElDescriptionsItem" === (null == (t = null == e ? void 0 : e.type) ? void 0 : t.name)
          }
        ))
          , n = [];
        let r = []
          , a = t.column
          , s = 0;
        return e.forEach(((o,l)=>{
            var u;
            const c = (null == (u = o.props) ? void 0 : u.span) || 1;
            if (l < e.length - 1 && (s += c > a ? a : c),
            l === e.length - 1) {
              const e = t.column - s % t.column;
              return r.push(i(o, e, a, !0)),
                void n.push(r)
            }
            c < a ? (a -= c,
              r.push(o)) : (r.push(i(o, c, a)),
              n.push(r),
              a = t.column,
              r = [])
          }
        )),
          n
      }
    ;
    return (e,t)=>(Ca(),
      _a("div", {
        class: Y(Vt(a))
      }, [e.title || e.extra || e.$slots.title || e.$slots.extra ? (Ca(),
        _a("div", {
          key: 0,
          class: Y(Vt(n).e("header"))
        }, [Ma("div", {
          class: Y(Vt(n).e("title"))
        }, [Qr(e.$slots, "title", {}, (()=>[$a(te(e.title), 1)]))], 2), Ma("div", {
          class: Y(Vt(n).e("extra"))
        }, [Qr(e.$slots, "extra", {}, (()=>[$a(te(e.extra), 1)]))], 2)], 2)) : za("v-if", !0), Ma("div", {
        class: Y(Vt(n).e("body"))
      }, [Ma("table", {
        class: Y([Vt(n).e("table"), Vt(n).is("bordered", e.border)])
      }, [Ma("tbody", null, [(Ca(!0),
        _a(ba, null, Yr(s(), ((e,t)=>(Ca(),
          Ra(CL, {
            key: t,
            row: e
          }, null, 8, ["row"])))), 128))])], 2)], 2)], 2))
  }
});
var OL = tS(DL, [["__file", "description.vue"]]);
const _L = vr({
  name: "ElDescriptionsItem",
  props: uy({
    label: {
      type: String,
      default: ""
    },
    span: {
      type: Number,
      default: 1
    },
    width: {
      type: [String, Number],
      default: ""
    },
    minWidth: {
      type: [String, Number],
      default: ""
    },
    align: {
      type: String,
      default: "left"
    },
    labelAlign: {
      type: String,
      default: ""
    },
    className: {
      type: String,
      default: ""
    },
    labelClassName: {
      type: String,
      default: ""
    }
  })
})
  , RL = vy(OL, {
  DescriptionsItem: _L
})
  , LL = my(_L)
  , IL = uy({
  mask: {
    type: Boolean,
    default: !0
  },
  customMaskEvent: {
    type: Boolean,
    default: !1
  },
  overlayClass: {
    type: [String, Array, Object]
  },
  zIndex: {
    type: [String, Number]
  }
});
var PL = vr({
  name: "ElOverlay",
  props: IL,
  emits: {
    click: e=>e instanceof MouseEvent
  },
  setup(e, {slots: t, emit: n}) {
    const r = qy("overlay")
      , {onClick: o, onMousedown: a, onMouseup: i} = ww(e.customMaskEvent ? void 0 : e=>{
        n("click", e)
      }
    );
    return ()=>e.mask ? ja("div", {
      class: [r.b(), e.overlayClass],
      style: {
        zIndex: e.zIndex
      },
      onClick: o,
      onMousedown: a,
      onMouseup: i
    }, [Qr(t, "default")], Ty.STYLE | Ty.CLASS | Ty.PROPS, ["onClick", "onMouseup", "onMousedown"]) : bi("div", {
      class: e.overlayClass,
      style: {
        zIndex: e.zIndex,
        position: "fixed",
        top: "0px",
        right: "0px",
        bottom: "0px",
        left: "0px"
      }
    }, [Qr(t, "default")])
  }
});
const FL = PL
  , BL = Symbol("dialogInjectionKey")
  , NL = uy({
  center: Boolean,
  alignCenter: Boolean,
  closeIcon: {
    type: cy
  },
  draggable: Boolean,
  overflow: Boolean,
  fullscreen: Boolean,
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  ariaLevel: {
    type: String,
    default: "2"
  }
})
  , ML = ["aria-level"]
  , jL = ["aria-label"]
  , VL = ["id"]
  , UL = vr({
  name: "ElDialogContent"
})
  , $L = vr({
  ...UL,
  props: NL,
  emits: {
    close: ()=>!0
  },
  setup(e) {
    const t = e
      , {t: n} = Hy()
      , {Close: r} = dy
      , {dialogRef: o, headerRef: a, bodyId: i, ns: s, style: l} = jo(BL)
      , {focusTrapRef: u} = jo(YE)
      , c = yi((()=>[s.b(), s.is("fullscreen", t.fullscreen), s.is("draggable", t.draggable), s.is("align-center", t.alignCenter), {
      [s.m("center")]: t.center
    }]))
      , d = yy(u, o)
      , f = yi((()=>t.draggable))
      , p = yi((()=>t.overflow));
    return My(o, a, f, p),
      (e,t)=>(Ca(),
        _a("div", {
          ref: Vt(d),
          class: Y(Vt(c)),
          style: z(Vt(l)),
          tabindex: "-1"
        }, [Ma("header", {
          ref_key: "headerRef",
          ref: a,
          class: Y([Vt(s).e("header"), {
            "show-close": e.showClose
          }])
        }, [Qr(e.$slots, "header", {}, (()=>[Ma("span", {
          role: "heading",
          "aria-level": e.ariaLevel,
          class: Y(Vt(s).e("title"))
        }, te(e.title), 11, ML)])), e.showClose ? (Ca(),
          _a("button", {
            key: 0,
            "aria-label": Vt(n)("el.dialog.close"),
            class: Y(Vt(s).e("headerbtn")),
            type: "button",
            onClick: t[0] || (t[0] = t=>e.$emit("close"))
          }, [ja(Vt(sS), {
            class: Y(Vt(s).e("close"))
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(e.closeIcon || Vt(r))))])),
            _: 1
          }, 8, ["class"])], 10, jL)) : za("v-if", !0)], 2), Ma("div", {
          id: Vt(i),
          class: Y(Vt(s).e("body"))
        }, [Qr(e.$slots, "default")], 10, VL), e.$slots.footer ? (Ca(),
          _a("footer", {
            key: 0,
            class: Y(Vt(s).e("footer"))
          }, [Qr(e.$slots, "footer")], 2)) : za("v-if", !0)], 6))
  }
});
var HL = tS($L, [["__file", "dialog-content.vue"]]);
const zL = uy({
  ...NL,
  appendToBody: Boolean,
  appendTo: {
    type: String,
    default: "body"
  },
  beforeClose: {
    type: Function
  },
  destroyOnClose: Boolean,
  closeOnClickModal: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  lockScroll: {
    type: Boolean,
    default: !0
  },
  modal: {
    type: Boolean,
    default: !0
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: Boolean,
  modalClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: {
    type: Boolean,
    default: !1
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
})
  , KL = {
  open: ()=>!0,
  opened: ()=>!0,
  close: ()=>!0,
  closed: ()=>!0,
  [xy]: e=>jg(e),
  openAutoFocus: ()=>!0,
  closeAutoFocus: ()=>!0
}
  , WL = (e,t)=>{
  var n;
  const r = ei().emit
    , {nextZIndex: o} = Bw();
  let a = "";
  const i = Cw()
    , s = Cw()
    , l = Ft(!1)
    , u = Ft(!1)
    , c = Ft(!1)
    , d = Ft(null != (n = e.zIndex) ? n : o());
  let f, p;
  const h = Wx("namespace", zy)
    , v = yi((()=>{
      const t = {}
        , n = `--${h.value}-dialog`;
      return e.fullscreen || (e.top && (t[`${n}-margin-top`] = e.top),
      e.width && (t[`${n}-width`] = om(e.width))),
        t
    }
  ))
    , g = yi((()=>e.alignCenter ? {
    display: "flex"
  } : {}));
  function m() {
    null == p || p(),
    null == f || f(),
      e.openDelay && e.openDelay > 0 ? ({stop: f} = Tc((()=>w()), e.openDelay)) : w()
  }
  function y() {
    null == f || f(),
    null == p || p(),
      e.closeDelay && e.closeDelay > 0 ? ({stop: p} = Tc((()=>x()), e.closeDelay)) : x()
  }
  function b() {
    e.beforeClose ? e.beforeClose((function(e) {
        e || (u.value = !0,
          l.value = !1)
      }
    )) : y()
  }
  function w() {
    mc && (l.value = !0)
  }
  function x() {
    l.value = !1
  }
  return e.lockScroll && Yy(l),
    Jn((()=>e.modelValue), (n=>{
        n ? (u.value = !1,
          m(),
          c.value = !0,
          d.value = kg(e.zIndex) ? o() : d.value++,
          hn((()=>{
              r("open"),
              t.value && (t.value.scrollTop = 0)
            }
          ))) : l.value && y()
      }
    )),
    Jn((()=>e.fullscreen), (e=>{
        t.value && (e ? (a = t.value.style.transform,
          t.value.style.transform = "") : t.value.style.transform = a)
      }
    )),
    Lr((()=>{
        e.modelValue && (l.value = !0,
          c.value = !0,
          m())
      }
    )),
    {
      afterEnter: function() {
        r("opened")
      },
      afterLeave: function() {
        r("closed"),
          r(xy, !1),
        e.destroyOnClose && (c.value = !1)
      },
      beforeLeave: function() {
        r("close")
      },
      handleClose: b,
      onModalClick: function() {
        e.closeOnClickModal && b()
      },
      close: y,
      doClose: x,
      onOpenAutoFocus: function() {
        r("openAutoFocus")
      },
      onCloseAutoFocus: function() {
        r("closeAutoFocus")
      },
      onCloseRequested: function() {
        e.closeOnPressEscape && b()
      },
      onFocusoutPrevented: function(e) {
        var t;
        "pointer" === (null == (t = e.detail) ? void 0 : t.focusReason) && e.preventDefault()
      },
      titleId: i,
      bodyId: s,
      closed: u,
      style: v,
      overlayDialogStyle: g,
      rendered: c,
      visible: l,
      zIndex: d
    }
}
  , GL = ["aria-label", "aria-labelledby", "aria-describedby"]
  , qL = vr({
  name: "ElDialog",
  inheritAttrs: !1
});
const YL = vy(tS(vr({
  ...qL,
  props: zL,
  emits: KL,
  setup(e, {expose: t}) {
    const n = e
      , r = po();
    Ny({
      scope: "el-dialog",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/dialog.html#slots"
    }, yi((()=>!!r.title)));
    const o = qy("dialog")
      , a = Ft()
      , i = Ft()
      , s = Ft()
      , {visible: l, titleId: u, bodyId: c, style: d, overlayDialogStyle: f, rendered: p, zIndex: h, afterEnter: v, afterLeave: g, beforeLeave: m, handleClose: y, onModalClick: b, onOpenAutoFocus: w, onCloseAutoFocus: x, onCloseRequested: S, onFocusoutPrevented: E} = WL(n, a);
    Mo(BL, {
      dialogRef: a,
      headerRef: i,
      bodyId: c,
      ns: o,
      rendered: p,
      style: d
    });
    const A = ww(b)
      , C = yi((()=>n.draggable && !n.fullscreen));
    return t({
      visible: l,
      dialogContentRef: s
    }),
      (e,t)=>(Ca(),
        Ra(ma, {
          to: e.appendTo,
          disabled: "body" === e.appendTo && !e.appendToBody
        }, [ja(es, {
          name: "dialog-fade",
          onAfterEnter: Vt(v),
          onAfterLeave: Vt(g),
          onBeforeLeave: Vt(m),
          persisted: ""
        }, {
          default: Fn((()=>[rr(ja(Vt(FL), {
            "custom-mask-event": "",
            mask: e.modal,
            "overlay-class": e.modalClass,
            "z-index": Vt(h)
          }, {
            default: Fn((()=>[Ma("div", {
              role: "dialog",
              "aria-modal": "true",
              "aria-label": e.title || void 0,
              "aria-labelledby": e.title ? void 0 : Vt(u),
              "aria-describedby": Vt(c),
              class: Y(`${Vt(o).namespace.value}-overlay-dialog`),
              style: z(Vt(f)),
              onClick: t[0] || (t[0] = (...e)=>Vt(A).onClick && Vt(A).onClick(...e)),
              onMousedown: t[1] || (t[1] = (...e)=>Vt(A).onMousedown && Vt(A).onMousedown(...e)),
              onMouseup: t[2] || (t[2] = (...e)=>Vt(A).onMouseup && Vt(A).onMouseup(...e))
            }, [ja(Vt(cA), {
              loop: "",
              trapped: Vt(l),
              "focus-start-el": "container",
              onFocusAfterTrapped: Vt(w),
              onFocusAfterReleased: Vt(x),
              onFocusoutPrevented: Vt(E),
              onReleaseRequested: Vt(S)
            }, {
              default: Fn((()=>[Vt(p) ? (Ca(),
                Ra(HL, qa({
                  key: 0,
                  ref_key: "dialogContentRef",
                  ref: s
                }, e.$attrs, {
                  center: e.center,
                  "align-center": e.alignCenter,
                  "close-icon": e.closeIcon,
                  draggable: Vt(C),
                  overflow: e.overflow,
                  fullscreen: e.fullscreen,
                  "show-close": e.showClose,
                  title: e.title,
                  "aria-level": e.headerAriaLevel,
                  onClose: Vt(y)
                }), Xr({
                  header: Fn((()=>[e.$slots.title ? Qr(e.$slots, "title", {
                    key: 1
                  }) : Qr(e.$slots, "header", {
                    key: 0,
                    close: Vt(y),
                    titleId: Vt(u),
                    titleClass: Vt(o).e("title")
                  })])),
                  default: Fn((()=>[Qr(e.$slots, "default")])),
                  _: 2
                }, [e.$slots.footer ? {
                  name: "footer",
                  fn: Fn((()=>[Qr(e.$slots, "footer")]))
                } : void 0]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : za("v-if", !0)])),
              _: 3
            }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])], 46, GL)])),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index"]), [[$s, Vt(l)]])])),
          _: 3
        }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])], 8, ["to", "disabled"]))
  }
}), [["__file", "dialog.vue"]]))
  , XL = uy({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: String,
    default: "solid"
  }
})
  , QL = vr({
  name: "ElDivider"
});
const JL = vy(tS(vr({
  ...QL,
  props: XL,
  setup(e) {
    const t = e
      , n = qy("divider")
      , r = yi((()=>n.cssVar({
      "border-style": t.borderStyle
    })));
    return (e,t)=>(Ca(),
      _a("div", {
        class: Y([Vt(n).b(), Vt(n).m(e.direction)]),
        style: z(Vt(r)),
        role: "separator"
      }, [e.$slots.default && "vertical" !== e.direction ? (Ca(),
        _a("div", {
          key: 0,
          class: Y([Vt(n).e("text"), Vt(n).is(e.contentPosition)])
        }, [Qr(e.$slots, "default")], 2)) : za("v-if", !0)], 6))
  }
}), [["__file", "divider.vue"]]))
  , ZL = uy({
  ...zL,
  direction: {
    type: String,
    default: "rtl",
    values: ["ltr", "rtl", "ttb", "btt"]
  },
  size: {
    type: [String, Number],
    default: "30%"
  },
  withHeader: {
    type: Boolean,
    default: !0
  },
  modalFade: {
    type: Boolean,
    default: !0
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
})
  , eI = KL
  , tI = ["aria-label", "aria-labelledby", "aria-describedby"]
  , nI = ["id", "aria-level"]
  , rI = ["aria-label"]
  , oI = ["id"]
  , aI = vr({
  name: "ElDrawer",
  inheritAttrs: !1
})
  , iI = vr({
  ...aI,
  props: ZL,
  emits: eI,
  setup(e, {expose: t}) {
    const n = e
      , r = po();
    Ny({
      scope: "el-drawer",
      from: "the title slot",
      replacement: "the header slot",
      version: "3.0.0",
      ref: "https://element-plus.org/en-US/component/drawer.html#slots"
    }, yi((()=>!!r.title)));
    const o = Ft()
      , a = Ft()
      , i = qy("drawer")
      , {t: s} = Hy()
      , {afterEnter: l, afterLeave: u, beforeLeave: c, visible: d, rendered: f, titleId: p, bodyId: h, zIndex: v, onModalClick: g, onOpenAutoFocus: m, onCloseAutoFocus: y, onFocusoutPrevented: b, onCloseRequested: w, handleClose: x} = WL(n, o)
      , S = yi((()=>"rtl" === n.direction || "ltr" === n.direction))
      , E = yi((()=>om(n.size)));
    return t({
      handleClose: x,
      afterEnter: l,
      afterLeave: u
    }),
      (e,t)=>(Ca(),
        Ra(ma, {
          to: "body",
          disabled: !e.appendToBody
        }, [ja(es, {
          name: Vt(i).b("fade"),
          onAfterEnter: Vt(l),
          onAfterLeave: Vt(u),
          onBeforeLeave: Vt(c),
          persisted: ""
        }, {
          default: Fn((()=>[rr(ja(Vt(FL), {
            mask: e.modal,
            "overlay-class": e.modalClass,
            "z-index": Vt(v),
            onClick: Vt(g)
          }, {
            default: Fn((()=>[ja(Vt(cA), {
              loop: "",
              trapped: Vt(d),
              "focus-trap-el": o.value,
              "focus-start-el": a.value,
              onFocusAfterTrapped: Vt(m),
              onFocusAfterReleased: Vt(y),
              onFocusoutPrevented: Vt(b),
              onReleaseRequested: Vt(w)
            }, {
              default: Fn((()=>[Ma("div", qa({
                ref_key: "drawerRef",
                ref: o,
                "aria-modal": "true",
                "aria-label": e.title || void 0,
                "aria-labelledby": e.title ? void 0 : Vt(p),
                "aria-describedby": Vt(h)
              }, e.$attrs, {
                class: [Vt(i).b(), e.direction, Vt(d) && "open"],
                style: Vt(S) ? "width: " + Vt(E) : "height: " + Vt(E),
                role: "dialog",
                onClick: t[1] || (t[1] = js((()=>{}
                ), ["stop"]))
              }), [Ma("span", {
                ref_key: "focusStartRef",
                ref: a,
                class: Y(Vt(i).e("sr-focus")),
                tabindex: "-1"
              }, null, 2), e.withHeader ? (Ca(),
                _a("header", {
                  key: 0,
                  class: Y(Vt(i).e("header"))
                }, [e.$slots.title ? Qr(e.$slots, "title", {
                  key: 1
                }, (()=>[za(" DEPRECATED SLOT ")])) : Qr(e.$slots, "header", {
                  key: 0,
                  close: Vt(x),
                  titleId: Vt(p),
                  titleClass: Vt(i).e("title")
                }, (()=>[e.$slots.title ? za("v-if", !0) : (Ca(),
                  _a("span", {
                    key: 0,
                    id: Vt(p),
                    role: "heading",
                    "aria-level": e.headerAriaLevel,
                    class: Y(Vt(i).e("title"))
                  }, te(e.title), 11, nI))])), e.showClose ? (Ca(),
                  _a("button", {
                    key: 2,
                    "aria-label": Vt(s)("el.drawer.close"),
                    class: Y(Vt(i).e("close-btn")),
                    type: "button",
                    onClick: t[0] || (t[0] = (...e)=>Vt(x) && Vt(x)(...e))
                  }, [ja(Vt(sS), {
                    class: Y(Vt(i).e("close"))
                  }, {
                    default: Fn((()=>[ja(Vt(Dm))])),
                    _: 1
                  }, 8, ["class"])], 10, rI)) : za("v-if", !0)], 2)) : za("v-if", !0), Vt(f) ? (Ca(),
                _a("div", {
                  key: 1,
                  id: Vt(h),
                  class: Y(Vt(i).e("body"))
                }, [Qr(e.$slots, "default")], 10, oI)) : za("v-if", !0), e.$slots.footer ? (Ca(),
                _a("div", {
                  key: 2,
                  class: Y(Vt(i).e("footer"))
                }, [Qr(e.$slots, "footer")], 2)) : za("v-if", !0)], 16, tI)])),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])])),
            _: 3
          }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [[$s, Vt(d)]])])),
          _: 3
        }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])], 8, ["disabled"]))
  }
});
const sI = vy(tS(iI, [["__file", "drawer.vue"]]));
var lI = tS(vr({
  inheritAttrs: !1
}), [["render", function(e, t, n, r, o, a) {
  return Qr(e.$slots, "default")
}
], ["__file", "collection.vue"]]);
var uI = tS(vr({
  name: "ElCollectionItem",
  inheritAttrs: !1
}), [["render", function(e, t, n, r, o, a) {
  return Qr(e.$slots, "default")
}
], ["__file", "collection-item.vue"]]);
const cI = "data-el-collection-item"
  , dI = e=>{
  const t = `El${e}Collection`
    , n = `${t}Item`
    , r = Symbol(t)
    , o = Symbol(n)
    , a = {
    ...lI,
    name: t,
    setup() {
      const e = Ft(null)
        , t = new Map;
      Mo(r, {
        itemMap: t,
        getItems: ()=>{
          const n = Vt(e);
          if (!n)
            return [];
          const r = Array.from(n.querySelectorAll(`[${cI}]`));
          return [...t.values()].sort(((e,t)=>r.indexOf(e.ref) - r.indexOf(t.ref)))
        }
        ,
        collectionRef: e
      })
    }
  }
    , i = {
    ...uI,
    name: n,
    setup(e, {attrs: t}) {
      const n = Ft(null)
        , a = jo(r, void 0);
      Mo(o, {
        collectionItemRef: n
      }),
        Lr((()=>{
            const e = Vt(n);
            e && a.itemMap.set(e, {
              ref: e,
              ...t
            })
          }
        )),
        Fr((()=>{
            const e = Vt(n);
            a.itemMap.delete(e)
          }
        ))
    }
  };
  return {
    COLLECTION_INJECTION_KEY: r,
    COLLECTION_ITEM_INJECTION_KEY: o,
    ElCollection: a,
    ElCollectionItem: i
  }
}
  , fI = uy({
  style: {
    type: [String, Array, Object]
  },
  currentTabId: {
    type: String
  },
  defaultCurrentTabId: String,
  loop: Boolean,
  dir: {
    type: String,
    values: ["ltr", "rtl"],
    default: "ltr"
  },
  orientation: {
    type: String
  },
  onBlur: Function,
  onFocus: Function,
  onMousedown: Function
})
  , {ElCollection: pI, ElCollectionItem: hI, COLLECTION_INJECTION_KEY: vI, COLLECTION_ITEM_INJECTION_KEY: gI} = dI("RovingFocusGroup")
  , mI = Symbol("elRovingFocusGroup")
  , yI = Symbol("elRovingFocusGroupItem")
  , bI = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
}
  , wI = (e,t,n)=>{
  const r = ((e,t)=>{
      if ("rtl" !== t)
        return e;
      switch (e) {
        case by.right:
          return by.left;
        case by.left:
          return by.right;
        default:
          return e
      }
    }
  )(e.key, n);
  if (!("vertical" === t && [by.left, by.right].includes(r) || "horizontal" === t && [by.up, by.down].includes(r)))
    return bI[r]
}
  , xI = e=>{
  const {activeElement: t} = document;
  for (const n of e) {
    if (n === t)
      return;
    if (n.focus(),
    t !== document.activeElement)
      return
  }
}
  , SI = "currentTabIdChange"
  , EI = "rovingFocusGroup.entryFocus"
  , AI = {
  bubbles: !1,
  cancelable: !0
}
  , CI = vr({
  name: "ElRovingFocusGroupImpl",
  inheritAttrs: !1,
  props: fI,
  emits: [SI, "entryFocus"],
  setup(e, {emit: t}) {
    var n;
    const r = Ft(null != (n = e.currentTabId || e.defaultCurrentTabId) ? n : null)
      , o = Ft(!1)
      , a = Ft(!1)
      , i = Ft(null)
      , {getItems: s} = jo(vI, void 0)
      , l = yi((()=>[{
      outline: "none"
    }, e.style]))
      , u = ic((t=>{
        var n;
        null == (n = e.onMousedown) || n.call(e, t)
      }
    ), (()=>{
        a.value = !0
      }
    ))
      , c = ic((t=>{
        var n;
        null == (n = e.onFocus) || n.call(e, t)
      }
    ), (e=>{
        const t = !Vt(a)
          , {target: n, currentTarget: i} = e;
        if (n === i && t && !Vt(o)) {
          const e = new Event(EI,AI);
          if (null == i || i.dispatchEvent(e),
            !e.defaultPrevented) {
            const e = s().filter((e=>e.focusable))
              , t = [e.find((e=>e.active)), e.find((e=>e.id === Vt(r))), ...e].filter(Boolean).map((e=>e.ref));
            xI(t)
          }
        }
        a.value = !1
      }
    ))
      , d = ic((t=>{
        var n;
        null == (n = e.onBlur) || n.call(e, t)
      }
    ), (()=>{
        o.value = !1
      }
    ));
    Mo(mI, {
      currentTabbedId: xt(r),
      loop: Yt(e, "loop"),
      tabIndex: yi((()=>Vt(o) ? -1 : 0)),
      rovingFocusGroupRef: i,
      rovingFocusGroupRootStyle: l,
      orientation: Yt(e, "orientation"),
      dir: Yt(e, "dir"),
      onItemFocus: e=>{
        t(SI, e)
      }
      ,
      onItemShiftTab: ()=>{
        o.value = !0
      }
      ,
      onBlur: d,
      onFocus: c,
      onMousedown: u
    }),
      Jn((()=>e.currentTabId), (e=>{
          r.value = null != e ? e : null
        }
      )),
      Rc(i, EI, ((...e)=>{
          t("entryFocus", ...e)
        }
      ))
  }
});
var kI = tS(vr({
  name: "ElRovingFocusGroup",
  components: {
    ElFocusGroupCollection: pI,
    ElRovingFocusGroupImpl: tS(CI, [["render", function(e, t, n, r, o, a) {
      return Qr(e.$slots, "default")
    }
    ], ["__file", "roving-focus-group-impl.vue"]])
  }
}), [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-roving-focus-group-impl")
    , s = Hr("el-focus-group-collection");
  return Ca(),
    Ra(s, null, {
      default: Fn((()=>[ja(i, X(Va(e.$attrs)), {
        default: Fn((()=>[Qr(e.$slots, "default")])),
        _: 3
      }, 16)])),
      _: 3
    })
}
], ["__file", "roving-focus-group.vue"]]);
const TI = vr({
  components: {
    ElRovingFocusCollectionItem: hI
  },
  props: {
    focusable: {
      type: Boolean,
      default: !0
    },
    active: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["mousedown", "focus", "keydown"],
  setup(e, {emit: t}) {
    const {currentTabbedId: n, loop: r, onItemFocus: o, onItemShiftTab: a} = jo(mI, void 0)
      , {getItems: i} = jo(vI, void 0)
      , s = Cw()
      , l = Ft(null)
      , u = ic((e=>{
        t("mousedown", e)
      }
    ), (t=>{
        e.focusable ? o(Vt(s)) : t.preventDefault()
      }
    ))
      , c = ic((e=>{
        t("focus", e)
      }
    ), (()=>{
        o(Vt(s))
      }
    ))
      , d = ic((e=>{
        t("keydown", e)
      }
    ), (e=>{
        const {key: t, shiftKey: n, target: o, currentTarget: s} = e;
        if (t === by.tab && n)
          return void a();
        if (o !== s)
          return;
        const l = wI(e);
        if (l) {
          e.preventDefault();
          let t = i().filter((e=>e.focusable)).map((e=>e.ref));
          switch (l) {
            case "last":
              t.reverse();
              break;
            case "prev":
            case "next":
            {
              "prev" === l && t.reverse();
              const e = t.indexOf(s);
              t = r.value ? (c = e + 1,
                (u = t).map(((e,t)=>u[(t + c) % u.length]))) : t.slice(e + 1);
              break
            }
          }
          hn((()=>{
              xI(t)
            }
          ))
        }
        var u, c
      }
    ))
      , f = yi((()=>n.value === Vt(s)));
    return Mo(yI, {
      rovingFocusGroupItemRef: l,
      tabIndex: yi((()=>Vt(f) ? 0 : -1)),
      handleMousedown: u,
      handleFocus: c,
      handleKeydown: d
    }),
      {
        id: s,
        handleKeydown: d,
        handleFocus: c,
        handleMousedown: u
      }
  }
});
var DI = tS(TI, [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-roving-focus-collection-item");
  return Ca(),
    Ra(i, {
      id: e.id,
      focusable: e.focusable,
      active: e.active
    }, {
      default: Fn((()=>[Qr(e.$slots, "default")])),
      _: 3
    }, 8, ["id", "focusable", "active"])
}
], ["__file", "roving-focus-item.vue"]]);
const OI = uy({
  trigger: EA.trigger,
  effect: {
    ...SA.effect,
    default: "light"
  },
  type: {
    type: String
  },
  placement: {
    type: String,
    default: "bottom"
  },
  popperOptions: {
    type: Object,
    default: ()=>({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: !0
  },
  loop: {
    type: Boolean,
    default: !0
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: [Number, String],
    default: 0
  },
  maxHeight: {
    type: [Number, String],
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  role: {
    type: String,
    default: "menu"
  },
  buttonProps: {
    type: Object
  },
  teleported: SA.teleported
})
  , _I = uy({
  command: {
    type: [Object, String, Number],
    default: ()=>({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: cy
  }
})
  , RI = uy({
  onKeydown: {
    type: Function
  }
})
  , LI = [by.down, by.pageDown, by.home]
  , II = [by.up, by.pageUp, by.end]
  , PI = [...LI, ...II]
  , {ElCollection: FI, ElCollectionItem: BI, COLLECTION_INJECTION_KEY: NI, COLLECTION_ITEM_INJECTION_KEY: MI} = dI("Dropdown")
  , jI = Symbol("elDropdown")
  , {ButtonGroup: VI} = WC
  , UI = vr({
  name: "ElDropdown",
  components: {
    ElButton: WC,
    ElButtonGroup: VI,
    ElScrollbar: DE,
    ElDropdownCollection: FI,
    ElTooltip: MA,
    ElRovingFocusGroup: kI,
    ElOnlyChild: NE,
    ElIcon: sS,
    ArrowDown: hm
  },
  props: OI,
  emits: ["visible-change", "click", "command"],
  setup(e, {emit: t}) {
    const n = ei()
      , r = qy("dropdown")
      , {t: o} = Hy()
      , a = Ft()
      , i = Ft()
      , s = Ft(null)
      , l = Ft(null)
      , u = Ft(null)
      , c = Ft(null)
      , d = Ft(!1)
      , f = [by.enter, by.space, by.down]
      , p = yi((()=>({
      maxHeight: om(e.maxHeight)
    })))
      , h = yi((()=>[r.m(b.value)]))
      , v = yi((()=>Gp(e.trigger)))
      , g = Cw().value
      , m = yi((()=>e.id || g));
    function y() {
      var e;
      null == (e = s.value) || e.onClose()
    }
    Jn([a, v], (([e,t],[n])=>{
        var r, o, a;
        (null == (r = null == n ? void 0 : n.$el) ? void 0 : r.removeEventListener) && n.$el.removeEventListener("pointerenter", w),
        (null == (o = null == e ? void 0 : e.$el) ? void 0 : o.removeEventListener) && e.$el.removeEventListener("pointerenter", w),
        (null == (a = null == e ? void 0 : e.$el) ? void 0 : a.addEventListener) && t.includes("hover") && e.$el.addEventListener("pointerenter", w)
      }
    ), {
      immediate: !0
    }),
      Fr((()=>{
          var e, t;
          (null == (t = null == (e = a.value) ? void 0 : e.$el) ? void 0 : t.removeEventListener) && a.value.$el.removeEventListener("pointerenter", w)
        }
      ));
    const b = hS();
    function w() {
      var e, t;
      null == (t = null == (e = a.value) ? void 0 : e.$el) || t.focus()
    }
    Mo(jI, {
      contentRef: l,
      role: yi((()=>e.role)),
      triggerId: m,
      isUsingKeyboard: d,
      onItemEnter: function() {},
      onItemLeave: function() {
        const e = Vt(l);
        v.value.includes("hover") && (null == e || e.focus()),
          c.value = null
      }
    }),
      Mo("elDropdown", {
        instance: n,
        dropdownSize: b,
        handleClick: function() {
          y()
        },
        commandHandler: function(...e) {
          t("command", ...e)
        },
        trigger: Yt(e, "trigger"),
        hideOnClick: Yt(e, "hideOnClick")
      });
    return {
      t: o,
      ns: r,
      scrollbar: u,
      wrapStyle: p,
      dropdownTriggerKls: h,
      dropdownSize: b,
      triggerId: m,
      triggerKeys: f,
      currentTabId: c,
      handleCurrentTabIdChange: function(e) {
        c.value = e
      },
      handlerMainButtonClick: e=>{
        t("click", e)
      }
      ,
      handleEntryFocus: function(e) {
        d.value || (e.preventDefault(),
          e.stopImmediatePropagation())
      },
      handleClose: y,
      handleOpen: function() {
        var e;
        null == (e = s.value) || e.onOpen()
      },
      handleBeforeShowTooltip: function() {
        t("visible-change", !0)
      },
      handleShowTooltip: function(e) {
        "keydown" === (null == e ? void 0 : e.type) && l.value.focus()
      },
      handleBeforeHideTooltip: function() {
        t("visible-change", !1)
      },
      onFocusAfterTrapped: e=>{
        var t, n;
        e.preventDefault(),
        null == (n = null == (t = l.value) ? void 0 : t.focus) || n.call(t, {
          preventScroll: !0
        })
      }
      ,
      popperRef: s,
      contentRef: l,
      triggeringElementRef: a,
      referenceElementRef: i
    }
  }
});
var $I = tS(UI, [["render", function(e, t, n, r, o, a) {
  var i;
  const s = Hr("el-dropdown-collection")
    , l = Hr("el-roving-focus-group")
    , u = Hr("el-scrollbar")
    , c = Hr("el-only-child")
    , d = Hr("el-tooltip")
    , f = Hr("el-button")
    , p = Hr("arrow-down")
    , h = Hr("el-icon")
    , v = Hr("el-button-group");
  return Ca(),
    _a("div", {
      class: Y([e.ns.b(), e.ns.is("disabled", e.disabled)])
    }, [ja(d, {
      ref: "popperRef",
      role: e.role,
      effect: e.effect,
      "fallback-placements": ["bottom", "top"],
      "popper-options": e.popperOptions,
      "gpu-acceleration": !1,
      "hide-after": "hover" === e.trigger ? e.hideTimeout : 0,
      "manual-mode": !0,
      placement: e.placement,
      "popper-class": [e.ns.e("popper"), e.popperClass],
      "reference-element": null == (i = e.referenceElementRef) ? void 0 : i.$el,
      trigger: e.trigger,
      "trigger-keys": e.triggerKeys,
      "trigger-target-el": e.contentRef,
      "show-after": "hover" === e.trigger ? e.showTimeout : 0,
      "stop-popper-mouse-event": !1,
      "virtual-ref": e.triggeringElementRef,
      "virtual-triggering": e.splitButton,
      disabled: e.disabled,
      transition: `${e.ns.namespace.value}-zoom-in-top`,
      teleported: e.teleported,
      pure: "",
      persistent: "",
      onBeforeShow: e.handleBeforeShowTooltip,
      onShow: e.handleShowTooltip,
      onBeforeHide: e.handleBeforeHideTooltip
    }, Xr({
      content: Fn((()=>[ja(u, {
        ref: "scrollbar",
        "wrap-style": e.wrapStyle,
        tag: "div",
        "view-class": e.ns.e("list")
      }, {
        default: Fn((()=>[ja(l, {
          loop: e.loop,
          "current-tab-id": e.currentTabId,
          orientation: "horizontal",
          onCurrentTabIdChange: e.handleCurrentTabIdChange,
          onEntryFocus: e.handleEntryFocus
        }, {
          default: Fn((()=>[ja(s, null, {
            default: Fn((()=>[Qr(e.$slots, "dropdown")])),
            _: 3
          })])),
          _: 3
        }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])])),
        _: 3
      }, 8, ["wrap-style", "view-class"])])),
      _: 2
    }, [e.splitButton ? void 0 : {
      name: "default",
      fn: Fn((()=>[ja(c, {
        id: e.triggerId,
        ref: "triggeringElementRef",
        role: "button",
        tabindex: e.tabindex
      }, {
        default: Fn((()=>[Qr(e.$slots, "default")])),
        _: 3
      }, 8, ["id", "tabindex"])]))
    }]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]), e.splitButton ? (Ca(),
      Ra(v, {
        key: 0
      }, {
        default: Fn((()=>[ja(f, qa({
          ref: "referenceElementRef"
        }, e.buttonProps, {
          size: e.dropdownSize,
          type: e.type,
          disabled: e.disabled,
          tabindex: e.tabindex,
          onClick: e.handlerMainButtonClick
        }), {
          default: Fn((()=>[Qr(e.$slots, "default")])),
          _: 3
        }, 16, ["size", "type", "disabled", "tabindex", "onClick"]), ja(f, qa({
          id: e.triggerId,
          ref: "triggeringElementRef"
        }, e.buttonProps, {
          role: "button",
          size: e.dropdownSize,
          type: e.type,
          class: e.ns.e("caret-button"),
          disabled: e.disabled,
          tabindex: e.tabindex,
          "aria-label": e.t("el.dropdown.toggleDropdown")
        }), {
          default: Fn((()=>[ja(h, {
            class: Y(e.ns.e("icon"))
          }, {
            default: Fn((()=>[ja(p)])),
            _: 1
          }, 8, ["class"])])),
          _: 1
        }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])])),
        _: 3
      })) : za("v-if", !0)], 2)
}
], ["__file", "dropdown.vue"]]);
const HI = vr({
  name: "DropdownItemImpl",
  components: {
    ElIcon: sS
  },
  props: _I,
  emits: ["pointermove", "pointerleave", "click", "clickimpl"],
  setup(e, {emit: t}) {
    const n = qy("dropdown")
      , {role: r} = jo(jI, void 0)
      , {collectionItemRef: o} = jo(MI, void 0)
      , {collectionItemRef: a} = jo(gI, void 0)
      , {rovingFocusGroupItemRef: i, tabIndex: s, handleFocus: l, handleKeydown: u, handleMousedown: c} = jo(yI, void 0)
      , d = yy(o, a, i)
      , f = yi((()=>"menu" === r.value ? "menuitem" : "navigation" === r.value ? "link" : "button"))
      , p = ic((e=>{
        const {code: n} = e;
        if (n === by.enter || n === by.space)
          return e.preventDefault(),
            e.stopImmediatePropagation(),
            t("clickimpl", e),
            !0
      }
    ), u);
    return {
      ns: n,
      itemRef: d,
      dataset: {
        [cI]: ""
      },
      role: f,
      tabIndex: s,
      handleFocus: l,
      handleKeydown: p,
      handleMousedown: c
    }
  }
})
  , zI = ["aria-disabled", "tabindex", "role"];
var KI = tS(HI, [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-icon");
  return Ca(),
    _a(ba, null, [e.divided ? (Ca(),
      _a("li", qa({
        key: 0,
        role: "separator",
        class: e.ns.bem("menu", "item", "divided")
      }, e.$attrs), null, 16)) : za("v-if", !0), Ma("li", qa({
      ref: e.itemRef
    }, {
      ...e.dataset,
      ...e.$attrs
    }, {
      "aria-disabled": e.disabled,
      class: [e.ns.be("menu", "item"), e.ns.is("disabled", e.disabled)],
      tabindex: e.tabIndex,
      role: e.role,
      onClick: t[0] || (t[0] = t=>e.$emit("clickimpl", t)),
      onFocus: t[1] || (t[1] = (...t)=>e.handleFocus && e.handleFocus(...t)),
      onKeydown: t[2] || (t[2] = js(((...t)=>e.handleKeydown && e.handleKeydown(...t)), ["self"])),
      onMousedown: t[3] || (t[3] = (...t)=>e.handleMousedown && e.handleMousedown(...t)),
      onPointermove: t[4] || (t[4] = t=>e.$emit("pointermove", t)),
      onPointerleave: t[5] || (t[5] = t=>e.$emit("pointerleave", t))
    }), [e.icon ? (Ca(),
      Ra(i, {
        key: 0
      }, {
        default: Fn((()=>[(Ca(),
          Ra(Kr(e.icon)))])),
        _: 1
      })) : za("v-if", !0), Qr(e.$slots, "default")], 16, zI)], 64)
}
], ["__file", "dropdown-item-impl.vue"]]);
const WI = ()=>{
  const e = jo("elDropdown", {})
    , t = yi((()=>null == e ? void 0 : e.dropdownSize));
  return {
    elDropdown: e,
    _elDropdownSize: t
  }
}
  , GI = vr({
  name: "ElDropdownItem",
  components: {
    ElDropdownCollectionItem: BI,
    ElRovingFocusItem: DI,
    ElDropdownItemImpl: KI
  },
  inheritAttrs: !1,
  props: _I,
  emits: ["pointermove", "pointerleave", "click"],
  setup(e, {emit: t, attrs: n}) {
    const {elDropdown: r} = WI()
      , o = ei()
      , a = Ft(null)
      , i = yi((()=>{
        var e, t;
        return null != (t = null == (e = Vt(a)) ? void 0 : e.textContent) ? t : ""
      }
    ))
      , {onItemEnter: s, onItemLeave: l} = jo(jI, void 0)
      , u = ic((e=>(t("pointermove", e),
      e.defaultPrevented)), sc((t=>{
        if (e.disabled)
          return void l(t);
        const n = t.currentTarget;
        n === document.activeElement || n.contains(document.activeElement) || (s(t),
        t.defaultPrevented || null == n || n.focus())
      }
    )))
      , c = ic((e=>(t("pointerleave", e),
      e.defaultPrevented)), sc((e=>{
        l(e)
      }
    )))
      , d = ic((n=>{
        if (!e.disabled)
          return t("click", n),
          "keydown" !== n.type && n.defaultPrevented
      }
    ), (t=>{
        var n, a, i;
        e.disabled ? t.stopImmediatePropagation() : ((null == (n = null == r ? void 0 : r.hideOnClick) ? void 0 : n.value) && (null == (a = r.handleClick) || a.call(r)),
        null == (i = r.commandHandler) || i.call(r, e.command, o, t))
      }
    ));
    return {
      handleClick: d,
      handlePointerMove: u,
      handlePointerLeave: c,
      textContent: i,
      propsAndAttrs: yi((()=>({
        ...e,
        ...n
      })))
    }
  }
});
var qI = tS(GI, [["render", function(e, t, n, r, o, a) {
  var i;
  const s = Hr("el-dropdown-item-impl")
    , l = Hr("el-roving-focus-item")
    , u = Hr("el-dropdown-collection-item");
  return Ca(),
    Ra(u, {
      disabled: e.disabled,
      "text-value": null != (i = e.textValue) ? i : e.textContent
    }, {
      default: Fn((()=>[ja(l, {
        focusable: !e.disabled
      }, {
        default: Fn((()=>[ja(s, qa(e.propsAndAttrs, {
          onPointerleave: e.handlePointerLeave,
          onPointermove: e.handlePointerMove,
          onClickimpl: e.handleClick
        }), {
          default: Fn((()=>[Qr(e.$slots, "default")])),
          _: 3
        }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])])),
        _: 3
      }, 8, ["focusable"])])),
      _: 3
    }, 8, ["disabled", "text-value"])
}
], ["__file", "dropdown-item.vue"]]);
const YI = vr({
  name: "ElDropdownMenu",
  props: RI,
  setup(e) {
    const t = qy("dropdown")
      , {_elDropdownSize: n} = WI()
      , r = n.value
      , {focusTrapRef: o, onKeydown: a} = jo(YE, void 0)
      , {contentRef: i, role: s, triggerId: l} = jo(jI, void 0)
      , {collectionRef: u, getItems: c} = jo(NI, void 0)
      , {rovingFocusGroupRef: d, rovingFocusGroupRootStyle: f, tabIndex: p, onBlur: h, onFocus: v, onMousedown: g} = jo(mI, void 0)
      , {collectionRef: m} = jo(vI, void 0)
      , y = yi((()=>[t.b("menu"), t.bm("menu", null == r ? void 0 : r.value)]))
      , b = yy(i, u, o, d, m)
      , w = ic((t=>{
        var n;
        null == (n = e.onKeydown) || n.call(e, t)
      }
    ), (e=>{
        const {currentTarget: t, code: n, target: r} = e;
        if (t.contains(r),
        by.tab === n && e.stopImmediatePropagation(),
          e.preventDefault(),
        r !== Vt(i))
          return;
        if (!PI.includes(n))
          return;
        const o = c().filter((e=>!e.disabled)).map((e=>e.ref));
        II.includes(n) && o.reverse(),
          xI(o)
      }
    ));
    return {
      size: r,
      rovingFocusGroupRootStyle: f,
      tabIndex: p,
      dropdownKls: y,
      role: s,
      triggerId: l,
      dropdownListWrapperRef: b,
      handleKeydown: e=>{
        w(e),
          a(e)
      }
      ,
      onBlur: h,
      onFocus: v,
      onMousedown: g
    }
  }
})
  , XI = ["role", "aria-labelledby"];
var QI = tS(YI, [["render", function(e, t, n, r, o, a) {
  return Ca(),
    _a("ul", {
      ref: e.dropdownListWrapperRef,
      class: Y(e.dropdownKls),
      style: z(e.rovingFocusGroupRootStyle),
      tabindex: -1,
      role: e.role,
      "aria-labelledby": e.triggerId,
      onBlur: t[0] || (t[0] = (...t)=>e.onBlur && e.onBlur(...t)),
      onFocus: t[1] || (t[1] = (...t)=>e.onFocus && e.onFocus(...t)),
      onKeydown: t[2] || (t[2] = js(((...t)=>e.handleKeydown && e.handleKeydown(...t)), ["self"])),
      onMousedown: t[3] || (t[3] = js(((...t)=>e.onMousedown && e.onMousedown(...t)), ["self"]))
    }, [Qr(e.$slots, "default")], 46, XI)
}
], ["__file", "dropdown-menu.vue"]]);
const JI = vy($I, {
  DropdownItem: qI,
  DropdownMenu: QI
})
  , ZI = my(qI)
  , eP = my(QI)
  , tP = {
  viewBox: "0 0 79 86",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
}
  , nP = ["id"]
  , rP = ["stop-color"]
  , oP = ["stop-color"]
  , aP = ["id"]
  , iP = ["stop-color"]
  , sP = ["stop-color"]
  , lP = ["id"]
  , uP = {
  id: "Illustrations",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}
  , cP = {
  id: "B-type",
  transform: "translate(-1268.000000, -535.000000)"
}
  , dP = {
  id: "Group-2",
  transform: "translate(1268.000000, 535.000000)"
}
  , fP = ["fill"]
  , pP = ["fill"]
  , hP = {
  id: "Group-Copy",
  transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
}
  , vP = ["fill"]
  , gP = ["fill"]
  , mP = ["fill"]
  , yP = ["fill"]
  , bP = ["fill"]
  , wP = {
  id: "Rectangle-Copy-17",
  transform: "translate(53.000000, 45.000000)"
}
  , xP = ["fill", "xlink:href"]
  , SP = ["fill", "mask"]
  , EP = ["fill"]
  , AP = vr({
  name: "ImgEmpty"
});
var CP = tS(vr({
  ...AP,
  setup(e) {
    const t = qy("empty")
      , n = Cw();
    return (e,r)=>(Ca(),
      _a("svg", tP, [Ma("defs", null, [Ma("linearGradient", {
        id: `linearGradient-1-${Vt(n)}`,
        x1: "38.8503086%",
        y1: "0%",
        x2: "61.1496914%",
        y2: "100%"
      }, [Ma("stop", {
        "stop-color": `var(${Vt(t).cssVarBlockName("fill-color-1")})`,
        offset: "0%"
      }, null, 8, rP), Ma("stop", {
        "stop-color": `var(${Vt(t).cssVarBlockName("fill-color-4")})`,
        offset: "100%"
      }, null, 8, oP)], 8, nP), Ma("linearGradient", {
        id: `linearGradient-2-${Vt(n)}`,
        x1: "0%",
        y1: "9.5%",
        x2: "100%",
        y2: "90.5%"
      }, [Ma("stop", {
        "stop-color": `var(${Vt(t).cssVarBlockName("fill-color-1")})`,
        offset: "0%"
      }, null, 8, iP), Ma("stop", {
        "stop-color": `var(${Vt(t).cssVarBlockName("fill-color-6")})`,
        offset: "100%"
      }, null, 8, sP)], 8, aP), Ma("rect", {
        id: `path-3-${Vt(n)}`,
        x: "0",
        y: "0",
        width: "17",
        height: "36"
      }, null, 8, lP)]), Ma("g", uP, [Ma("g", cP, [Ma("g", dP, [Ma("path", {
        id: "Oval-Copy-2",
        d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
        fill: `var(${Vt(t).cssVarBlockName("fill-color-3")})`
      }, null, 8, fP), Ma("polygon", {
        id: "Rectangle-Copy-14",
        fill: `var(${Vt(t).cssVarBlockName("fill-color-7")})`,
        transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
        points: "13 58 53 58 42 45 2 45"
      }, null, 8, pP), Ma("g", hP, [Ma("polygon", {
        id: "Rectangle-Copy-10",
        fill: `var(${Vt(t).cssVarBlockName("fill-color-7")})`,
        transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
        points: "2.84078316e-14 3 18 3 23 7 5 7"
      }, null, 8, vP), Ma("polygon", {
        id: "Rectangle-Copy-11",
        fill: `var(${Vt(t).cssVarBlockName("fill-color-5")})`,
        points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
      }, null, 8, gP), Ma("rect", {
        id: "Rectangle-Copy-12",
        fill: `url(#linearGradient-1-${Vt(n)})`,
        transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
        x: "38",
        y: "7",
        width: "17",
        height: "36"
      }, null, 8, mP), Ma("polygon", {
        id: "Rectangle-Copy-13",
        fill: `var(${Vt(t).cssVarBlockName("fill-color-2")})`,
        transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
        points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
      }, null, 8, yP)]), Ma("rect", {
        id: "Rectangle-Copy-15",
        fill: `url(#linearGradient-2-${Vt(n)})`,
        x: "13",
        y: "45",
        width: "40",
        height: "36"
      }, null, 8, bP), Ma("g", wP, [Ma("use", {
        id: "Mask",
        fill: `var(${Vt(t).cssVarBlockName("fill-color-8")})`,
        transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
        "xlink:href": `#path-3-${Vt(n)}`
      }, null, 8, xP), Ma("polygon", {
        id: "Rectangle-Copy",
        fill: `var(${Vt(t).cssVarBlockName("fill-color-9")})`,
        mask: `url(#mask-4-${Vt(n)})`,
        transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
        points: "7 0 24 0 20 18 7 16.5"
      }, null, 8, SP)]), Ma("polygon", {
        id: "Rectangle-Copy-18",
        fill: `var(${Vt(t).cssVarBlockName("fill-color-2")})`,
        transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
        points: "62 45 79 45 70 58 53 58"
      }, null, 8, EP)])])])]))
  }
}), [["__file", "img-empty.vue"]]);
const kP = uy({
  image: {
    type: String,
    default: ""
  },
  imageSize: Number,
  description: {
    type: String,
    default: ""
  }
})
  , TP = ["src"]
  , DP = {
  key: 1
}
  , OP = vr({
  name: "ElEmpty"
})
  , _P = vr({
  ...OP,
  props: kP,
  setup(e) {
    const t = e
      , {t: n} = Hy()
      , r = qy("empty")
      , o = yi((()=>t.description || n("el.table.emptyText")))
      , a = yi((()=>({
      width: om(t.imageSize)
    })));
    return (e,t)=>(Ca(),
      _a("div", {
        class: Y(Vt(r).b())
      }, [Ma("div", {
        class: Y(Vt(r).e("image")),
        style: z(Vt(a))
      }, [e.image ? (Ca(),
        _a("img", {
          key: 0,
          src: e.image,
          ondragstart: "return false"
        }, null, 8, TP)) : Qr(e.$slots, "image", {
        key: 1
      }, (()=>[ja(CP)]))], 6), Ma("div", {
        class: Y(Vt(r).e("description"))
      }, [e.$slots.description ? Qr(e.$slots, "description", {
        key: 0
      }) : (Ca(),
        _a("p", DP, te(Vt(o)), 1))], 2), e.$slots.default ? (Ca(),
        _a("div", {
          key: 0,
          class: Y(Vt(r).e("bottom"))
        }, [Qr(e.$slots, "default")], 2)) : za("v-if", !0)], 2))
  }
});
const RP = vy(tS(_P, [["__file", "empty.vue"]]))
  , LP = uy({
  urlList: {
    type: Array,
    default: ()=>[]
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  hideOnClickModal: Boolean,
  teleported: Boolean,
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: .2
  },
  maxScale: {
    type: Number,
    default: 7
  },
  crossorigin: {
    type: String
  }
})
  , IP = {
  close: ()=>!0,
  switch: e=>Vg(e),
  rotate: e=>Vg(e)
}
  , PP = ["src", "crossorigin"]
  , FP = vr({
  name: "ElImageViewer"
})
  , BP = vr({
  ...FP,
  props: LP,
  emits: IP,
  setup(e, {expose: t, emit: n}) {
    var r;
    const o = e
      , a = {
      CONTAIN: {
        name: "contain",
        icon: Ot(Fm)
      },
      ORIGINAL: {
        name: "original",
        icon: Ot(Gm)
      }
    }
      , {t: i} = Hy()
      , s = qy("image-viewer")
      , {nextZIndex: l} = Bw()
      , u = Ft()
      , c = Ft([])
      , d = ae()
      , f = Ft(!0)
      , p = Ft(o.initialIndex)
      , h = Bt(a.CONTAIN)
      , v = Ft({
      scale: 1,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: !1
    })
      , g = Ft(null != (r = o.zIndex) ? r : l())
      , m = yi((()=>{
        const {urlList: e} = o;
        return e.length <= 1
      }
    ))
      , y = yi((()=>0 === p.value))
      , b = yi((()=>p.value === o.urlList.length - 1))
      , w = yi((()=>o.urlList[p.value]))
      , x = yi((()=>[s.e("btn"), s.e("prev"), s.is("disabled", !o.infinite && y.value)]))
      , S = yi((()=>[s.e("btn"), s.e("next"), s.is("disabled", !o.infinite && b.value)]))
      , E = yi((()=>{
        const {scale: e, deg: t, offsetX: n, offsetY: r, enableTransition: o} = v.value;
        let i = n / e
          , s = r / e;
        switch (t % 360) {
          case 90:
          case -270:
            [i,s] = [s, -i];
            break;
          case 180:
          case -180:
            [i,s] = [-i, -s];
            break;
          case 270:
          case -90:
            [i,s] = [-s, i]
        }
        const l = {
          transform: `scale(${e}) rotate(${t}deg) translate(${i}px, ${s}px)`,
          transition: o ? "transform .3s" : ""
        };
        return h.value.name === a.CONTAIN.name && (l.maxWidth = l.maxHeight = "100%"),
          l
      }
    ));
    function A() {
      d.stop(),
        n("close")
    }
    function C() {
      f.value = !1
    }
    function k(e) {
      f.value = !1,
        e.target.alt = i("el.image.error")
    }
    function T(e) {
      if (f.value || 0 !== e.button || !u.value)
        return;
      v.value.enableTransition = !1;
      const {offsetX: t, offsetY: n} = v.value
        , r = e.pageX
        , o = e.pageY
        , a = Pg((e=>{
          v.value = {
            ...v.value,
            offsetX: t + e.pageX - r,
            offsetY: n + e.pageY - o
          }
        }
      ))
        , i = Rc(document, "mousemove", a);
      Rc(document, "mouseup", (()=>{
          i()
        }
      )),
        e.preventDefault()
    }
    function D() {
      v.value = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: !1
      }
    }
    function O() {
      if (f.value)
        return;
      const e = Yg(a)
        , t = Object.values(a)
        , n = h.value.name
        , r = t.findIndex((e=>e.name === n))
        , o = (r + 1) % e.length;
      h.value = a[e[o]],
        D()
    }
    function _(e) {
      const t = o.urlList.length;
      p.value = (e + t) % t
    }
    function R() {
      y.value && !o.infinite || _(p.value - 1)
    }
    function L() {
      b.value && !o.infinite || _(p.value + 1)
    }
    function I(e, t={}) {
      if (f.value)
        return;
      const {minScale: r, maxScale: a} = o
        , {zoomRate: i, rotateDeg: s, enableTransition: l} = {
        zoomRate: o.zoomRate,
        rotateDeg: 90,
        enableTransition: !0,
        ...t
      };
      switch (e) {
        case "zoomOut":
          v.value.scale > r && (v.value.scale = Number.parseFloat((v.value.scale / i).toFixed(3)));
          break;
        case "zoomIn":
          v.value.scale < a && (v.value.scale = Number.parseFloat((v.value.scale * i).toFixed(3)));
          break;
        case "clockwise":
          v.value.deg += s,
            n("rotate", v.value.deg);
          break;
        case "anticlockwise":
          v.value.deg -= s,
            n("rotate", v.value.deg)
      }
      v.value.enableTransition = l
    }
    return Jn(w, (()=>{
        hn((()=>{
            const e = c.value[0];
            (null == e ? void 0 : e.complete) || (f.value = !0)
          }
        ))
      }
    )),
      Jn(p, (e=>{
          D(),
            n("switch", e)
        }
      )),
      Lr((()=>{
          var e, t;
          !function() {
            const e = Pg((e=>{
                switch (e.code) {
                  case by.esc:
                    o.closeOnPressEscape && A();
                    break;
                  case by.space:
                    O();
                    break;
                  case by.left:
                    R();
                    break;
                  case by.up:
                    I("zoomIn");
                    break;
                  case by.right:
                    L();
                    break;
                  case by.down:
                    I("zoomOut")
                }
              }
            ))
              , t = Pg((e=>{
                I((e.deltaY || e.deltaX) < 0 ? "zoomIn" : "zoomOut", {
                  zoomRate: o.zoomRate,
                  enableTransition: !1
                })
              }
            ));
            d.run((()=>{
                Rc(document, "keydown", e),
                  Rc(document, "wheel", t)
              }
            ))
          }(),
          null == (t = null == (e = u.value) ? void 0 : e.focus) || t.call(e)
        }
      )),
      t({
        setActiveItem: _
      }),
      (e,t)=>(Ca(),
        Ra(ma, {
          to: "body",
          disabled: !e.teleported
        }, [ja(es, {
          name: "viewer-fade",
          appear: ""
        }, {
          default: Fn((()=>[Ma("div", {
            ref_key: "wrapper",
            ref: u,
            tabindex: -1,
            class: Y(Vt(s).e("wrapper")),
            style: z({
              zIndex: g.value
            })
          }, [Ma("div", {
            class: Y(Vt(s).e("mask")),
            onClick: t[0] || (t[0] = js((t=>e.hideOnClickModal && A()), ["self"]))
          }, null, 2), za(" CLOSE "), Ma("span", {
            class: Y([Vt(s).e("btn"), Vt(s).e("close")]),
            onClick: A
          }, [ja(Vt(sS), null, {
            default: Fn((()=>[ja(Vt(Dm))])),
            _: 1
          })], 2), za(" ARROW "), Vt(m) ? za("v-if", !0) : (Ca(),
            _a(ba, {
              key: 0
            }, [Ma("span", {
              class: Y(Vt(x)),
              onClick: R
            }, [ja(Vt(sS), null, {
              default: Fn((()=>[ja(Vt(vm))])),
              _: 1
            })], 2), Ma("span", {
              class: Y(Vt(S)),
              onClick: L
            }, [ja(Vt(sS), null, {
              default: Fn((()=>[ja(Vt(gm))])),
              _: 1
            })], 2)], 64)), za(" ACTIONS "), Ma("div", {
            class: Y([Vt(s).e("btn"), Vt(s).e("actions")])
          }, [Ma("div", {
            class: Y(Vt(s).e("actions__inner"))
          }, [ja(Vt(sS), {
            onClick: t[1] || (t[1] = e=>I("zoomOut"))
          }, {
            default: Fn((()=>[ja(Vt(iy))])),
            _: 1
          }), ja(Vt(sS), {
            onClick: t[2] || (t[2] = e=>I("zoomIn"))
          }, {
            default: Fn((()=>[ja(Vt(ay))])),
            _: 1
          }), Ma("i", {
            class: Y(Vt(s).e("actions__divider"))
          }, null, 2), ja(Vt(sS), {
            onClick: O
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(Vt(h).icon)))])),
            _: 1
          }), Ma("i", {
            class: Y(Vt(s).e("actions__divider"))
          }, null, 2), ja(Vt(sS), {
            onClick: t[3] || (t[3] = e=>I("anticlockwise"))
          }, {
            default: Fn((()=>[ja(Vt(Km))])),
            _: 1
          }), ja(Vt(sS), {
            onClick: t[4] || (t[4] = e=>I("clockwise"))
          }, {
            default: Fn((()=>[ja(Vt(Wm))])),
            _: 1
          })], 2)], 2), za(" CANVAS "), Ma("div", {
            class: Y(Vt(s).e("canvas"))
          }, [(Ca(!0),
            _a(ba, null, Yr(e.urlList, ((t,n)=>rr((Ca(),
              _a("img", {
                ref_for: !0,
                ref: e=>c.value[n] = e,
                key: t,
                src: t,
                style: z(Vt(E)),
                class: Y(Vt(s).e("img")),
                crossorigin: e.crossorigin,
                onLoad: C,
                onError: k,
                onMousedown: T
              }, null, 46, PP)), [[$s, n === p.value]]))), 128))], 2), Qr(e.$slots, "default")], 6)])),
          _: 3
        })], 8, ["disabled"]))
  }
});
const NP = vy(tS(BP, [["__file", "image-viewer.vue"]]))
  , MP = uy({
  hideOnClickModal: Boolean,
  src: {
    type: String,
    default: ""
  },
  fit: {
    type: String,
    values: ["", "contain", "cover", "fill", "none", "scale-down"],
    default: ""
  },
  loading: {
    type: String,
    values: ["eager", "lazy"]
  },
  lazy: Boolean,
  scrollContainer: {
    type: [String, Object]
  },
  previewSrcList: {
    type: Array,
    default: ()=>[]
  },
  previewTeleported: Boolean,
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  minScale: {
    type: Number,
    default: .2
  },
  maxScale: {
    type: Number,
    default: 7
  },
  crossorigin: {
    type: String
  }
})
  , jP = {
  load: e=>e instanceof Event,
  error: e=>e instanceof Event,
  switch: e=>Vg(e),
  close: ()=>!0,
  show: ()=>!0
}
  , VP = ["src", "loading", "crossorigin"]
  , UP = {
  key: 0
}
  , $P = vr({
  name: "ElImage",
  inheritAttrs: !1
})
  , HP = vr({
  ...$P,
  props: MP,
  emits: jP,
  setup(e, {emit: t}) {
    const n = e;
    let r = "";
    const {t: o} = Hy()
      , a = qy("image")
      , i = ho()
      , s = By()
      , l = Ft()
      , u = Ft(!1)
      , c = Ft(!0)
      , d = Ft(!1)
      , f = Ft()
      , p = Ft()
      , h = mc && "loading"in HTMLImageElement.prototype;
    let v, g;
    const m = yi((()=>[a.e("inner"), x.value && a.e("preview"), c.value && a.is("loading")]))
      , y = yi((()=>i.style))
      , w = yi((()=>{
          const {fit: e} = n;
          return mc && e ? {
            objectFit: e
          } : {}
        }
      ))
      , x = yi((()=>{
          const {previewSrcList: e} = n;
          return Array.isArray(e) && e.length > 0
        }
      ))
      , S = yi((()=>{
          const {previewSrcList: e, initialIndex: t} = n;
          let r = t;
          return t > e.length - 1 && (r = 0),
            r
        }
      ))
      , E = yi((()=>"eager" !== n.loading && (!h && "lazy" === n.loading || n.lazy)))
      , A = ()=>{
        mc && (c.value = !0,
          u.value = !1,
          l.value = n.src)
      }
    ;
    function C(e) {
      c.value = !1,
        u.value = !1,
        t("load", e)
    }
    function k(e) {
      c.value = !1,
        u.value = !0,
        t("error", e)
    }
    function T() {
      ((e,t)=>{
          if (!mc || !e || !t)
            return !1;
          const n = e.getBoundingClientRect();
          let r;
          return r = t instanceof Element ? t.getBoundingClientRect() : {
            top: 0,
            right: window.innerWidth,
            bottom: window.innerHeight,
            left: 0
          },
          n.top < r.bottom && n.bottom > r.top && n.right > r.left && n.left < r.right
        }
      )(f.value, p.value) && (A(),
        _())
    }
    const D = Cc(T, 200, !0);
    async function O() {
      var e;
      if (!mc)
        return;
      await hn();
      const {scrollContainer: t} = n;
      $g(t) ? p.value = t : b(t) && "" !== t ? p.value = null != (e = document.querySelector(t)) ? e : void 0 : f.value && (p.value = im(f.value)),
      p.value && (v = Rc(p, "scroll", D),
        setTimeout((()=>T()), 100))
    }
    function _() {
      mc && p.value && D && (null == v || v(),
        p.value = void 0)
    }
    function R(e) {
      if (e.ctrlKey)
        return e.deltaY < 0 || e.deltaY > 0 ? (e.preventDefault(),
          !1) : void 0
    }
    function L() {
      x.value && (g = Rc("wheel", R, {
        passive: !1
      }),
        r = document.body.style.overflow,
        document.body.style.overflow = "hidden",
        d.value = !0,
        t("show"))
    }
    function I() {
      null == g || g(),
        document.body.style.overflow = r,
        d.value = !1,
        t("close")
    }
    function P(e) {
      t("switch", e)
    }
    return Jn((()=>n.src), (()=>{
        E.value ? (c.value = !0,
          u.value = !1,
          _(),
          O()) : A()
      }
    )),
      Lr((()=>{
          E.value ? O() : A()
        }
      )),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "container",
          ref: f,
          class: Y([Vt(a).b(), e.$attrs.class]),
          style: z(Vt(y))
        }, [u.value ? Qr(e.$slots, "error", {
          key: 0
        }, (()=>[Ma("div", {
          class: Y(Vt(a).e("error"))
        }, te(Vt(o)("el.image.error")), 3)])) : (Ca(),
          _a(ba, {
            key: 1
          }, [void 0 !== l.value ? (Ca(),
            _a("img", qa({
              key: 0
            }, Vt(s), {
              src: l.value,
              loading: e.loading,
              style: Vt(w),
              class: Vt(m),
              crossorigin: e.crossorigin,
              onClick: L,
              onLoad: C,
              onError: k
            }), null, 16, VP)) : za("v-if", !0), c.value ? (Ca(),
            _a("div", {
              key: 1,
              class: Y(Vt(a).e("wrapper"))
            }, [Qr(e.$slots, "placeholder", {}, (()=>[Ma("div", {
              class: Y(Vt(a).e("placeholder"))
            }, null, 2)]))], 2)) : za("v-if", !0)], 64)), Vt(x) ? (Ca(),
          _a(ba, {
            key: 2
          }, [d.value ? (Ca(),
            Ra(Vt(NP), {
              key: 0,
              "z-index": e.zIndex,
              "initial-index": Vt(S),
              infinite: e.infinite,
              "zoom-rate": e.zoomRate,
              "min-scale": e.minScale,
              "max-scale": e.maxScale,
              "url-list": e.previewSrcList,
              "hide-on-click-modal": e.hideOnClickModal,
              teleported: e.previewTeleported,
              "close-on-press-escape": e.closeOnPressEscape,
              onClose: I,
              onSwitch: P
            }, {
              default: Fn((()=>[e.$slots.viewer ? (Ca(),
                _a("div", UP, [Qr(e.$slots, "viewer")])) : za("v-if", !0)])),
              _: 3
            }, 8, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "url-list", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : za("v-if", !0)], 64)) : za("v-if", !0)], 6))
  }
});
const zP = vy(tS(HP, [["__file", "image.vue"]]))
  , KP = uy({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: Number,
  readonly: Boolean,
  disabled: Boolean,
  size: Ux,
  controls: {
    type: Boolean,
    default: !0
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: [String, Number, null],
    validator: e=>null === e || Vg(e) || ["min", "max"].includes(e),
    default: null
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: e=>e >= 0 && e === Number.parseInt(`${e}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
})
  , WP = {
  [Sy]: (e,t)=>t !== e,
  blur: e=>e instanceof FocusEvent,
  focus: e=>e instanceof FocusEvent,
  [Ey]: e=>Vg(e) || Cg(e),
  [xy]: e=>Vg(e) || Cg(e)
}
  , GP = ["aria-label", "onKeydown"]
  , qP = ["aria-label", "onKeydown"]
  , YP = vr({
  name: "ElInputNumber"
})
  , XP = vr({
  ...YP,
  props: KP,
  emits: WP,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , {t: o} = Hy()
      , a = qy("input-number")
      , i = Ft()
      , s = bt({
        currentValue: r.modelValue,
        userInput: null
      })
      , {formItem: l} = gS()
      , u = yi((()=>Vg(r.modelValue) && r.modelValue <= r.min))
      , c = yi((()=>Vg(r.modelValue) && r.modelValue >= r.max))
      , d = yi((()=>{
          const e = m(r.step);
          return Mg(r.precision) ? Math.max(m(r.modelValue), e) : (r.precision,
            r.precision)
        }
      ))
      , f = yi((()=>r.controls && "right" === r.controlsPosition))
      , p = hS()
      , h = vS()
      , v = yi((()=>{
          if (null !== s.userInput)
            return s.userInput;
          let e = s.currentValue;
          if (Cg(e))
            return "";
          if (Vg(e)) {
            if (Number.isNaN(e))
              return "";
            Mg(r.precision) || (e = e.toFixed(r.precision))
          }
          return e
        }
      ))
      , g = (e,t)=>{
        if (Mg(t) && (t = d.value),
        0 === t)
          return Math.round(e);
        let n = String(e);
        const r = n.indexOf(".");
        if (-1 === r)
          return e;
        if (!n.replace(".", "").split("")[r + t])
          return e;
        const o = n.length;
        return "5" === n.charAt(o - 1) && (n = `${n.slice(0, Math.max(0, o - 1))}6`),
          Number.parseFloat(Number(n).toFixed(t))
      }
      , m = e=>{
        if (Cg(e))
          return 0;
        const t = e.toString()
          , n = t.indexOf(".");
        let r = 0;
        return -1 !== n && (r = t.length - n - 1),
          r
      }
      , y = (e,t=1)=>Vg(e) ? g(e + r.step * t) : s.currentValue
      , w = ()=>{
        if (r.readonly || h.value || c.value)
          return;
        const e = Number(v.value) || 0
          , t = y(e);
        E(t),
          n(Ey, s.currentValue),
          D()
      }
      , x = ()=>{
        if (r.readonly || h.value || u.value)
          return;
        const e = Number(v.value) || 0
          , t = y(e, -1);
        E(t),
          n(Ey, s.currentValue),
          D()
      }
      , S = (e,t)=>{
        const {max: o, min: a, step: i, precision: s, stepStrictly: l, valueOnClear: u} = r;
        o < a && Jg("InputNumber", "min should not be greater than max.");
        let c = Number(e);
        if (Cg(e) || Number.isNaN(c))
          return null;
        if ("" === e) {
          if (null === u)
            return null;
          c = b(u) ? {
            min: a,
            max: o
          }[u] : u
        }
        return l && (c = g(Math.round(c / i) * i, s)),
        Mg(s) || (c = g(c, s)),
        (c > o || c < a) && (c = c > o ? o : a,
        t && n(xy, c)),
          c
      }
      , E = (e,t=!0)=>{
        var o;
        const a = s.currentValue
          , i = S(e);
        t ? a === i && e || (s.userInput = null,
          n(xy, i),
        a !== i && n(Sy, i, a),
        r.validateEvent && (null == (o = null == l ? void 0 : l.validate) || o.call(l, "change").catch((e=>{}
        ))),
          s.currentValue = i) : n(xy, i)
      }
      , A = e=>{
        s.userInput = e;
        const t = "" === e ? null : Number(e);
        n(Ey, t),
          E(t, !1)
      }
      , C = e=>{
        const t = "" !== e ? Number(e) : "";
        (Vg(t) && !Number.isNaN(t) || "" === e) && E(t),
          D(),
          s.userInput = null
      }
      , k = e=>{
        n("focus", e)
      }
      , T = e=>{
        var t;
        s.userInput = null,
          n("blur", e),
        r.validateEvent && (null == (t = null == l ? void 0 : l.validate) || t.call(l, "blur").catch((e=>{}
        )))
      }
      , D = ()=>{
        s.currentValue !== r.modelValue && (s.currentValue = r.modelValue)
      }
      , O = e=>{
        document.activeElement === e.target && e.preventDefault()
      }
    ;
    return Jn((()=>r.modelValue), ((e,t)=>{
        const n = S(e, !0);
        null === s.userInput && n !== t && (s.currentValue = n)
      }
    ), {
      immediate: !0
    }),
      Lr((()=>{
          var e;
          const {min: t, max: o, modelValue: a} = r
            , l = null == (e = i.value) ? void 0 : e.input;
          if (l.setAttribute("role", "spinbutton"),
            Number.isFinite(o) ? l.setAttribute("aria-valuemax", String(o)) : l.removeAttribute("aria-valuemax"),
            Number.isFinite(t) ? l.setAttribute("aria-valuemin", String(t)) : l.removeAttribute("aria-valuemin"),
            l.setAttribute("aria-valuenow", s.currentValue || 0 === s.currentValue ? String(s.currentValue) : ""),
            l.setAttribute("aria-disabled", String(h.value)),
          !Vg(a) && null != a) {
            let e = Number(a);
            Number.isNaN(e) && (e = null),
              n(xy, e)
          }
        }
      )),
      Pr((()=>{
          var e, t;
          const n = null == (e = i.value) ? void 0 : e.input;
          null == n || n.setAttribute("aria-valuenow", `${null != (t = s.currentValue) ? t : ""}`)
        }
      )),
      t({
        focus: ()=>{
          var e, t;
          null == (t = null == (e = i.value) ? void 0 : e.focus) || t.call(e)
        }
        ,
        blur: ()=>{
          var e, t;
          null == (t = null == (e = i.value) ? void 0 : e.blur) || t.call(e)
        }
      }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y([Vt(a).b(), Vt(a).m(Vt(p)), Vt(a).is("disabled", Vt(h)), Vt(a).is("without-controls", !e.controls), Vt(a).is("controls-right", Vt(f))]),
          onDragstart: t[0] || (t[0] = js((()=>{}
          ), ["prevent"]))
        }, [e.controls ? rr((Ca(),
          _a("span", {
            key: 0,
            role: "button",
            "aria-label": Vt(o)("el.inputNumber.decrease"),
            class: Y([Vt(a).e("decrease"), Vt(a).is("disabled", Vt(u))]),
            onKeydown: Us(x, ["enter"])
          }, [ja(Vt(sS), null, {
            default: Fn((()=>[Vt(f) ? (Ca(),
              Ra(Vt(hm), {
                key: 0
              })) : (Ca(),
              Ra(Vt(jm), {
                key: 1
              }))])),
            _: 1
          })], 42, GP)), [[Vt(Pk), x]]) : za("v-if", !0), e.controls ? rr((Ca(),
          _a("span", {
            key: 1,
            role: "button",
            "aria-label": Vt(o)("el.inputNumber.increase"),
            class: Y([Vt(a).e("increase"), Vt(a).is("disabled", Vt(c))]),
            onKeydown: Us(w, ["enter"])
          }, [ja(Vt(sS), null, {
            default: Fn((()=>[Vt(f) ? (Ca(),
              Ra(Vt(mm), {
                key: 0
              })) : (Ca(),
              Ra(Vt(Hm), {
                key: 1
              }))])),
            _: 1
          })], 42, qP)), [[Vt(Pk), w]]) : za("v-if", !0), ja(Vt(yE), {
          id: e.id,
          ref_key: "input",
          ref: i,
          type: "number",
          step: e.step,
          "model-value": Vt(v),
          placeholder: e.placeholder,
          readonly: e.readonly,
          disabled: Vt(h),
          size: Vt(p),
          max: e.max,
          min: e.min,
          name: e.name,
          label: e.label,
          "validate-event": !1,
          onWheel: O,
          onKeydown: [Us(js(w, ["prevent"]), ["up"]), Us(js(x, ["prevent"]), ["down"])],
          onBlur: T,
          onFocus: k,
          onInput: A,
          onChange: C
        }, null, 8, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "label", "onKeydown"])], 34))
  }
});
const QP = vy(tS(XP, [["__file", "input-number.vue"]]))
  , JP = uy({
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger", "default"],
    default: "default"
  },
  underline: {
    type: Boolean,
    default: !0
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  href: {
    type: String,
    default: ""
  },
  target: {
    type: String,
    default: "_self"
  },
  icon: {
    type: cy
  }
})
  , ZP = {
  click: e=>e instanceof MouseEvent
}
  , eF = ["href", "target"]
  , tF = vr({
  name: "ElLink"
});
const nF = vy(tS(vr({
  ...tF,
  props: JP,
  emits: ZP,
  setup(e, {emit: t}) {
    const n = e
      , r = qy("link")
      , o = yi((()=>[r.b(), r.m(n.type), r.is("disabled", n.disabled), r.is("underline", n.underline && !n.disabled)]));
    function a(e) {
      n.disabled || t("click", e)
    }
    return (e,t)=>(Ca(),
      _a("a", {
        class: Y(Vt(o)),
        href: e.disabled || !e.href ? void 0 : e.href,
        target: e.disabled || !e.href ? void 0 : e.target,
        onClick: a
      }, [e.icon ? (Ca(),
        Ra(Vt(sS), {
          key: 0
        }, {
          default: Fn((()=>[(Ca(),
            Ra(Kr(e.icon)))])),
          _: 1
        })) : za("v-if", !0), e.$slots.default ? (Ca(),
        _a("span", {
          key: 1,
          class: Y(Vt(r).e("inner"))
        }, [Qr(e.$slots, "default")], 2)) : za("v-if", !0), e.$slots.icon ? Qr(e.$slots, "icon", {
        key: 2
      }) : za("v-if", !0)], 10, eF))
  }
}), [["__file", "link.vue"]]));
var rF = tS(vr({
  name: "ElMenuCollapseTransition",
  setup() {
    const e = qy("menu");
    return {
      listeners: {
        onBeforeEnter: e=>e.style.opacity = "0.2",
        onEnter(t, n) {
          tm(t, `${e.namespace.value}-opacity-transition`),
            t.style.opacity = "1",
            n()
        },
        onAfterEnter(t) {
          nm(t, `${e.namespace.value}-opacity-transition`),
            t.style.opacity = ""
        },
        onBeforeLeave(t) {
          t.dataset || (t.dataset = {}),
            em(t, e.m("collapse")) ? (nm(t, e.m("collapse")),
              t.dataset.oldOverflow = t.style.overflow,
              t.dataset.scrollWidth = t.clientWidth.toString(),
              tm(t, e.m("collapse"))) : (tm(t, e.m("collapse")),
              t.dataset.oldOverflow = t.style.overflow,
              t.dataset.scrollWidth = t.clientWidth.toString(),
              nm(t, e.m("collapse"))),
            t.style.width = `${t.scrollWidth}px`,
            t.style.overflow = "hidden"
        },
        onLeave(e) {
          tm(e, "horizontal-collapse-transition"),
            e.style.width = `${e.dataset.scrollWidth}px`
        }
      }
    }
  }
}), [["render", function(e, t, n, r, o, a) {
  return Ca(),
    Ra(es, qa({
      mode: "out-in"
    }, e.listeners), {
      default: Fn((()=>[Qr(e.$slots, "default")])),
      _: 3
    }, 16)
}
], ["__file", "menu-collapse-transition.vue"]]);
function oF(e, t) {
  const n = yi((()=>{
      let n = e.parent;
      const r = [t.value];
      for (; "ElMenu" !== n.type.name; )
        n.props.index && r.unshift(n.props.index),
          n = n.parent;
      return r
    }
  ));
  return {
    parentMenu: yi((()=>{
        let t = e.parent;
        for (; t && !["ElMenu", "ElSubMenu"].includes(t.type.name); )
          t = t.parent;
        return t
      }
    )),
    indexPath: n
  }
}
function aF(e) {
  return yi((()=>{
      const t = e.backgroundColor;
      return t ? new jC(t).shade(20).toString() : ""
    }
  ))
}
const iF = (e,t)=>{
  const n = qy("menu");
  return yi((()=>n.cssVarBlock({
    "text-color": e.textColor || "",
    "hover-text-color": e.textColor || "",
    "bg-color": e.backgroundColor || "",
    "hover-bg-color": aF(e).value || "",
    "active-color": e.activeTextColor || "",
    level: `${t}`
  })))
}
  , sF = uy({
  index: {
    type: String,
    required: !0
  },
  showTimeout: Number,
  hideTimeout: Number,
  popperClass: String,
  disabled: Boolean,
  teleported: {
    type: Boolean,
    default: void 0
  },
  popperOffset: Number,
  expandCloseIcon: {
    type: cy
  },
  expandOpenIcon: {
    type: cy
  },
  collapseCloseIcon: {
    type: cy
  },
  collapseOpenIcon: {
    type: cy
  }
})
  , lF = "ElSubMenu";
var uF = vr({
  name: lF,
  props: sF,
  setup(e, {slots: t, expose: n}) {
    const r = ei()
      , {indexPath: o, parentMenu: a} = oF(r, yi((()=>e.index)))
      , i = qy("menu")
      , s = qy("sub-menu")
      , l = jo("rootMenu");
    l || Jg(lF, "can not inject root menu");
    const u = jo(`subMenu:${a.value.uid}`);
    u || Jg(lF, "can not inject sub menu");
    const c = Ft({})
      , d = Ft({});
    let f;
    const p = Ft(!1)
      , h = Ft()
      , v = Ft(null)
      , g = yi((()=>"horizontal" === C.value && y.value ? "bottom-start" : "right-start"))
      , m = yi((()=>"horizontal" === C.value && y.value || "vertical" === C.value && !l.props.collapse ? e.expandCloseIcon && e.expandOpenIcon ? E.value ? e.expandOpenIcon : e.expandCloseIcon : hm : e.collapseCloseIcon && e.collapseOpenIcon ? E.value ? e.collapseOpenIcon : e.collapseCloseIcon : gm))
      , y = yi((()=>0 === u.level))
      , w = yi((()=>{
          const t = e.teleported;
          return void 0 === t ? y.value : t
        }
      ))
      , x = yi((()=>l.props.collapse ? `${i.namespace.value}-zoom-in-left` : `${i.namespace.value}-zoom-in-top`))
      , S = yi((()=>"horizontal" === C.value && y.value ? ["bottom-start", "bottom-end", "top-start", "top-end", "right-start", "left-start"] : ["right-start", "right", "right-end", "left-start", "bottom-start", "bottom-end", "top-start", "top-end"]))
      , E = yi((()=>l.openedMenus.includes(e.index)))
      , A = yi((()=>{
          let e = !1;
          return Object.values(c.value).forEach((t=>{
              t.active && (e = !0)
            }
          )),
            Object.values(d.value).forEach((t=>{
                t.active && (e = !0)
              }
            )),
            e
        }
      ))
      , C = yi((()=>l.props.mode))
      , k = bt({
        index: e.index,
        indexPath: o,
        active: A
      })
      , T = iF(l.props, u.level + 1)
      , D = yi((()=>{
          var t;
          return null != (t = e.popperOffset) ? t : l.props.popperOffset
        }
      ))
      , O = yi((()=>{
          var t;
          return null != (t = e.popperClass) ? t : l.props.popperClass
        }
      ))
      , _ = yi((()=>{
          var t;
          return null != (t = e.showTimeout) ? t : l.props.showTimeout
        }
      ))
      , R = yi((()=>{
          var t;
          return null != (t = e.hideTimeout) ? t : l.props.hideTimeout
        }
      ))
      , L = e=>{
        var t, n, r;
        e || null == (r = null == (n = null == (t = v.value) ? void 0 : t.popperRef) ? void 0 : n.popperInstanceRef) || r.destroy()
      }
      , I = ()=>{
        "hover" === l.props.menuTrigger && "horizontal" === l.props.mode || l.props.collapse && "vertical" === l.props.mode || e.disabled || l.handleSubMenuClick({
          index: e.index,
          indexPath: o.value,
          active: A.value
        })
      }
      , P = (t,n=_.value)=>{
        var r;
        "focus" !== t.type && ("click" === l.props.menuTrigger && "horizontal" === l.props.mode || !l.props.collapse && "vertical" === l.props.mode || e.disabled ? u.mouseInChild.value = !0 : (u.mouseInChild.value = !0,
        null == f || f(),
          ({stop: f} = Tc((()=>{
              l.openMenu(e.index, o.value)
            }
          ), n)),
        w.value && (null == (r = a.value.vnode.el) || r.dispatchEvent(new MouseEvent("mouseenter")))))
      }
      , F = (t=!1)=>{
        var n;
        "click" === l.props.menuTrigger && "horizontal" === l.props.mode || !l.props.collapse && "vertical" === l.props.mode ? u.mouseInChild.value = !1 : (null == f || f(),
          u.mouseInChild.value = !1,
          ({stop: f} = Tc((()=>!p.value && l.closeMenu(e.index, o.value)), R.value)),
        w.value && t && (null == (n = u.handleMouseleave) || n.call(u, !0)))
      }
    ;
    Jn((()=>l.props.collapse), (e=>L(Boolean(e))));
    {
      const e = e=>{
          d.value[e.index] = e
        }
        , t = e=>{
          delete d.value[e.index]
        }
      ;
      Mo(`subMenu:${r.uid}`, {
        addSubMenu: e,
        removeSubMenu: t,
        handleMouseleave: F,
        mouseInChild: p,
        level: u.level + 1
      })
    }
    return n({
      opened: E
    }),
      Lr((()=>{
          l.addSubMenu(k),
            u.addSubMenu(k)
        }
      )),
      Fr((()=>{
          u.removeSubMenu(k),
            l.removeSubMenu(k)
        }
      )),
      ()=>{
        var n;
        const o = [null == (n = t.title) ? void 0 : n.call(t), bi(sS, {
          class: s.e("icon-arrow"),
          style: {
            transform: E.value ? e.expandCloseIcon && e.expandOpenIcon || e.collapseCloseIcon && e.collapseOpenIcon && l.props.collapse ? "none" : "rotateZ(180deg)" : "none"
          }
        }, {
          default: ()=>b(m.value) ? bi(r.appContext.components[m.value]) : bi(m.value)
        })]
          , a = l.isMenuPopup ? bi(MA, {
          ref: v,
          visible: E.value,
          effect: "light",
          pure: !0,
          offset: D.value,
          showArrow: !1,
          persistent: !0,
          popperClass: O.value,
          placement: g.value,
          teleported: w.value,
          fallbackPlacements: S.value,
          transition: x.value,
          gpuAcceleration: !1
        }, {
          content: ()=>{
            var e;
            return bi("div", {
              class: [i.m(C.value), i.m("popup-container"), O.value],
              onMouseenter: e=>P(e, 100),
              onMouseleave: ()=>F(!0),
              onFocus: e=>P(e, 100)
            }, [bi("ul", {
              class: [i.b(), i.m("popup"), i.m(`popup-${g.value}`)],
              style: T.value
            }, [null == (e = t.default) ? void 0 : e.call(t)])])
          }
          ,
          default: ()=>bi("div", {
            class: s.e("title"),
            onClick: I
          }, o)
        }) : bi(ba, {}, [bi("div", {
          class: s.e("title"),
          ref: h,
          onClick: I
        }, o), bi(KO, {}, {
          default: ()=>{
            var e;
            return rr(bi("ul", {
              role: "menu",
              class: [i.b(), i.m("inline")],
              style: T.value
            }, [null == (e = t.default) ? void 0 : e.call(t)]), [[$s, E.value]])
          }
        })]);
        return bi("li", {
          class: [s.b(), s.is("active", A.value), s.is("opened", E.value), s.is("disabled", e.disabled)],
          role: "menuitem",
          ariaHaspopup: !0,
          ariaExpanded: E.value,
          onMouseenter: P,
          onMouseleave: ()=>F(),
          onFocus: P
        }, [a])
      }
  }
});
const cF = uy({
  mode: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "vertical"
  },
  defaultActive: {
    type: String,
    default: ""
  },
  defaultOpeneds: {
    type: Array,
    default: ()=>[]
  },
  uniqueOpened: Boolean,
  router: Boolean,
  menuTrigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  collapse: Boolean,
  backgroundColor: String,
  textColor: String,
  activeTextColor: String,
  closeOnClickOutside: Boolean,
  collapseTransition: {
    type: Boolean,
    default: !0
  },
  ellipsis: {
    type: Boolean,
    default: !0
  },
  popperOffset: {
    type: Number,
    default: 6
  },
  ellipsisIcon: {
    type: cy,
    default: ()=>Um
  },
  popperEffect: {
    type: String,
    values: ["dark", "light"],
    default: "dark"
  },
  popperClass: String,
  showTimeout: {
    type: Number,
    default: 300
  },
  hideTimeout: {
    type: Number,
    default: 300
  }
})
  , dF = e=>Array.isArray(e) && e.every((e=>b(e)));
var fF = vr({
  name: "ElMenu",
  props: cF,
  emits: {
    close: (e,t)=>b(e) && dF(t),
    open: (e,t)=>b(e) && dF(t),
    select: (e,t,n,r)=>b(e) && dF(t) && x(n) && (void 0 === r || r instanceof Promise)
  },
  setup(e, {emit: t, slots: n, expose: r}) {
    const o = ei()
      , a = o.appContext.config.globalProperties.$router
      , i = Ft()
      , s = qy("menu")
      , l = qy("sub-menu")
      , u = Ft(-1)
      , c = Ft(e.defaultOpeneds && !e.collapse ? e.defaultOpeneds.slice(0) : [])
      , d = Ft(e.defaultActive)
      , f = Ft({})
      , p = Ft({})
      , h = yi((()=>"horizontal" === e.mode || "vertical" === e.mode && e.collapse))
      , v = (n,r)=>{
        c.value.includes(n) || (e.uniqueOpened && (c.value = c.value.filter((e=>r.includes(e)))),
          c.value.push(n),
          t("open", n, r))
      }
      , g = e=>{
        const t = c.value.indexOf(e);
        -1 !== t && c.value.splice(t, 1)
      }
      , m = (e,n)=>{
        g(e),
          t("close", e, n)
      }
      , y = ({index: e, indexPath: t})=>{
        c.value.includes(e) ? m(e, t) : v(e, t)
      }
      , b = n=>{
        ("horizontal" === e.mode || e.collapse) && (c.value = []);
        const {index: r, indexPath: o} = n;
        if (!Cg(r) && !Cg(o))
          if (e.router && a) {
            const e = n.route || r
              , i = a.push(e).then((e=>(e || (d.value = r),
              e)));
            t("select", r, o, {
              index: r,
              indexPath: o,
              route: e
            }, i)
          } else
            d.value = r,
              t("select", r, o, {
                index: r,
                indexPath: o
              })
      }
      , w = ()=>{
        var e, t;
        if (!i.value)
          return -1;
        const n = Array.from(null != (t = null == (e = i.value) ? void 0 : e.childNodes) ? t : []).filter((e=>"#comment" !== e.nodeName && ("#text" !== e.nodeName || e.nodeValue)))
          , r = getComputedStyle(i.value)
          , o = Number.parseInt(r.paddingLeft, 10)
          , a = Number.parseInt(r.paddingRight, 10)
          , s = i.value.clientWidth - o - a;
        let l = 0
          , u = 0;
        return n.forEach(((e,t)=>{
            l += (e=>{
                const t = getComputedStyle(e)
                  , n = Number.parseInt(t.marginLeft, 10)
                  , r = Number.parseInt(t.marginRight, 10);
                return e.offsetWidth + n + r || 0
              }
            )(e),
            l <= s - 64 && (u = t + 1)
          }
        )),
          u === n.length ? -1 : u
      }
    ;
    let x = !0;
    const S = ()=>{
        if (u.value === w())
          return;
        const e = ()=>{
            u.value = -1,
              hn((()=>{
                  u.value = w()
                }
              ))
          }
        ;
        x ? e() : ((e,t=33.34)=>{
            let n;
            return ()=>{
              n && clearTimeout(n),
                n = setTimeout((()=>{
                    e()
                  }
                ), t)
            }
          }
        )(e)(),
          x = !1
      }
    ;
    let E;
    Jn((()=>e.defaultActive), (t=>{
        f.value[t] || (d.value = ""),
          (t=>{
              const n = f.value
                , r = n[t] || d.value && n[d.value] || n[e.defaultActive];
              d.value = r ? r.index : t
            }
          )(t)
      }
    )),
      Jn((()=>e.collapse), (e=>{
          e && (c.value = [])
        }
      )),
      Jn(f.value, (()=>{
          const t = d.value && f.value[d.value];
          if (!t || "horizontal" === e.mode || e.collapse)
            return;
          t.indexPath.forEach((e=>{
              const t = p.value[e];
              t && v(e, t.indexPath)
            }
          ))
        }
      )),
      qn((()=>{
          "horizontal" === e.mode && e.ellipsis ? E = Uc(i, S).stop : null == E || E()
        }
      ));
    const A = Ft(!1);
    {
      const t = e=>{
          p.value[e.index] = e
        }
        , n = e=>{
          delete p.value[e.index]
        }
        , r = e=>{
          f.value[e.index] = e
        }
        , a = e=>{
          delete f.value[e.index]
        }
      ;
      Mo("rootMenu", bt({
        props: e,
        openedMenus: c,
        items: f,
        subMenus: p,
        activeIndex: d,
        isMenuPopup: h,
        addMenuItem: r,
        removeMenuItem: a,
        addSubMenu: t,
        removeSubMenu: n,
        openMenu: v,
        closeMenu: m,
        handleMenuItemClick: b,
        handleSubMenuClick: y
      })),
        Mo(`subMenu:${o.uid}`, {
          addSubMenu: t,
          removeSubMenu: n,
          mouseInChild: A,
          level: 0
        })
    }
    Lr((()=>{
        "horizontal" === e.mode && new class {
          constructor(e, t) {
            this.domNode = e,
              this.init(t)
          }
          init(e) {
            const t = this.domNode.childNodes;
            Array.from(t).forEach((t=>{
                1 === t.nodeType && new class {
                  constructor(e, t) {
                    this.domNode = e,
                      this.submenu = null,
                      this.submenu = null,
                      this.init(t)
                  }
                  init(e) {
                    this.domNode.setAttribute("tabindex", "0");
                    const t = this.domNode.querySelector(`.${e}-menu`);
                    t && (this.submenu = new class {
                      constructor(e, t) {
                        this.parent = e,
                          this.domNode = t,
                          this.subIndex = 0,
                          this.subIndex = 0,
                          this.init()
                      }
                      init() {
                        this.subMenuItems = this.domNode.querySelectorAll("li"),
                          this.addListeners()
                      }
                      gotoSubIndex(e) {
                        e === this.subMenuItems.length ? e = 0 : e < 0 && (e = this.subMenuItems.length - 1),
                          this.subMenuItems[e].focus(),
                          this.subIndex = e
                      }
                      addListeners() {
                        const e = this.parent.domNode;
                        Array.prototype.forEach.call(this.subMenuItems, (t=>{
                            t.addEventListener("keydown", (t=>{
                                let n = !1;
                                switch (t.code) {
                                  case by.down:
                                    this.gotoSubIndex(this.subIndex + 1),
                                      n = !0;
                                    break;
                                  case by.up:
                                    this.gotoSubIndex(this.subIndex - 1),
                                      n = !0;
                                    break;
                                  case by.tab:
                                    nc(e, "mouseleave");
                                    break;
                                  case by.enter:
                                  case by.space:
                                    n = !0,
                                      t.currentTarget.click()
                                }
                                return n && (t.preventDefault(),
                                  t.stopPropagation()),
                                  !1
                              }
                            ))
                          }
                        ))
                      }
                    }
                    (this,t)),
                      this.addListeners()
                  }
                  addListeners() {
                    this.domNode.addEventListener("keydown", (e=>{
                        let t = !1;
                        switch (e.code) {
                          case by.down:
                            nc(e.currentTarget, "mouseenter"),
                            this.submenu && this.submenu.gotoSubIndex(0),
                              t = !0;
                            break;
                          case by.up:
                            nc(e.currentTarget, "mouseenter"),
                            this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1),
                              t = !0;
                            break;
                          case by.tab:
                            nc(e.currentTarget, "mouseleave");
                            break;
                          case by.enter:
                          case by.space:
                            t = !0,
                              e.currentTarget.click()
                        }
                        t && e.preventDefault()
                      }
                    ))
                  }
                }
                (t,e)
              }
            ))
          }
        }
        (o.vnode.el,s.namespace.value)
      }
    ));
    {
      const e = e=>{
          const {indexPath: t} = p.value[e];
          t.forEach((e=>v(e, t)))
        }
      ;
      r({
        open: e,
        close: g,
        handleResize: S
      })
    }
    return ()=>{
      var r, o;
      let a = null != (o = null == (r = n.default) ? void 0 : r.call(n)) ? o : [];
      const d = [];
      if ("horizontal" === e.mode && i.value) {
        const t = _y(a)
          , n = -1 === u.value ? t : t.slice(0, u.value)
          , r = -1 === u.value ? [] : t.slice(u.value);
        (null == r ? void 0 : r.length) && e.ellipsis && (a = n,
          d.push(bi(uF, {
            index: "sub-menu-more",
            class: l.e("hide-arrow"),
            popperOffset: e.popperOffset
          }, {
            title: ()=>bi(sS, {
              class: l.e("icon-more")
            }, {
              default: ()=>bi(e.ellipsisIcon)
            }),
            default: ()=>r
          })))
      }
      const f = iF(e, 0)
        , h = e.closeOnClickOutside ? [[Rk, ()=>{
        c.value.length && (A.value || (c.value.forEach((e=>{
            return t("close", e, (n = e,
              p.value[n].indexPath));
            var n
          }
        )),
          c.value = []))
      }
      ]] : []
        , v = rr(bi("ul", {
        key: String(e.collapse),
        role: "menubar",
        ref: i,
        style: f.value,
        class: {
          [s.b()]: !0,
          [s.m(e.mode)]: !0,
          [s.m("collapse")]: e.collapse
        }
      }, [...a, ...d]), h);
      return e.collapseTransition && "vertical" === e.mode ? bi(rF, (()=>v)) : v
    }
  }
});
const pF = uy({
  index: {
    type: [String, null],
    default: null
  },
  route: {
    type: [String, Object]
  },
  disabled: Boolean
})
  , hF = "ElMenuItem";
var vF = tS(vr({
  name: hF,
  components: {
    ElTooltip: MA
  },
  props: pF,
  emits: {
    click: e=>b(e.index) && Array.isArray(e.indexPath)
  },
  setup(e, {emit: t}) {
    const n = ei()
      , r = jo("rootMenu")
      , o = qy("menu")
      , a = qy("menu-item");
    r || Jg(hF, "can not inject root menu");
    const {parentMenu: i, indexPath: s} = oF(n, Yt(e, "index"))
      , l = jo(`subMenu:${i.value.uid}`);
    l || Jg(hF, "can not inject sub menu");
    const u = yi((()=>e.index === r.activeIndex))
      , c = bt({
      index: e.index,
      indexPath: s,
      active: u
    });
    return Lr((()=>{
        l.addSubMenu(c),
          r.addMenuItem(c)
      }
    )),
      Fr((()=>{
          l.removeSubMenu(c),
            r.removeMenuItem(c)
        }
      )),
      {
        parentMenu: i,
        rootMenu: r,
        active: u,
        nsMenu: o,
        nsMenuItem: a,
        handleClick: ()=>{
          e.disabled || (r.handleMenuItemClick({
            index: e.index,
            indexPath: s.value,
            route: e.route
          }),
            t("click", c))
        }
      }
  }
}), [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-tooltip");
  return Ca(),
    _a("li", {
      class: Y([e.nsMenuItem.b(), e.nsMenuItem.is("active", e.active), e.nsMenuItem.is("disabled", e.disabled)]),
      role: "menuitem",
      tabindex: "-1",
      onClick: t[0] || (t[0] = (...t)=>e.handleClick && e.handleClick(...t))
    }, ["ElMenu" === e.parentMenu.type.name && e.rootMenu.props.collapse && e.$slots.title ? (Ca(),
      Ra(i, {
        key: 0,
        effect: e.rootMenu.props.popperEffect,
        placement: "right",
        "fallback-placements": ["left"],
        persistent: ""
      }, {
        content: Fn((()=>[Qr(e.$slots, "title")])),
        default: Fn((()=>[Ma("div", {
          class: Y(e.nsMenu.be("tooltip", "trigger"))
        }, [Qr(e.$slots, "default")], 2)])),
        _: 3
      }, 8, ["effect"])) : (Ca(),
      _a(ba, {
        key: 1
      }, [Qr(e.$slots, "default"), Qr(e.$slots, "title")], 64))], 2)
}
], ["__file", "menu-item.vue"]]);
var gF = tS(vr({
  name: "ElMenuItemGroup",
  props: {
    title: String
  },
  setup: ()=>({
    ns: qy("menu-item-group")
  })
}), [["render", function(e, t, n, r, o, a) {
  return Ca(),
    _a("li", {
      class: Y(e.ns.b())
    }, [Ma("div", {
      class: Y(e.ns.e("title"))
    }, [e.$slots.title ? Qr(e.$slots, "title", {
      key: 1
    }) : (Ca(),
      _a(ba, {
        key: 0
      }, [$a(te(e.title), 1)], 64))], 2), Ma("ul", null, [Qr(e.$slots, "default")])], 2)
}
], ["__file", "menu-item-group.vue"]]);
const mF = vy(fF, {
  MenuItem: vF,
  MenuItemGroup: gF,
  SubMenu: uF
})
  , yF = my(vF)
  , bF = my(gF)
  , wF = my(uF)
  , xF = uy({
  icon: {
    type: cy,
    default: ()=>ym
  },
  title: String,
  content: {
    type: String,
    default: ""
  }
})
  , SF = ["aria-label"]
  , EF = vr({
  name: "ElPageHeader"
})
  , AF = vr({
  ...EF,
  props: xF,
  emits: {
    back: ()=>!0
  },
  setup(e, {emit: t}) {
    const n = po()
      , {t: r} = Hy()
      , o = qy("page-header")
      , a = yi((()=>[o.b(), {
      [o.m("has-breadcrumb")]: !!n.breadcrumb,
      [o.m("has-extra")]: !!n.extra,
      [o.is("contentful")]: !!n.default
    }]));
    function i() {
      t("back")
    }
    return (e,t)=>(Ca(),
      _a("div", {
        class: Y(Vt(a))
      }, [e.$slots.breadcrumb ? (Ca(),
        _a("div", {
          key: 0,
          class: Y(Vt(o).e("breadcrumb"))
        }, [Qr(e.$slots, "breadcrumb")], 2)) : za("v-if", !0), Ma("div", {
        class: Y(Vt(o).e("header"))
      }, [Ma("div", {
        class: Y(Vt(o).e("left"))
      }, [Ma("div", {
        class: Y(Vt(o).e("back")),
        role: "button",
        tabindex: "0",
        onClick: i
      }, [e.icon || e.$slots.icon ? (Ca(),
        _a("div", {
          key: 0,
          "aria-label": e.title || Vt(r)("el.pageHeader.title"),
          class: Y(Vt(o).e("icon"))
        }, [Qr(e.$slots, "icon", {}, (()=>[e.icon ? (Ca(),
          Ra(Vt(sS), {
            key: 0
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(e.icon)))])),
            _: 1
          })) : za("v-if", !0)]))], 10, SF)) : za("v-if", !0), Ma("div", {
        class: Y(Vt(o).e("title"))
      }, [Qr(e.$slots, "title", {}, (()=>[$a(te(e.title || Vt(r)("el.pageHeader.title")), 1)]))], 2)], 2), ja(Vt(JL), {
        direction: "vertical"
      }), Ma("div", {
        class: Y(Vt(o).e("content"))
      }, [Qr(e.$slots, "content", {}, (()=>[$a(te(e.content), 1)]))], 2)], 2), e.$slots.extra ? (Ca(),
        _a("div", {
          key: 0,
          class: Y(Vt(o).e("extra"))
        }, [Qr(e.$slots, "extra")], 2)) : za("v-if", !0)], 2), e.$slots.default ? (Ca(),
        _a("div", {
          key: 1,
          class: Y(Vt(o).e("main"))
        }, [Qr(e.$slots, "default")], 2)) : za("v-if", !0)], 2))
  }
});
const CF = vy(tS(AF, [["__file", "page-header.vue"]]))
  , kF = Symbol("elPaginationKey")
  , TF = uy({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  prevText: {
    type: String
  },
  prevIcon: {
    type: cy
  }
})
  , DF = {
  click: e=>e instanceof MouseEvent
}
  , OF = ["disabled", "aria-label", "aria-disabled"]
  , _F = {
  key: 0
}
  , RF = vr({
  name: "ElPaginationPrev"
})
  , LF = vr({
  ...RF,
  props: TF,
  emits: DF,
  setup(e) {
    const t = e
      , {t: n} = Hy()
      , r = yi((()=>t.disabled || t.currentPage <= 1));
    return (e,t)=>(Ca(),
      _a("button", {
        type: "button",
        class: "btn-prev",
        disabled: Vt(r),
        "aria-label": e.prevText || Vt(n)("el.pagination.prev"),
        "aria-disabled": Vt(r),
        onClick: t[0] || (t[0] = t=>e.$emit("click", t))
      }, [e.prevText ? (Ca(),
        _a("span", _F, te(e.prevText), 1)) : (Ca(),
        Ra(Vt(sS), {
          key: 1
        }, {
          default: Fn((()=>[(Ca(),
            Ra(Kr(e.prevIcon)))])),
          _: 1
        }))], 8, OF))
  }
});
var IF = tS(LF, [["__file", "prev.vue"]]);
const PF = uy({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    default: 50
  },
  nextText: {
    type: String
  },
  nextIcon: {
    type: cy
  }
})
  , FF = ["disabled", "aria-label", "aria-disabled"]
  , BF = {
  key: 0
}
  , NF = vr({
  name: "ElPaginationNext"
})
  , MF = vr({
  ...NF,
  props: PF,
  emits: ["click"],
  setup(e) {
    const t = e
      , {t: n} = Hy()
      , r = yi((()=>t.disabled || t.currentPage === t.pageCount || 0 === t.pageCount));
    return (e,t)=>(Ca(),
      _a("button", {
        type: "button",
        class: "btn-next",
        disabled: Vt(r),
        "aria-label": e.nextText || Vt(n)("el.pagination.next"),
        "aria-disabled": Vt(r),
        onClick: t[0] || (t[0] = t=>e.$emit("click", t))
      }, [e.nextText ? (Ca(),
        _a("span", BF, te(e.nextText), 1)) : (Ca(),
        Ra(Vt(sS), {
          key: 1
        }, {
          default: Fn((()=>[(Ca(),
            Ra(Kr(e.nextIcon)))])),
          _: 1
        }))], 8, FF))
  }
});
var jF = tS(MF, [["__file", "next.vue"]]);
const VF = Symbol("ElSelectGroup")
  , UF = Symbol("ElSelect");
const $F = vr({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: !0,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: Boolean
  },
  setup(e) {
    const t = qy("select")
      , n = Cw()
      , r = yi((()=>[t.be("dropdown", "item"), t.is("disabled", Vt(s)), t.is("selected", Vt(i)), t.is("hovering", Vt(f))]))
      , o = bt({
      index: -1,
      groupDisabled: !1,
      visible: !0,
      hover: !1
    })
      , {currentLabel: a, itemSelected: i, isDisabled: s, select: l, hoverItem: u, updateOption: c} = function(e, t) {
      const n = jo(UF)
        , r = jo(VF, {
          disabled: !1
        })
        , o = yi((()=>n.props.multiple ? c(n.props.modelValue, e.value) : c([n.props.modelValue], e.value)))
        , a = yi((()=>{
            if (n.props.multiple) {
              const e = n.props.modelValue || [];
              return !o.value && e.length >= n.props.multipleLimit && n.props.multipleLimit > 0
            }
            return !1
          }
        ))
        , i = yi((()=>e.label || (x(e.value) ? "" : e.value)))
        , s = yi((()=>e.value || e.label || ""))
        , l = yi((()=>e.disabled || t.groupDisabled || a.value))
        , u = ei()
        , c = (t=[],r)=>{
          if (x(e.value)) {
            const e = n.props.valueKey;
            return t && t.some((t=>Dt(Lp(t, e)) === Lp(r, e)))
          }
          return t && t.includes(r)
        }
      ;
      return Jn((()=>i.value), (()=>{
          e.created || n.props.remote || n.setSelected()
        }
      )),
        Jn((()=>e.value), ((t,r)=>{
            const {remote: o, valueKey: a} = n.props;
            if (Ag(t, r) || (n.onOptionDestroy(r, u.proxy),
              n.onOptionCreate(u.proxy)),
            !e.created && !o) {
              if (a && x(t) && x(r) && t[a] === r[a])
                return;
              n.setSelected()
            }
          }
        )),
        Jn((()=>r.disabled), (()=>{
            t.groupDisabled = r.disabled
          }
        ), {
          immediate: !0
        }),
        {
          select: n,
          currentLabel: i,
          currentValue: s,
          itemSelected: o,
          isDisabled: l,
          hoverItem: ()=>{
            e.disabled || r.disabled || (n.states.hoveringIndex = n.optionsArray.indexOf(u.proxy))
          }
          ,
          updateOption: n=>{
            const r = new RegExp(Gg(n),"i");
            t.visible = r.test(i.value) || e.created
          }
        }
    }(e, o)
      , {visible: d, hover: f} = Wt(o)
      , p = ei().proxy;
    return l.onOptionCreate(p),
      Fr((()=>{
          const e = p.value
            , {selected: t} = l.states
            , n = (l.props.multiple ? t : [t]).some((e=>e.value === p.value));
          hn((()=>{
              l.states.cachedOptions.get(e) !== p || n || l.states.cachedOptions.delete(e)
            }
          )),
            l.onOptionDestroy(e, p)
        }
      )),
      {
        ns: t,
        id: n,
        containerKls: r,
        currentLabel: a,
        itemSelected: i,
        isDisabled: s,
        select: l,
        hoverItem: u,
        updateOption: c,
        visible: d,
        hover: f,
        selectOptionClick: function() {
          !0 !== e.disabled && !0 !== o.groupDisabled && l.handleOptionSelect(p)
        },
        states: o
      }
  }
})
  , HF = ["id", "aria-disabled", "aria-selected"];
var zF = tS($F, [["render", function(e, t, n, r, o, a) {
  return rr((Ca(),
    _a("li", {
      id: e.id,
      class: Y(e.containerKls),
      role: "option",
      "aria-disabled": e.isDisabled || void 0,
      "aria-selected": e.itemSelected,
      onMouseenter: t[0] || (t[0] = (...t)=>e.hoverItem && e.hoverItem(...t)),
      onClick: t[1] || (t[1] = js(((...t)=>e.selectOptionClick && e.selectOptionClick(...t)), ["stop"]))
    }, [Qr(e.$slots, "default", {}, (()=>[Ma("span", null, te(e.currentLabel), 1)]))], 42, HF)), [[$s, e.visible]])
}
], ["__file", "option.vue"]]);
var KF = tS(vr({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const e = jo(UF)
      , t = qy("select")
      , n = yi((()=>e.props.popperClass))
      , r = yi((()=>e.props.multiple))
      , o = yi((()=>e.props.fitInputWidth))
      , a = Ft("");
    function i() {
      var t;
      a.value = `${null == (t = e.selectRef) ? void 0 : t.offsetWidth}px`
    }
    return Lr((()=>{
        i(),
          Uc(e.selectRef, i)
      }
    )),
      {
        ns: t,
        minWidth: a,
        popperClass: n,
        isMultiple: r,
        isFitInputWidth: o
      }
  }
}), [["render", function(e, t, n, r, o, a) {
  return Ca(),
    _a("div", {
      class: Y([e.ns.b("dropdown"), e.ns.is("multiple", e.isMultiple), e.popperClass]),
      style: z({
        [e.isFitInputWidth ? "width" : "minWidth"]: e.minWidth
      })
    }, [e.$slots.header ? (Ca(),
      _a("div", {
        key: 0,
        class: Y(e.ns.be("dropdown", "header"))
      }, [Qr(e.$slots, "header")], 2)) : za("v-if", !0), Qr(e.$slots, "default"), e.$slots.footer ? (Ca(),
      _a("div", {
        key: 1,
        class: Y(e.ns.be("dropdown", "footer"))
      }, [Qr(e.$slots, "footer")], 2)) : za("v-if", !0)], 6)
}
], ["__file", "select-dropdown.vue"]]);
function WF(e) {
  const t = Ft(!1);
  return {
    handleCompositionStart: ()=>{
      t.value = !0
    }
    ,
    handleCompositionUpdate: e=>{
      const n = e.target.value
        , r = n[n.length - 1] || "";
      t.value = !Iy(r)
    }
    ,
    handleCompositionEnd: n=>{
      t.value && (t.value = !1,
      y(e) && e(n))
    }
  }
}
const GF = (e,t)=>{
    const {t: n} = Hy()
      , r = Cw()
      , o = qy("select")
      , a = qy("input")
      , i = bt({
      inputValue: "",
      options: new Map,
      cachedOptions: new Map,
      disabledOptions: new Map,
      optionValues: [],
      selected: e.multiple ? [] : {},
      selectionWidth: 0,
      calculatorWidth: 0,
      collapseItemWidth: 0,
      selectedLabel: "",
      hoveringIndex: -1,
      previousQuery: null,
      inputHovering: !1,
      menuVisibleOnFocus: !1,
      isBeforeHide: !1
    })
      , s = Ft(null)
      , l = Ft(null)
      , u = Ft(null)
      , c = Ft(null)
      , d = Ft(null)
      , f = Ft(null)
      , p = Ft(null)
      , v = Ft(null)
      , g = Ft(null)
      , m = Ft(null)
      , b = Ft(null)
      , w = Ft(null)
      , {wrapperRef: S, isFocused: E, handleFocus: A, handleBlur: k} = Hx(d, {
      afterFocus() {
        e.automaticDropdown && !T.value && (T.value = !0,
          i.menuVisibleOnFocus = !0)
      },
      beforeBlur(e) {
        var t, n;
        return (null == (t = u.value) ? void 0 : t.isFocusInsideContent(e)) || (null == (n = c.value) ? void 0 : n.isFocusInsideContent(e))
      },
      afterBlur() {
        T.value = !1,
          i.menuVisibleOnFocus = !1
      }
    })
      , T = Ft(!1)
      , D = Ft()
      , {form: O, formItem: _} = gS()
      , {inputId: R} = mS(e, {
      formItemContext: _
    })
      , L = yi((()=>e.disabled || (null == O ? void 0 : O.disabled)))
      , I = yi((()=>H.value.some((e=>"" === e.value))))
      , P = yi((()=>e.multiple ? h(e.modelValue) && e.modelValue.length > 0 : !Cg(e.modelValue) && ("" !== e.modelValue || I.value)))
      , F = yi((()=>e.clearable && !L.value && i.inputHovering && P.value))
      , B = yi((()=>e.remote && e.filterable && !e.remoteShowSuffix ? "" : e.suffixIcon))
      , N = yi((()=>o.is("reverse", B.value && T.value)))
      , M = yi((()=>(null == _ ? void 0 : _.validateState) || ""))
      , j = yi((()=>hy[M.value]))
      , V = yi((()=>e.remote ? 300 : 0))
      , U = yi((()=>e.loading ? e.loadingText || n("el.select.loading") : !(e.remote && !i.inputValue && 0 === i.options.size) && (e.filterable && i.inputValue && i.options.size > 0 && 0 === $.value ? e.noMatchText || n("el.select.noMatch") : 0 === i.options.size ? e.noDataText || n("el.select.noData") : null)))
      , $ = yi((()=>H.value.filter((e=>e.visible)).length))
      , H = yi((()=>{
        const e = Array.from(i.options.values())
          , t = [];
        return i.optionValues.forEach((n=>{
            const r = e.findIndex((e=>e.value === n));
            r > -1 && t.push(e[r])
          }
        )),
          t.length >= e.length ? t : e
      }
    ))
      , z = yi((()=>Array.from(i.cachedOptions.values())))
      , K = yi((()=>{
        const t = H.value.filter((e=>!e.created)).some((e=>e.currentLabel === i.inputValue));
        return e.filterable && e.allowCreate && "" !== i.inputValue && !t
      }
    ))
      , W = ()=>{
      e.filterable && y(e.filterMethod) || e.filterable && e.remote && y(e.remoteMethod) || H.value.forEach((e=>{
          e.updateOption(i.inputValue)
        }
      ))
    }
      , G = hS()
      , q = yi((()=>["small"].includes(G.value) ? "small" : "default"))
      , Y = yi({
      get: ()=>T.value && !1 !== U.value,
      set(e) {
        T.value = e
      }
    })
      , X = yi((()=>h(e.modelValue) ? 0 === e.modelValue.length && !i.inputValue : !e.filterable || !i.inputValue))
      , Q = yi((()=>{
        var t;
        const r = null != (t = e.placeholder) ? t : n("el.select.placeholder");
        return e.multiple || !P.value ? r : i.selectedLabel
      }
    ));
    Jn((()=>e.modelValue), ((t,n)=>{
        e.multiple && e.filterable && !e.reserveKeyword && (i.inputValue = "",
          J("")),
          ee(),
        !Ag(t, n) && e.validateEvent && (null == _ || _.validate("change").catch((e=>{}
        )))
      }
    ), {
      flush: "post",
      deep: !0
    }),
      Jn((()=>T.value), (e=>{
          e ? J(i.inputValue) : (i.inputValue = "",
            i.previousQuery = null,
            i.isBeforeHide = !0),
            t("visible-change", e)
        }
      )),
      Jn((()=>i.options.entries()), (()=>{
          var t;
          if (!mc)
            return;
          const n = (null == (t = s.value) ? void 0 : t.querySelectorAll("input")) || [];
          (e.filterable || e.defaultFirstOption || Mg(e.modelValue)) && Array.from(n).includes(document.activeElement) || ee(),
          e.defaultFirstOption && (e.filterable || e.remote) && $.value && Z()
        }
      ), {
        flush: "post"
      }),
      Jn((()=>i.hoveringIndex), (e=>{
          Vg(e) && e > -1 ? D.value = H.value[e] || {} : D.value = {},
            H.value.forEach((e=>{
                e.hover = D.value === e
              }
            ))
        }
      )),
      qn((()=>{
          i.isBeforeHide || W()
        }
      ));
    const J = t=>{
      i.previousQuery !== t && (i.previousQuery = t,
        e.filterable && y(e.filterMethod) ? e.filterMethod(t) : e.filterable && e.remote && y(e.remoteMethod) && e.remoteMethod(t),
        e.defaultFirstOption && (e.filterable || e.remote) && $.value ? hn(Z) : hn(ne))
    }
      , Z = ()=>{
      const e = H.value.filter((e=>e.visible && !e.disabled && !e.states.groupDisabled))
        , t = e.find((e=>e.created))
        , n = e[0];
      i.hoveringIndex = fe(H.value, t || n)
    }
      , ee = ()=>{
      if (!e.multiple) {
        const t = te(e.modelValue);
        return i.selectedLabel = t.currentLabel,
          void (i.selected = t)
      }
      i.selectedLabel = "";
      const t = [];
      h(e.modelValue) && e.modelValue.forEach((e=>{
          t.push(te(e))
        }
      )),
        i.selected = t
    }
      , te = t=>{
      let n;
      const r = "object" === C(t).toLowerCase()
        , o = "null" === C(t).toLowerCase()
        , a = "undefined" === C(t).toLowerCase();
      for (let s = i.cachedOptions.size - 1; s >= 0; s--) {
        const o = z.value[s];
        if (r ? Lp(o.value, e.valueKey) === Lp(t, e.valueKey) : o.value === t) {
          n = {
            value: t,
            currentLabel: o.currentLabel,
            isDisabled: o.isDisabled
          };
          break
        }
      }
      if (n)
        return n;
      return {
        value: t,
        currentLabel: r ? t.label : o || a ? "" : t
      }
    }
      , ne = ()=>{
      e.multiple ? i.hoveringIndex = H.value.findIndex((e=>i.selected.some((t=>xe(t) === xe(e))))) : i.hoveringIndex = H.value.findIndex((e=>xe(e) === xe(i.selected)))
    }
      , re = ()=>{
      i.calculatorWidth = f.value.getBoundingClientRect().width
    }
      , oe = ()=>{
      var e, t;
      null == (t = null == (e = u.value) ? void 0 : e.updatePopper) || t.call(e)
    }
      , ae = ()=>{
      var e, t;
      null == (t = null == (e = c.value) ? void 0 : e.updatePopper) || t.call(e)
    }
      , ie = ()=>{
      i.inputValue.length > 0 && !T.value && (T.value = !0),
        J(i.inputValue)
    }
      , se = t=>{
      if (i.inputValue = t.target.value,
        !e.remote)
        return ie();
      le()
    }
      , le = ug((()=>{
        ie()
      }
    ), V.value)
      , ue = n=>{
      Ag(e.modelValue, n) || t(Sy, n)
    }
      , ce = n=>{
      n.stopPropagation();
      const r = e.multiple ? [] : void 0;
      if (e.multiple)
        for (const e of i.selected)
          e.isDisabled && r.push(e.value);
      t(xy, r),
        ue(r),
        i.hoveringIndex = -1,
        T.value = !1,
        t("clear"),
        ye()
    }
      , de = n=>{
      if (e.multiple) {
        const r = (e.modelValue || []).slice()
          , o = fe(r, n.value);
        o > -1 ? r.splice(o, 1) : (e.multipleLimit <= 0 || r.length < e.multipleLimit) && r.push(n.value),
          t(xy, r),
          ue(r),
        n.created && J(""),
        e.filterable && !e.reserveKeyword && (i.inputValue = "")
      } else
        t(xy, n.value),
          ue(n.value),
          T.value = !1;
      ye(),
      T.value || hn((()=>{
          pe(n)
        }
      ))
    }
      , fe = (t=[],n)=>{
      if (!x(n))
        return t.indexOf(n);
      const r = e.valueKey;
      let o = -1;
      return t.some(((e,t)=>Dt(Lp(e, r)) === Lp(n, r) && (o = t,
        !0))),
        o
    }
      , pe = e=>{
      var t, n, r, a, i;
      const s = h(e) ? e[0] : e;
      let l = null;
      if (null == s ? void 0 : s.value) {
        const e = H.value.filter((e=>e.value === s.value));
        e.length > 0 && (l = e[0].$el)
      }
      if (u.value && l) {
        const e = null == (a = null == (r = null == (n = null == (t = u.value) ? void 0 : t.popperRef) ? void 0 : n.contentRef) ? void 0 : r.querySelector) ? void 0 : a.call(r, `.${o.be("dropdown", "wrap")}`);
        e && um(e, l)
      }
      null == (i = w.value) || i.handleScroll()
    }
      , {handleCompositionStart: he, handleCompositionUpdate: ve, handleCompositionEnd: ge} = WF((e=>se(e)))
      , me = yi((()=>{
        var e, t;
        return null == (t = null == (e = u.value) ? void 0 : e.popperRef) ? void 0 : t.contentRef
      }
    ))
      , ye = ()=>{
      var e;
      null == (e = d.value) || e.focus()
    }
      , be = e=>{
      if (T.value = !1,
        E.value) {
        const t = new FocusEvent("focus",e);
        hn((()=>k(t)))
      }
    }
      , we = ()=>{
      L.value || (i.menuVisibleOnFocus ? i.menuVisibleOnFocus = !1 : T.value = !T.value)
    }
      , xe = t=>x(t.value) ? Lp(t.value, e.valueKey) : t.value
      , Se = yi((()=>H.value.filter((e=>e.visible)).every((e=>e.disabled))))
      , Ee = yi((()=>e.multiple ? e.collapseTags ? i.selected.slice(0, e.maxCollapseTags) : i.selected : []))
      , Ae = yi((()=>e.multiple && e.collapseTags ? i.selected.slice(e.maxCollapseTags) : []))
      , Ce = e=>{
      if (T.value) {
        if (0 !== i.options.size && 0 !== $.value && !Se.value) {
          "next" === e ? (i.hoveringIndex++,
          i.hoveringIndex === i.options.size && (i.hoveringIndex = 0)) : "prev" === e && (i.hoveringIndex--,
          i.hoveringIndex < 0 && (i.hoveringIndex = i.options.size - 1));
          const t = H.value[i.hoveringIndex];
          !0 !== t.disabled && !0 !== t.states.groupDisabled && t.visible || Ce(e),
            hn((()=>pe(D.value)))
        }
      } else
        T.value = !0
    }
      , ke = yi((()=>{
        const t = (()=>{
            if (!l.value)
              return 0;
            const e = window.getComputedStyle(l.value);
            return Number.parseFloat(e.gap || "6px")
          }
        )();
        return {
          maxWidth: `${b.value && 1 === e.maxCollapseTags ? i.selectionWidth - i.collapseItemWidth - t : i.selectionWidth}px`
        }
      }
    ))
      , Te = yi((()=>({
      maxWidth: `${i.selectionWidth}px`
    })))
      , De = yi((()=>({
      width: `${Math.max(i.calculatorWidth, 11)}px`
    })));
    return e.multiple && !h(e.modelValue) && t(xy, []),
    !e.multiple && h(e.modelValue) && t(xy, ""),
      Uc(l, (()=>{
          i.selectionWidth = l.value.getBoundingClientRect().width
        }
      )),
      Uc(f, re),
      Uc(g, oe),
      Uc(S, oe),
      Uc(m, ae),
      Uc(b, (()=>{
          i.collapseItemWidth = b.value.getBoundingClientRect().width
        }
      )),
      Lr((()=>{
          ee()
        }
      )),
      {
        inputId: R,
        contentId: r,
        nsSelect: o,
        nsInput: a,
        states: i,
        isFocused: E,
        expanded: T,
        optionsArray: H,
        hoverOption: D,
        selectSize: G,
        filteredOptionsCount: $,
        resetCalculatorWidth: re,
        updateTooltip: oe,
        updateTagTooltip: ae,
        debouncedOnInputChange: le,
        onInput: se,
        deletePrevTag: n=>{
          if (e.multiple && n.code !== by.delete && n.target.value.length <= 0) {
            const n = e.modelValue.slice()
              , r = (e=>yg(e, (e=>!i.disabledOptions.has(e))))(n);
            if (r < 0)
              return;
            n.splice(r, 1),
              t(xy, n),
              ue(n)
          }
        }
        ,
        deleteTag: (n,r)=>{
          const o = i.selected.indexOf(r);
          if (o > -1 && !L.value) {
            const n = e.modelValue.slice();
            n.splice(o, 1),
              t(xy, n),
              ue(n),
              t("remove-tag", r.value)
          }
          n.stopPropagation(),
            ye()
        }
        ,
        deleteSelected: ce,
        handleOptionSelect: de,
        scrollToOption: pe,
        hasModelValue: P,
        shouldShowPlaceholder: X,
        currentPlaceholder: Q,
        showClose: F,
        iconComponent: B,
        iconReverse: N,
        validateState: M,
        validateIcon: j,
        showNewOption: K,
        updateOptions: W,
        collapseTagSize: q,
        setSelected: ee,
        selectDisabled: L,
        emptyText: U,
        handleCompositionStart: he,
        handleCompositionUpdate: ve,
        handleCompositionEnd: ge,
        onOptionCreate: e=>{
          i.options.set(e.value, e),
            i.cachedOptions.set(e.value, e),
          e.disabled && i.disabledOptions.set(e.value, e)
        }
        ,
        onOptionDestroy: (e,t)=>{
          i.options.get(e) === t && i.options.delete(e)
        }
        ,
        handleMenuEnter: ()=>{
          hn((()=>pe(i.selected)))
        }
        ,
        handleFocus: A,
        focus: ye,
        blur: ()=>{
          be()
        }
        ,
        handleBlur: k,
        handleClearClick: e=>{
          ce(e)
        }
        ,
        handleClickOutside: be,
        handleEsc: ()=>{
          i.inputValue.length > 0 ? i.inputValue = "" : T.value = !1
        }
        ,
        toggleMenu: we,
        selectOption: ()=>{
          T.value ? H.value[i.hoveringIndex] && de(H.value[i.hoveringIndex]) : we()
        }
        ,
        getValueKey: xe,
        navigateOptions: Ce,
        dropdownMenuVisible: Y,
        showTagList: Ee,
        collapseTagList: Ae,
        tagStyle: ke,
        collapseTagStyle: Te,
        inputStyle: De,
        popperRef: me,
        inputRef: d,
        tooltipRef: u,
        tagTooltipRef: c,
        calculatorRef: f,
        prefixRef: p,
        suffixRef: v,
        selectRef: s,
        wrapperRef: S,
        selectionRef: l,
        scrollbarRef: w,
        menuRef: g,
        tagMenuRef: m,
        collapseItemRef: b
      }
  }
;
var qF = vr({
  name: "ElOptions",
  setup(e, {slots: t}) {
    const n = jo(UF);
    let r = [];
    return ()=>{
      var e, o;
      const a = null == (e = t.default) ? void 0 : e.call(t)
        , i = [];
      return a.length && function e(t) {
        h(t) && t.forEach((t=>{
            var n, r, o, a;
            const s = null == (n = (null == t ? void 0 : t.type) || {}) ? void 0 : n.name;
            "ElOptionGroup" === s ? e(b(t.children) || h(t.children) || !y(null == (r = t.children) ? void 0 : r.default) ? t.children : null == (o = t.children) ? void 0 : o.default()) : "ElOption" === s ? i.push(null == (a = t.props) ? void 0 : a.value) : h(t.children) && e(t.children)
          }
        ))
      }(null == (o = a[0]) ? void 0 : o.children),
      Ag(i, r) || (r = i,
      n && (n.states.optionValues = i)),
        a
    }
  }
});
const YF = uy({
  name: String,
  id: String,
  modelValue: {
    type: [Array, String, Number, Boolean, Object],
    default: void 0
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  automaticDropdown: Boolean,
  size: Ux,
  effect: {
    type: String,
    default: "light"
  },
  disabled: Boolean,
  clearable: Boolean,
  filterable: Boolean,
  allowCreate: Boolean,
  loading: Boolean,
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: ()=>({})
  },
  remote: Boolean,
  loadingText: String,
  noMatchText: String,
  noDataText: String,
  remoteMethod: Function,
  filterMethod: Function,
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  placeholder: {
    type: String
  },
  defaultFirstOption: Boolean,
  reserveKeyword: {
    type: Boolean,
    default: !0
  },
  valueKey: {
    type: String,
    default: "value"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  teleported: SA.teleported,
  persistent: {
    type: Boolean,
    default: !0
  },
  clearIcon: {
    type: cy,
    default: km
  },
  fitInputWidth: Boolean,
  suffixIcon: {
    type: cy,
    default: hm
  },
  tagType: {
    ...fO.type,
    default: "info"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  remoteShowSuffix: Boolean,
  placement: {
    type: String,
    values: pb,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: Array,
    default: ["bottom-start", "top-start", "right", "left"]
  },
  ariaLabel: {
    type: String,
    default: void 0
  }
})
  , XF = "ElSelect"
  , QF = vr({
  name: XF,
  componentName: XF,
  components: {
    ElInput: yE,
    ElSelectMenu: KF,
    ElOption: zF,
    ElOptions: qF,
    ElTag: vO,
    ElScrollbar: DE,
    ElTooltip: MA,
    ElIcon: sS
  },
  directives: {
    ClickOutside: Rk
  },
  props: YF,
  emits: [xy, Sy, "remove-tag", "clear", "visible-change", "focus", "blur"],
  setup(e, {emit: t}) {
    const n = GF(e, t);
    return Mo(UF, bt({
      props: e,
      states: n.states,
      optionsArray: n.optionsArray,
      handleOptionSelect: n.handleOptionSelect,
      onOptionCreate: n.onOptionCreate,
      onOptionDestroy: n.onOptionDestroy,
      selectRef: n.selectRef,
      setSelected: n.setSelected
    })),
      {
        ...n
      }
  }
})
  , JF = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"]
  , ZF = ["textContent"];
var eB = tS(QF, [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-tag")
    , s = Hr("el-tooltip")
    , l = Hr("el-icon")
    , u = Hr("el-option")
    , c = Hr("el-options")
    , d = Hr("el-scrollbar")
    , f = Hr("el-select-menu")
    , p = Wr("click-outside");
  return rr((Ca(),
    _a("div", {
      ref: "selectRef",
      class: Y([e.nsSelect.b(), e.nsSelect.m(e.selectSize)]),
      onMouseenter: t[14] || (t[14] = t=>e.states.inputHovering = !0),
      onMouseleave: t[15] || (t[15] = t=>e.states.inputHovering = !1),
      onClick: t[16] || (t[16] = js(((...t)=>e.toggleMenu && e.toggleMenu(...t)), ["stop"]))
    }, [ja(s, {
      ref: "tooltipRef",
      visible: e.dropdownMenuVisible,
      placement: e.placement,
      teleported: e.teleported,
      "popper-class": [e.nsSelect.e("popper"), e.popperClass],
      "popper-options": e.popperOptions,
      "fallback-placements": e.fallbackPlacements,
      effect: e.effect,
      pure: "",
      trigger: "click",
      transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      persistent: e.persistent,
      onBeforeShow: e.handleMenuEnter,
      onHide: t[13] || (t[13] = t=>e.states.isBeforeHide = !1)
    }, {
      default: Fn((()=>{
          var n;
          return [Ma("div", {
            ref: "wrapperRef",
            class: Y([e.nsSelect.e("wrapper"), e.nsSelect.is("focused", e.isFocused), e.nsSelect.is("hovering", e.states.inputHovering), e.nsSelect.is("filterable", e.filterable), e.nsSelect.is("disabled", e.selectDisabled)])
          }, [e.$slots.prefix ? (Ca(),
            _a("div", {
              key: 0,
              ref: "prefixRef",
              class: Y(e.nsSelect.e("prefix"))
            }, [Qr(e.$slots, "prefix")], 2)) : za("v-if", !0), Ma("div", {
            ref: "selectionRef",
            class: Y([e.nsSelect.e("selection"), e.nsSelect.is("near", e.multiple && !e.$slots.prefix && !!e.states.selected.length)])
          }, [e.multiple ? Qr(e.$slots, "tag", {
            key: 0
          }, (()=>[(Ca(!0),
            _a(ba, null, Yr(e.showTagList, (t=>(Ca(),
              _a("div", {
                key: e.getValueKey(t),
                class: Y(e.nsSelect.e("selected-item"))
              }, [ja(i, {
                closable: !e.selectDisabled && !t.isDisabled,
                size: e.collapseTagSize,
                type: e.tagType,
                "disable-transitions": "",
                style: z(e.tagStyle),
                onClose: n=>e.deleteTag(n, t)
              }, {
                default: Fn((()=>[Ma("span", {
                  class: Y(e.nsSelect.e("tags-text"))
                }, te(t.currentLabel), 3)])),
                _: 2
              }, 1032, ["closable", "size", "type", "style", "onClose"])], 2)))), 128)), e.collapseTags && e.states.selected.length > e.maxCollapseTags ? (Ca(),
            Ra(s, {
              key: 0,
              ref: "tagTooltipRef",
              disabled: e.dropdownMenuVisible || !e.collapseTagsTooltip,
              "fallback-placements": ["bottom", "top", "right", "left"],
              effect: e.effect,
              placement: "bottom",
              teleported: e.teleported
            }, {
              default: Fn((()=>[Ma("div", {
                ref: "collapseItemRef",
                class: Y(e.nsSelect.e("selected-item"))
              }, [ja(i, {
                closable: !1,
                size: e.collapseTagSize,
                type: e.tagType,
                "disable-transitions": "",
                style: z(e.collapseTagStyle)
              }, {
                default: Fn((()=>[Ma("span", {
                  class: Y(e.nsSelect.e("tags-text"))
                }, " + " + te(e.states.selected.length - e.maxCollapseTags), 3)])),
                _: 1
              }, 8, ["size", "type", "style"])], 2)])),
              content: Fn((()=>[Ma("div", {
                ref: "tagMenuRef",
                class: Y(e.nsSelect.e("selection"))
              }, [(Ca(!0),
                _a(ba, null, Yr(e.collapseTagList, (t=>(Ca(),
                  _a("div", {
                    key: e.getValueKey(t),
                    class: Y(e.nsSelect.e("selected-item"))
                  }, [ja(i, {
                    class: "in-tooltip",
                    closable: !e.selectDisabled && !t.isDisabled,
                    size: e.collapseTagSize,
                    type: e.tagType,
                    "disable-transitions": "",
                    onClose: n=>e.deleteTag(n, t)
                  }, {
                    default: Fn((()=>[Ma("span", {
                      class: Y(e.nsSelect.e("tags-text"))
                    }, te(t.currentLabel), 3)])),
                    _: 2
                  }, 1032, ["closable", "size", "type", "onClose"])], 2)))), 128))], 2)])),
              _: 1
            }, 8, ["disabled", "effect", "teleported"])) : za("v-if", !0)])) : za("v-if", !0), e.selectDisabled ? za("v-if", !0) : (Ca(),
            _a("div", {
              key: 1,
              class: Y([e.nsSelect.e("selected-item"), e.nsSelect.e("input-wrapper"), e.nsSelect.is("hidden", !e.filterable)])
            }, [rr(Ma("input", {
              id: e.inputId,
              ref: "inputRef",
              "onUpdate:modelValue": t[0] || (t[0] = t=>e.states.inputValue = t),
              type: "text",
              class: Y([e.nsSelect.e("input"), e.nsSelect.is(e.selectSize)]),
              disabled: e.selectDisabled,
              autocomplete: e.autocomplete,
              style: z(e.inputStyle),
              role: "combobox",
              readonly: !e.filterable,
              spellcheck: "false",
              "aria-activedescendant": (null == (n = e.hoverOption) ? void 0 : n.id) || "",
              "aria-controls": e.contentId,
              "aria-expanded": e.dropdownMenuVisible,
              "aria-label": e.ariaLabel,
              "aria-autocomplete": "none",
              "aria-haspopup": "listbox",
              onFocus: t[1] || (t[1] = (...t)=>e.handleFocus && e.handleFocus(...t)),
              onBlur: t[2] || (t[2] = (...t)=>e.handleBlur && e.handleBlur(...t)),
              onKeydown: [t[3] || (t[3] = Us(js((t=>e.navigateOptions("next")), ["stop", "prevent"]), ["down"])), t[4] || (t[4] = Us(js((t=>e.navigateOptions("prev")), ["stop", "prevent"]), ["up"])), t[5] || (t[5] = Us(js(((...t)=>e.handleEsc && e.handleEsc(...t)), ["stop", "prevent"]), ["esc"])), t[6] || (t[6] = Us(js(((...t)=>e.selectOption && e.selectOption(...t)), ["stop", "prevent"]), ["enter"])), t[7] || (t[7] = Us(js(((...t)=>e.deletePrevTag && e.deletePrevTag(...t)), ["stop"]), ["delete"]))],
              onCompositionstart: t[8] || (t[8] = (...t)=>e.handleCompositionStart && e.handleCompositionStart(...t)),
              onCompositionupdate: t[9] || (t[9] = (...t)=>e.handleCompositionUpdate && e.handleCompositionUpdate(...t)),
              onCompositionend: t[10] || (t[10] = (...t)=>e.handleCompositionEnd && e.handleCompositionEnd(...t)),
              onInput: t[11] || (t[11] = (...t)=>e.onInput && e.onInput(...t)),
              onClick: t[12] || (t[12] = js(((...t)=>e.toggleMenu && e.toggleMenu(...t)), ["stop"]))
            }, null, 46, JF), [[ks, e.states.inputValue]]), e.filterable ? (Ca(),
              _a("span", {
                key: 0,
                ref: "calculatorRef",
                "aria-hidden": "true",
                class: Y(e.nsSelect.e("input-calculator")),
                textContent: te(e.states.inputValue)
              }, null, 10, ZF)) : za("v-if", !0)], 2)), e.shouldShowPlaceholder ? (Ca(),
            _a("div", {
              key: 2,
              class: Y([e.nsSelect.e("selected-item"), e.nsSelect.e("placeholder"), e.nsSelect.is("transparent", !e.hasModelValue || e.expanded && !e.states.inputValue)])
            }, [Ma("span", null, te(e.currentPlaceholder), 1)], 2)) : za("v-if", !0)], 2), Ma("div", {
            ref: "suffixRef",
            class: Y(e.nsSelect.e("suffix"))
          }, [e.iconComponent && !e.showClose ? (Ca(),
            Ra(l, {
              key: 0,
              class: Y([e.nsSelect.e("caret"), e.nsSelect.e("icon"), e.iconReverse])
            }, {
              default: Fn((()=>[(Ca(),
                Ra(Kr(e.iconComponent)))])),
              _: 1
            }, 8, ["class"])) : za("v-if", !0), e.showClose && e.clearIcon ? (Ca(),
            Ra(l, {
              key: 1,
              class: Y([e.nsSelect.e("caret"), e.nsSelect.e("icon")]),
              onClick: e.handleClearClick
            }, {
              default: Fn((()=>[(Ca(),
                Ra(Kr(e.clearIcon)))])),
              _: 1
            }, 8, ["class", "onClick"])) : za("v-if", !0), e.validateState && e.validateIcon ? (Ca(),
            Ra(l, {
              key: 2,
              class: Y([e.nsInput.e("icon"), e.nsInput.e("validateIcon")])
            }, {
              default: Fn((()=>[(Ca(),
                Ra(Kr(e.validateIcon)))])),
              _: 1
            }, 8, ["class"])) : za("v-if", !0)], 2)], 2)]
        }
      )),
      content: Fn((()=>[ja(f, {
        ref: "menuRef"
      }, {
        default: Fn((()=>[e.$slots.header ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(e.nsSelect.be("dropdown", "header"))
          }, [Qr(e.$slots, "header")], 2)) : za("v-if", !0), rr(ja(d, {
          id: e.contentId,
          ref: "scrollbarRef",
          tag: "ul",
          "wrap-class": e.nsSelect.be("dropdown", "wrap"),
          "view-class": e.nsSelect.be("dropdown", "list"),
          class: Y([e.nsSelect.is("empty", 0 === e.filteredOptionsCount)]),
          role: "listbox",
          "aria-label": e.ariaLabel,
          "aria-orientation": "vertical"
        }, {
          default: Fn((()=>[e.showNewOption ? (Ca(),
            Ra(u, {
              key: 0,
              value: e.states.inputValue,
              created: !0
            }, null, 8, ["value"])) : za("v-if", !0), ja(c, null, {
            default: Fn((()=>[Qr(e.$slots, "default")])),
            _: 3
          })])),
          _: 3
        }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [[$s, e.states.options.size > 0 && !e.loading]]), e.$slots.loading && e.loading ? (Ca(),
          _a("div", {
            key: 1,
            class: Y(e.nsSelect.be("dropdown", "loading"))
          }, [Qr(e.$slots, "loading")], 2)) : e.loading || 0 === e.filteredOptionsCount ? (Ca(),
          _a("div", {
            key: 2,
            class: Y(e.nsSelect.be("dropdown", "empty"))
          }, [Qr(e.$slots, "empty", {}, (()=>[Ma("span", null, te(e.emptyText), 1)]))], 2)) : za("v-if", !0), e.$slots.footer ? (Ca(),
          _a("div", {
            key: 3,
            class: Y(e.nsSelect.be("dropdown", "footer"))
          }, [Qr(e.$slots, "footer")], 2)) : za("v-if", !0)])),
        _: 3
      }, 512)])),
      _: 3
    }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "onBeforeShow"])], 34)), [[p, e.handleClickOutside, e.popperRef]])
}
], ["__file", "select.vue"]]);
var tB = tS(vr({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(e) {
    const t = qy("select")
      , n = Ft(null)
      , r = ei()
      , o = Ft([]);
    Mo(VF, bt({
      ...Wt(e)
    }));
    const a = yi((()=>o.value.some((e=>!0 === e.visible))))
      , i = e=>{
        const t = [];
        return h(e.children) && e.children.forEach((e=>{
            var n, r;
            e.type && "ElOption" === e.type.name && e.component && e.component.proxy ? t.push(e.component.proxy) : (null == (n = e.children) ? void 0 : n.length) ? t.push(...i(e)) : (null == (r = e.component) ? void 0 : r.subTree) && t.push(...i(e.component.subTree))
          }
        )),
          t
      }
      , s = ()=>{
        o.value = i(r.subTree)
      }
    ;
    return Lr((()=>{
        s()
      }
    )),
      qc(n, s, {
        attributes: !0,
        subtree: !0,
        childList: !0
      }),
      {
        groupRef: n,
        visible: a,
        ns: t
      }
  }
}), [["render", function(e, t, n, r, o, a) {
  return rr((Ca(),
    _a("ul", {
      ref: "groupRef",
      class: Y(e.ns.be("group", "wrap"))
    }, [Ma("li", {
      class: Y(e.ns.be("group", "title"))
    }, te(e.label), 3), Ma("li", null, [Ma("ul", {
      class: Y(e.ns.b("group"))
    }, [Qr(e.$slots, "default")], 2)])], 2)), [[$s, e.visible]])
}
], ["__file", "option-group.vue"]]);
const nB = vy(eB, {
  Option: zF,
  OptionGroup: tB
})
  , rB = my(zF)
  , oB = my(tB)
  , aB = ()=>jo(kF, {})
  , iB = uy({
  pageSize: {
    type: Number,
    required: !0
  },
  pageSizes: {
    type: Array,
    default: ()=>[10, 20, 30, 40, 50, 100]
  },
  popperClass: {
    type: String
  },
  disabled: Boolean,
  teleported: Boolean,
  size: {
    type: String,
    values: Cy
  }
})
  , sB = vr({
  name: "ElPaginationSizes"
})
  , lB = vr({
  ...sB,
  props: iB,
  emits: ["page-size-change"],
  setup(e, {emit: t}) {
    const n = e
      , {t: r} = Hy()
      , o = qy("pagination")
      , a = aB()
      , i = Ft(n.pageSize);
    Jn((()=>n.pageSizes), ((e,r)=>{
        if (!Ag(e, r) && Array.isArray(e)) {
          const r = e.includes(n.pageSize) ? n.pageSize : n.pageSizes[0];
          t("page-size-change", r)
        }
      }
    )),
      Jn((()=>n.pageSize), (e=>{
          i.value = e
        }
      ));
    const s = yi((()=>n.pageSizes));
    function l(e) {
      var t;
      e !== i.value && (i.value = e,
      null == (t = a.handleSizeChange) || t.call(a, Number(e)))
    }
    return (e,t)=>(Ca(),
      _a("span", {
        class: Y(Vt(o).e("sizes"))
      }, [ja(Vt(nB), {
        "model-value": i.value,
        disabled: e.disabled,
        "popper-class": e.popperClass,
        size: e.size,
        teleported: e.teleported,
        "validate-event": !1,
        onChange: l
      }, {
        default: Fn((()=>[(Ca(!0),
          _a(ba, null, Yr(Vt(s), (e=>(Ca(),
            Ra(Vt(rB), {
              key: e,
              value: e,
              label: e + Vt(r)("el.pagination.pagesize")
            }, null, 8, ["value", "label"])))), 128))])),
        _: 1
      }, 8, ["model-value", "disabled", "popper-class", "size", "teleported"])], 2))
  }
});
var uB = tS(lB, [["__file", "sizes.vue"]]);
const cB = uy({
  size: {
    type: String,
    values: Cy
  }
})
  , dB = ["disabled"]
  , fB = vr({
  name: "ElPaginationJumper"
})
  , pB = vr({
  ...fB,
  props: cB,
  setup(e) {
    const {t: t} = Hy()
      , n = qy("pagination")
      , {pageCount: r, disabled: o, currentPage: a, changeEvent: i} = aB()
      , s = Ft()
      , l = yi((()=>{
        var e;
        return null != (e = s.value) ? e : null == a ? void 0 : a.value
      }
    ));
    function u(e) {
      s.value = e ? +e : ""
    }
    function c(e) {
      e = Math.trunc(+e),
      null == i || i(e),
        s.value = void 0
    }
    return (e,a)=>(Ca(),
      _a("span", {
        class: Y(Vt(n).e("jump")),
        disabled: Vt(o)
      }, [Ma("span", {
        class: Y([Vt(n).e("goto")])
      }, te(Vt(t)("el.pagination.goto")), 3), ja(Vt(yE), {
        size: e.size,
        class: Y([Vt(n).e("editor"), Vt(n).is("in-pagination")]),
        min: 1,
        max: Vt(r),
        disabled: Vt(o),
        "model-value": Vt(l),
        "validate-event": !1,
        label: Vt(t)("el.pagination.page"),
        type: "number",
        "onUpdate:modelValue": u,
        onChange: c
      }, null, 8, ["size", "class", "max", "disabled", "model-value", "label"]), Ma("span", {
        class: Y([Vt(n).e("classifier")])
      }, te(Vt(t)("el.pagination.pageClassifier")), 3)], 10, dB))
  }
});
var hB = tS(pB, [["__file", "jumper.vue"]]);
const vB = uy({
  total: {
    type: Number,
    default: 1e3
  }
})
  , gB = ["disabled"]
  , mB = vr({
  name: "ElPaginationTotal"
})
  , yB = vr({
  ...mB,
  props: vB,
  setup(e) {
    const {t: t} = Hy()
      , n = qy("pagination")
      , {disabled: r} = aB();
    return (e,o)=>(Ca(),
      _a("span", {
        class: Y(Vt(n).e("total")),
        disabled: Vt(r)
      }, te(Vt(t)("el.pagination.total", {
        total: e.total
      })), 11, gB))
  }
});
var bB = tS(yB, [["__file", "total.vue"]]);
const wB = uy({
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    required: !0
  },
  pagerCount: {
    type: Number,
    default: 7
  },
  disabled: Boolean
})
  , xB = ["onKeyup"]
  , SB = ["aria-current", "aria-label", "tabindex"]
  , EB = ["tabindex", "aria-label"]
  , AB = ["aria-current", "aria-label", "tabindex"]
  , CB = ["tabindex", "aria-label"]
  , kB = ["aria-current", "aria-label", "tabindex"]
  , TB = vr({
  name: "ElPaginationPager"
})
  , DB = vr({
  ...TB,
  props: wB,
  emits: ["change"],
  setup(e, {emit: t}) {
    const n = e
      , r = qy("pager")
      , o = qy("icon")
      , {t: a} = Hy()
      , i = Ft(!1)
      , s = Ft(!1)
      , l = Ft(!1)
      , u = Ft(!1)
      , c = Ft(!1)
      , d = Ft(!1)
      , f = yi((()=>{
        const e = n.pagerCount
          , t = (e - 1) / 2
          , r = Number(n.currentPage)
          , o = Number(n.pageCount);
        let a = !1
          , i = !1;
        o > e && (r > e - t && (a = !0),
        r < o - t && (i = !0));
        const s = [];
        if (a && !i) {
          for (let t = o - (e - 2); t < o; t++)
            s.push(t)
        } else if (!a && i)
          for (let n = 2; n < e; n++)
            s.push(n);
        else if (a && i) {
          const t = Math.floor(e / 2) - 1;
          for (let e = r - t; e <= r + t; e++)
            s.push(e)
        } else
          for (let n = 2; n < o; n++)
            s.push(n);
        return s
      }
    ))
      , p = yi((()=>["more", "btn-quickprev", o.b(), r.is("disabled", n.disabled)]))
      , h = yi((()=>["more", "btn-quicknext", o.b(), r.is("disabled", n.disabled)]))
      , v = yi((()=>n.disabled ? -1 : 0));
    function g(e=!1) {
      n.disabled || (e ? l.value = !0 : u.value = !0)
    }
    function m(e=!1) {
      e ? c.value = !0 : d.value = !0
    }
    function y(e) {
      const r = e.target;
      if ("li" === r.tagName.toLowerCase() && Array.from(r.classList).includes("number")) {
        const e = Number(r.textContent);
        e !== n.currentPage && t("change", e)
      } else
        "li" === r.tagName.toLowerCase() && Array.from(r.classList).includes("more") && b(e)
    }
    function b(e) {
      const r = e.target;
      if ("ul" === r.tagName.toLowerCase() || n.disabled)
        return;
      let o = Number(r.textContent);
      const a = n.pageCount
        , i = n.currentPage
        , s = n.pagerCount - 2;
      r.className.includes("more") && (r.className.includes("quickprev") ? o = i - s : r.className.includes("quicknext") && (o = i + s)),
      Number.isNaN(+o) || (o < 1 && (o = 1),
      o > a && (o = a)),
      o !== i && t("change", o)
    }
    return qn((()=>{
        const e = (n.pagerCount - 1) / 2;
        i.value = !1,
          s.value = !1,
        n.pageCount > n.pagerCount && (n.currentPage > n.pagerCount - e && (i.value = !0),
        n.currentPage < n.pageCount - e && (s.value = !0))
      }
    )),
      (e,t)=>(Ca(),
        _a("ul", {
          class: Y(Vt(r).b()),
          onClick: b,
          onKeyup: Us(y, ["enter"])
        }, [e.pageCount > 0 ? (Ca(),
          _a("li", {
            key: 0,
            class: Y([[Vt(r).is("active", 1 === e.currentPage), Vt(r).is("disabled", e.disabled)], "number"]),
            "aria-current": 1 === e.currentPage,
            "aria-label": Vt(a)("el.pagination.currentPage", {
              pager: 1
            }),
            tabindex: Vt(v)
          }, " 1 ", 10, SB)) : za("v-if", !0), i.value ? (Ca(),
          _a("li", {
            key: 1,
            class: Y(Vt(p)),
            tabindex: Vt(v),
            "aria-label": Vt(a)("el.pagination.prevPages", {
              pager: e.pagerCount - 2
            }),
            onMouseenter: t[0] || (t[0] = e=>g(!0)),
            onMouseleave: t[1] || (t[1] = e=>l.value = !1),
            onFocus: t[2] || (t[2] = e=>m(!0)),
            onBlur: t[3] || (t[3] = e=>c.value = !1)
          }, [!l.value && !c.value || e.disabled ? (Ca(),
            Ra(Vt(Vm), {
              key: 1
            })) : (Ca(),
            Ra(Vt(Om), {
              key: 0
            }))], 42, EB)) : za("v-if", !0), (Ca(!0),
          _a(ba, null, Yr(Vt(f), (t=>(Ca(),
            _a("li", {
              key: t,
              class: Y([[Vt(r).is("active", e.currentPage === t), Vt(r).is("disabled", e.disabled)], "number"]),
              "aria-current": e.currentPage === t,
              "aria-label": Vt(a)("el.pagination.currentPage", {
                pager: t
              }),
              tabindex: Vt(v)
            }, te(t), 11, AB)))), 128)), s.value ? (Ca(),
          _a("li", {
            key: 2,
            class: Y(Vt(h)),
            tabindex: Vt(v),
            "aria-label": Vt(a)("el.pagination.nextPages", {
              pager: e.pagerCount - 2
            }),
            onMouseenter: t[4] || (t[4] = e=>g()),
            onMouseleave: t[5] || (t[5] = e=>u.value = !1),
            onFocus: t[6] || (t[6] = e=>m()),
            onBlur: t[7] || (t[7] = e=>d.value = !1)
          }, [!u.value && !d.value || e.disabled ? (Ca(),
            Ra(Vt(Vm), {
              key: 1
            })) : (Ca(),
            Ra(Vt(_m), {
              key: 0
            }))], 42, CB)) : za("v-if", !0), e.pageCount > 1 ? (Ca(),
          _a("li", {
            key: 3,
            class: Y([[Vt(r).is("active", e.currentPage === e.pageCount), Vt(r).is("disabled", e.disabled)], "number"]),
            "aria-current": e.currentPage === e.pageCount,
            "aria-label": Vt(a)("el.pagination.currentPage", {
              pager: e.pageCount
            }),
            tabindex: Vt(v)
          }, te(e.pageCount), 11, kB)) : za("v-if", !0)], 42, xB))
  }
});
var OB = tS(DB, [["__file", "pager.vue"]]);
const _B = e=>"number" != typeof e
  , RB = uy({
  pageSize: Number,
  defaultPageSize: Number,
  total: Number,
  pageCount: Number,
  pagerCount: {
    type: Number,
    validator: e=>Vg(e) && Math.trunc(e) === e && e > 4 && e < 22 && e % 2 == 1,
    default: 7
  },
  currentPage: Number,
  defaultCurrentPage: Number,
  layout: {
    type: String,
    default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
  },
  pageSizes: {
    type: Array,
    default: ()=>[10, 20, 30, 40, 50, 100]
  },
  popperClass: {
    type: String,
    default: ""
  },
  prevText: {
    type: String,
    default: ""
  },
  prevIcon: {
    type: cy,
    default: ()=>vm
  },
  nextText: {
    type: String,
    default: ""
  },
  nextIcon: {
    type: cy,
    default: ()=>gm
  },
  teleported: {
    type: Boolean,
    default: !0
  },
  small: Boolean,
  background: Boolean,
  disabled: Boolean,
  hideOnSinglePage: Boolean
})
  , LB = "ElPagination";
var IB = vr({
  name: LB,
  props: RB,
  emits: {
    "update:current-page": e=>Vg(e),
    "update:page-size": e=>Vg(e),
    "size-change": e=>Vg(e),
    change: (e,t)=>Vg(e) && Vg(t),
    "current-change": e=>Vg(e),
    "prev-click": e=>Vg(e),
    "next-click": e=>Vg(e)
  },
  setup(e, {emit: t, slots: n}) {
    const {t: r} = Hy()
      , o = qy("pagination")
      , a = ei().vnode.props || {}
      , i = "onUpdate:currentPage"in a || "onUpdate:current-page"in a || "onCurrentChange"in a
      , s = "onUpdate:pageSize"in a || "onUpdate:page-size"in a || "onSizeChange"in a
      , l = yi((()=>{
        if (_B(e.total) && _B(e.pageCount))
          return !1;
        if (!_B(e.currentPage) && !i)
          return !1;
        if (e.layout.includes("sizes"))
          if (_B(e.pageCount)) {
            if (!_B(e.total) && !_B(e.pageSize) && !s)
              return !1
          } else if (!s)
            return !1;
        return !0
      }
    ))
      , u = Ft(_B(e.defaultPageSize) ? 10 : e.defaultPageSize)
      , c = Ft(_B(e.defaultCurrentPage) ? 1 : e.defaultCurrentPage)
      , d = yi({
      get: ()=>_B(e.pageSize) ? u.value : e.pageSize,
      set(n) {
        _B(e.pageSize) && (u.value = n),
        s && (t("update:page-size", n),
          t("size-change", n))
      }
    })
      , f = yi((()=>{
        let t = 0;
        return _B(e.pageCount) ? _B(e.total) || (t = Math.max(1, Math.ceil(e.total / d.value))) : t = e.pageCount,
          t
      }
    ))
      , p = yi({
      get: ()=>_B(e.currentPage) ? c.value : e.currentPage,
      set(n) {
        let r = n;
        n < 1 ? r = 1 : n > f.value && (r = f.value),
        _B(e.currentPage) && (c.value = r),
        i && (t("update:current-page", r),
          t("current-change", r))
      }
    });
    function h(e) {
      p.value = e
    }
    function v() {
      e.disabled || (p.value -= 1,
        t("prev-click", p.value))
    }
    function g() {
      e.disabled || (p.value += 1,
        t("next-click", p.value))
    }
    function m(e, t) {
      e && (e.props || (e.props = {}),
        e.props.class = [e.props.class, t].join(" "))
    }
    return Jn(f, (e=>{
        p.value > e && (p.value = e)
      }
    )),
      Jn([p, d], (e=>{
          t("change", ...e)
        }
      ), {
        flush: "post"
      }),
      Mo(kF, {
        pageCount: f,
        disabled: yi((()=>e.disabled)),
        currentPage: p,
        changeEvent: h,
        handleSizeChange: function(e) {
          d.value = e;
          const t = f.value;
          p.value > t && (p.value = t)
        }
      }),
      ()=>{
        var t, a;
        if (!l.value)
          return r("el.pagination.deprecationWarning"),
            null;
        if (!e.layout)
          return null;
        if (e.hideOnSinglePage && f.value <= 1)
          return null;
        const i = []
          , s = []
          , u = bi("div", {
          class: o.e("rightwrapper")
        }, s)
          , c = {
          prev: bi(IF, {
            disabled: e.disabled,
            currentPage: p.value,
            prevText: e.prevText,
            prevIcon: e.prevIcon,
            onClick: v
          }),
          jumper: bi(hB, {
            size: e.small ? "small" : "default"
          }),
          pager: bi(OB, {
            currentPage: p.value,
            pageCount: f.value,
            pagerCount: e.pagerCount,
            onChange: h,
            disabled: e.disabled
          }),
          next: bi(jF, {
            disabled: e.disabled,
            currentPage: p.value,
            pageCount: f.value,
            nextText: e.nextText,
            nextIcon: e.nextIcon,
            onClick: g
          }),
          sizes: bi(uB, {
            pageSize: d.value,
            pageSizes: e.pageSizes,
            popperClass: e.popperClass,
            disabled: e.disabled,
            teleported: e.teleported,
            size: e.small ? "small" : "default"
          }),
          slot: null != (a = null == (t = null == n ? void 0 : n.default) ? void 0 : t.call(n)) ? a : null,
          total: bi(bB, {
            total: _B(e.total) ? 0 : e.total
          })
        }
          , y = e.layout.split(",").map((e=>e.trim()));
        let b = !1;
        return y.forEach((e=>{
            "->" !== e ? b ? s.push(c[e]) : i.push(c[e]) : b = !0
          }
        )),
          m(i[0], o.is("first")),
          m(i[i.length - 1], o.is("last")),
        b && s.length > 0 && (m(s[0], o.is("first")),
          m(s[s.length - 1], o.is("last")),
          i.push(u)),
          bi("div", {
            class: [o.b(), o.is("background", e.background), {
              [o.m("small")]: e.small
            }]
          }, i)
      }
  }
});
const PB = vy(IB)
  , FB = uy({
  title: String,
  confirmButtonText: String,
  cancelButtonText: String,
  confirmButtonType: {
    type: String,
    values: yC,
    default: "primary"
  },
  cancelButtonType: {
    type: String,
    values: yC,
    default: "text"
  },
  icon: {
    type: cy,
    default: ()=>zm
  },
  iconColor: {
    type: String,
    default: "#f90"
  },
  hideIcon: {
    type: Boolean,
    default: !1
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  teleported: SA.teleported,
  persistent: SA.persistent,
  width: {
    type: [String, Number],
    default: 150
  }
})
  , BB = {
  confirm: e=>e instanceof MouseEvent,
  cancel: e=>e instanceof MouseEvent
}
  , NB = vr({
  name: "ElPopconfirm"
})
  , MB = vr({
  ...NB,
  props: FB,
  emits: BB,
  setup(e, {emit: t}) {
    const n = e
      , {t: r} = Hy()
      , o = qy("popconfirm")
      , a = Ft()
      , i = ()=>{
      var e, t;
      null == (t = null == (e = a.value) ? void 0 : e.onClose) || t.call(e)
    }
      , s = yi((()=>({
      width: om(n.width)
    })))
      , l = e=>{
      t("confirm", e),
        i()
    }
      , u = e=>{
      t("cancel", e),
        i()
    }
      , c = yi((()=>n.confirmButtonText || r("el.popconfirm.confirmButtonText")))
      , d = yi((()=>n.cancelButtonText || r("el.popconfirm.cancelButtonText")));
    return (e,t)=>(Ca(),
      Ra(Vt(MA), qa({
        ref_key: "tooltipRef",
        ref: a,
        trigger: "click",
        effect: "light"
      }, e.$attrs, {
        "popper-class": `${Vt(o).namespace.value}-popover`,
        "popper-style": Vt(s),
        teleported: e.teleported,
        "fallback-placements": ["bottom", "top", "right", "left"],
        "hide-after": e.hideAfter,
        persistent: e.persistent
      }), {
        content: Fn((()=>[Ma("div", {
          class: Y(Vt(o).b())
        }, [Ma("div", {
          class: Y(Vt(o).e("main"))
        }, [!e.hideIcon && e.icon ? (Ca(),
          Ra(Vt(sS), {
            key: 0,
            class: Y(Vt(o).e("icon")),
            style: z({
              color: e.iconColor
            })
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(e.icon)))])),
            _: 1
          }, 8, ["class", "style"])) : za("v-if", !0), $a(" " + te(e.title), 1)], 2), Ma("div", {
          class: Y(Vt(o).e("action"))
        }, [ja(Vt(WC), {
          size: "small",
          type: "text" === e.cancelButtonType ? "" : e.cancelButtonType,
          text: "text" === e.cancelButtonType,
          onClick: u
        }, {
          default: Fn((()=>[$a(te(Vt(d)), 1)])),
          _: 1
        }, 8, ["type", "text"]), ja(Vt(WC), {
          size: "small",
          type: "text" === e.confirmButtonType ? "" : e.confirmButtonType,
          text: "text" === e.confirmButtonType,
          onClick: l
        }, {
          default: Fn((()=>[$a(te(Vt(c)), 1)])),
          _: 1
        }, 8, ["type", "text"])], 2)], 2)])),
        default: Fn((()=>[e.$slots.reference ? Qr(e.$slots, "reference", {
          key: 0
        }) : za("v-if", !0)])),
        _: 3
      }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]))
  }
});
const jB = vy(tS(MB, [["__file", "popconfirm.vue"]]))
  , VB = uy({
  trigger: EA.trigger,
  placement: OI.placement,
  disabled: EA.disabled,
  visible: SA.visible,
  transition: SA.transition,
  popperOptions: OI.popperOptions,
  tabindex: OI.tabindex,
  content: SA.content,
  popperStyle: SA.popperStyle,
  popperClass: SA.popperClass,
  enterable: {
    ...SA.enterable,
    default: !0
  },
  effect: {
    ...SA.effect,
    default: "light"
  },
  teleported: SA.teleported,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  "onUpdate:visible": {
    type: Function
  }
})
  , UB = {
  "update:visible": e=>jg(e),
  "before-enter": ()=>!0,
  "before-leave": ()=>!0,
  "after-enter": ()=>!0,
  "after-leave": ()=>!0
}
  , $B = vr({
  name: "ElPopover"
});
var HB = tS(vr({
  ...$B,
  props: VB,
  emits: UB,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = yi((()=>r["onUpdate:visible"]))
      , a = qy("popover")
      , i = Ft()
      , s = yi((()=>{
          var e;
          return null == (e = Vt(i)) ? void 0 : e.popperRef
        }
      ))
      , l = yi((()=>[{
        width: om(r.width)
      }, r.popperStyle]))
      , u = yi((()=>[a.b(), r.popperClass, {
        [a.m("plain")]: !!r.content
      }]))
      , c = yi((()=>r.transition === `${a.namespace.value}-fade-in-linear`))
      , d = ()=>{
        n("before-enter")
      }
      , f = ()=>{
        n("before-leave")
      }
      , p = ()=>{
        n("after-enter")
      }
      , h = ()=>{
        n("update:visible", !1),
          n("after-leave")
      }
    ;
    return t({
      popperRef: s,
      hide: ()=>{
        var e;
        null == (e = i.value) || e.hide()
      }
    }),
      (e,t)=>(Ca(),
        Ra(Vt(MA), qa({
          ref_key: "tooltipRef",
          ref: i
        }, e.$attrs, {
          trigger: e.trigger,
          placement: e.placement,
          disabled: e.disabled,
          visible: e.visible,
          transition: e.transition,
          "popper-options": e.popperOptions,
          tabindex: e.tabindex,
          content: e.content,
          offset: e.offset,
          "show-after": e.showAfter,
          "hide-after": e.hideAfter,
          "auto-close": e.autoClose,
          "show-arrow": e.showArrow,
          "aria-label": e.title,
          effect: e.effect,
          enterable: e.enterable,
          "popper-class": Vt(u),
          "popper-style": Vt(l),
          teleported: e.teleported,
          persistent: e.persistent,
          "gpu-acceleration": Vt(c),
          "onUpdate:visible": Vt(o),
          onBeforeShow: d,
          onBeforeHide: f,
          onShow: p,
          onHide: h
        }), {
          content: Fn((()=>[e.title ? (Ca(),
            _a("div", {
              key: 0,
              class: Y(Vt(a).e("title")),
              role: "title"
            }, te(e.title), 3)) : za("v-if", !0), Qr(e.$slots, "default", {}, (()=>[$a(te(e.content), 1)]))])),
          default: Fn((()=>[e.$slots.reference ? Qr(e.$slots, "reference", {
            key: 0
          }) : za("v-if", !0)])),
          _: 3
        }, 16, ["trigger", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "persistent", "gpu-acceleration", "onUpdate:visible"]))
  }
}), [["__file", "popover.vue"]]);
const zB = (e,t)=>{
    const n = t.arg || t.value
      , r = null == n ? void 0 : n.popperRef;
    r && (r.triggerRef = e)
  }
;
const KB = (GB = "popover",
  (WB = {
    mounted(e, t) {
      zB(e, t)
    },
    updated(e, t) {
      zB(e, t)
    }
  }).install = e=>{
    e.directive(GB, WB)
  }
  ,
  WB);
var WB, GB;
const qB = vy(HB, {
  directive: KB
})
  , YB = uy({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: e=>e >= 0 && e <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: String,
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: !1
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: !0
  },
  color: {
    type: [String, Array, Function],
    default: ""
  },
  striped: Boolean,
  stripedFlow: Boolean,
  format: {
    type: Function,
    default: e=>`${e}%`
  }
})
  , XB = ["aria-valuenow"]
  , QB = {
  viewBox: "0 0 100 100"
}
  , JB = ["d", "stroke", "stroke-linecap", "stroke-width"]
  , ZB = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"]
  , eN = {
  key: 0
}
  , tN = vr({
  name: "ElProgress"
})
  , nN = vr({
  ...tN,
  props: YB,
  setup(e) {
    const t = e
      , n = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    }
      , r = qy("progress")
      , o = yi((()=>({
      width: `${t.percentage}%`,
      animationDuration: `${t.duration}s`,
      backgroundColor: m(t.percentage)
    })))
      , a = yi((()=>(t.strokeWidth / t.width * 100).toFixed(1)))
      , i = yi((()=>["circle", "dashboard"].includes(t.type) ? Number.parseInt("" + (50 - Number.parseFloat(a.value) / 2), 10) : 0))
      , s = yi((()=>{
        const e = i.value
          , n = "dashboard" === t.type;
        return `\n          M 50 50\n          m 0 ${n ? "" : "-"}${e}\n          a ${e} ${e} 0 1 1 0 ${n ? "-" : ""}${2 * e}\n          a ${e} ${e} 0 1 1 0 ${n ? "" : "-"}${2 * e}\n          `
      }
    ))
      , l = yi((()=>2 * Math.PI * i.value))
      , u = yi((()=>"dashboard" === t.type ? .75 : 1))
      , c = yi((()=>`${-1 * l.value * (1 - u.value) / 2}px`))
      , d = yi((()=>({
      strokeDasharray: `${l.value * u.value}px, ${l.value}px`,
      strokeDashoffset: c.value
    })))
      , f = yi((()=>({
      strokeDasharray: `${l.value * u.value * (t.percentage / 100)}px, ${l.value}px`,
      strokeDashoffset: c.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    })))
      , p = yi((()=>{
        let e;
        return e = t.color ? m(t.percentage) : n[t.status] || n.default,
          e
      }
    ))
      , h = yi((()=>"warning" === t.status ? oy : "line" === t.type ? "success" === t.status ? Am : km : "success" === t.status ? Sm : Dm))
      , v = yi((()=>"line" === t.type ? 12 + .4 * t.strokeWidth : .111111 * t.width + 2))
      , g = yi((()=>t.format(t.percentage)));
    const m = e=>{
        var n;
        const {color: r} = t;
        if (y(r))
          return r(e);
        if (b(r))
          return r;
        {
          const t = function(e) {
            const t = 100 / e.length;
            return e.map(((e,n)=>b(e) ? {
              color: e,
              percentage: (n + 1) * t
            } : e)).sort(((e,t)=>e.percentage - t.percentage))
          }(r);
          for (const n of t)
            if (n.percentage > e)
              return n.color;
          return null == (n = t[t.length - 1]) ? void 0 : n.color
        }
      }
    ;
    return (e,t)=>(Ca(),
      _a("div", {
        class: Y([Vt(r).b(), Vt(r).m(e.type), Vt(r).is(e.status), {
          [Vt(r).m("without-text")]: !e.showText,
          [Vt(r).m("text-inside")]: e.textInside
        }]),
        role: "progressbar",
        "aria-valuenow": e.percentage,
        "aria-valuemin": "0",
        "aria-valuemax": "100"
      }, ["line" === e.type ? (Ca(),
        _a("div", {
          key: 0,
          class: Y(Vt(r).b("bar"))
        }, [Ma("div", {
          class: Y(Vt(r).be("bar", "outer")),
          style: z({
            height: `${e.strokeWidth}px`
          })
        }, [Ma("div", {
          class: Y([Vt(r).be("bar", "inner"), {
            [Vt(r).bem("bar", "inner", "indeterminate")]: e.indeterminate
          }, {
            [Vt(r).bem("bar", "inner", "striped")]: e.striped
          }, {
            [Vt(r).bem("bar", "inner", "striped-flow")]: e.stripedFlow
          }]),
          style: z(Vt(o))
        }, [(e.showText || e.$slots.default) && e.textInside ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(r).be("bar", "innerText"))
          }, [Qr(e.$slots, "default", {
            percentage: e.percentage
          }, (()=>[Ma("span", null, te(Vt(g)), 1)]))], 2)) : za("v-if", !0)], 6)], 6)], 2)) : (Ca(),
        _a("div", {
          key: 1,
          class: Y(Vt(r).b("circle")),
          style: z({
            height: `${e.width}px`,
            width: `${e.width}px`
          })
        }, [(Ca(),
          _a("svg", QB, [Ma("path", {
            class: Y(Vt(r).be("circle", "track")),
            d: Vt(s),
            stroke: `var(${Vt(r).cssVarName("fill-color-light")}, #e5e9f2)`,
            "stroke-linecap": e.strokeLinecap,
            "stroke-width": Vt(a),
            fill: "none",
            style: z(Vt(d))
          }, null, 14, JB), Ma("path", {
            class: Y(Vt(r).be("circle", "path")),
            d: Vt(s),
            stroke: Vt(p),
            fill: "none",
            opacity: e.percentage ? 1 : 0,
            "stroke-linecap": e.strokeLinecap,
            "stroke-width": Vt(a),
            style: z(Vt(f))
          }, null, 14, ZB)]))], 6)), !e.showText && !e.$slots.default || e.textInside ? za("v-if", !0) : (Ca(),
        _a("div", {
          key: 2,
          class: Y(Vt(r).e("text")),
          style: z({
            fontSize: `${Vt(v)}px`
          })
        }, [Qr(e.$slots, "default", {
          percentage: e.percentage
        }, (()=>[e.status ? (Ca(),
          Ra(Vt(sS), {
            key: 1
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(Vt(h))))])),
            _: 1
          })) : (Ca(),
          _a("span", eN, te(Vt(g)), 1))]))], 6))], 10, XB))
  }
});
const rN = vy(tS(nN, [["__file", "progress.vue"]]))
  , oN = uy({
  modelValue: {
    type: Number,
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  lowThreshold: {
    type: Number,
    default: 2
  },
  highThreshold: {
    type: Number,
    default: 4
  },
  max: {
    type: Number,
    default: 5
  },
  colors: {
    type: [Array, Object],
    default: ()=>["", "", ""]
  },
  voidColor: {
    type: String,
    default: ""
  },
  disabledVoidColor: {
    type: String,
    default: ""
  },
  icons: {
    type: [Array, Object],
    default: ()=>[Qm, Qm, Qm]
  },
  voidIcon: {
    type: cy,
    default: ()=>Jm
  },
  disabledVoidIcon: {
    type: cy,
    default: ()=>Qm
  },
  disabled: Boolean,
  allowHalf: Boolean,
  showText: Boolean,
  showScore: Boolean,
  textColor: {
    type: String,
    default: ""
  },
  texts: {
    type: Array,
    default: ()=>["Extremely bad", "Disappointed", "Fair", "Satisfied", "Surprise"]
  },
  scoreTemplate: {
    type: String,
    default: "{value}"
  },
  size: Ux,
  label: {
    type: String,
    default: void 0
  },
  clearable: {
    type: Boolean,
    default: !1
  }
})
  , aN = {
  [Sy]: e=>Vg(e),
  [xy]: e=>Vg(e)
}
  , iN = ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"]
  , sN = ["onMousemove", "onClick"]
  , lN = vr({
  name: "ElRate"
})
  , uN = vr({
  ...lN,
  props: oN,
  emits: aN,
  setup(e, {expose: t, emit: n}) {
    const r = e;
    function o(e, t) {
      const n = e=>x(e)
        , r = Object.keys(t).map((e=>+e)).filter((r=>{
          const o = t[r];
          return !!n(o) && o.excluded ? e < r : e <= r
        }
      )).sort(((e,t)=>e - t))
        , o = t[r[0]];
      return n(o) && o.value || o
    }
    const a = jo(fS, void 0)
      , i = jo(pS, void 0)
      , s = hS()
      , l = qy("rate")
      , {inputId: u, isLabeledByFormItem: c} = mS(r, {
      formItemContext: i
    })
      , d = Ft(r.modelValue)
      , f = Ft(-1)
      , p = Ft(!0)
      , v = yi((()=>[l.b(), l.m(s.value)]))
      , g = yi((()=>r.disabled || (null == a ? void 0 : a.disabled)))
      , m = yi((()=>l.cssVarBlock({
      "void-color": r.voidColor,
      "disabled-void-color": r.disabledVoidColor,
      "fill-color": E.value
    })))
      , y = yi((()=>{
        let e = "";
        return r.showScore ? e = r.scoreTemplate.replace(/\{\s*value\s*\}/, g.value ? `${r.modelValue}` : `${d.value}`) : r.showText && (e = r.texts[Math.ceil(d.value) - 1]),
          e
      }
    ))
      , w = yi((()=>100 * r.modelValue - 100 * Math.floor(r.modelValue)))
      , S = yi((()=>h(r.colors) ? {
      [r.lowThreshold]: r.colors[0],
      [r.highThreshold]: {
        value: r.colors[1],
        excluded: !0
      },
      [r.max]: r.colors[2]
    } : r.colors))
      , E = yi((()=>{
        const e = o(d.value, S.value);
        return x(e) ? "" : e
      }
    ))
      , A = yi((()=>{
        let e = "";
        return g.value ? e = `${w.value}%` : r.allowHalf && (e = "50%"),
          {
            color: E.value,
            width: e
          }
      }
    ))
      , C = yi((()=>{
        let e = h(r.icons) ? [...r.icons] : {
          ...r.icons
        };
        return e = Ot(e),
          h(e) ? {
            [r.lowThreshold]: e[0],
            [r.highThreshold]: {
              value: e[1],
              excluded: !0
            },
            [r.max]: e[2]
          } : e
      }
    ))
      , k = yi((()=>o(r.modelValue, C.value)))
      , T = yi((()=>g.value ? b(r.disabledVoidIcon) ? r.disabledVoidIcon : Ot(r.disabledVoidIcon) : b(r.voidIcon) ? r.voidIcon : Ot(r.voidIcon)))
      , D = yi((()=>o(d.value, C.value)));
    function O(e) {
      const t = g.value && w.value > 0 && e - 1 < r.modelValue && e > r.modelValue
        , n = r.allowHalf && p.value && e - .5 <= d.value && e > d.value;
      return t || n
    }
    function _(e) {
      r.clearable && e === r.modelValue && (e = 0),
        n(xy, e),
      r.modelValue !== e && n("change", e)
    }
    function R(e) {
      if (g.value)
        return;
      let t = d.value;
      const o = e.code;
      return o === by.up || o === by.right ? (r.allowHalf ? t += .5 : t += 1,
        e.stopPropagation(),
        e.preventDefault()) : o !== by.left && o !== by.down || (r.allowHalf ? t -= .5 : t -= 1,
        e.stopPropagation(),
        e.preventDefault()),
        t = t < 0 ? 0 : t,
        t = t > r.max ? r.max : t,
        n(xy, t),
        n("change", t),
        t
    }
    function L(e, t) {
      if (!g.value) {
        if (r.allowHalf && t) {
          let n = t.target;
          em(n, l.e("item")) && (n = n.querySelector(`.${l.e("icon")}`)),
          (0 === n.clientWidth || em(n, l.e("decimal"))) && (n = n.parentNode),
            p.value = 2 * t.offsetX <= n.clientWidth,
            d.value = p.value ? e - .5 : e
        } else
          d.value = e;
        f.value = e
      }
    }
    function I() {
      g.value || (r.allowHalf && (p.value = r.modelValue !== Math.floor(r.modelValue)),
        d.value = r.modelValue,
        f.value = -1)
    }
    return Jn((()=>r.modelValue), (e=>{
        d.value = e,
          p.value = r.modelValue !== Math.floor(r.modelValue)
      }
    )),
    r.modelValue || n(xy, 0),
      t({
        setCurrentValue: L,
        resetCurrentValue: I
      }),
      (e,t)=>{
        var n;
        return Ca(),
          _a("div", {
            id: Vt(u),
            class: Y([Vt(v), Vt(l).is("disabled", Vt(g))]),
            role: "slider",
            "aria-label": Vt(c) ? void 0 : e.label || "rating",
            "aria-labelledby": Vt(c) ? null == (n = Vt(i)) ? void 0 : n.labelId : void 0,
            "aria-valuenow": d.value,
            "aria-valuetext": Vt(y) || void 0,
            "aria-valuemin": "0",
            "aria-valuemax": e.max,
            tabindex: "0",
            style: z(Vt(m)),
            onKeydown: R
          }, [(Ca(!0),
            _a(ba, null, Yr(e.max, ((e,t)=>(Ca(),
              _a("span", {
                key: t,
                class: Y(Vt(l).e("item")),
                onMousemove: t=>L(e, t),
                onMouseleave: I,
                onClick: t=>{
                  return n = e,
                    void (g.value || (r.allowHalf && p.value ? _(d.value) : _(n)));
                  var n
                }
              }, [ja(Vt(sS), {
                class: Y([Vt(l).e("icon"), {
                  hover: f.value === e
                }, Vt(l).is("active", e <= d.value)])
              }, {
                default: Fn((()=>[O(e) ? za("v-if", !0) : (Ca(),
                  _a(ba, {
                    key: 0
                  }, [rr((Ca(),
                    Ra(Kr(Vt(D)), null, null, 512)), [[$s, e <= d.value]]), rr((Ca(),
                    Ra(Kr(Vt(T)), null, null, 512)), [[$s, !(e <= d.value)]])], 64)), O(e) ? (Ca(),
                  _a(ba, {
                    key: 1
                  }, [(Ca(),
                    Ra(Kr(Vt(T)), {
                      class: Y([Vt(l).em("decimal", "box")])
                    }, null, 8, ["class"])), ja(Vt(sS), {
                    style: z(Vt(A)),
                    class: Y([Vt(l).e("icon"), Vt(l).e("decimal")])
                  }, {
                    default: Fn((()=>[(Ca(),
                      Ra(Kr(Vt(k))))])),
                    _: 1
                  }, 8, ["style", "class"])], 64)) : za("v-if", !0)])),
                _: 2
              }, 1032, ["class"])], 42, sN)))), 128)), e.showText || e.showScore ? (Ca(),
            _a("span", {
              key: 0,
              class: Y(Vt(l).e("text")),
              style: z({
                color: e.textColor
              })
            }, te(Vt(y)), 7)) : za("v-if", !0)], 46, iN)
      }
  }
});
const cN = vy(tS(uN, [["__file", "rate.vue"]]))
  , dN = {
  success: "icon-success",
  warning: "icon-warning",
  error: "icon-error",
  info: "icon-info"
}
  , fN = {
  [dN.success]: Em,
  [dN.warning]: oy,
  [dN.error]: Cm,
  [dN.info]: Nm
}
  , pN = uy({
  title: {
    type: String,
    default: ""
  },
  subTitle: {
    type: String,
    default: ""
  },
  icon: {
    type: String,
    values: ["success", "warning", "info", "error"],
    default: "info"
  }
})
  , hN = vr({
  name: "ElResult"
});
const vN = vy(tS(vr({
  ...hN,
  props: pN,
  setup(e) {
    const t = e
      , n = qy("result")
      , r = yi((()=>{
        const e = t.icon
          , n = e && dN[e] ? dN[e] : "icon-info";
        return {
          class: n,
          component: fN[n] || fN["icon-info"]
        }
      }
    ));
    return (e,t)=>(Ca(),
      _a("div", {
        class: Y(Vt(n).b())
      }, [Ma("div", {
        class: Y(Vt(n).e("icon"))
      }, [Qr(e.$slots, "icon", {}, (()=>[Vt(r).component ? (Ca(),
        Ra(Kr(Vt(r).component), {
          key: 0,
          class: Y(Vt(r).class)
        }, null, 8, ["class"])) : za("v-if", !0)]))], 2), e.title || e.$slots.title ? (Ca(),
        _a("div", {
          key: 0,
          class: Y(Vt(n).e("title"))
        }, [Qr(e.$slots, "title", {}, (()=>[Ma("p", null, te(e.title), 1)]))], 2)) : za("v-if", !0), e.subTitle || e.$slots["sub-title"] ? (Ca(),
        _a("div", {
          key: 1,
          class: Y(Vt(n).e("subtitle"))
        }, [Qr(e.$slots, "sub-title", {}, (()=>[Ma("p", null, te(e.subTitle), 1)]))], 2)) : za("v-if", !0), e.$slots.extra ? (Ca(),
        _a("div", {
          key: 2,
          class: Y(Vt(n).e("extra"))
        }, [Qr(e.$slots, "extra")], 2)) : za("v-if", !0)], 2))
  }
}), [["__file", "result.vue"]]));
var gN = Number.isNaN || function(e) {
    return "number" == typeof e && e != e
  }
;
function mN(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (r = e[n],
      o = t[n],
      !(r === o || gN(r) && gN(o)))
      return !1;
  var r, o;
  return !0
}
const yN = ()=>{
  const e = ei().proxy.$props;
  return yi((()=>{
      const t = (e,t,n)=>({});
      return e.perfMode ? Ep(t) : function(e, t) {
        void 0 === t && (t = mN);
        var n = null;
        function r() {
          for (var r = [], o = 0; o < arguments.length; o++)
            r[o] = arguments[o];
          if (n && n.lastThis === this && t(r, n.lastArgs))
            return n.lastResult;
          var a = e.apply(this, r);
          return n = {
            lastResult: a,
            lastArgs: r,
            lastThis: this
          },
            a
        }
        return r.clear = function() {
          n = null
        }
          ,
          r
      }(t)
    }
  ))
}
  , bN = "itemRendered"
  , wN = "scroll"
  , xN = "forward"
  , SN = "backward"
  , EN = "auto"
  , AN = "smart"
  , CN = "start"
  , kN = "center"
  , TN = "end"
  , DN = "horizontal"
  , ON = "vertical"
  , _N = "rtl"
  , RN = "negative"
  , LN = "positive-ascending"
  , IN = "positive-descending"
  , PN = {
  [DN]: "left",
  [ON]: "top"
}
  , FN = {
  [DN]: "deltaX",
  [ON]: "deltaY"
}
  , BN = ly({
  type: [Number, Function],
  required: !0
})
  , NN = ly({
  type: Number
})
  , MN = ly({
  type: Number,
  default: 2
})
  , jN = ly({
  type: String,
  values: ["ltr", "rtl"],
  default: "ltr"
})
  , VN = ly({
  type: Number,
  default: 0
})
  , UN = ly({
  type: Number,
  required: !0
})
  , $N = ly({
  type: String,
  values: ["horizontal", "vertical"],
  default: ON
})
  , HN = uy({
  className: {
    type: String,
    default: ""
  },
  containerElement: {
    type: [String, Object],
    default: "div"
  },
  data: {
    type: Array,
    default: ()=>[]
  },
  direction: jN,
  height: {
    type: [String, Number],
    required: !0
  },
  innerElement: {
    type: [String, Object],
    default: "div"
  },
  style: {
    type: [Object, String, Array]
  },
  useIsScrolling: {
    type: Boolean,
    default: !1
  },
  width: {
    type: [Number, String],
    required: !1
  },
  perfMode: {
    type: Boolean,
    default: !0
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: !1
  }
})
  , zN = uy({
  cache: MN,
  estimatedItemSize: NN,
  layout: $N,
  initScrollOffset: VN,
  total: UN,
  itemSize: BN,
  ...HN
})
  , KN = {
  type: Number,
  default: 6
}
  , WN = {
  type: Number,
  default: 0
}
  , GN = {
  type: Number,
  default: 2
}
  , qN = uy({
  columnCache: MN,
  columnWidth: BN,
  estimatedColumnWidth: NN,
  estimatedRowHeight: NN,
  initScrollLeft: VN,
  initScrollTop: VN,
  itemKey: {
    type: Function,
    default: ({columnIndex: e, rowIndex: t})=>`${t}:${e}`
  },
  rowCache: MN,
  rowHeight: BN,
  totalColumn: UN,
  totalRow: UN,
  hScrollbarSize: KN,
  vScrollbarSize: KN,
  scrollbarStartGap: WN,
  scrollbarEndGap: GN,
  role: String,
  ...HN
})
  , YN = uy({
  alwaysOn: Boolean,
  class: String,
  layout: $N,
  total: UN,
  ratio: {
    type: Number,
    required: !0
  },
  clientSize: {
    type: Number,
    required: !0
  },
  scrollFrom: {
    type: Number,
    required: !0
  },
  scrollbarSize: KN,
  startGap: WN,
  endGap: GN,
  visible: Boolean
})
  , XN = (e,t)=>e < t ? xN : SN
  , QN = e=>"ltr" === e || e === _N || e === DN
  , JN = e=>e === _N;
let ZN = null;
function eM(e=!1) {
  if (null === ZN || e) {
    const e = document.createElement("div")
      , t = e.style;
    t.width = "50px",
      t.height = "50px",
      t.overflow = "scroll",
      t.direction = "rtl";
    const n = document.createElement("div")
      , r = n.style;
    return r.width = "100px",
      r.height = "100px",
      e.appendChild(n),
      document.body.appendChild(e),
      e.scrollLeft > 0 ? ZN = IN : (e.scrollLeft = 1,
        ZN = 0 === e.scrollLeft ? RN : LN),
      document.body.removeChild(e),
      ZN
  }
  return ZN
}
const tM = vr({
  name: "ElVirtualScrollBar",
  props: YN,
  emits: ["scroll", "start-move", "stop-move"],
  setup(e, {emit: t}) {
    const n = yi((()=>e.startGap + e.endGap))
      , r = qy("virtual-scrollbar")
      , o = qy("scrollbar")
      , a = Ft()
      , i = Ft();
    let s = null
      , l = null;
    const u = bt({
        isDragging: !1,
        traveled: 0
      })
      , c = yi((()=>bE[e.layout]))
      , d = yi((()=>e.clientSize - Vt(n)))
      , f = yi((()=>({
        position: "absolute",
        width: `${DN === e.layout ? d.value : e.scrollbarSize}px`,
        height: `${DN === e.layout ? e.scrollbarSize : d.value}px`,
        [PN[e.layout]]: "2px",
        right: "2px",
        bottom: "2px",
        borderRadius: "4px"
      })))
      , p = yi((()=>{
          const t = e.ratio
            , n = e.clientSize;
          if (t >= 100)
            return Number.POSITIVE_INFINITY;
          if (t >= 50)
            return t * n / 100;
          const r = n / 3;
          return Math.floor(Math.min(Math.max(t * n, 20), r))
        }
      ))
      , h = yi((()=>{
          if (!Number.isFinite(p.value))
            return {
              display: "none"
            };
          const t = `${p.value}px`
            , n = function({move: e, size: t, bar: n}, r) {
            const o = {}
              , a = `translate${n.axis}(${e}px)`;
            return o[n.size] = t,
              o.transform = a,
              o.msTransform = a,
              o.webkitTransform = a,
              "horizontal" === r ? o.height = "100%" : o.width = "100%",
              o
          }({
            bar: c.value,
            size: t,
            move: u.traveled
          }, e.layout);
          return n
        }
      ))
      , v = yi((()=>Math.floor(e.clientSize - p.value - Vt(n))))
      , g = ()=>{
        window.removeEventListener("mousemove", b),
          window.removeEventListener("mouseup", y),
          document.onselectstart = l,
          l = null;
        const e = Vt(i);
        e && (e.removeEventListener("touchmove", b),
          e.removeEventListener("touchend", y))
      }
      , m = e=>{
        e.stopImmediatePropagation(),
        e.ctrlKey || [1, 2].includes(e.button) || (u.isDragging = !0,
          u[c.value.axis] = e.currentTarget[c.value.offset] - (e[c.value.client] - e.currentTarget.getBoundingClientRect()[c.value.direction]),
          t("start-move"),
          (()=>{
              window.addEventListener("mousemove", b),
                window.addEventListener("mouseup", y);
              const e = Vt(i);
              e && (l = document.onselectstart,
                document.onselectstart = ()=>!1,
                e.addEventListener("touchmove", b),
                e.addEventListener("touchend", y))
            }
          )())
      }
      , y = ()=>{
        u.isDragging = !1,
          u[c.value.axis] = 0,
          t("stop-move"),
          g()
      }
      , b = n=>{
        const {isDragging: r} = u;
        if (!r)
          return;
        if (!i.value || !a.value)
          return;
        const o = u[c.value.axis];
        if (!o)
          return;
        Wg(s);
        const l = -1 * (a.value.getBoundingClientRect()[c.value.direction] - n[c.value.client]) - (i.value[c.value.offset] - o);
        s = Kg((()=>{
            u.traveled = Math.max(e.startGap, Math.min(l, v.value)),
              t("scroll", l, v.value)
          }
        ))
      }
      , w = e=>{
        const n = Math.abs(e.target.getBoundingClientRect()[c.value.direction] - e[c.value.client]) - i.value[c.value.offset] / 2;
        u.traveled = Math.max(0, Math.min(n, v.value)),
          t("scroll", n, v.value)
      }
    ;
    return Jn((()=>e.scrollFrom), (e=>{
        u.isDragging || (u.traveled = Math.ceil(e * v.value))
      }
    )),
      Fr((()=>{
          g()
        }
      )),
      ()=>bi("div", {
        role: "presentation",
        ref: a,
        class: [r.b(), e.class, (e.alwaysOn || u.isDragging) && "always-on"],
        style: f.value,
        onMousedown: js(w, ["stop", "prevent"]),
        onTouchstartPrevent: m
      }, bi("div", {
        ref: i,
        class: o.e("thumb"),
        style: h.value,
        onMousedown: m
      }, []))
  }
})
  , nM = ({name: e, getOffset: t, getItemSize: n, getItemOffset: r, getEstimatedTotalSize: o, getStartIndexForOffset: a, getStopIndexForStartIndex: i, initCache: s, clearCache: l, validateProps: u})=>vr({
  name: null != e ? e : "ElVirtualList",
  props: zN,
  emits: [bN, wN],
  setup(e, {emit: c, expose: d}) {
    u(e);
    const f = ei()
      , h = qy("vl")
      , v = Ft(s(e, f))
      , g = yN()
      , m = Ft()
      , y = Ft()
      , b = Ft()
      , w = Ft({
        isScrolling: !1,
        scrollDir: "forward",
        scrollOffset: Vg(e.initScrollOffset) ? e.initScrollOffset : 0,
        updateRequested: !1,
        isScrollbarDragging: !1,
        scrollbarAlwaysOn: e.scrollbarAlwaysOn
      })
      , x = yi((()=>{
          const {total: t, cache: n} = e
            , {isScrolling: r, scrollDir: o, scrollOffset: s} = Vt(w);
          if (0 === t)
            return [0, 0, 0, 0];
          const l = a(e, s, Vt(v))
            , u = i(e, l, s, Vt(v))
            , c = r && o !== SN ? 1 : Math.max(1, n)
            , d = r && o !== xN ? 1 : Math.max(1, n);
          return [Math.max(0, l - c), Math.max(0, Math.min(t - 1, u + d)), l, u]
        }
      ))
      , S = yi((()=>o(e, Vt(v))))
      , E = yi((()=>QN(e.layout)))
      , A = yi((()=>[{
        position: "relative",
        ["overflow-" + (E.value ? "x" : "y")]: "scroll",
        WebkitOverflowScrolling: "touch",
        willChange: "transform"
      }, {
        direction: e.direction,
        height: Vg(e.height) ? `${e.height}px` : e.height,
        width: Vg(e.width) ? `${e.width}px` : e.width
      }, e.style]))
      , C = yi((()=>{
          const e = Vt(S)
            , t = Vt(E);
          return {
            height: t ? "100%" : `${e}px`,
            pointerEvents: Vt(w).isScrolling ? "none" : void 0,
            width: t ? `${e}px` : "100%"
          }
        }
      ))
      , k = yi((()=>E.value ? e.width : e.height))
      , {onWheel: T} = (({atEndEdge: e, atStartEdge: t, layout: n},r)=>{
          let o, a = 0;
          const i = n=>n < 0 && t.value || n > 0 && e.value;
          return {
            hasReachedEdge: i,
            onWheel: e=>{
              Wg(o);
              const t = e[FN[n.value]];
              i(a) && i(a + t) || (a += t,
              td() || e.preventDefault(),
                o = Kg((()=>{
                    r(a),
                      a = 0
                  }
                )))
            }
          }
        }
      )({
        atStartEdge: yi((()=>w.value.scrollOffset <= 0)),
        atEndEdge: yi((()=>w.value.scrollOffset >= S.value)),
        layout: yi((()=>e.layout))
      }, (e=>{
          var t, n;
          null == (n = (t = b.value).onMouseUp) || n.call(t),
            O(Math.min(w.value.scrollOffset + e, S.value - k.value))
        }
      ))
      , D = ()=>{
        const {total: t} = e;
        if (t > 0) {
          const [e,t,n,r] = Vt(x);
          c(bN, e, t, n, r)
        }
        const {scrollDir: n, scrollOffset: r, updateRequested: o} = Vt(w);
        c(wN, n, r, o)
      }
      , O = e=>{
        (e = Math.max(e, 0)) !== Vt(w).scrollOffset && (w.value = {
          ...Vt(w),
          scrollOffset: e,
          scrollDir: XN(Vt(w).scrollOffset, e),
          updateRequested: !0
        },
          hn(R))
      }
      , _ = (n,r=EN)=>{
        const {scrollOffset: o} = Vt(w);
        n = Math.max(0, Math.min(n, e.total - 1)),
          O(t(e, n, r, o, Vt(v)))
      }
      , R = ()=>{
        w.value.isScrolling = !1,
          hn((()=>{
              g.value(-1, null, null)
            }
          ))
      }
      , L = ()=>{
        const e = m.value;
        e && (e.scrollTop = 0)
      }
    ;
    Lr((()=>{
        if (!mc)
          return;
        const {initScrollOffset: t} = e
          , n = Vt(m);
        Vg(t) && n && (Vt(E) ? n.scrollLeft = t : n.scrollTop = t),
          D()
      }
    )),
      Pr((()=>{
          const {direction: t, layout: n} = e
            , {scrollOffset: r, updateRequested: o} = Vt(w)
            , a = Vt(m);
          if (o && a)
            if (n === DN)
              if (t === _N)
                switch (eM()) {
                  case RN:
                    a.scrollLeft = -r;
                    break;
                  case LN:
                    a.scrollLeft = r;
                    break;
                  default:
                  {
                    const {clientWidth: e, scrollWidth: t} = a;
                    a.scrollLeft = t - e - r;
                    break
                  }
                }
              else
                a.scrollLeft = r;
            else
              a.scrollTop = r
        }
      ));
    const I = {
      ns: h,
      clientSize: k,
      estimatedTotalSize: S,
      windowStyle: A,
      windowRef: m,
      innerRef: y,
      innerStyle: C,
      itemsToRender: x,
      scrollbarRef: b,
      states: w,
      getItemStyle: t=>{
        const {direction: o, itemSize: a, layout: i} = e
          , s = g.value(l && a, l && i, l && o);
        let u;
        if (p(s, String(t)))
          u = s[t];
        else {
          const a = r(e, t, Vt(v))
            , i = n(e, t, Vt(v))
            , l = Vt(E)
            , c = o === _N
            , d = l ? a : 0;
          s[t] = u = {
            position: "absolute",
            left: c ? void 0 : `${d}px`,
            right: c ? `${d}px` : void 0,
            top: l ? 0 : `${a}px`,
            height: l ? "100%" : `${i}px`,
            width: l ? `${i}px` : "100%"
          }
        }
        return u
      }
      ,
      onScroll: t=>{
        Vt(E) ? (t=>{
            const {clientWidth: n, scrollLeft: r, scrollWidth: o} = t.currentTarget
              , a = Vt(w);
            if (a.scrollOffset === r)
              return;
            const {direction: i} = e;
            let s = r;
            if (i === _N)
              switch (eM()) {
                case RN:
                  s = -r;
                  break;
                case IN:
                  s = o - n - r
              }
            s = Math.max(0, Math.min(s, o - n)),
              w.value = {
                ...a,
                isScrolling: !0,
                scrollDir: XN(a.scrollOffset, s),
                scrollOffset: s,
                updateRequested: !1
              },
              hn(R)
          }
        )(t) : (e=>{
            const {clientHeight: t, scrollHeight: n, scrollTop: r} = e.currentTarget
              , o = Vt(w);
            if (o.scrollOffset === r)
              return;
            const a = Math.max(0, Math.min(r, n - t));
            w.value = {
              ...o,
              isScrolling: !0,
              scrollDir: XN(o.scrollOffset, a),
              scrollOffset: a,
              updateRequested: !1
            },
              hn(R)
          }
        )(t),
          D()
      }
      ,
      onScrollbarScroll: (e,t)=>{
        const n = (S.value - k.value) / t * e;
        O(Math.min(S.value - k.value, n))
      }
      ,
      onWheel: T,
      scrollTo: O,
      scrollToItem: _,
      resetScrollTop: L
    };
    return d({
      windowRef: m,
      innerRef: y,
      getItemStyleCache: g,
      scrollTo: O,
      scrollToItem: _,
      resetScrollTop: L,
      states: w
    }),
      I
  },
  render(e) {
    var t;
    const {$slots: n, className: r, clientSize: o, containerElement: a, data: i, getItemStyle: s, innerElement: l, itemsToRender: u, innerStyle: c, layout: d, total: f, onScroll: p, onScrollbarScroll: h, onWheel: v, states: g, useIsScrolling: m, windowStyle: y, ns: w} = e
      , [x,S] = u
      , E = Kr(a)
      , A = Kr(l)
      , C = [];
    if (f > 0)
      for (let b = x; b <= S; b++)
        C.push(null == (t = n.default) ? void 0 : t.call(n, {
          data: i,
          key: b,
          index: b,
          isScrolling: m ? g.isScrolling : void 0,
          style: s(b)
        }));
    const k = [bi(A, {
      style: c,
      ref: "innerRef"
    }, b(A) ? C : {
      default: ()=>C
    })]
      , T = bi(tM, {
      ref: "scrollbarRef",
      clientSize: o,
      layout: d,
      onScroll: h,
      ratio: 100 * o / this.estimatedTotalSize,
      scrollFrom: g.scrollOffset / (this.estimatedTotalSize - o),
      total: f
    })
      , D = bi(E, {
      class: [w.e("window"), r],
      style: y,
      onScroll: p,
      onWheel: v,
      ref: "windowRef",
      key: 0
    }, b(E) ? [k] : {
      default: ()=>[k]
    });
    return bi("div", {
      key: 0,
      class: [w.e("wrapper"), g.scrollbarAlwaysOn ? "always-on" : ""]
    }, [D, T])
  }
})
  , rM = nM({
  name: "ElFixedSizeList",
  getItemOffset: ({itemSize: e},t)=>t * e,
  getItemSize: ({itemSize: e})=>e,
  getEstimatedTotalSize: ({total: e, itemSize: t})=>t * e,
  getOffset: ({height: e, total: t, itemSize: n, layout: r, width: o},a,i,s)=>{
    const l = QN(r) ? o : e
      , u = Math.max(0, t * n - l)
      , c = Math.min(u, a * n)
      , d = Math.max(0, (a + 1) * n - l);
    switch (i === AN && (i = s >= d - l && s <= c + l ? EN : kN),
      i) {
      case CN:
        return c;
      case TN:
        return d;
      case kN:
      {
        const e = Math.round(d + (c - d) / 2);
        return e < Math.ceil(l / 2) ? 0 : e > u + Math.floor(l / 2) ? u : e
      }
      default:
        return s >= d && s <= c ? s : s < d ? d : c
    }
  }
  ,
  getStartIndexForOffset: ({total: e, itemSize: t},n)=>Math.max(0, Math.min(e - 1, Math.floor(n / t))),
  getStopIndexForStartIndex: ({height: e, total: t, itemSize: n, layout: r, width: o},a,i)=>{
    const s = a * n
      , l = QN(r) ? o : e
      , u = Math.ceil((l + i - s) / n);
    return Math.max(0, Math.min(t - 1, a + u - 1))
  }
  ,
  initCache() {},
  clearCache: !0,
  validateProps() {}
})
  , oM = (e,t,n)=>{
  const {itemSize: r} = e
    , {items: o, lastVisitedIndex: a} = n;
  if (t > a) {
    let e = 0;
    if (a >= 0) {
      const t = o[a];
      e = t.offset + t.size
    }
    for (let n = a + 1; n <= t; n++) {
      const t = r(n);
      o[n] = {
        offset: e,
        size: t
      },
        e += t
    }
    n.lastVisitedIndex = t
  }
  return o[t]
}
  , aM = (e,t,n,r,o)=>{
  for (; n <= r; ) {
    const a = n + Math.floor((r - n) / 2)
      , i = oM(e, a, t).offset;
    if (i === o)
      return a;
    i < o ? n = a + 1 : i > o && (r = a - 1)
  }
  return Math.max(0, n - 1)
}
  , iM = (e,t,n,r)=>{
  const {total: o} = e;
  let a = 1;
  for (; n < o && oM(e, n, t).offset < r; )
    n += a,
      a *= 2;
  return aM(e, t, Math.floor(n / 2), Math.min(n, o - 1), r)
}
  , sM = ({total: e},{items: t, estimatedItemSize: n, lastVisitedIndex: r})=>{
  let o = 0;
  if (r >= e && (r = e - 1),
  r >= 0) {
    const e = t[r];
    o = e.offset + e.size
  }
  return o + (e - r - 1) * n
}
  , lM = nM({
  name: "ElDynamicSizeList",
  getItemOffset: (e,t,n)=>oM(e, t, n).offset,
  getItemSize: (e,t,{items: n})=>n[t].size,
  getEstimatedTotalSize: sM,
  getOffset: (e,t,n,r,o)=>{
    const {height: a, layout: i, width: s} = e
      , l = QN(i) ? s : a
      , u = oM(e, t, o)
      , c = sM(e, o)
      , d = Math.max(0, Math.min(c - l, u.offset))
      , f = Math.max(0, u.offset - l + u.size);
    switch (n === AN && (n = r >= f - l && r <= d + l ? EN : kN),
      n) {
      case CN:
        return d;
      case TN:
        return f;
      case kN:
        return Math.round(f + (d - f) / 2);
      default:
        return r >= f && r <= d ? r : r < f ? f : d
    }
  }
  ,
  getStartIndexForOffset: (e,t,n)=>((e,t,n)=>{
      const {items: r, lastVisitedIndex: o} = t;
      return (o > 0 ? r[o].offset : 0) >= n ? aM(e, t, 0, o, n) : iM(e, t, Math.max(0, o), n)
    }
  )(e, n, t),
  getStopIndexForStartIndex: (e,t,n,r)=>{
    const {height: o, total: a, layout: i, width: s} = e
      , l = QN(i) ? s : o
      , u = oM(e, t, r)
      , c = n + l;
    let d = u.offset + u.size
      , f = t;
    for (; f < a - 1 && d < c; )
      f++,
        d += oM(e, f, r).size;
    return f
  }
  ,
  initCache({estimatedItemSize: e=50}, t) {
    const n = {
      items: {},
      estimatedItemSize: e,
      lastVisitedIndex: -1,
      clearCacheAfterIndex: (e,r=!0)=>{
        var o, a;
        n.lastVisitedIndex = Math.min(n.lastVisitedIndex, e - 1),
        null == (o = t.exposed) || o.getItemStyleCache(-1),
        r && (null == (a = t.proxy) || a.$forceUpdate())
      }
    };
    return n
  },
  clearCache: !1,
  validateProps: ({itemSize: e})=>{}
})
  , uM = ({name: e, clearCache: t, getColumnPosition: n, getColumnStartIndexForOffset: r, getColumnStopIndexForStartIndex: o, getEstimatedTotalHeight: a, getEstimatedTotalWidth: i, getColumnOffset: s, getRowOffset: l, getRowPosition: u, getRowStartIndexForOffset: c, getRowStopIndexForStartIndex: d, initCache: f, injectToInstance: h, validateProps: v})=>vr({
  name: null != e ? e : "ElVirtualList",
  props: qN,
  emits: [bN, wN],
  setup(e, {emit: g, expose: m, slots: y}) {
    const w = qy("vl");
    v(e);
    const x = ei()
      , S = Ft(f(e, x));
    null == h || h(x, S);
    const E = Ft()
      , A = Ft()
      , C = Ft()
      , k = Ft(null)
      , T = Ft({
        isScrolling: !1,
        scrollLeft: Vg(e.initScrollLeft) ? e.initScrollLeft : 0,
        scrollTop: Vg(e.initScrollTop) ? e.initScrollTop : 0,
        updateRequested: !1,
        xAxisScrollDir: xN,
        yAxisScrollDir: xN
      })
      , D = yN()
      , O = yi((()=>Number.parseInt(`${e.height}`, 10)))
      , _ = yi((()=>Number.parseInt(`${e.width}`, 10)))
      , R = yi((()=>{
          const {totalColumn: t, totalRow: n, columnCache: a} = e
            , {isScrolling: i, xAxisScrollDir: s, scrollLeft: l} = Vt(T);
          if (0 === t || 0 === n)
            return [0, 0, 0, 0];
          const u = r(e, l, Vt(S))
            , c = o(e, u, l, Vt(S))
            , d = i && s !== SN ? 1 : Math.max(1, a)
            , f = i && s !== xN ? 1 : Math.max(1, a);
          return [Math.max(0, u - d), Math.max(0, Math.min(t - 1, c + f)), u, c]
        }
      ))
      , L = yi((()=>{
          const {totalColumn: t, totalRow: n, rowCache: r} = e
            , {isScrolling: o, yAxisScrollDir: a, scrollTop: i} = Vt(T);
          if (0 === t || 0 === n)
            return [0, 0, 0, 0];
          const s = c(e, i, Vt(S))
            , l = d(e, s, i, Vt(S))
            , u = o && a !== SN ? 1 : Math.max(1, r)
            , f = o && a !== xN ? 1 : Math.max(1, r);
          return [Math.max(0, s - u), Math.max(0, Math.min(n - 1, l + f)), s, l]
        }
      ))
      , I = yi((()=>a(e, Vt(S))))
      , P = yi((()=>i(e, Vt(S))))
      , F = yi((()=>{
          var t;
          return [{
            position: "relative",
            overflow: "hidden",
            WebkitOverflowScrolling: "touch",
            willChange: "transform"
          }, {
            direction: e.direction,
            height: Vg(e.height) ? `${e.height}px` : e.height,
            width: Vg(e.width) ? `${e.width}px` : e.width
          }, null != (t = e.style) ? t : {}]
        }
      ))
      , B = yi((()=>{
          const e = `${Vt(P)}px`;
          return {
            height: `${Vt(I)}px`,
            pointerEvents: Vt(T).isScrolling ? "none" : void 0,
            width: e
          }
        }
      ))
      , N = ()=>{
        const {totalColumn: t, totalRow: n} = e;
        if (t > 0 && n > 0) {
          const [e,t,n,r] = Vt(R)
            , [o,a,i,s] = Vt(L);
          g(bN, {
            columnCacheStart: e,
            columnCacheEnd: t,
            rowCacheStart: o,
            rowCacheEnd: a,
            columnVisibleStart: n,
            columnVisibleEnd: r,
            rowVisibleStart: i,
            rowVisibleEnd: s
          })
        }
        const {scrollLeft: r, scrollTop: o, updateRequested: a, xAxisScrollDir: i, yAxisScrollDir: s} = Vt(T);
        g(wN, {
          xAxisScrollDir: i,
          scrollLeft: r,
          yAxisScrollDir: s,
          scrollTop: o,
          updateRequested: a
        })
      }
      , M = t=>{
        const {clientHeight: n, clientWidth: r, scrollHeight: o, scrollLeft: a, scrollTop: i, scrollWidth: s} = t.currentTarget
          , l = Vt(T);
        if (l.scrollTop === i && l.scrollLeft === a)
          return;
        let u = a;
        if (JN(e.direction))
          switch (eM()) {
            case RN:
              u = -a;
              break;
            case IN:
              u = s - r - a
          }
        T.value = {
          ...l,
          isScrolling: !0,
          scrollLeft: u,
          scrollTop: Math.max(0, Math.min(i, o - n)),
          updateRequested: !0,
          xAxisScrollDir: XN(l.scrollLeft, u),
          yAxisScrollDir: XN(l.scrollTop, i)
        },
          hn((()=>z())),
          K(),
          N()
      }
      , j = (e,t)=>{
        const n = Vt(O)
          , r = (I.value - n) / t * e;
        $({
          scrollTop: Math.min(I.value - n, r)
        })
      }
      , V = (e,t)=>{
        const n = Vt(_)
          , r = (P.value - n) / t * e;
        $({
          scrollLeft: Math.min(P.value - n, r)
        })
      }
      , {onWheel: U} = (({atXEndEdge: e, atXStartEdge: t, atYEndEdge: n, atYStartEdge: r},o)=>{
          let a = null
            , i = 0
            , s = 0;
          const l = (o,a)=>{
              const i = o <= 0 && t.value || o >= 0 && e.value
                , s = a <= 0 && r.value || a >= 0 && n.value;
              return i && s
            }
          ;
          return {
            hasReachedEdge: l,
            onWheel: e=>{
              Wg(a);
              let t = e.deltaX
                , n = e.deltaY;
              Math.abs(t) > Math.abs(n) ? n = 0 : t = 0,
              e.shiftKey && 0 !== n && (t = n,
                n = 0),
              l(i, s) && l(i + t, s + n) || (i += t,
                s += n,
                e.preventDefault(),
                a = Kg((()=>{
                    o(i, s),
                      i = 0,
                      s = 0
                  }
                )))
            }
          }
        }
      )({
        atXStartEdge: yi((()=>T.value.scrollLeft <= 0)),
        atXEndEdge: yi((()=>T.value.scrollLeft >= P.value - Vt(_))),
        atYStartEdge: yi((()=>T.value.scrollTop <= 0)),
        atYEndEdge: yi((()=>T.value.scrollTop >= I.value - Vt(O)))
      }, ((e,t)=>{
          var n, r, o, a;
          null == (r = null == (n = A.value) ? void 0 : n.onMouseUp) || r.call(n),
          null == (a = null == (o = C.value) ? void 0 : o.onMouseUp) || a.call(o);
          const i = Vt(_)
            , s = Vt(O);
          $({
            scrollLeft: Math.min(T.value.scrollLeft + e, P.value - i),
            scrollTop: Math.min(T.value.scrollTop + t, I.value - s)
          })
        }
      ))
      , $ = ({scrollLeft: e=T.value.scrollLeft, scrollTop: t=T.value.scrollTop})=>{
        e = Math.max(e, 0),
          t = Math.max(t, 0);
        const n = Vt(T);
        t === n.scrollTop && e === n.scrollLeft || (T.value = {
          ...n,
          xAxisScrollDir: XN(n.scrollLeft, e),
          yAxisScrollDir: XN(n.scrollTop, t),
          scrollLeft: e,
          scrollTop: t,
          updateRequested: !0
        },
          hn((()=>z())),
          K(),
          N())
      }
      , H = (r,o)=>{
        const {columnWidth: a, direction: i, rowHeight: s} = e
          , l = D.value(t && a, t && s, t && i)
          , c = `${r},${o}`;
        if (p(l, c))
          return l[c];
        {
          const [,t] = n(e, o, Vt(S))
            , a = Vt(S)
            , s = JN(i)
            , [d,f] = u(e, r, a)
            , [p] = n(e, o, a);
          return l[c] = {
            position: "absolute",
            left: s ? void 0 : `${t}px`,
            right: s ? `${t}px` : void 0,
            top: `${f}px`,
            height: `${d}px`,
            width: `${p}px`
          },
            l[c]
        }
      }
      , z = ()=>{
        T.value.isScrolling = !1,
          hn((()=>{
              D.value(-1, null, null)
            }
          ))
      }
    ;
    Lr((()=>{
        if (!mc)
          return;
        const {initScrollLeft: t, initScrollTop: n} = e
          , r = Vt(E);
        r && (Vg(t) && (r.scrollLeft = t),
        Vg(n) && (r.scrollTop = n)),
          N()
      }
    ));
    const K = ()=>{
      const {direction: t} = e
        , {scrollLeft: n, scrollTop: r, updateRequested: o} = Vt(T)
        , a = Vt(E);
      if (o && a) {
        if (t === _N)
          switch (eM()) {
            case RN:
              a.scrollLeft = -n;
              break;
            case LN:
              a.scrollLeft = n;
              break;
            default:
            {
              const {clientWidth: e, scrollWidth: t} = a;
              a.scrollLeft = t - e - n;
              break
            }
          }
        else
          a.scrollLeft = Math.max(0, n);
        a.scrollTop = Math.max(0, r)
      }
    }
      , {resetAfterColumnIndex: W, resetAfterRowIndex: G, resetAfter: q} = x.proxy;
    m({
      windowRef: E,
      innerRef: k,
      getItemStyleCache: D,
      scrollTo: $,
      scrollToItem: (t=0,n=0,r=EN)=>{
        const o = Vt(T);
        n = Math.max(0, Math.min(n, e.totalColumn - 1)),
          t = Math.max(0, Math.min(t, e.totalRow - 1));
        const u = lm(w.namespace.value)
          , c = Vt(S)
          , d = a(e, c)
          , f = i(e, c);
        $({
          scrollLeft: s(e, n, r, o.scrollLeft, c, f > e.width ? u : 0),
          scrollTop: l(e, t, r, o.scrollTop, c, d > e.height ? u : 0)
        })
      }
      ,
      states: T,
      resetAfterColumnIndex: W,
      resetAfterRowIndex: G,
      resetAfter: q
    });
    const Y = ()=>{
        const t = Kr(e.innerElement)
          , n = (()=>{
            var t;
            const [n,r] = Vt(R)
              , [o,a] = Vt(L)
              , {data: i, totalColumn: s, totalRow: l, useIsScrolling: u, itemKey: c} = e
              , d = [];
            if (l > 0 && s > 0)
              for (let e = o; e <= a; e++)
                for (let o = n; o <= r; o++)
                  d.push(null == (t = y.default) ? void 0 : t.call(y, {
                    columnIndex: o,
                    data: i,
                    key: c({
                      columnIndex: o,
                      data: i,
                      rowIndex: e
                    }),
                    isScrolling: u ? Vt(T).isScrolling : void 0,
                    style: H(e, o),
                    rowIndex: e
                  }));
            return d
          }
        )();
        return [bi(t, {
          style: Vt(B),
          ref: k
        }, b(t) ? n : {
          default: ()=>n
        })]
      }
    ;
    return ()=>{
      const t = Kr(e.containerElement)
        , {horizontalScrollbar: n, verticalScrollbar: r} = (()=>{
          const {scrollbarAlwaysOn: t, scrollbarStartGap: n, scrollbarEndGap: r, totalColumn: o, totalRow: a} = e
            , i = Vt(_)
            , s = Vt(O)
            , l = Vt(P)
            , u = Vt(I)
            , {scrollLeft: c, scrollTop: d} = Vt(T);
          return {
            horizontalScrollbar: bi(tM, {
              ref: A,
              alwaysOn: t,
              startGap: n,
              endGap: r,
              class: w.e("horizontal"),
              clientSize: i,
              layout: "horizontal",
              onScroll: V,
              ratio: 100 * i / l,
              scrollFrom: c / (l - i),
              total: a,
              visible: !0
            }),
            verticalScrollbar: bi(tM, {
              ref: C,
              alwaysOn: t,
              startGap: n,
              endGap: r,
              class: w.e("vertical"),
              clientSize: s,
              layout: "vertical",
              onScroll: j,
              ratio: 100 * s / u,
              scrollFrom: d / (u - s),
              total: o,
              visible: !0
            })
          }
        }
      )()
        , o = Y();
      return bi("div", {
        key: 0,
        class: w.e("wrapper"),
        role: e.role
      }, [bi(t, {
        class: e.className,
        style: Vt(F),
        onScroll: M,
        onWheel: U,
        ref: E
      }, b(t) ? o : {
        default: ()=>o
      }), n, r])
    }
  }
})
  , cM = uM({
  name: "ElFixedSizeGrid",
  getColumnPosition: ({columnWidth: e},t)=>[e, t * e],
  getRowPosition: ({rowHeight: e},t)=>[e, t * e],
  getEstimatedTotalHeight: ({totalRow: e, rowHeight: t})=>t * e,
  getEstimatedTotalWidth: ({totalColumn: e, columnWidth: t})=>t * e,
  getColumnOffset: ({totalColumn: e, columnWidth: t, width: n},r,o,a,i,s)=>{
    n = Number(n);
    const l = Math.max(0, e * t - n)
      , u = Math.min(l, r * t)
      , c = Math.max(0, r * t - n + s + t);
    switch ("smart" === o && (o = a >= c - n && a <= u + n ? EN : kN),
      o) {
      case CN:
        return u;
      case TN:
        return c;
      case kN:
      {
        const e = Math.round(c + (u - c) / 2);
        return e < Math.ceil(n / 2) ? 0 : e > l + Math.floor(n / 2) ? l : e
      }
      default:
        return a >= c && a <= u ? a : c > u || a < c ? c : u
    }
  }
  ,
  getRowOffset: ({rowHeight: e, height: t, totalRow: n},r,o,a,i,s)=>{
    t = Number(t);
    const l = Math.max(0, n * e - t)
      , u = Math.min(l, r * e)
      , c = Math.max(0, r * e - t + s + e);
    switch (o === AN && (o = a >= c - t && a <= u + t ? EN : kN),
      o) {
      case CN:
        return u;
      case TN:
        return c;
      case kN:
      {
        const e = Math.round(c + (u - c) / 2);
        return e < Math.ceil(t / 2) ? 0 : e > l + Math.floor(t / 2) ? l : e
      }
      default:
        return a >= c && a <= u ? a : c > u || a < c ? c : u
    }
  }
  ,
  getColumnStartIndexForOffset: ({columnWidth: e, totalColumn: t},n)=>Math.max(0, Math.min(t - 1, Math.floor(n / e))),
  getColumnStopIndexForStartIndex: ({columnWidth: e, totalColumn: t, width: n},r,o)=>{
    const a = r * e
      , i = Math.ceil((n + o - a) / e);
    return Math.max(0, Math.min(t - 1, r + i - 1))
  }
  ,
  getRowStartIndexForOffset: ({rowHeight: e, totalRow: t},n)=>Math.max(0, Math.min(t - 1, Math.floor(n / e))),
  getRowStopIndexForStartIndex: ({rowHeight: e, totalRow: t, height: n},r,o)=>{
    const a = r * e
      , i = Math.ceil((n + o - a) / e);
    return Math.max(0, Math.min(t - 1, r + i - 1))
  }
  ,
  initCache: ()=>{}
  ,
  clearCache: !0,
  validateProps: ({columnWidth: e, rowHeight: t})=>{}
})
  , {max: dM, min: fM, floor: pM} = Math
  , hM = {
  column: "columnWidth",
  row: "rowHeight"
}
  , vM = {
  column: "lastVisitedColumnIndex",
  row: "lastVisitedRowIndex"
}
  , gM = (e,t,n,r)=>{
  const [o,a,i] = [n[r], e[hM[r]], n[vM[r]]];
  if (t > i) {
    let e = 0;
    if (i >= 0) {
      const t = o[i];
      e = t.offset + t.size
    }
    for (let n = i + 1; n <= t; n++) {
      const t = a(n);
      o[n] = {
        offset: e,
        size: t
      },
        e += t
    }
    n[vM[r]] = t
  }
  return o[t]
}
  , mM = (e,t,n,r,o,a)=>{
  for (; n <= r; ) {
    const i = n + pM((r - n) / 2)
      , s = gM(e, i, t, a).offset;
    if (s === o)
      return i;
    s < o ? n = i + 1 : r = i - 1
  }
  return dM(0, n - 1)
}
  , yM = (e,t,n,r)=>{
  const [o,a] = [t[r], t[vM[r]]];
  return (a > 0 ? o[a].offset : 0) >= n ? mM(e, t, 0, a, n, r) : ((e,t,n,r,o)=>{
      const a = "column" === o ? e.totalColumn : e.totalRow;
      let i = 1;
      for (; n < a && gM(e, n, t, o).offset < r; )
        n += i,
          i *= 2;
      return mM(e, t, pM(n / 2), fM(n, a - 1), r, o)
    }
  )(e, t, dM(0, a), n, r)
}
  , bM = ({totalRow: e},{estimatedRowHeight: t, lastVisitedRowIndex: n, row: r})=>{
  let o = 0;
  if (n >= e && (n = e - 1),
  n >= 0) {
    const e = r[n];
    o = e.offset + e.size
  }
  return o + (e - n - 1) * t
}
  , wM = ({totalColumn: e},{column: t, estimatedColumnWidth: n, lastVisitedColumnIndex: r})=>{
  let o = 0;
  if (r > e && (r = e - 1),
  r >= 0) {
    const e = t[r];
    o = e.offset + e.size
  }
  return o + (e - r - 1) * n
}
  , xM = {
  column: wM,
  row: bM
}
  , SM = (e,t,n,r,o,a,i)=>{
  const [s,l] = ["row" === a ? e.height : e.width, xM[a]]
    , u = gM(e, t, o, a)
    , c = l(e, o)
    , d = dM(0, fM(c - s, u.offset))
    , f = dM(0, u.offset - s + i + u.size);
  switch (n === AN && (n = r >= f - s && r <= d + s ? EN : kN),
    n) {
    case CN:
      return d;
    case TN:
      return f;
    case kN:
      return Math.round(f + (d - f) / 2);
    default:
      return r >= f && r <= d ? r : f > d || r < f ? f : d
  }
}
  , EM = uM({
  name: "ElDynamicSizeGrid",
  getColumnPosition: (e,t,n)=>{
    const r = gM(e, t, n, "column");
    return [r.size, r.offset]
  }
  ,
  getRowPosition: (e,t,n)=>{
    const r = gM(e, t, n, "row");
    return [r.size, r.offset]
  }
  ,
  getColumnOffset: (e,t,n,r,o,a)=>SM(e, t, n, r, o, "column", a),
  getRowOffset: (e,t,n,r,o,a)=>SM(e, t, n, r, o, "row", a),
  getColumnStartIndexForOffset: (e,t,n)=>yM(e, n, t, "column"),
  getColumnStopIndexForStartIndex: (e,t,n,r)=>{
    const o = gM(e, t, r, "column")
      , a = n + e.width;
    let i = o.offset + o.size
      , s = t;
    for (; s < e.totalColumn - 1 && i < a; )
      s++,
        i += gM(e, t, r, "column").size;
    return s
  }
  ,
  getEstimatedTotalHeight: bM,
  getEstimatedTotalWidth: wM,
  getRowStartIndexForOffset: (e,t,n)=>yM(e, n, t, "row"),
  getRowStopIndexForStartIndex: (e,t,n,r)=>{
    const {totalRow: o, height: a} = e
      , i = gM(e, t, r, "row")
      , s = n + a;
    let l = i.size + i.offset
      , u = t;
    for (; u < o - 1 && l < s; )
      u++,
        l += gM(e, u, r, "row").size;
    return u
  }
  ,
  injectToInstance: (e,t)=>{
    const n = ({columnIndex: n, rowIndex: r},o)=>{
        var a, i;
        o = !!Mg(o) || o,
        Vg(n) && (t.value.lastVisitedColumnIndex = Math.min(t.value.lastVisitedColumnIndex, n - 1)),
        Vg(r) && (t.value.lastVisitedRowIndex = Math.min(t.value.lastVisitedRowIndex, r - 1)),
        null == (a = e.exposed) || a.getItemStyleCache.value(-1, null, null),
        o && (null == (i = e.proxy) || i.$forceUpdate())
      }
    ;
    Object.assign(e.proxy, {
      resetAfterColumnIndex: (e,t)=>{
        n({
          columnIndex: e
        }, t)
      }
      ,
      resetAfterRowIndex: (e,t)=>{
        n({
          rowIndex: e
        }, t)
      }
      ,
      resetAfter: n
    })
  }
  ,
  initCache: ({estimatedColumnWidth: e=50, estimatedRowHeight: t=50})=>({
    column: {},
    estimatedColumnWidth: e,
    estimatedRowHeight: t,
    lastVisitedColumnIndex: -1,
    lastVisitedRowIndex: -1,
    row: {}
  }),
  clearCache: !1,
  validateProps: ({columnWidth: e, rowHeight: t})=>{}
});
var AM = tS(vr({
  props: {
    item: {
      type: Object,
      required: !0
    },
    style: Object,
    height: Number
  },
  setup: ()=>({
    ns: qy("select")
  })
}), [["render", function(e, t, n, r, o, a) {
  return e.item.isTitle ? (Ca(),
    _a("div", {
      key: 0,
      class: Y(e.ns.be("group", "title")),
      style: z([e.style, {
        lineHeight: `${e.height}px`
      }])
    }, te(e.item.label), 7)) : (Ca(),
    _a("div", {
      key: 1,
      class: Y(e.ns.be("group", "split")),
      style: z(e.style)
    }, [Ma("span", {
      class: Y(e.ns.be("group", "split-dash")),
      style: z({
        top: e.height / 2 + "px"
      })
    }, null, 6)], 6))
}
], ["__file", "group-item.vue"]]);
const CM = {
  label: "label",
  value: "value",
  disabled: "disabled",
  options: "options"
};
function kM(e) {
  const t = yi((()=>({
    ...CM,
    ...e.props
  })));
  return {
    aliasProps: t,
    getLabel: e=>Lp(e, t.value.label),
    getValue: e=>Lp(e, t.value.value),
    getDisabled: e=>Lp(e, t.value.disabled),
    getOptions: e=>Lp(e, t.value.options)
  }
}
const TM = uy({
  allowCreate: Boolean,
  autocomplete: {
    type: String,
    default: "none"
  },
  automaticDropdown: Boolean,
  clearable: Boolean,
  clearIcon: {
    type: cy,
    default: km
  },
  effect: {
    type: String,
    default: "light"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  defaultFirstOption: Boolean,
  disabled: Boolean,
  estimatedOptionHeight: {
    type: Number,
    default: void 0
  },
  filterable: Boolean,
  filterMethod: Function,
  height: {
    type: Number,
    default: 274
  },
  itemHeight: {
    type: Number,
    default: 34
  },
  id: String,
  loading: Boolean,
  loadingText: String,
  modelValue: {
    type: [Array, String, Number, Boolean, Object]
  },
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  name: String,
  noDataText: String,
  noMatchText: String,
  remoteMethod: Function,
  reserveKeyword: {
    type: Boolean,
    default: !0
  },
  options: {
    type: Array,
    required: !0
  },
  placeholder: {
    type: String
  },
  teleported: SA.teleported,
  persistent: {
    type: Boolean,
    default: !0
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: ()=>({})
  },
  remote: Boolean,
  size: Ux,
  props: {
    type: Object,
    default: ()=>CM
  },
  valueKey: {
    type: String,
    default: "value"
  },
  scrollbarAlwaysOn: Boolean,
  validateEvent: {
    type: Boolean,
    default: !0
  },
  placement: {
    type: String,
    values: pb,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: Array,
    default: ["bottom-start", "top-start", "right", "left"]
  },
  tagType: {
    ...fO.type,
    default: "info"
  },
  ariaLabel: {
    type: String,
    default: void 0
  }
})
  , DM = uy({
  data: Array,
  disabled: Boolean,
  hovering: Boolean,
  item: {
    type: Object,
    required: !0
  },
  index: Number,
  style: Object,
  selected: Boolean,
  created: Boolean
})
  , OM = Symbol("ElSelectV2Injection")
  , _M = vr({
  props: DM,
  emits: ["select", "hover"],
  setup(e, {emit: t}) {
    const n = jo(OM)
      , r = qy("select")
      , {hoverItem: o, selectOptionClick: a} = function(e, {emit: t}) {
      return {
        hoverItem: ()=>{
          e.disabled || t("hover", e.index)
        }
        ,
        selectOptionClick: ()=>{
          e.disabled || t("select", e.item, e.index)
        }
      }
    }(e, {
      emit: t
    })
      , {getLabel: i} = kM(n.props);
    return {
      ns: r,
      hoverItem: o,
      selectOptionClick: a,
      getLabel: i
    }
  }
})
  , RM = ["aria-selected"];
var LM = tS(_M, [["render", function(e, t, n, r, o, a) {
  return Ca(),
    _a("li", {
      "aria-selected": e.selected,
      style: z(e.style),
      class: Y([e.ns.be("dropdown", "item"), e.ns.is("selected", e.selected), e.ns.is("disabled", e.disabled), e.ns.is("created", e.created), e.ns.is("hovering", e.hovering)]),
      onMouseenter: t[0] || (t[0] = (...t)=>e.hoverItem && e.hoverItem(...t)),
      onClick: t[1] || (t[1] = js(((...t)=>e.selectOptionClick && e.selectOptionClick(...t)), ["stop"]))
    }, [Qr(e.$slots, "default", {
      item: e.item,
      index: e.index,
      disabled: e.disabled
    }, (()=>[Ma("span", null, te(e.getLabel(e.item)), 1)]))], 46, RM)
}
], ["__file", "option-item.vue"]])
  , IM = vr({
  name: "ElSelectDropdown",
  props: {
    loading: Boolean,
    data: {
      type: Array,
      required: !0
    },
    hoveringIndex: Number,
    width: Number
  },
  setup(e, {slots: t, expose: n}) {
    const r = jo(OM)
      , o = qy("select")
      , {getLabel: a, getValue: i, getDisabled: s} = kM(r.props)
      , l = Ft([])
      , u = Ft()
      , c = yi((()=>e.data.length));
    Jn((()=>c.value), (()=>{
        var e, t;
        null == (t = (e = r.tooltipRef.value).updatePopper) || t.call(e)
      }
    ));
    const d = yi((()=>Mg(r.props.estimatedOptionHeight)))
      , f = yi((()=>d.value ? {
      itemSize: r.props.itemHeight
    } : {
      estimatedSize: r.props.estimatedOptionHeight,
      itemSize: e=>l.value[e]
    }))
      , p = (e,t)=>r.props.multiple ? ((e=[],t)=>{
        const {props: {valueKey: n}} = r;
        return x(t) ? e && e.some((e=>Dt(Lp(e, n)) === Lp(t, n))) : e.includes(t)
      }
    )(e, i(t)) : ((e,t)=>{
        if (x(t)) {
          const {valueKey: n} = r.props;
          return Lp(e, n) === Lp(t, n)
        }
        return e === t
      }
    )(e, i(t))
      , h = (e,t)=>{
      const {disabled: n, multiple: o, multipleLimit: a} = r.props;
      return n || !t && !!o && a > 0 && e.length >= a
    }
      , v = t=>e.hoveringIndex === t;
    n({
      listRef: u,
      isSized: d,
      isItemDisabled: h,
      isItemHovering: v,
      isItemSelected: p,
      scrollToItem: e=>{
        const t = u.value;
        t && t.scrollToItem(e)
      }
      ,
      resetScrollTop: ()=>{
        const e = u.value;
        e && e.resetScrollTop()
      }
    });
    const g = e=>{
        const {index: n, data: o, style: i} = e
          , l = Vt(d)
          , {itemSize: u, estimatedSize: c} = Vt(f)
          , {modelValue: g} = r.props
          , {onSelect: m, onHover: y} = r
          , b = o[n];
        if ("Group" === b.type)
          return ja(AM, {
            item: b,
            style: i,
            height: l ? u : c
          }, null);
        const w = p(g, b)
          , x = h(g, w)
          , S = v(n);
        return ja(LM, qa(e, {
          selected: w,
          disabled: s(b) || x,
          created: !!b.created,
          hovering: S,
          item: b,
          onSelect: m,
          onHover: y
        }), {
          default: e=>{
            var n;
            return (null == (n = t.default) ? void 0 : n.call(t, e)) || ja("span", null, [a(b)])
          }
        })
      }
      , {onKeyboardNavigate: m, onKeyboardSelect: y} = r
      , b = e=>{
        const {code: t} = e
          , {tab: n, esc: o, down: a, up: i, enter: s} = by;
        switch (t !== n && (e.preventDefault(),
          e.stopPropagation()),
          t) {
          case n:
          case o:
            r.expanded = !1;
            break;
          case a:
            m("forward");
            break;
          case i:
            m("backward");
            break;
          case s:
            y()
        }
      }
    ;
    return ()=>{
      var n, a, i, s;
      const {data: l, width: c} = e
        , {height: p, multiple: h, scrollbarAlwaysOn: v} = r.props
        , m = Vt(d) ? rM : lM;
      return ja("div", {
        class: [o.b("dropdown"), o.is("multiple", h)],
        style: {
          width: `${c}px`
        }
      }, [null == (n = t.header) ? void 0 : n.call(t), (null == (a = t.loading) ? void 0 : a.call(t)) || (null == (i = t.empty) ? void 0 : i.call(t)) || ja(m, qa({
        ref: u
      }, Vt(f), {
        className: o.be("dropdown", "list"),
        scrollbarAlwaysOn: v,
        data: l,
        height: p,
        width: c,
        total: l.length,
        onKeydown: b
      }), {
        default: e=>ja(g, e, null)
      }), null == (s = t.footer) ? void 0 : s.call(t)])
    }
  }
});
function PM(e, t) {
  const {aliasProps: n, getLabel: r, getValue: o} = kM(e)
    , a = Ft(0)
    , i = Ft(null)
    , s = yi((()=>e.allowCreate && e.filterable));
  return {
    createNewOption: function(r) {
      if (s.value)
        if (r && r.length > 0) {
          if (function(n) {
            const r = e=>o(e) === n;
            return e.options && e.options.some(r) || t.createdOptions.some(r)
          }(r))
            return;
          const i = {
            [n.value.value]: r,
            [n.value.label]: r,
            created: !0,
            [n.value.disabled]: !1
          };
          t.createdOptions.length >= a.value ? t.createdOptions[a.value] = i : t.createdOptions.push(i)
        } else if (e.multiple)
          t.createdOptions.length = a.value;
        else {
          const e = i.value;
          t.createdOptions.length = 0,
          e && e.created && t.createdOptions.push(e)
        }
    },
    removeNewOption: function(n) {
      if (!s.value || !n || !n.created || n.created && e.reserveKeyword && t.inputValue === r(n))
        return;
      const i = t.createdOptions.findIndex((e=>o(e) === o(n)));
      ~i && (t.createdOptions.splice(i, 1),
        a.value--)
    },
    selectNewOption: function(t) {
      s.value && (e.multiple && t.created ? a.value++ : i.value = t)
    },
    clearAllNewOption: function() {
      s.value && (t.createdOptions.length = 0,
        a.value = 0)
    }
  }
}
const FM = (e,t)=>{
  const {t: n} = Hy()
    , r = qy("select")
    , o = qy("input")
    , {form: a, formItem: i} = gS()
    , {inputId: s} = mS(e, {
      formItemContext: i
    })
    , {getLabel: l, getValue: u, getDisabled: c, getOptions: d} = kM(e)
    , f = bt({
      inputValue: "",
      cachedOptions: [],
      createdOptions: [],
      hoveringIndex: -1,
      inputHovering: !1,
      selectionWidth: 0,
      calculatorWidth: 0,
      collapseItemWidth: 0,
      previousQuery: null,
      previousValue: void 0,
      selectedLabel: "",
      menuVisibleOnFocus: !1,
      isBeforeHide: !1
    })
    , p = Ft(-1)
    , v = Ft(-1)
    , g = Ft(null)
    , m = Ft(null)
    , b = Ft(null)
    , w = Ft(null)
    , S = Ft(null)
    , E = Ft(null)
    , A = Ft(null)
    , C = Ft(null)
    , k = Ft(null)
    , T = Ft(null)
    , D = Ft(null)
    , {wrapperRef: O, isFocused: _, handleFocus: R, handleBlur: L} = Hx(S, {
      afterFocus() {
        e.automaticDropdown && !F.value && (F.value = !0,
          f.menuVisibleOnFocus = !0)
      },
      beforeBlur(e) {
        var t, n;
        return (null == (t = b.value) ? void 0 : t.isFocusInsideContent(e)) || (null == (n = w.value) ? void 0 : n.isFocusInsideContent(e))
      },
      afterBlur() {
        F.value = !1,
          f.menuVisibleOnFocus = !1
      }
    })
    , I = Ft([])
    , P = Ft([])
    , F = Ft(!1)
    , B = yi((()=>e.disabled || (null == a ? void 0 : a.disabled)))
    , N = yi((()=>{
        const t = P.value.length * e.itemHeight;
        return t > e.height ? e.height : t
      }
    ))
    , M = yi((()=>I.value.some((e=>"" === u(e)))))
    , j = yi((()=>e.multiple ? h(e.modelValue) && e.modelValue.length > 0 : !Cg(e.modelValue) && ("" !== e.modelValue || M.value)))
    , V = yi((()=>e.clearable && !B.value && f.inputHovering && j.value))
    , U = yi((()=>e.remote && e.filterable ? "" : hm))
    , $ = yi((()=>U.value && r.is("reverse", F.value)))
    , H = yi((()=>(null == i ? void 0 : i.validateState) || ""))
    , z = yi((()=>hy[H.value]))
    , K = yi((()=>e.remote ? 300 : 0))
    , W = yi((()=>e.loading ? e.loadingText || n("el.select.loading") : !(e.remote && !f.inputValue && 0 === I.value.length) && (e.filterable && f.inputValue && I.value.length > 0 && 0 === P.value.length ? e.noMatchText || n("el.select.noMatch") : 0 === I.value.length ? e.noDataText || n("el.select.noData") : null)))
    , G = t=>{
      const n = n=>{
          if (e.filterable && y(e.filterMethod))
            return !0;
          if (e.filterable && e.remote && y(e.remoteMethod))
            return !0;
          const r = new RegExp(Gg(t),"i");
          return !t || r.test(l(n) || "")
        }
      ;
      return e.loading ? [] : [...f.createdOptions, ...e.options].reduce(((t,r)=>{
          const o = d(r);
          if (h(o)) {
            const e = o.filter(n);
            e.length > 0 && t.push({
              label: l(r),
              isTitle: !0,
              type: "Group"
            }, ...e, {
              type: "Group"
            })
          } else
            (e.remote || n(r)) && t.push(r);
          return t
        }
      ), [])
    }
    , q = ()=>{
      I.value = G(""),
        P.value = G(f.inputValue)
    }
    , Y = yi((()=>{
        const e = new Map;
        return I.value.forEach(((t,n)=>{
            e.set(Ce(u(t)), {
              option: t,
              index: n
            })
          }
        )),
          e
      }
    ))
    , X = yi((()=>{
        const e = new Map;
        return P.value.forEach(((t,n)=>{
            e.set(Ce(u(t)), {
              option: t,
              index: n
            })
          }
        )),
          e
      }
    ))
    , Q = yi((()=>P.value.every((e=>c(e)))))
    , J = hS()
    , Z = yi((()=>"small" === J.value ? "small" : "default"))
    , ee = ()=>{
      var e;
      v.value = (null == (e = g.value) ? void 0 : e.offsetWidth) || 200
    }
    , te = yi((()=>{
        const t = (()=>{
            if (!m.value)
              return 0;
            const e = window.getComputedStyle(m.value);
            return Number.parseFloat(e.gap || "6px")
          }
        )();
        return {
          maxWidth: `${D.value && 1 === e.maxCollapseTags ? f.selectionWidth - f.collapseItemWidth - t : f.selectionWidth}px`
        }
      }
    ))
    , ne = yi((()=>({
      maxWidth: `${f.selectionWidth}px`
    })))
    , re = yi((()=>({
      width: `${Math.max(f.calculatorWidth, 11)}px`
    })))
    , oe = yi((()=>h(e.modelValue) ? 0 === e.modelValue.length && !f.inputValue : !e.filterable || !f.inputValue))
    , ae = yi((()=>{
        var t;
        const r = null != (t = e.placeholder) ? t : n("el.select.placeholder");
        return e.multiple || !j.value ? r : f.selectedLabel
      }
    ))
    , ie = yi((()=>{
        var e, t;
        return null == (t = null == (e = b.value) ? void 0 : e.popperRef) ? void 0 : t.contentRef
      }
    ))
    , se = yi((()=>{
        if (e.multiple) {
          const t = e.modelValue.length;
          if (e.modelValue.length > 0 && X.value.has(e.modelValue[t - 1])) {
            const {index: n} = X.value.get(e.modelValue[t - 1]);
            return n
          }
        } else if (e.modelValue && X.value.has(e.modelValue)) {
          const {index: t} = X.value.get(e.modelValue);
          return t
        }
        return -1
      }
    ))
    , le = yi({
      get: ()=>F.value && !1 !== W.value,
      set(e) {
        F.value = e
      }
    })
    , ue = yi((()=>e.multiple ? e.collapseTags ? f.cachedOptions.slice(0, e.maxCollapseTags) : f.cachedOptions : []))
    , ce = yi((()=>e.multiple && e.collapseTags ? f.cachedOptions.slice(e.maxCollapseTags) : []))
    , {createNewOption: de, removeNewOption: fe, selectNewOption: pe, clearAllNewOption: he} = PM(e, f)
    , {handleCompositionStart: ve, handleCompositionUpdate: ge, handleCompositionEnd: me} = WF((e=>Fe(e)))
    , ye = ()=>{
      B.value || (f.menuVisibleOnFocus ? f.menuVisibleOnFocus = !1 : F.value = !F.value)
    }
    , be = ()=>{
      f.inputValue.length > 0 && !F.value && (F.value = !0),
        de(f.inputValue),
        xe(f.inputValue)
    }
    , we = ug(be, K.value)
    , xe = t=>{
      f.previousQuery !== t && (f.previousQuery = t,
        e.filterable && y(e.filterMethod) ? e.filterMethod(t) : e.filterable && e.remote && y(e.remoteMethod) && e.remoteMethod(t),
        e.defaultFirstOption && (e.filterable || e.remote) && P.value.length ? hn(Se) : hn(Pe))
    }
    , Se = ()=>{
      const e = P.value.filter((e=>!e.disabled && "Group" !== e.type))
        , t = e.find((e=>e.created))
        , n = e[0];
      f.hoveringIndex = Ae(P.value, t || n)
    }
    , Ee = n=>{
      t(xy, n),
        (n=>{
            Ag(e.modelValue, n) || t(Sy, n)
          }
        )(n),
        f.previousValue = String(n)
    }
    , Ae = (t=[],n)=>{
      if (!x(n))
        return t.indexOf(n);
      const r = e.valueKey;
      let o = -1;
      return t.some(((e,t)=>Lp(e, r) === Lp(n, r) && (o = t,
        !0))),
        o
    }
    , Ce = t=>x(t) ? Lp(t, e.valueKey) : t
    , ke = ()=>{
      ee()
    }
    , Te = ()=>{
      f.selectionWidth = m.value.getBoundingClientRect().width
    }
    , De = ()=>{
      f.calculatorWidth = E.value.getBoundingClientRect().width
    }
    , Oe = ()=>{
      var e, t;
      null == (t = null == (e = b.value) ? void 0 : e.updatePopper) || t.call(e)
    }
    , _e = ()=>{
      var e, t;
      null == (t = null == (e = w.value) ? void 0 : e.updatePopper) || t.call(e)
    }
    , Re = (t,n)=>{
      if (e.multiple) {
        let n = e.modelValue.slice();
        const r = Ae(n, u(t));
        r > -1 ? (n = [...n.slice(0, r), ...n.slice(r + 1)],
          f.cachedOptions.splice(r, 1),
          fe(t)) : (e.multipleLimit <= 0 || n.length < e.multipleLimit) && (n = [...n, u(t)],
          f.cachedOptions.push(t),
          pe(t)),
          Ee(n),
        t.created && xe(""),
        e.filterable && !e.reserveKeyword && (f.inputValue = "")
      } else
        p.value = n,
          f.selectedLabel = l(t),
          Ee(u(t)),
          F.value = !1,
          pe(t),
        t.created || he();
      Le()
    }
    , Le = ()=>{
      var e;
      null == (e = S.value) || e.focus()
    }
    , Ie = (e,t=void 0)=>{
      const n = P.value;
      if (!["forward", "backward"].includes(e) || B.value || n.length <= 0 || Q.value)
        return;
      if (!F.value)
        return ye();
      void 0 === t && (t = f.hoveringIndex);
      let r = -1;
      "forward" === e ? (r = t + 1,
      r >= n.length && (r = 0)) : "backward" === e && (r = t - 1,
      (r < 0 || r >= n.length) && (r = n.length - 1));
      const o = n[r];
      if (c(o) || "Group" === o.type)
        return Ie(e, r);
      f.hoveringIndex = r,
        Be(r)
    }
    , Pe = ()=>{
      e.multiple ? f.hoveringIndex = P.value.findIndex((t=>e.modelValue.some((e=>Ce(e) === Ce(t))))) : f.hoveringIndex = P.value.findIndex((t=>Ce(t) === Ce(e.modelValue)))
    }
    , Fe = t=>{
      if (f.inputValue = t.target.value,
        !e.remote)
        return be();
      we()
    }
    , Be = e=>{
      k.value.scrollToItem(e)
    }
    , Ne = e=>{
      const t = Ce(e);
      if (Y.value.has(t)) {
        const {option: e} = Y.value.get(t);
        return e
      }
      return {
        value: e,
        label: e
      }
    }
    , Me = ()=>{
      if (e.multiple)
        if (e.modelValue.length > 0) {
          f.cachedOptions.length = 0,
            f.previousValue = e.modelValue.toString();
          for (const t of e.modelValue) {
            const e = Ne(t);
            f.cachedOptions.push(e)
          }
        } else
          f.cachedOptions = [],
            f.previousValue = void 0;
      else if (j.value) {
        f.previousValue = e.modelValue;
        const t = P.value
          , n = t.findIndex((t=>Ce(u(t)) === Ce(e.modelValue)));
        f.selectedLabel = ~n ? l(t[n]) : Ce(e.modelValue)
      } else
        f.selectedLabel = "",
          f.previousValue = void 0;
      he(),
        ee()
    }
  ;
  return Jn(F, (e=>{
      e ? xe("") : (f.inputValue = "",
        f.previousQuery = null,
        f.isBeforeHide = !0,
        de("")),
        t("visible-change", e)
    }
  )),
    Jn((()=>e.modelValue), ((t,n)=>{
        var r;
        t && t.toString() === f.previousValue || Me(),
        !Ag(t, n) && e.validateEvent && (null == (r = null == i ? void 0 : i.validate) || r.call(i, "change").catch((e=>{}
        )))
      }
    ), {
      deep: !0
    }),
    Jn((()=>e.options), (()=>{
        const e = S.value;
        (!e || e && document.activeElement !== e) && Me()
      }
    ), {
      deep: !0,
      flush: "post"
    }),
    Jn((()=>P.value), (()=>k.value && hn(k.value.resetScrollTop))),
    qn((()=>{
        f.isBeforeHide || q()
      }
    )),
    qn((()=>{
        const {valueKey: t, options: n} = e
          , r = new Map;
        for (const e of n) {
          const n = u(e);
          let o = n;
          if (x(o) && (o = Lp(n, t)),
            r.get(o))
            break;
          r.set(o, !0)
        }
      }
    )),
    Lr((()=>{
        Me()
      }
    )),
    Uc(g, ke),
    Uc(m, Te),
    Uc(E, De),
    Uc(k, Oe),
    Uc(O, Oe),
    Uc(T, _e),
    Uc(D, (()=>{
        f.collapseItemWidth = D.value.getBoundingClientRect().width
      }
    )),
    {
      inputId: s,
      collapseTagSize: Z,
      currentPlaceholder: ae,
      expanded: F,
      emptyText: W,
      popupHeight: N,
      debounce: K,
      allOptions: I,
      filteredOptions: P,
      iconComponent: U,
      iconReverse: $,
      tagStyle: te,
      collapseTagStyle: ne,
      inputStyle: re,
      popperSize: v,
      dropdownMenuVisible: le,
      hasModelValue: j,
      shouldShowPlaceholder: oe,
      selectDisabled: B,
      selectSize: J,
      showClearBtn: V,
      states: f,
      isFocused: _,
      nsSelect: r,
      nsInput: o,
      calculatorRef: E,
      inputRef: S,
      menuRef: k,
      tagMenuRef: T,
      tooltipRef: b,
      tagTooltipRef: w,
      selectRef: g,
      wrapperRef: O,
      selectionRef: m,
      prefixRef: A,
      suffixRef: C,
      collapseItemRef: D,
      popperRef: ie,
      validateState: H,
      validateIcon: z,
      showTagList: ue,
      collapseTagList: ce,
      debouncedOnInputChange: we,
      deleteTag: (n,r)=>{
        let o = e.modelValue.slice();
        const a = Ae(o, u(r));
        a > -1 && !B.value && (o = [...e.modelValue.slice(0, a), ...e.modelValue.slice(a + 1)],
          f.cachedOptions.splice(a, 1),
          Ee(o),
          t("remove-tag", u(r)),
          fe(r)),
          n.stopPropagation(),
          Le()
      }
      ,
      getLabel: l,
      getValue: u,
      getDisabled: c,
      getValueKey: Ce,
      handleBlur: L,
      handleClear: ()=>{
        let n;
        n = h(e.modelValue) ? [] : void 0,
          e.multiple ? f.cachedOptions = [] : f.selectedLabel = "",
          F.value = !1,
          Ee(n),
          t("clear"),
          he(),
          Le()
      }
      ,
      handleClickOutside: e=>{
        if (F.value = !1,
          _.value) {
          const t = new FocusEvent("focus",e);
          L(t)
        }
      }
      ,
      handleDel: t=>{
        if (e.multiple && (t.code !== by.delete && 0 === f.inputValue.length)) {
          t.preventDefault();
          const n = e.modelValue.slice()
            , r = yg(n, (e=>!f.cachedOptions.some((t=>u(t) === e && c(t)))));
          if (r < 0)
            return;
          n.splice(r, 1);
          const o = f.cachedOptions[r];
          f.cachedOptions.splice(r, 1),
            fe(o),
            Ee(n)
        }
      }
      ,
      handleEsc: ()=>{
        f.inputValue.length > 0 ? f.inputValue = "" : F.value = !1
      }
      ,
      handleFocus: R,
      focus: Le,
      blur: ()=>{
        var e;
        null == (e = S.value) || e.blur()
      }
      ,
      handleMenuEnter: ()=>hn((()=>{
          ~se.value && Be(f.hoveringIndex)
        }
      )),
      handleResize: ke,
      resetSelectionWidth: Te,
      resetCalculatorWidth: De,
      updateTooltip: Oe,
      updateTagTooltip: _e,
      updateOptions: q,
      toggleMenu: ye,
      scrollTo: Be,
      onInput: Fe,
      onKeyboardNavigate: Ie,
      onKeyboardSelect: ()=>{
        if (!F.value)
          return ye();
        ~f.hoveringIndex && P.value[f.hoveringIndex] && Re(P.value[f.hoveringIndex], f.hoveringIndex)
      }
      ,
      onSelect: Re,
      onHover: e=>{
        f.hoveringIndex = e
      }
      ,
      handleCompositionStart: ve,
      handleCompositionEnd: me,
      handleCompositionUpdate: ge
    }
}
  , BM = vr({
  name: "ElSelectV2",
  components: {
    ElSelectMenu: IM,
    ElTag: vO,
    ElTooltip: MA,
    ElIcon: sS
  },
  directives: {
    ClickOutside: Rk
  },
  props: TM,
  emits: [xy, Sy, "remove-tag", "clear", "visible-change", "focus", "blur"],
  setup(e, {emit: t}) {
    const n = yi((()=>{
        const {modelValue: t, multiple: n} = e
          , r = n ? [] : void 0;
        return h(t) ? n ? t : r : n ? r : t
      }
    ))
      , r = FM(bt({
      ...Wt(e),
      modelValue: n
    }), t);
    return Mo(OM, {
      props: bt({
        ...Wt(e),
        height: r.popupHeight,
        modelValue: n
      }),
      tooltipRef: r.tooltipRef,
      onSelect: r.onSelect,
      onHover: r.onHover,
      onKeyboardNavigate: r.onKeyboardNavigate,
      onKeyboardSelect: r.onKeyboardSelect
    }),
      {
        ...r,
        modelValue: n
      }
  }
})
  , NM = ["id", "autocomplete", "aria-expanded", "aria-label", "disabled", "readonly", "name"]
  , MM = ["textContent"];
var jM = tS(BM, [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-tag")
    , s = Hr("el-tooltip")
    , l = Hr("el-icon")
    , u = Hr("el-select-menu")
    , c = Wr("click-outside");
  return rr((Ca(),
    _a("div", {
      ref: "selectRef",
      class: Y([e.nsSelect.b(), e.nsSelect.m(e.selectSize)]),
      onMouseenter: t[14] || (t[14] = t=>e.states.inputHovering = !0),
      onMouseleave: t[15] || (t[15] = t=>e.states.inputHovering = !1),
      onClick: t[16] || (t[16] = js(((...t)=>e.toggleMenu && e.toggleMenu(...t)), ["stop"]))
    }, [ja(s, {
      ref: "tooltipRef",
      visible: e.dropdownMenuVisible,
      teleported: e.teleported,
      "popper-class": [e.nsSelect.e("popper"), e.popperClass],
      "gpu-acceleration": !1,
      "stop-popper-mouse-event": !1,
      "popper-options": e.popperOptions,
      "fallback-placements": e.fallbackPlacements,
      effect: e.effect,
      placement: e.placement,
      pure: "",
      transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
      trigger: "click",
      persistent: e.persistent,
      onBeforeShow: e.handleMenuEnter,
      onHide: t[13] || (t[13] = t=>e.states.isBeforeHide = !1)
    }, {
      default: Fn((()=>[Ma("div", {
        ref: "wrapperRef",
        class: Y([e.nsSelect.e("wrapper"), e.nsSelect.is("focused", e.isFocused), e.nsSelect.is("hovering", e.states.inputHovering), e.nsSelect.is("filterable", e.filterable), e.nsSelect.is("disabled", e.selectDisabled)])
      }, [e.$slots.prefix ? (Ca(),
        _a("div", {
          key: 0,
          ref: "prefixRef",
          class: Y(e.nsSelect.e("prefix"))
        }, [Qr(e.$slots, "prefix")], 2)) : za("v-if", !0), Ma("div", {
        ref: "selectionRef",
        class: Y([e.nsSelect.e("selection"), e.nsSelect.is("near", e.multiple && !e.$slots.prefix && !!e.modelValue.length)])
      }, [e.multiple ? Qr(e.$slots, "tag", {
        key: 0
      }, (()=>[(Ca(!0),
        _a(ba, null, Yr(e.showTagList, (t=>(Ca(),
          _a("div", {
            key: e.getValueKey(e.getValue(t)),
            class: Y(e.nsSelect.e("selected-item"))
          }, [ja(i, {
            closable: !e.selectDisabled && !e.getDisabled(t),
            size: e.collapseTagSize,
            type: e.tagType,
            "disable-transitions": "",
            style: z(e.tagStyle),
            onClose: n=>e.deleteTag(n, t)
          }, {
            default: Fn((()=>[Ma("span", {
              class: Y(e.nsSelect.e("tags-text"))
            }, te(e.getLabel(t)), 3)])),
            _: 2
          }, 1032, ["closable", "size", "type", "style", "onClose"])], 2)))), 128)), e.collapseTags && e.modelValue.length > e.maxCollapseTags ? (Ca(),
        Ra(s, {
          key: 0,
          ref: "tagTooltipRef",
          disabled: e.dropdownMenuVisible || !e.collapseTagsTooltip,
          "fallback-placements": ["bottom", "top", "right", "left"],
          effect: e.effect,
          placement: "bottom",
          teleported: e.teleported
        }, {
          default: Fn((()=>[Ma("div", {
            ref: "collapseItemRef",
            class: Y(e.nsSelect.e("selected-item"))
          }, [ja(i, {
            closable: !1,
            size: e.collapseTagSize,
            type: e.tagType,
            style: z(e.collapseTagStyle),
            "disable-transitions": ""
          }, {
            default: Fn((()=>[Ma("span", {
              class: Y(e.nsSelect.e("tags-text"))
            }, " + " + te(e.modelValue.length - e.maxCollapseTags), 3)])),
            _: 1
          }, 8, ["size", "type", "style"])], 2)])),
          content: Fn((()=>[Ma("div", {
            ref: "tagMenuRef",
            class: Y(e.nsSelect.e("selection"))
          }, [(Ca(!0),
            _a(ba, null, Yr(e.collapseTagList, (t=>(Ca(),
              _a("div", {
                key: e.getValueKey(e.getValue(t)),
                class: Y(e.nsSelect.e("selected-item"))
              }, [ja(i, {
                class: "in-tooltip",
                closable: !e.selectDisabled && !e.getDisabled(t),
                size: e.collapseTagSize,
                type: e.tagType,
                "disable-transitions": "",
                onClose: n=>e.deleteTag(n, t)
              }, {
                default: Fn((()=>[Ma("span", {
                  class: Y(e.nsSelect.e("tags-text"))
                }, te(e.getLabel(t)), 3)])),
                _: 2
              }, 1032, ["closable", "size", "type", "onClose"])], 2)))), 128))], 2)])),
          _: 1
        }, 8, ["disabled", "effect", "teleported"])) : za("v-if", !0)])) : za("v-if", !0), e.selectDisabled ? za("v-if", !0) : (Ca(),
        _a("div", {
          key: 1,
          class: Y([e.nsSelect.e("selected-item"), e.nsSelect.e("input-wrapper"), e.nsSelect.is("hidden", !e.filterable)])
        }, [rr(Ma("input", {
          id: e.inputId,
          ref: "inputRef",
          "onUpdate:modelValue": t[0] || (t[0] = t=>e.states.inputValue = t),
          style: z(e.inputStyle),
          autocomplete: e.autocomplete,
          "aria-autocomplete": "list",
          "aria-haspopup": "listbox",
          autocapitalize: "off",
          "aria-expanded": e.expanded,
          "aria-label": e.ariaLabel,
          class: Y([e.nsSelect.e("input"), e.nsSelect.is(e.selectSize)]),
          disabled: e.selectDisabled,
          role: "combobox",
          readonly: !e.filterable,
          spellcheck: "false",
          type: "text",
          name: e.name,
          onFocus: t[1] || (t[1] = (...t)=>e.handleFocus && e.handleFocus(...t)),
          onBlur: t[2] || (t[2] = (...t)=>e.handleBlur && e.handleBlur(...t)),
          onInput: t[3] || (t[3] = (...t)=>e.onInput && e.onInput(...t)),
          onCompositionstart: t[4] || (t[4] = (...t)=>e.handleCompositionStart && e.handleCompositionStart(...t)),
          onCompositionupdate: t[5] || (t[5] = (...t)=>e.handleCompositionUpdate && e.handleCompositionUpdate(...t)),
          onCompositionend: t[6] || (t[6] = (...t)=>e.handleCompositionEnd && e.handleCompositionEnd(...t)),
          onKeydown: [t[7] || (t[7] = Us(js((t=>e.onKeyboardNavigate("backward")), ["stop", "prevent"]), ["up"])), t[8] || (t[8] = Us(js((t=>e.onKeyboardNavigate("forward")), ["stop", "prevent"]), ["down"])), t[9] || (t[9] = Us(js(((...t)=>e.onKeyboardSelect && e.onKeyboardSelect(...t)), ["stop", "prevent"]), ["enter"])), t[10] || (t[10] = Us(js(((...t)=>e.handleEsc && e.handleEsc(...t)), ["stop", "prevent"]), ["esc"])), t[11] || (t[11] = Us(js(((...t)=>e.handleDel && e.handleDel(...t)), ["stop"]), ["delete"]))],
          onClick: t[12] || (t[12] = js(((...t)=>e.toggleMenu && e.toggleMenu(...t)), ["stop"]))
        }, null, 46, NM), [[ks, e.states.inputValue]]), e.filterable ? (Ca(),
          _a("span", {
            key: 0,
            ref: "calculatorRef",
            "aria-hidden": "true",
            class: Y(e.nsSelect.e("input-calculator")),
            textContent: te(e.states.inputValue)
          }, null, 10, MM)) : za("v-if", !0)], 2)), e.shouldShowPlaceholder ? (Ca(),
        _a("div", {
          key: 2,
          class: Y([e.nsSelect.e("selected-item"), e.nsSelect.e("placeholder"), e.nsSelect.is("transparent", !e.hasModelValue || e.expanded && !e.states.inputValue)])
        }, [Ma("span", null, te(e.currentPlaceholder), 1)], 2)) : za("v-if", !0)], 2), Ma("div", {
        ref: "suffixRef",
        class: Y(e.nsSelect.e("suffix"))
      }, [e.iconComponent ? rr((Ca(),
        Ra(l, {
          key: 0,
          class: Y([e.nsSelect.e("caret"), e.nsInput.e("icon"), e.iconReverse])
        }, {
          default: Fn((()=>[(Ca(),
            Ra(Kr(e.iconComponent)))])),
          _: 1
        }, 8, ["class"])), [[$s, !e.showClearBtn]]) : za("v-if", !0), e.showClearBtn && e.clearIcon ? (Ca(),
        Ra(l, {
          key: 1,
          class: Y([e.nsSelect.e("caret"), e.nsInput.e("icon")]),
          onClick: js(e.handleClear, ["prevent", "stop"])
        }, {
          default: Fn((()=>[(Ca(),
            Ra(Kr(e.clearIcon)))])),
          _: 1
        }, 8, ["class", "onClick"])) : za("v-if", !0), e.validateState && e.validateIcon ? (Ca(),
        Ra(l, {
          key: 2,
          class: Y([e.nsInput.e("icon"), e.nsInput.e("validateIcon")])
        }, {
          default: Fn((()=>[(Ca(),
            Ra(Kr(e.validateIcon)))])),
          _: 1
        }, 8, ["class"])) : za("v-if", !0)], 2)], 2)])),
      content: Fn((()=>[ja(u, {
        ref: "menuRef",
        data: e.filteredOptions,
        width: e.popperSize,
        "hovering-index": e.states.hoveringIndex,
        "scrollbar-always-on": e.scrollbarAlwaysOn
      }, Xr({
        default: Fn((t=>[Qr(e.$slots, "default", X(Va(t)))])),
        _: 2
      }, [e.$slots.header ? {
        name: "header",
        fn: Fn((()=>[Ma("div", {
          class: Y(e.nsSelect.be("dropdown", "header"))
        }, [Qr(e.$slots, "header")], 2)]))
      } : void 0, e.$slots.loading && e.loading ? {
        name: "loading",
        fn: Fn((()=>[Ma("div", {
          class: Y(e.nsSelect.be("dropdown", "loading"))
        }, [Qr(e.$slots, "loading")], 2)]))
      } : e.loading || 0 === e.filteredOptions.length ? {
        name: "empty",
        fn: Fn((()=>[Ma("div", {
          class: Y(e.nsSelect.be("dropdown", "empty"))
        }, [Qr(e.$slots, "empty", {}, (()=>[Ma("span", null, te(e.emptyText), 1)]))], 2)]))
      } : void 0, e.$slots.footer ? {
        name: "footer",
        fn: Fn((()=>[Ma("div", {
          class: Y(e.nsSelect.be("dropdown", "footer"))
        }, [Qr(e.$slots, "footer")], 2)]))
      } : void 0]), 1032, ["data", "width", "hovering-index", "scrollbar-always-on"])])),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "placement", "transition", "persistent", "onBeforeShow"])], 34)), [[c, e.handleClickOutside, e.popperRef]])
}
], ["__file", "select.vue"]]);
jM.install = e=>{
  e.component(jM.name, jM)
}
;
const VM = jM
  , UM = uy({
  animated: {
    type: Boolean,
    default: !1
  },
  count: {
    type: Number,
    default: 1
  },
  rows: {
    type: Number,
    default: 3
  },
  loading: {
    type: Boolean,
    default: !0
  },
  throttle: {
    type: Number
  }
})
  , $M = uy({
  variant: {
    type: String,
    values: ["circle", "rect", "h1", "h3", "text", "caption", "p", "image", "button"],
    default: "text"
  }
})
  , HM = vr({
  name: "ElSkeletonItem"
});
var zM = tS(vr({
  ...HM,
  props: $M,
  setup(e) {
    const t = qy("skeleton");
    return (e,n)=>(Ca(),
      _a("div", {
        class: Y([Vt(t).e("item"), Vt(t).e(e.variant)])
      }, ["image" === e.variant ? (Ca(),
        Ra(Vt($m), {
          key: 0
        })) : za("v-if", !0)], 2))
  }
}), [["__file", "skeleton-item.vue"]]);
const KM = vr({
  name: "ElSkeleton"
})
  , WM = vr({
  ...KM,
  props: UM,
  setup(e, {expose: t}) {
    const n = e
      , r = qy("skeleton")
      , o = ((e,t=0)=>{
        if (0 === t)
          return e;
        const n = Ft(!1);
        let r = 0;
        const o = ()=>{
            r && clearTimeout(r),
              r = window.setTimeout((()=>{
                  n.value = e.value
                }
              ), t)
          }
        ;
        return Lr(o),
          Jn((()=>e.value), (e=>{
              e ? o() : n.value = e
            }
          )),
          n
      }
    )(Yt(n, "loading"), n.throttle);
    return t({
      uiLoading: o
    }),
      (e,t)=>Vt(o) ? (Ca(),
        _a("div", qa({
          key: 0,
          class: [Vt(r).b(), Vt(r).is("animated", e.animated)]
        }, e.$attrs), [(Ca(!0),
          _a(ba, null, Yr(e.count, (t=>(Ca(),
            _a(ba, {
              key: t
            }, [e.loading ? Qr(e.$slots, "template", {
              key: t
            }, (()=>[ja(zM, {
              class: Y(Vt(r).is("first")),
              variant: "p"
            }, null, 8, ["class"]), (Ca(!0),
              _a(ba, null, Yr(e.rows, (t=>(Ca(),
                Ra(zM, {
                  key: t,
                  class: Y([Vt(r).e("paragraph"), Vt(r).is("last", t === e.rows && e.rows > 1)]),
                  variant: "p"
                }, null, 8, ["class"])))), 128))])) : za("v-if", !0)], 64)))), 128))], 16)) : Qr(e.$slots, "default", X(qa({
        key: 1
      }, e.$attrs)))
  }
});
const GM = vy(tS(WM, [["__file", "skeleton.vue"]]), {
  SkeletonItem: zM
})
  , qM = my(zM)
  , YM = Symbol("sliderContextKey")
  , XM = uy({
  modelValue: {
    type: [Number, Array],
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  step: {
    type: Number,
    default: 1
  },
  showInput: Boolean,
  showInputControls: {
    type: Boolean,
    default: !0
  },
  size: Ux,
  inputSize: Ux,
  showStops: Boolean,
  showTooltip: {
    type: Boolean,
    default: !0
  },
  formatTooltip: {
    type: Function,
    default: void 0
  },
  disabled: Boolean,
  range: Boolean,
  vertical: Boolean,
  height: String,
  debounce: {
    type: Number,
    default: 300
  },
  label: {
    type: String,
    default: void 0
  },
  rangeStartLabel: {
    type: String,
    default: void 0
  },
  rangeEndLabel: {
    type: String,
    default: void 0
  },
  formatValueText: {
    type: Function,
    default: void 0
  },
  tooltipClass: {
    type: String,
    default: void 0
  },
  placement: {
    type: String,
    values: pb,
    default: "top"
  },
  marks: {
    type: Object
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
})
  , QM = e=>Vg(e) || h(e) && e.every(Vg)
  , JM = {
  [xy]: QM,
  [Ey]: QM,
  [Sy]: QM
}
  , ZM = (e,t,n)=>{
  const {form: r, formItem: o} = gS()
    , a = Bt()
    , i = Ft()
    , s = Ft()
    , l = {
      firstButton: i,
      secondButton: s
    }
    , u = yi((()=>e.disabled || (null == r ? void 0 : r.disabled) || !1))
    , c = yi((()=>Math.min(t.firstValue, t.secondValue)))
    , d = yi((()=>Math.max(t.firstValue, t.secondValue)))
    , f = yi((()=>e.range ? 100 * (d.value - c.value) / (e.max - e.min) + "%" : 100 * (t.firstValue - e.min) / (e.max - e.min) + "%"))
    , p = yi((()=>e.range ? 100 * (c.value - e.min) / (e.max - e.min) + "%" : "0%"))
    , h = yi((()=>e.vertical ? {
      height: e.height
    } : {}))
    , v = yi((()=>e.vertical ? {
      height: f.value,
      bottom: p.value
    } : {
      width: f.value,
      left: p.value
    }))
    , g = ()=>{
      a.value && (t.sliderSize = a.value["client" + (e.vertical ? "Height" : "Width")])
    }
    , m = n=>{
      const r = (n=>{
          const r = e.min + n * (e.max - e.min) / 100;
          if (!e.range)
            return i;
          let o;
          return o = Math.abs(c.value - r) < Math.abs(d.value - r) ? t.firstValue < t.secondValue ? "firstButton" : "secondButton" : t.firstValue > t.secondValue ? "firstButton" : "secondButton",
            l[o]
        }
      )(n);
      return r.value.setPosition(n),
        r
    }
    , y = e=>{
      n(xy, e),
        n(Ey, e)
    }
    , b = async()=>{
      await hn(),
        n(Sy, e.range ? [c.value, d.value] : e.modelValue)
    }
    , w = n=>{
      var r, o, i, s, l, c;
      if (u.value || t.dragging)
        return;
      g();
      let d = 0;
      if (e.vertical) {
        const e = null != (i = null == (o = null == (r = n.touches) ? void 0 : r.item(0)) ? void 0 : o.clientY) ? i : n.clientY;
        d = (a.value.getBoundingClientRect().bottom - e) / t.sliderSize * 100
      } else {
        d = ((null != (c = null == (l = null == (s = n.touches) ? void 0 : s.item(0)) ? void 0 : l.clientX) ? c : n.clientX) - a.value.getBoundingClientRect().left) / t.sliderSize * 100
      }
      return d < 0 || d > 100 ? void 0 : m(d)
    }
  ;
  return {
    elFormItem: o,
    slider: a,
    firstButton: i,
    secondButton: s,
    sliderDisabled: u,
    minValue: c,
    maxValue: d,
    runwayStyle: h,
    barStyle: v,
    resetSize: g,
    setPosition: m,
    emitChange: b,
    onSliderWrapperPrevent: e=>{
      var t, n;
      ((null == (t = l.firstButton.value) ? void 0 : t.dragging) || (null == (n = l.secondButton.value) ? void 0 : n.dragging)) && e.preventDefault()
    }
    ,
    onSliderClick: e=>{
      w(e) && b()
    }
    ,
    onSliderDown: async e=>{
      const t = w(e);
      t && (await hn(),
        t.value.onButtonDown(e))
    }
    ,
    setFirstValue: n=>{
      t.firstValue = n,
        y(e.range ? [c.value, d.value] : n)
    }
    ,
    setSecondValue: n=>{
      t.secondValue = n,
      e.range && y([c.value, d.value])
    }
  }
}
  , {left: ej, down: tj, right: nj, up: rj, home: oj, end: aj, pageUp: ij, pageDown: sj} = by
  , lj = (e,t,n)=>{
  const {disabled: r, min: o, max: a, step: i, showTooltip: s, precision: l, sliderSize: u, formatTooltip: c, emitChange: d, resetSize: f, updateDragging: p} = jo(YM)
    , {tooltip: h, tooltipVisible: v, formatValue: g, displayTooltip: m, hideTooltip: y} = ((e,t,n)=>{
        const r = Ft()
          , o = Ft(!1)
          , a = yi((()=>t.value instanceof Function))
          , i = yi((()=>a.value && t.value(e.modelValue) || e.modelValue))
          , s = ug((()=>{
            n.value && (o.value = !0)
          }
        ), 50)
          , l = ug((()=>{
            n.value && (o.value = !1)
          }
        ), 50);
        return {
          tooltip: r,
          tooltipVisible: o,
          formatValue: i,
          displayTooltip: s,
          hideTooltip: l
        }
      }
    )(e, c, s)
    , b = Ft()
    , w = yi((()=>(e.modelValue - o.value) / (a.value - o.value) * 100 + "%"))
    , x = yi((()=>e.vertical ? {
      bottom: w.value
    } : {
      left: w.value
    }))
    , S = e=>{
      r.value || (t.newPosition = Number.parseFloat(w.value) + e / (a.value - o.value) * 100,
        T(t.newPosition),
        d())
    }
    , E = e=>{
      let t, n;
      return e.type.startsWith("touch") ? (n = e.touches[0].clientY,
        t = e.touches[0].clientX) : (n = e.clientY,
        t = e.clientX),
        {
          clientX: t,
          clientY: n
        }
    }
    , A = n=>{
      t.dragging = !0,
        t.isClick = !0;
      const {clientX: r, clientY: o} = E(n);
      e.vertical ? t.startY = o : t.startX = r,
        t.startPosition = Number.parseFloat(w.value),
        t.newPosition = t.startPosition
    }
    , C = n=>{
      if (t.dragging) {
        let r;
        t.isClick = !1,
          m(),
          f();
        const {clientX: o, clientY: a} = E(n);
        e.vertical ? (t.currentY = a,
          r = (t.startY - t.currentY) / u.value * 100) : (t.currentX = o,
          r = (t.currentX - t.startX) / u.value * 100),
          t.newPosition = t.startPosition + r,
          T(t.newPosition)
      }
    }
    , k = ()=>{
      t.dragging && (setTimeout((()=>{
          t.dragging = !1,
          t.hovering || y(),
          t.isClick || T(t.newPosition),
            d()
        }
      ), 0),
        window.removeEventListener("mousemove", C),
        window.removeEventListener("touchmove", C),
        window.removeEventListener("mouseup", k),
        window.removeEventListener("touchend", k),
        window.removeEventListener("contextmenu", k))
    }
    , T = async r=>{
      if (null === r || Number.isNaN(+r))
        return;
      r < 0 ? r = 0 : r > 100 && (r = 100);
      const s = 100 / ((a.value - o.value) / i.value);
      let u = Math.round(r / s) * s * (a.value - o.value) * .01 + o.value;
      u = Number.parseFloat(u.toFixed(l.value)),
      u !== e.modelValue && n(xy, u),
      t.dragging || e.modelValue === t.oldValue || (t.oldValue = e.modelValue),
        await hn(),
      t.dragging && m(),
        h.value.updatePopper()
    }
  ;
  return Jn((()=>t.dragging), (e=>{
      p(e)
    }
  )),
    {
      disabled: r,
      button: b,
      tooltip: h,
      tooltipVisible: v,
      showTooltip: s,
      wrapperStyle: x,
      formatValue: g,
      handleMouseEnter: ()=>{
        t.hovering = !0,
          m()
      }
      ,
      handleMouseLeave: ()=>{
        t.hovering = !1,
        t.dragging || y()
      }
      ,
      onButtonDown: e=>{
        r.value || (e.preventDefault(),
          A(e),
          window.addEventListener("mousemove", C),
          window.addEventListener("touchmove", C),
          window.addEventListener("mouseup", k),
          window.addEventListener("touchend", k),
          window.addEventListener("contextmenu", k),
          b.value.focus())
      }
      ,
      onKeyDown: e=>{
        let t = !0;
        [ej, tj].includes(e.key) ? S(-i.value) : [nj, rj].includes(e.key) ? S(i.value) : e.key === oj ? r.value || (T(0),
          d()) : e.key === aj ? r.value || (T(100),
          d()) : e.key === sj ? S(4 * -i.value) : e.key === ij ? S(4 * i.value) : t = !1,
        t && e.preventDefault()
      }
      ,
      setPosition: T
    }
}
  , uj = uy({
  modelValue: {
    type: Number,
    default: 0
  },
  vertical: Boolean,
  tooltipClass: String,
  placement: {
    type: String,
    values: pb,
    default: "top"
  }
})
  , cj = {
  [xy]: e=>Vg(e)
}
  , dj = ["tabindex"]
  , fj = vr({
  name: "ElSliderButton"
});
var pj = tS(vr({
  ...fj,
  props: uj,
  emits: cj,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = qy("slider")
      , a = bt({
      hovering: !1,
      dragging: !1,
      isClick: !1,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: r.modelValue
    })
      , {disabled: i, button: s, tooltip: l, showTooltip: u, tooltipVisible: c, wrapperStyle: d, formatValue: f, handleMouseEnter: p, handleMouseLeave: h, onButtonDown: v, onKeyDown: g, setPosition: m} = lj(r, a, n)
      , {hovering: y, dragging: b} = Wt(a);
    return t({
      onButtonDown: v,
      onKeyDown: g,
      setPosition: m,
      hovering: y,
      dragging: b
    }),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "button",
          ref: s,
          class: Y([Vt(o).e("button-wrapper"), {
            hover: Vt(y),
            dragging: Vt(b)
          }]),
          style: z(Vt(d)),
          tabindex: Vt(i) ? -1 : 0,
          onMouseenter: t[0] || (t[0] = (...e)=>Vt(p) && Vt(p)(...e)),
          onMouseleave: t[1] || (t[1] = (...e)=>Vt(h) && Vt(h)(...e)),
          onMousedown: t[2] || (t[2] = (...e)=>Vt(v) && Vt(v)(...e)),
          onTouchstart: t[3] || (t[3] = (...e)=>Vt(v) && Vt(v)(...e)),
          onFocus: t[4] || (t[4] = (...e)=>Vt(p) && Vt(p)(...e)),
          onBlur: t[5] || (t[5] = (...e)=>Vt(h) && Vt(h)(...e)),
          onKeydown: t[6] || (t[6] = (...e)=>Vt(g) && Vt(g)(...e))
        }, [ja(Vt(MA), {
          ref_key: "tooltip",
          ref: l,
          visible: Vt(c),
          placement: e.placement,
          "fallback-placements": ["top", "bottom", "right", "left"],
          "stop-popper-mouse-event": !1,
          "popper-class": e.tooltipClass,
          disabled: !Vt(u),
          persistent: ""
        }, {
          content: Fn((()=>[Ma("span", null, te(Vt(f)), 1)])),
          default: Fn((()=>[Ma("div", {
            class: Y([Vt(o).e("button"), {
              hover: Vt(y),
              dragging: Vt(b)
            }])
          }, null, 2)])),
          _: 1
        }, 8, ["visible", "placement", "popper-class", "disabled"])], 46, dj))
  }
}), [["__file", "button.vue"]]);
var hj = vr({
  name: "ElSliderMarker",
  props: uy({
    mark: {
      type: [String, Object],
      default: void 0
    }
  }),
  setup(e) {
    const t = qy("slider")
      , n = yi((()=>b(e.mark) ? e.mark : e.mark.label))
      , r = yi((()=>b(e.mark) ? void 0 : e.mark.style));
    return ()=>bi("div", {
      class: t.e("marks-text"),
      style: r.value
    }, n.value)
  }
});
const vj = ["id", "role", "aria-label", "aria-labelledby"]
  , gj = {
  key: 1
}
  , mj = vr({
  name: "ElSlider"
})
  , yj = vr({
  ...mj,
  props: XM,
  emits: JM,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = qy("slider")
      , {t: a} = Hy()
      , i = bt({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: !1,
      sliderSize: 1
    })
      , {elFormItem: s, slider: l, firstButton: u, secondButton: c, sliderDisabled: d, minValue: f, maxValue: p, runwayStyle: h, barStyle: v, resetSize: g, emitChange: m, onSliderWrapperPrevent: y, onSliderClick: b, onSliderDown: w, setFirstValue: x, setSecondValue: S} = ZM(r, i, n)
      , {stops: E, getStopStyle: A} = ((e,t,n,r)=>({
      stops: yi((()=>{
          if (!e.showStops || e.min > e.max)
            return [];
          if (0 === e.step)
            return [];
          const o = (e.max - e.min) / e.step
            , a = 100 * e.step / (e.max - e.min)
            , i = Array.from({
            length: o - 1
          }).map(((e,t)=>(t + 1) * a));
          return e.range ? i.filter((t=>t < 100 * (n.value - e.min) / (e.max - e.min) || t > 100 * (r.value - e.min) / (e.max - e.min))) : i.filter((n=>n > 100 * (t.firstValue - e.min) / (e.max - e.min)))
        }
      )),
      getStopStyle: t=>e.vertical ? {
        bottom: `${t}%`
      } : {
        left: `${t}%`
      }
    }))(r, i, f, p)
      , {inputId: C, isLabeledByFormItem: k} = mS(r, {
      formItemContext: s
    })
      , T = hS()
      , D = yi((()=>r.inputSize || T.value))
      , O = yi((()=>r.label || a("el.slider.defaultLabel", {
      min: r.min,
      max: r.max
    })))
      , _ = yi((()=>r.range ? r.rangeStartLabel || a("el.slider.defaultRangeStartLabel") : O.value))
      , R = yi((()=>r.formatValueText ? r.formatValueText(M.value) : `${M.value}`))
      , L = yi((()=>r.rangeEndLabel || a("el.slider.defaultRangeEndLabel")))
      , I = yi((()=>r.formatValueText ? r.formatValueText(j.value) : `${j.value}`))
      , P = yi((()=>[o.b(), o.m(T.value), o.is("vertical", r.vertical), {
      [o.m("with-input")]: r.showInput
    }]))
      , F = (e=>yi((()=>e.marks ? Object.keys(e.marks).map(Number.parseFloat).sort(((e,t)=>e - t)).filter((t=>t <= e.max && t >= e.min)).map((t=>({
      point: t,
      position: 100 * (t - e.min) / (e.max - e.min),
      mark: e.marks[t]
    }))) : [])))(r);
    ((e,t,n,r,o,a)=>{
        const i = e=>{
            o(xy, e),
              o(Ey, e)
          }
          , s = ()=>e.range ? ![n.value, r.value].every(((e,n)=>e === t.oldValue[n])) : e.modelValue !== t.oldValue
          , l = ()=>{
            var n, r;
            e.min > e.max && Jg("Slider", "min should not be greater than max.");
            const o = e.modelValue;
            e.range && Array.isArray(o) ? o[1] < e.min ? i([e.min, e.min]) : o[0] > e.max ? i([e.max, e.max]) : o[0] < e.min ? i([e.min, o[1]]) : o[1] > e.max ? i([o[0], e.max]) : (t.firstValue = o[0],
              t.secondValue = o[1],
            s() && (e.validateEvent && (null == (n = null == a ? void 0 : a.validate) || n.call(a, "change").catch((e=>{}
            ))),
              t.oldValue = o.slice())) : e.range || "number" != typeof o || Number.isNaN(o) || (o < e.min ? i(e.min) : o > e.max ? i(e.max) : (t.firstValue = o,
            s() && (e.validateEvent && (null == (r = null == a ? void 0 : a.validate) || r.call(a, "change").catch((e=>{}
            ))),
              t.oldValue = o)))
          }
        ;
        l(),
          Jn((()=>t.dragging), (e=>{
              e || l()
            }
          )),
          Jn((()=>e.modelValue), ((e,n)=>{
              t.dragging || Array.isArray(e) && Array.isArray(n) && e.every(((e,t)=>e === n[t])) && t.firstValue === e[0] && t.secondValue === e[1] || l()
            }
          ), {
            deep: !0
          }),
          Jn((()=>[e.min, e.max]), (()=>{
              l()
            }
          ))
      }
    )(r, i, f, p, n, s);
    const B = yi((()=>{
        const e = [r.min, r.max, r.step].map((e=>{
            const t = `${e}`.split(".")[1];
            return t ? t.length : 0
          }
        ));
        return Math.max.apply(null, e)
      }
    ))
      , {sliderWrapper: N} = ((e,t,n)=>{
        const r = Ft();
        return Lr((async()=>{
            e.range ? (Array.isArray(e.modelValue) ? (t.firstValue = Math.max(e.min, e.modelValue[0]),
              t.secondValue = Math.min(e.max, e.modelValue[1])) : (t.firstValue = e.min,
              t.secondValue = e.max),
              t.oldValue = [t.firstValue, t.secondValue]) : ("number" != typeof e.modelValue || Number.isNaN(e.modelValue) ? t.firstValue = e.min : t.firstValue = Math.min(e.max, Math.max(e.min, e.modelValue)),
              t.oldValue = t.firstValue),
              Rc(window, "resize", n),
              await hn(),
              n()
          }
        )),
          {
            sliderWrapper: r
          }
      }
    )(r, i, g)
      , {firstValue: M, secondValue: j, sliderSize: V} = Wt(i);
    return Mo(YM, {
      ...Wt(r),
      sliderSize: V,
      disabled: d,
      precision: B,
      emitChange: m,
      resetSize: g,
      updateDragging: e=>{
        i.dragging = e
      }
    }),
      t({
        onSliderClick: b
      }),
      (e,t)=>{
        var n, r;
        return Ca(),
          _a("div", {
            id: e.range ? Vt(C) : void 0,
            ref_key: "sliderWrapper",
            ref: N,
            class: Y(Vt(P)),
            role: e.range ? "group" : void 0,
            "aria-label": e.range && !Vt(k) ? Vt(O) : void 0,
            "aria-labelledby": e.range && Vt(k) ? null == (n = Vt(s)) ? void 0 : n.labelId : void 0,
            onTouchstart: t[2] || (t[2] = (...e)=>Vt(y) && Vt(y)(...e)),
            onTouchmove: t[3] || (t[3] = (...e)=>Vt(y) && Vt(y)(...e))
          }, [Ma("div", {
            ref_key: "slider",
            ref: l,
            class: Y([Vt(o).e("runway"), {
              "show-input": e.showInput && !e.range
            }, Vt(o).is("disabled", Vt(d))]),
            style: z(Vt(h)),
            onMousedown: t[0] || (t[0] = (...e)=>Vt(w) && Vt(w)(...e)),
            onTouchstart: t[1] || (t[1] = (...e)=>Vt(w) && Vt(w)(...e))
          }, [Ma("div", {
            class: Y(Vt(o).e("bar")),
            style: z(Vt(v))
          }, null, 6), ja(pj, {
            id: e.range ? void 0 : Vt(C),
            ref_key: "firstButton",
            ref: u,
            "model-value": Vt(M),
            vertical: e.vertical,
            "tooltip-class": e.tooltipClass,
            placement: e.placement,
            role: "slider",
            "aria-label": e.range || !Vt(k) ? Vt(_) : void 0,
            "aria-labelledby": !e.range && Vt(k) ? null == (r = Vt(s)) ? void 0 : r.labelId : void 0,
            "aria-valuemin": e.min,
            "aria-valuemax": e.range ? Vt(j) : e.max,
            "aria-valuenow": Vt(M),
            "aria-valuetext": Vt(R),
            "aria-orientation": e.vertical ? "vertical" : "horizontal",
            "aria-disabled": Vt(d),
            "onUpdate:modelValue": Vt(x)
          }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]), e.range ? (Ca(),
            Ra(pj, {
              key: 0,
              ref_key: "secondButton",
              ref: c,
              "model-value": Vt(j),
              vertical: e.vertical,
              "tooltip-class": e.tooltipClass,
              placement: e.placement,
              role: "slider",
              "aria-label": Vt(L),
              "aria-valuemin": Vt(M),
              "aria-valuemax": e.max,
              "aria-valuenow": Vt(j),
              "aria-valuetext": Vt(I),
              "aria-orientation": e.vertical ? "vertical" : "horizontal",
              "aria-disabled": Vt(d),
              "onUpdate:modelValue": Vt(S)
            }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : za("v-if", !0), e.showStops ? (Ca(),
            _a("div", gj, [(Ca(!0),
              _a(ba, null, Yr(Vt(E), ((e,t)=>(Ca(),
                _a("div", {
                  key: t,
                  class: Y(Vt(o).e("stop")),
                  style: z(Vt(A)(e))
                }, null, 6)))), 128))])) : za("v-if", !0), Vt(F).length > 0 ? (Ca(),
            _a(ba, {
              key: 2
            }, [Ma("div", null, [(Ca(!0),
              _a(ba, null, Yr(Vt(F), ((e,t)=>(Ca(),
                _a("div", {
                  key: t,
                  style: z(Vt(A)(e.position)),
                  class: Y([Vt(o).e("stop"), Vt(o).e("marks-stop")])
                }, null, 6)))), 128))]), Ma("div", {
              class: Y(Vt(o).e("marks"))
            }, [(Ca(!0),
              _a(ba, null, Yr(Vt(F), ((e,t)=>(Ca(),
                Ra(Vt(hj), {
                  key: t,
                  mark: e.mark,
                  style: z(Vt(A)(e.position))
                }, null, 8, ["mark", "style"])))), 128))], 2)], 64)) : za("v-if", !0)], 38), e.showInput && !e.range ? (Ca(),
            Ra(Vt(QP), {
              key: 0,
              ref: "input",
              "model-value": Vt(M),
              class: Y(Vt(o).e("input")),
              step: e.step,
              disabled: Vt(d),
              controls: e.showInputControls,
              min: e.min,
              max: e.max,
              debounce: e.debounce,
              size: Vt(D),
              "onUpdate:modelValue": Vt(x),
              onChange: Vt(m)
            }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "debounce", "size", "onUpdate:modelValue", "onChange"])) : za("v-if", !0)], 42, vj)
      }
  }
});
const bj = vy(tS(yj, [["__file", "slider.vue"]]))
  , wj = vr({
  name: "ElSpaceItem",
  props: uy({
    prefixCls: {
      type: String
    }
  }),
  setup(e, {slots: t}) {
    const n = qy("space")
      , r = yi((()=>`${e.prefixCls || n.b()}__item`));
    return ()=>bi("div", {
      class: r.value
    }, Qr(t, "default"))
  }
})
  , xj = {
  small: 8,
  default: 12,
  large: 16
};
const Sj = vy(vr({
  name: "ElSpace",
  props: uy({
    direction: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    class: {
      type: [String, Object, Array],
      default: ""
    },
    style: {
      type: [String, Array, Object],
      default: ""
    },
    alignment: {
      type: String,
      default: "center"
    },
    prefixCls: {
      type: String
    },
    spacer: {
      type: [Object, String, Number, Array],
      default: null,
      validator: e=>La(e) || Vg(e) || b(e)
    },
    wrap: Boolean,
    fill: Boolean,
    fillRatio: {
      type: Number,
      default: 100
    },
    size: {
      type: [String, Array, Number],
      values: Cy,
      validator: e=>Vg(e) || h(e) && 2 === e.length && e.every(Vg)
    }
  }),
  setup(e, {slots: t}) {
    const {classes: n, containerStyle: r, itemStyle: o} = function(e) {
      const t = qy("space")
        , n = yi((()=>[t.b(), t.m(e.direction), e.class]))
        , r = Ft(0)
        , o = Ft(0)
        , a = yi((()=>[e.wrap || e.fill ? {
        flexWrap: "wrap"
      } : {}, {
        alignItems: e.alignment
      }, {
        rowGap: `${o.value}px`,
        columnGap: `${r.value}px`
      }, e.style]))
        , i = yi((()=>e.fill ? {
        flexGrow: 1,
        minWidth: `${e.fillRatio}%`
      } : {}));
      return qn((()=>{
          const {size: t="small", wrap: n, direction: a, fill: i} = e;
          if (h(t)) {
            const [e=0,n=0] = t;
            r.value = e,
              o.value = n
          } else {
            let e;
            e = Vg(t) ? t : xj[t || "small"] || xj.small,
              (n || i) && "horizontal" === a ? r.value = o.value = e : "horizontal" === a ? (r.value = e,
                o.value = 0) : (o.value = e,
                r.value = 0)
          }
        }
      )),
        {
          classes: n,
          containerStyle: a,
          itemStyle: i
        }
    }(e);
    function a(t, n="", r=[]) {
      const {prefixCls: i} = e;
      return t.forEach(((e,t)=>{
          Dy(e) ? h(e.children) && e.children.forEach(((e,t)=>{
              Dy(e) && h(e.children) ? a(e.children, `${n + t}-`, r) : r.push(ja(wj, {
                style: o.value,
                prefixCls: i,
                key: `nested-${n + t}`
              }, {
                default: ()=>[e]
              }, Ty.PROPS | Ty.STYLE, ["style", "prefixCls"]))
            }
          )) : Oy(e) && r.push(ja(wj, {
            style: o.value,
            prefixCls: i,
            key: `LoopKey${n + t}`
          }, {
            default: ()=>[e]
          }, Ty.PROPS | Ty.STYLE, ["style", "prefixCls"]))
        }
      )),
        r
    }
    return ()=>{
      var i;
      const {spacer: s, direction: l} = e
        , u = Qr(t, "default", {
        key: 0
      }, (()=>[]));
      if (0 === (null != (i = u.children) ? i : []).length)
        return null;
      if (h(u.children)) {
        let e = a(u.children);
        if (s) {
          const t = e.length - 1;
          e = e.reduce(((e,n,r)=>{
              const a = [...e, n];
              return r !== t && a.push(ja("span", {
                style: [o.value, "vertical" === l ? "width: 100%" : null],
                key: r
              }, [La(s) ? s : $a(s, Ty.TEXT)], Ty.STYLE)),
                a
            }
          ), [])
        }
        return ja("div", {
          class: n.value,
          style: r.value
        }, e, Ty.STYLE | Ty.CLASS)
      }
      return u.children
    }
  }
}))
  , Ej = uy({
  decimalSeparator: {
    type: String,
    default: "."
  },
  groupSeparator: {
    type: String,
    default: ","
  },
  precision: {
    type: Number,
    default: 0
  },
  formatter: Function,
  value: {
    type: [Number, Object],
    default: 0
  },
  prefix: String,
  suffix: String,
  title: String,
  valueStyle: {
    type: [String, Object, Array]
  }
})
  , Aj = vr({
  name: "ElStatistic"
});
const Cj = vy(tS(vr({
  ...Aj,
  props: Ej,
  setup(e, {expose: t}) {
    const n = e
      , r = qy("statistic")
      , o = yi((()=>{
        const {value: e, formatter: t, precision: r, decimalSeparator: o, groupSeparator: a} = n;
        if (y(t))
          return t(e);
        if (!Vg(e))
          return e;
        let[i,s=""] = String(e).split(".");
        return s = s.padEnd(r, "0").slice(0, r > 0 ? r : 0),
          i = i.replace(/\B(?=(\d{3})+(?!\d))/g, a),
          [i, s].join(s ? o : "")
      }
    ));
    return t({
      displayValue: o
    }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y(Vt(r).b())
        }, [e.$slots.title || e.title ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(r).e("head"))
          }, [Qr(e.$slots, "title", {}, (()=>[$a(te(e.title), 1)]))], 2)) : za("v-if", !0), Ma("div", {
          class: Y(Vt(r).e("content"))
        }, [e.$slots.prefix || e.prefix ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(r).e("prefix"))
          }, [Qr(e.$slots, "prefix", {}, (()=>[Ma("span", null, te(e.prefix), 1)]))], 2)) : za("v-if", !0), Ma("span", {
          class: Y(Vt(r).e("number")),
          style: z(e.valueStyle)
        }, te(Vt(o)), 7), e.$slots.suffix || e.suffix ? (Ca(),
          _a("div", {
            key: 1,
            class: Y(Vt(r).e("suffix"))
          }, [Qr(e.$slots, "suffix", {}, (()=>[Ma("span", null, te(e.suffix), 1)]))], 2)) : za("v-if", !0)], 2)], 2))
  }
}), [["__file", "statistic.vue"]]))
  , kj = uy({
  format: {
    type: String,
    default: "HH:mm:ss"
  },
  prefix: String,
  suffix: String,
  title: String,
  value: {
    type: [Number, Object],
    default: 0
  },
  valueStyle: {
    type: [String, Object, Array]
  }
})
  , Tj = {
  finish: ()=>!0,
  [Sy]: e=>Vg(e)
}
  , Dj = [["Y", 31536e6], ["M", 2592e6], ["D", 864e5], ["H", 36e5], ["m", 6e4], ["s", 1e3], ["S", 1]]
  , Oj = e=>Vg(e) ? new Date(e).getTime() : e.valueOf()
  , _j = (e,t)=>{
  let n = e;
  const r = Dj.reduce(((e,[t,r])=>{
      const o = new RegExp(`${t}+(?![^\\[\\]]*\\])`,"g");
      if (o.test(e)) {
        const t = Math.floor(n / r);
        return n -= t * r,
          e.replace(o, (e=>String(t).padStart(e.length, "0")))
      }
      return e
    }
  ), t);
  return r.replace(/\[([^\]]*)]/g, "$1")
}
  , Rj = vr({
  name: "ElCountdown"
})
  , Lj = vr({
  ...Rj,
  props: kj,
  emits: Tj,
  setup(e, {expose: t, emit: n}) {
    const r = e;
    let o;
    const a = Ft(Oj(r.value) - Date.now())
      , i = yi((()=>_j(a.value, r.format)))
      , s = e=>_j(e, r.format)
      , l = ()=>{
        o && (Wg(o),
          o = void 0)
      }
    ;
    return Jn((()=>[r.value, r.format]), (()=>{
        l(),
          (()=>{
              const e = Oj(r.value)
                , t = ()=>{
                  let r = e - Date.now();
                  n("change", r),
                    r <= 0 ? (r = 0,
                      l(),
                      n("finish")) : o = Kg(t),
                    a.value = r
                }
              ;
              o = Kg(t)
            }
          )()
      }
    ), {
      immediate: !0
    }),
      Fr((()=>{
          l()
        }
      )),
      t({
        displayValue: i
      }),
      (e,t)=>(Ca(),
        Ra(Vt(Cj), {
          value: a.value,
          title: e.title,
          prefix: e.prefix,
          suffix: e.suffix,
          "value-style": e.valueStyle,
          formatter: s
        }, Xr({
          _: 2
        }, [Yr(e.$slots, ((t,n)=>({
          name: n,
          fn: Fn((()=>[Qr(e.$slots, n)]))
        })))]), 1032, ["value", "title", "prefix", "suffix", "value-style"]))
  }
});
const Ij = vy(tS(Lj, [["__file", "countdown.vue"]]))
  , Pj = uy({
  space: {
    type: [Number, String],
    default: ""
  },
  active: {
    type: Number,
    default: 0
  },
  direction: {
    type: String,
    default: "horizontal",
    values: ["horizontal", "vertical"]
  },
  alignCenter: {
    type: Boolean
  },
  simple: {
    type: Boolean
  },
  finishStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "finish"
  },
  processStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "process"
  }
})
  , Fj = {
  [Sy]: (e,t)=>[e, t].every(Vg)
}
  , Bj = vr({
  name: "ElSteps"
});
var Nj = tS(vr({
  ...Bj,
  props: Pj,
  emits: Fj,
  setup(e, {emit: t}) {
    const n = e
      , r = qy("steps")
      , {children: o, addChild: a, removeChild: i} = Vx(ei(), "ElStep");
    return Jn(o, (()=>{
        o.value.forEach(((e,t)=>{
            e.setIndex(t)
          }
        ))
      }
    )),
      Mo("ElSteps", {
        props: n,
        steps: o,
        addStep: a,
        removeStep: i
      }),
      Jn((()=>n.active), ((e,n)=>{
          t(Sy, e, n)
        }
      )),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y([Vt(r).b(), Vt(r).m(e.simple ? "simple" : e.direction)])
        }, [Qr(e.$slots, "default")], 2))
  }
}), [["__file", "steps.vue"]]);
const Mj = uy({
  title: {
    type: String,
    default: ""
  },
  icon: {
    type: cy
  },
  description: {
    type: String,
    default: ""
  },
  status: {
    type: String,
    values: ["", "wait", "process", "finish", "error", "success"],
    default: ""
  }
})
  , jj = vr({
  name: "ElStep"
});
var Vj = tS(vr({
  ...jj,
  props: Mj,
  setup(e) {
    const t = e
      , n = qy("step")
      , r = Ft(-1)
      , o = Ft({})
      , a = Ft("")
      , i = jo("ElSteps")
      , s = ei();
    Lr((()=>{
        Jn([()=>i.props.active, ()=>i.props.processStatus, ()=>i.props.finishStatus], (([e])=>{
            y(e)
          }
        ), {
          immediate: !0
        })
      }
    )),
      Fr((()=>{
          i.removeStep(b.uid)
        }
      ));
    const l = yi((()=>t.status || a.value))
      , u = yi((()=>{
        const e = i.steps.value[r.value - 1];
        return e ? e.currentStatus : "wait"
      }
    ))
      , c = yi((()=>i.props.alignCenter))
      , d = yi((()=>"vertical" === i.props.direction))
      , f = yi((()=>i.props.simple))
      , p = yi((()=>i.steps.value.length))
      , h = yi((()=>{
        var e;
        return (null == (e = i.steps.value[p.value - 1]) ? void 0 : e.uid) === (null == s ? void 0 : s.uid)
      }
    ))
      , v = yi((()=>f.value ? "" : i.props.space))
      , g = yi((()=>[n.b(), n.is(f.value ? "simple" : i.props.direction), n.is("flex", h.value && !v.value && !c.value), n.is("center", c.value && !d.value && !f.value)]))
      , m = yi((()=>{
        const e = {
          flexBasis: Vg(v.value) ? `${v.value}px` : v.value ? v.value : 100 / (p.value - (c.value ? 0 : 1)) + "%"
        };
        return d.value || h.value && (e.maxWidth = 100 / p.value + "%"),
          e
      }
    ))
      , y = e=>{
      e > r.value ? a.value = i.props.finishStatus : e === r.value && "error" !== u.value ? a.value = i.props.processStatus : a.value = "wait";
      const t = i.steps.value[r.value - 1];
      t && t.calcProgress(a.value)
    }
      , b = bt({
      uid: s.uid,
      currentStatus: l,
      setIndex: e=>{
        r.value = e
      }
      ,
      calcProgress: e=>{
        const t = "wait" === e
          , n = {
          transitionDelay: `${t ? "-" : ""}${150 * r.value}ms`
        }
          , a = e === i.props.processStatus || t ? 0 : 100;
        n.borderWidth = a && !f.value ? "1px" : 0,
          n["vertical" === i.props.direction ? "height" : "width"] = `${a}%`,
          o.value = n
      }
    });
    return i.addStep(b),
      (e,t)=>(Ca(),
        _a("div", {
          style: z(Vt(m)),
          class: Y(Vt(g))
        }, [za(" icon & line "), Ma("div", {
          class: Y([Vt(n).e("head"), Vt(n).is(Vt(l))])
        }, [Vt(f) ? za("v-if", !0) : (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(n).e("line"))
          }, [Ma("i", {
            class: Y(Vt(n).e("line-inner")),
            style: z(o.value)
          }, null, 6)], 2)), Ma("div", {
          class: Y([Vt(n).e("icon"), Vt(n).is(e.icon || e.$slots.icon ? "icon" : "text")])
        }, [Qr(e.$slots, "icon", {}, (()=>[e.icon ? (Ca(),
          Ra(Vt(sS), {
            key: 0,
            class: Y(Vt(n).e("icon-inner"))
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(e.icon)))])),
            _: 1
          }, 8, ["class"])) : "success" === Vt(l) ? (Ca(),
          Ra(Vt(sS), {
            key: 1,
            class: Y([Vt(n).e("icon-inner"), Vt(n).is("status")])
          }, {
            default: Fn((()=>[ja(Vt(Sm))])),
            _: 1
          }, 8, ["class"])) : "error" === Vt(l) ? (Ca(),
          Ra(Vt(sS), {
            key: 2,
            class: Y([Vt(n).e("icon-inner"), Vt(n).is("status")])
          }, {
            default: Fn((()=>[ja(Vt(Dm))])),
            _: 1
          }, 8, ["class"])) : Vt(f) ? za("v-if", !0) : (Ca(),
          _a("div", {
            key: 3,
            class: Y(Vt(n).e("icon-inner"))
          }, te(r.value + 1), 3))]))], 2)], 2), za(" title & description "), Ma("div", {
          class: Y(Vt(n).e("main"))
        }, [Ma("div", {
          class: Y([Vt(n).e("title"), Vt(n).is(Vt(l))])
        }, [Qr(e.$slots, "title", {}, (()=>[$a(te(e.title), 1)]))], 2), Vt(f) ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(n).e("arrow"))
          }, null, 2)) : (Ca(),
          _a("div", {
            key: 1,
            class: Y([Vt(n).e("description"), Vt(n).is(Vt(l))])
          }, [Qr(e.$slots, "description", {}, (()=>[$a(te(e.description), 1)]))], 2))], 2)], 6))
  }
}), [["__file", "item.vue"]]);
const Uj = vy(Nj, {
  Step: Vj
})
  , $j = my(Vj)
  , Hj = uy({
  modelValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  loading: {
    type: Boolean,
    default: !1
  },
  size: {
    type: String,
    validator: ky
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: {
    type: Boolean,
    default: !1
  },
  inactiveActionIcon: {
    type: cy
  },
  activeActionIcon: {
    type: cy
  },
  activeIcon: {
    type: cy
  },
  inactiveIcon: {
    type: cy
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: !0
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  beforeChange: {
    type: Function
  },
  id: String,
  tabindex: {
    type: [String, Number]
  },
  label: {
    type: String,
    default: void 0
  }
})
  , zj = {
  [xy]: e=>jg(e) || b(e) || Vg(e),
  [Sy]: e=>jg(e) || b(e) || Vg(e),
  [Ey]: e=>jg(e) || b(e) || Vg(e)
}
  , Kj = ["onClick"]
  , Wj = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"]
  , Gj = ["aria-hidden"]
  , qj = ["aria-hidden"]
  , Yj = ["aria-hidden"]
  , Xj = "ElSwitch"
  , Qj = vr({
  name: Xj
});
const Jj = vy(tS(vr({
  ...Qj,
  props: Hj,
  emits: zj,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , {formItem: o} = gS()
      , a = hS()
      , i = qy("switch")
      , {inputId: s} = mS(r, {
      formItemContext: o
    })
      , l = vS(yi((()=>r.loading)))
      , u = Ft(!1 !== r.modelValue)
      , c = Ft()
      , d = Ft()
      , f = yi((()=>[i.b(), i.m(a.value), i.is("disabled", l.value), i.is("checked", m.value)]))
      , p = yi((()=>[i.e("label"), i.em("label", "left"), i.is("active", !m.value)]))
      , h = yi((()=>[i.e("label"), i.em("label", "right"), i.is("active", m.value)]))
      , v = yi((()=>({
      width: om(r.width)
    })));
    Jn((()=>r.modelValue), (()=>{
        u.value = !0
      }
    ));
    const g = yi((()=>!!u.value && r.modelValue))
      , m = yi((()=>g.value === r.activeValue));
    [r.activeValue, r.inactiveValue].includes(g.value) || (n(xy, r.inactiveValue),
      n(Sy, r.inactiveValue),
      n(Ey, r.inactiveValue)),
      Jn(m, (e=>{
          var t;
          c.value.checked = e,
          r.validateEvent && (null == (t = null == o ? void 0 : o.validate) || t.call(o, "change").catch((e=>{}
          )))
        }
      ));
    const y = ()=>{
        const e = m.value ? r.inactiveValue : r.activeValue;
        n(xy, e),
          n(Sy, e),
          n(Ey, e),
          hn((()=>{
              c.value.checked = m.value
            }
          ))
      }
      , b = ()=>{
        if (l.value)
          return;
        const {beforeChange: e} = r;
        if (!e)
          return void y();
        const t = e();
        [S(t), jg(t)].includes(!0) || Jg(Xj, "beforeChange must return type `Promise<boolean>` or `boolean`"),
          S(t) ? t.then((e=>{
              e && y()
            }
          )).catch((e=>{}
          )) : t && y()
      }
    ;
    return Lr((()=>{
        c.value.checked = m.value
      }
    )),
      t({
        focus: ()=>{
          var e, t;
          null == (t = null == (e = c.value) ? void 0 : e.focus) || t.call(e)
        }
        ,
        checked: m
      }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y(Vt(f)),
          onClick: js(b, ["prevent"])
        }, [Ma("input", {
          id: Vt(s),
          ref_key: "input",
          ref: c,
          class: Y(Vt(i).e("input")),
          type: "checkbox",
          role: "switch",
          "aria-checked": Vt(m),
          "aria-disabled": Vt(l),
          "aria-label": e.label,
          name: e.name,
          "true-value": e.activeValue,
          "false-value": e.inactiveValue,
          disabled: Vt(l),
          tabindex: e.tabindex,
          onChange: y,
          onKeydown: Us(b, ["enter"])
        }, null, 42, Wj), e.inlinePrompt || !e.inactiveIcon && !e.inactiveText ? za("v-if", !0) : (Ca(),
          _a("span", {
            key: 0,
            class: Y(Vt(p))
          }, [e.inactiveIcon ? (Ca(),
            Ra(Vt(sS), {
              key: 0
            }, {
              default: Fn((()=>[(Ca(),
                Ra(Kr(e.inactiveIcon)))])),
              _: 1
            })) : za("v-if", !0), !e.inactiveIcon && e.inactiveText ? (Ca(),
            _a("span", {
              key: 1,
              "aria-hidden": Vt(m)
            }, te(e.inactiveText), 9, Gj)) : za("v-if", !0)], 2)), Ma("span", {
          ref_key: "core",
          ref: d,
          class: Y(Vt(i).e("core")),
          style: z(Vt(v))
        }, [e.inlinePrompt ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(i).e("inner"))
          }, [e.activeIcon || e.inactiveIcon ? (Ca(),
            Ra(Vt(sS), {
              key: 0,
              class: Y(Vt(i).is("icon"))
            }, {
              default: Fn((()=>[(Ca(),
                Ra(Kr(Vt(m) ? e.activeIcon : e.inactiveIcon)))])),
              _: 1
            }, 8, ["class"])) : e.activeText || e.inactiveText ? (Ca(),
            _a("span", {
              key: 1,
              class: Y(Vt(i).is("text")),
              "aria-hidden": !Vt(m)
            }, te(Vt(m) ? e.activeText : e.inactiveText), 11, qj)) : za("v-if", !0)], 2)) : za("v-if", !0), Ma("div", {
          class: Y(Vt(i).e("action"))
        }, [e.loading ? (Ca(),
          Ra(Vt(sS), {
            key: 0,
            class: Y(Vt(i).is("loading"))
          }, {
            default: Fn((()=>[ja(Vt(Mm))])),
            _: 1
          }, 8, ["class"])) : Vt(m) ? Qr(e.$slots, "active-action", {
          key: 1
        }, (()=>[e.activeActionIcon ? (Ca(),
          Ra(Vt(sS), {
            key: 0
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(e.activeActionIcon)))])),
            _: 1
          })) : za("v-if", !0)])) : Vt(m) ? za("v-if", !0) : Qr(e.$slots, "inactive-action", {
          key: 2
        }, (()=>[e.inactiveActionIcon ? (Ca(),
          Ra(Vt(sS), {
            key: 0
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(e.inactiveActionIcon)))])),
            _: 1
          })) : za("v-if", !0)]))], 2)], 6), e.inlinePrompt || !e.activeIcon && !e.activeText ? za("v-if", !0) : (Ca(),
          _a("span", {
            key: 1,
            class: Y(Vt(h))
          }, [e.activeIcon ? (Ca(),
            Ra(Vt(sS), {
              key: 0
            }, {
              default: Fn((()=>[(Ca(),
                Ra(Kr(e.activeIcon)))])),
              _: 1
            })) : za("v-if", !0), !e.activeIcon && e.activeText ? (Ca(),
            _a("span", {
              key: 1,
              "aria-hidden": !Vt(m)
            }, te(e.activeText), 9, Yj)) : za("v-if", !0)], 2))], 10, Kj))
  }
}), [["__file", "switch.vue"]]))
  , Zj = function(e) {
  var t;
  return null == (t = e.target) ? void 0 : t.closest("td")
}
  , eV = function(e, t, n, r, o) {
  if (!t && !r && (!o || Array.isArray(o) && !o.length))
    return e;
  n = "string" == typeof n ? "descending" === n ? -1 : 1 : n && n < 0 ? -1 : 1;
  const a = r ? null : function(n, r) {
      return o ? (Array.isArray(o) || (o = [o]),
        o.map((t=>"string" == typeof t ? Lp(n, t) : t(n, r, e)))) : ("$key" !== t && x(n) && "$value"in n && (n = n.$value),
        [x(n) ? Lp(n, t) : n])
    }
  ;
  return e.map(((e,t)=>({
    value: e,
    index: t,
    key: a ? a(e, t) : null
  }))).sort(((e,t)=>{
      let o = function(e, t) {
        if (r)
          return r(e.value, t.value);
        for (let n = 0, r = e.key.length; n < r; n++) {
          if (e.key[n] < t.key[n])
            return -1;
          if (e.key[n] > t.key[n])
            return 1
        }
        return 0
      }(e, t);
      return o || (o = e.index - t.index),
      o * +n
    }
  )).map((e=>e.value))
}
  , tV = function(e, t) {
  let n = null;
  return e.columns.forEach((e=>{
      e.id === t && (n = e)
    }
  )),
    n
}
  , nV = function(e, t) {
  let n = null;
  for (let r = 0; r < e.columns.length; r++) {
    const o = e.columns[r];
    if (o.columnKey === t) {
      n = o;
      break
    }
  }
  return n || Jg("ElTable", `No column matching with column-key: ${t}`),
    n
}
  , rV = function(e, t, n) {
  const r = (t.className || "").match(new RegExp(`${n}-table_[^\\s]+`,"gm"));
  return r ? tV(e, r[0]) : null
}
  , oV = (e,t)=>{
  if (!e)
    throw new Error("Row is required when get row identity");
  if ("string" == typeof t) {
    if (!t.includes("."))
      return `${e[t]}`;
    const n = t.split(".");
    let r = e;
    for (const e of n)
      r = r[e];
    return `${r}`
  }
  if ("function" == typeof t)
    return t.call(null, e)
}
  , aV = function(e, t) {
  const n = {};
  return (e || []).forEach(((e,r)=>{
      n[oV(e, t)] = {
        row: e,
        index: r
      }
    }
  )),
    n
};
function iV(e) {
  return "" === e || void 0 !== e && (e = Number.parseInt(e, 10),
  Number.isNaN(e) && (e = "")),
    e
}
function sV(e) {
  return "" === e || void 0 !== e && (e = iV(e),
  Number.isNaN(e) && (e = 80)),
    e
}
function lV(e, t, n) {
  let r = !1;
  const o = e.indexOf(t)
    , a = -1 !== o
    , i = i=>{
      "add" === i ? e.push(t) : e.splice(o, 1),
        r = !0,
      h(t.children) && t.children.forEach((t=>{
          lV(e, t, null != n ? n : !a)
        }
      ))
    }
  ;
  return jg(n) ? n && !a ? i("add") : !n && a && i("remove") : i(a ? "remove" : "add"),
    r
}
function uV(e, t, n="children", r="hasChildren") {
  const o = e=>!(Array.isArray(e) && e.length);
  function a(e, i, s) {
    t(e, i, s),
      i.forEach((e=>{
          if (e[r])
            return void t(e, null, s + 1);
          const i = e[n];
          o(i) || a(e, i, s + 1)
        }
      ))
  }
  e.forEach((e=>{
      if (e[r])
        return void t(e, null, 0);
      const i = e[n];
      o(i) || a(e, i, 0)
    }
  ))
}
let cV = null;
function dV(e) {
  return e.children ? wg(e.children, dV) : [e]
}
function fV(e, t) {
  return e + t.colSpan
}
const pV = (e,t,n,r)=>{
    let o = 0
      , a = e;
    const i = n.states.columns.value;
    if (r) {
      const t = dV(r[e]);
      o = i.slice(0, i.indexOf(t[0])).reduce(fV, 0),
        a = o + t.reduce(fV, 0) - 1
    } else
      o = e;
    let s;
    switch (t) {
      case "left":
        a < n.states.fixedLeafColumnsLength.value && (s = "left");
        break;
      case "right":
        o >= i.length - n.states.rightFixedLeafColumnsLength.value && (s = "right");
        break;
      default:
        a < n.states.fixedLeafColumnsLength.value ? s = "left" : o >= i.length - n.states.rightFixedLeafColumnsLength.value && (s = "right")
    }
    return s ? {
      direction: s,
      start: o,
      after: a
    } : {}
  }
  , hV = (e,t,n,r,o,a=0)=>{
    const i = []
      , {direction: s, start: l, after: u} = pV(t, n, r, o);
    if (s) {
      const t = "left" === s;
      i.push(`${e}-fixed-column--${s}`),
        t && u + a === r.states.fixedLeafColumnsLength.value - 1 ? i.push("is-last-column") : t || l - a != r.states.columns.value.length - r.states.rightFixedLeafColumnsLength.value || i.push("is-first-column")
    }
    return i
  }
;
function vV(e, t) {
  return e + (null === t.realWidth || Number.isNaN(t.realWidth) ? Number(t.width) : t.realWidth)
}
const gV = (e,t,n,r)=>{
    const {direction: o, start: a=0, after: i=0} = pV(e, t, n, r);
    if (!o)
      return;
    const s = {}
      , l = "left" === o
      , u = n.states.columns.value;
    return l ? s.left = u.slice(0, a).reduce(vV, 0) : s.right = u.slice(i + 1).reverse().reduce(vV, 0),
      s
  }
  , mV = (e,t)=>{
    e && (Number.isNaN(e[t]) || (e[t] = `${e[t]}px`))
  }
;
const yV = (e,t)=>{
    const n = t.sortingColumn;
    return n && "string" != typeof n.sortable ? eV(e, t.sortProp, t.sortOrder, n.sortMethod, n.sortBy) : e
  }
  , bV = e=>{
    const t = [];
    return e.forEach((e=>{
        e.children && e.children.length > 0 ? t.push.apply(t, bV(e.children)) : t.push(e)
      }
    )),
      t
  }
;
function wV() {
  var e;
  const t = ei()
    , {size: n} = Wt(null == (e = t.proxy) ? void 0 : e.$props)
    , r = Ft(null)
    , o = Ft([])
    , a = Ft([])
    , i = Ft(!1)
    , s = Ft([])
    , l = Ft([])
    , u = Ft([])
    , c = Ft([])
    , d = Ft([])
    , f = Ft([])
    , h = Ft([])
    , v = Ft([])
    , g = Ft(0)
    , m = Ft(0)
    , y = Ft(0)
    , b = Ft(!1)
    , w = Ft([])
    , x = Ft(!1)
    , S = Ft(!1)
    , E = Ft(null)
    , A = Ft({})
    , C = Ft(null)
    , k = Ft(null)
    , T = Ft(null)
    , D = Ft(null)
    , O = Ft(null);
  Jn(o, (()=>t.state && L(!1)), {
    deep: !0
  });
  const _ = e=>{
    var t;
    null == (t = e.children) || t.forEach((t=>{
        t.fixed = e.fixed,
          _(t)
      }
    ))
  }
    , R = ()=>{
    s.value.forEach((e=>{
        _(e)
      }
    )),
      c.value = s.value.filter((e=>!0 === e.fixed || "left" === e.fixed)),
      d.value = s.value.filter((e=>"right" === e.fixed)),
    c.value.length > 0 && s.value[0] && "selection" === s.value[0].type && !s.value[0].fixed && (s.value[0].fixed = !0,
      c.value.unshift(s.value[0]));
    const e = s.value.filter((e=>!e.fixed));
    l.value = [].concat(c.value).concat(e).concat(d.value);
    const t = bV(e)
      , n = bV(c.value)
      , r = bV(d.value);
    g.value = t.length,
      m.value = n.length,
      y.value = r.length,
      u.value = [].concat(n).concat(t).concat(r),
      i.value = c.value.length > 0 || d.value.length > 0
  }
    , L = (e,n=!1)=>{
    e && R(),
      n ? t.state.doLayout() : t.state.debouncedUpdateLayout()
  }
    , I = e=>{
    var n;
    if (!t || !t.store)
      return 0;
    const {treeData: r} = t.store.states;
    let o = 0;
    const a = null == (n = r.value[e]) ? void 0 : n.children;
    return a && (o += a.length,
      a.forEach((e=>{
          o += I(e)
        }
      ))),
      o
  }
    , P = (e,t,n)=>{
    k.value && k.value !== e && (k.value.order = null),
      k.value = e,
      T.value = t,
      D.value = n
  }
    , F = ()=>{
    let e = Vt(a);
    Object.keys(A.value).forEach((t=>{
        const n = A.value[t];
        if (!n || 0 === n.length)
          return;
        const r = tV({
          columns: u.value
        }, t);
        r && r.filterMethod && (e = e.filter((e=>n.some((t=>r.filterMethod.call(null, t, e, r))))))
      }
    )),
      C.value = e
  }
    , B = ()=>{
    o.value = yV(C.value, {
      sortingColumn: k.value,
      sortProp: T.value,
      sortOrder: D.value
    })
  }
    , {setExpandRowKeys: N, toggleRowExpansion: M, updateExpandRows: j, states: V, isRowExpanded: U} = function(e) {
    const t = ei()
      , n = Ft(!1)
      , r = Ft([]);
    return {
      updateExpandRows: ()=>{
        const t = e.data.value || []
          , o = e.rowKey.value;
        if (n.value)
          r.value = t.slice();
        else if (o) {
          const e = aV(r.value, o);
          r.value = t.reduce(((t,n)=>{
              const r = oV(n, o);
              return e[r] && t.push(n),
                t
            }
          ), [])
        } else
          r.value = []
      }
      ,
      toggleRowExpansion: (e,n)=>{
        lV(r.value, e, n) && t.emit("expand-change", e, r.value.slice())
      }
      ,
      setExpandRowKeys: n=>{
        t.store.assertRowKey();
        const o = e.data.value || []
          , a = e.rowKey.value
          , i = aV(o, a);
        r.value = n.reduce(((e,t)=>{
            const n = i[t];
            return n && e.push(n.row),
              e
          }
        ), [])
      }
      ,
      isRowExpanded: t=>{
        const n = e.rowKey.value;
        return n ? !!aV(r.value, n)[oV(t, n)] : r.value.includes(t)
      }
      ,
      states: {
        expandRows: r,
        defaultExpandAll: n
      }
    }
  }({
    data: o,
    rowKey: r
  })
    , {updateTreeExpandKeys: $, toggleTreeExpansion: H, updateTreeData: z, loadOrToggle: K, states: W} = function(e) {
    const t = Ft([])
      , n = Ft({})
      , r = Ft(16)
      , o = Ft(!1)
      , a = Ft({})
      , i = Ft("hasChildren")
      , s = Ft("children")
      , l = ei()
      , u = yi((()=>{
          if (!e.rowKey.value)
            return {};
          const t = e.data.value || [];
          return d(t)
        }
      ))
      , c = yi((()=>{
          const t = e.rowKey.value
            , n = Object.keys(a.value)
            , r = {};
          return n.length ? (n.forEach((e=>{
              if (a.value[e].length) {
                const n = {
                  children: []
                };
                a.value[e].forEach((e=>{
                    const o = oV(e, t);
                    n.children.push(o),
                    e[i.value] && !r[o] && (r[o] = {
                      children: []
                    })
                  }
                )),
                  r[e] = n
              }
            }
          )),
            r) : r
        }
      ))
      , d = t=>{
        const n = e.rowKey.value
          , r = {};
        return uV(t, ((e,t,a)=>{
            const i = oV(e, n);
            Array.isArray(t) ? r[i] = {
              children: t.map((e=>oV(e, n))),
              level: a
            } : o.value && (r[i] = {
              children: [],
              lazy: !0,
              level: a
            })
          }
        ), s.value, i.value),
          r
      }
      , f = (e=!1,r=(e=>null == (e = l.store) ? void 0 : e.states.defaultExpandAll.value)())=>{
        var a;
        const i = u.value
          , s = c.value
          , d = Object.keys(i)
          , f = {};
        if (d.length) {
          const a = Vt(n)
            , l = []
            , u = (n,o)=>{
              if (e)
                return t.value ? r || t.value.includes(o) : !(!r && !(null == n ? void 0 : n.expanded));
              {
                const e = r || t.value && t.value.includes(o);
                return !(!(null == n ? void 0 : n.expanded) && !e)
              }
            }
          ;
          d.forEach((e=>{
              const t = a[e]
                , n = {
                ...i[e]
              };
              if (n.expanded = u(t, e),
                n.lazy) {
                const {loaded: r=!1, loading: o=!1} = t || {};
                n.loaded = !!r,
                  n.loading = !!o,
                  l.push(e)
              }
              f[e] = n
            }
          ));
          const c = Object.keys(s);
          o.value && c.length && l.length && c.forEach((e=>{
              const t = a[e]
                , n = s[e].children;
              if (l.includes(e)) {
                if (0 !== f[e].children.length)
                  throw new Error("[ElTable]children must be an empty array.");
                f[e].children = n
              } else {
                const {loaded: r=!1, loading: o=!1} = t || {};
                f[e] = {
                  lazy: !0,
                  loaded: !!r,
                  loading: !!o,
                  expanded: u(t, e),
                  children: n,
                  level: ""
                }
              }
            }
          ))
        }
        n.value = f,
        null == (a = l.store) || a.updateTableScrollY()
      }
    ;
    Jn((()=>t.value), (()=>{
        f(!0)
      }
    )),
      Jn((()=>u.value), (()=>{
          f()
        }
      )),
      Jn((()=>c.value), (()=>{
          f()
        }
      ));
    const p = (t,r)=>{
        l.store.assertRowKey();
        const o = e.rowKey.value
          , a = oV(t, o)
          , i = a && n.value[a];
        if (a && i && "expanded"in i) {
          const e = i.expanded;
          r = void 0 === r ? !i.expanded : r,
            n.value[a].expanded = r,
          e !== r && l.emit("expand-change", t, r),
            l.store.updateTableScrollY()
        }
      }
      , h = (e,t,r)=>{
        const {load: o} = l.props;
        o && !n.value[t].loaded && (n.value[t].loading = !0,
          o(e, r, (r=>{
              if (!Array.isArray(r))
                throw new TypeError("[ElTable] data must be an array");
              n.value[t].loading = !1,
                n.value[t].loaded = !0,
                n.value[t].expanded = !0,
              r.length && (a.value[t] = r),
                l.emit("expand-change", e, !0)
            }
          )))
      }
    ;
    return {
      loadData: h,
      loadOrToggle: t=>{
        l.store.assertRowKey();
        const r = e.rowKey.value
          , a = oV(t, r)
          , i = n.value[a];
        o.value && i && "loaded"in i && !i.loaded ? h(t, a, i) : p(t, void 0)
      }
      ,
      toggleTreeExpansion: p,
      updateTreeExpandKeys: e=>{
        t.value = e,
          f()
      }
      ,
      updateTreeData: f,
      normalize: d,
      states: {
        expandRowKeys: t,
        treeData: n,
        indent: r,
        lazy: o,
        lazyTreeNodeMap: a,
        lazyColumnIdentifier: i,
        childrenColumnName: s
      }
    }
  }({
    data: o,
    rowKey: r
  })
    , {updateCurrentRowData: G, updateCurrentRow: q, setCurrentRowKey: Y, states: X} = function(e) {
    const t = ei()
      , n = Ft(null)
      , r = Ft(null)
      , o = ()=>{
        n.value = null
      }
      , a = n=>{
        const {data: o, rowKey: a} = e;
        let i = null;
        a.value && (i = (Vt(o) || []).find((e=>oV(e, a.value) === n))),
          r.value = i,
          t.emit("current-change", r.value, null)
      }
    ;
    return {
      setCurrentRowKey: e=>{
        t.store.assertRowKey(),
          n.value = e,
          a(e)
      }
      ,
      restoreCurrentRowKey: o,
      setCurrentRowByKey: a,
      updateCurrentRow: e=>{
        const n = r.value;
        if (e && e !== n)
          return r.value = e,
            void t.emit("current-change", r.value, n);
        !e && n && (r.value = null,
          t.emit("current-change", null, n))
      }
      ,
      updateCurrentRowData: ()=>{
        const i = e.rowKey.value
          , s = e.data.value || []
          , l = r.value;
        if (!s.includes(l) && l) {
          if (i) {
            const e = oV(l, i);
            a(e)
          } else
            r.value = null;
          null === r.value && t.emit("current-change", null, l)
        } else
          n.value && (a(n.value),
            o())
      }
      ,
      states: {
        _currentRowKey: n,
        currentRow: r
      }
    }
  }({
    data: o,
    rowKey: r
  });
  return {
    assertRowKey: ()=>{
      if (!r.value)
        throw new Error("[ElTable] prop row-key is required")
    }
    ,
    updateColumns: R,
    scheduleLayout: L,
    isSelected: e=>w.value.includes(e),
    clearSelection: ()=>{
      b.value = !1;
      w.value.length && (w.value = [],
        t.emit("selection-change", []))
    }
    ,
    cleanSelection: ()=>{
      let e;
      if (r.value) {
        e = [];
        const t = aV(w.value, r.value)
          , n = aV(o.value, r.value);
        for (const r in t)
          p(t, r) && !n[r] && e.push(t[r].row)
      } else
        e = w.value.filter((e=>!o.value.includes(e)));
      if (e.length) {
        const n = w.value.filter((t=>!e.includes(t)));
        w.value = n,
          t.emit("selection-change", n.slice())
      }
    }
    ,
    getSelectionRows: ()=>(w.value || []).slice(),
    toggleRowSelection: (e,n=void 0,r=!0)=>{
      if (lV(w.value, e, n)) {
        const n = (w.value || []).slice();
        r && t.emit("select", n, e),
          t.emit("selection-change", n)
      }
    }
    ,
    _toggleAllSelection: ()=>{
      var e, n;
      const r = S.value ? !b.value : !(b.value || w.value.length);
      b.value = r;
      let a = !1
        , i = 0;
      const s = null == (n = null == (e = null == t ? void 0 : t.store) ? void 0 : e.states) ? void 0 : n.rowKey.value;
      o.value.forEach(((e,t)=>{
          const n = t + i;
          E.value ? E.value.call(null, e, n) && lV(w.value, e, r) && (a = !0) : lV(w.value, e, r) && (a = !0),
            i += I(oV(e, s))
        }
      )),
      a && t.emit("selection-change", w.value ? w.value.slice() : []),
        t.emit("select-all", w.value)
    }
    ,
    toggleAllSelection: null,
    updateSelectionByRowKey: ()=>{
      const e = aV(w.value, r.value);
      o.value.forEach((t=>{
          const n = oV(t, r.value)
            , o = e[n];
          o && (w.value[o.index] = t)
        }
      ))
    }
    ,
    updateAllSelected: ()=>{
      var e, n, a;
      if (0 === (null == (e = o.value) ? void 0 : e.length))
        return void (b.value = !1);
      let i;
      r.value && (i = aV(w.value, r.value));
      let s = !0
        , l = 0
        , u = 0;
      for (let d = 0, f = (o.value || []).length; d < f; d++) {
        const e = null == (a = null == (n = null == t ? void 0 : t.store) ? void 0 : n.states) ? void 0 : a.rowKey.value
          , f = d + u
          , p = o.value[d]
          , h = E.value && E.value.call(null, p, f);
        if (c = p,
          i ? i[oV(c, r.value)] : w.value.includes(c))
          l++;
        else if (!E.value || h) {
          s = !1;
          break
        }
        u += I(oV(p, e))
      }
      var c;
      0 === l && (s = !1),
        b.value = s
    }
    ,
    updateFilters: (e,t)=>{
      Array.isArray(e) || (e = [e]);
      const n = {};
      return e.forEach((e=>{
          A.value[e.id] = t,
            n[e.columnKey || e.id] = t
        }
      )),
        n
    }
    ,
    updateCurrentRow: q,
    updateSort: P,
    execFilter: F,
    execSort: B,
    execQuery: (e=void 0)=>{
      e && e.filter || F(),
        B()
    }
    ,
    clearFilter: e=>{
      const {tableHeaderRef: n} = t.refs;
      if (!n)
        return;
      const r = Object.assign({}, n.filterPanels)
        , o = Object.keys(r);
      if (o.length)
        if ("string" == typeof e && (e = [e]),
          Array.isArray(e)) {
          const n = e.map((e=>nV({
            columns: u.value
          }, e)));
          o.forEach((e=>{
              const t = n.find((t=>t.id === e));
              t && (t.filteredValue = [])
            }
          )),
            t.store.commit("filterChange", {
              column: n,
              values: [],
              silent: !0,
              multi: !0
            })
        } else
          o.forEach((e=>{
              const t = u.value.find((t=>t.id === e));
              t && (t.filteredValue = [])
            }
          )),
            A.value = {},
            t.store.commit("filterChange", {
              column: {},
              values: [],
              silent: !0
            })
    }
    ,
    clearSort: ()=>{
      k.value && (P(null, null, null),
        t.store.commit("changeSortCondition", {
          silent: !0
        }))
    }
    ,
    toggleRowExpansion: M,
    setExpandRowKeysAdapter: e=>{
      N(e),
        $(e)
    }
    ,
    setCurrentRowKey: Y,
    toggleRowExpansionAdapter: (e,t)=>{
      u.value.some((({type: e})=>"expand" === e)) ? M(e, t) : H(e, t)
    }
    ,
    isRowExpanded: U,
    updateExpandRows: j,
    updateCurrentRowData: G,
    loadOrToggle: K,
    updateTreeData: z,
    states: {
      tableSize: n,
      rowKey: r,
      data: o,
      _data: a,
      isComplex: i,
      _columns: s,
      originColumns: l,
      columns: u,
      fixedColumns: c,
      rightFixedColumns: d,
      leafColumns: f,
      fixedLeafColumns: h,
      rightFixedLeafColumns: v,
      updateOrderFns: [],
      leafColumnsLength: g,
      fixedLeafColumnsLength: m,
      rightFixedLeafColumnsLength: y,
      isAllSelected: b,
      selection: w,
      reserveSelection: x,
      selectOnIndeterminate: S,
      selectable: E,
      filters: A,
      filteredData: C,
      sortingColumn: k,
      sortProp: T,
      sortOrder: D,
      hoverRow: O,
      ...V,
      ...W,
      ...X
    }
  }
}
function xV(e, t) {
  return e.map((e=>{
      var n;
      return e.id === t.id ? t : ((null == (n = e.children) ? void 0 : n.length) && (e.children = xV(e.children, t)),
        e)
    }
  ))
}
function SV(e) {
  e.forEach((e=>{
      var t, n;
      e.no = null == (t = e.getColumnIndex) ? void 0 : t.call(e),
      (null == (n = e.children) ? void 0 : n.length) && SV(e.children)
    }
  )),
    e.sort(((e,t)=>e.no - t.no))
}
const EV = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  "treeProps.hasChildren": {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  "treeProps.children": {
    key: "childrenColumnName",
    default: "children"
  }
};
function AV(e, t) {
  if (!e)
    throw new Error("Table is required.");
  const n = function() {
    const e = ei()
      , t = wV();
    return {
      ns: qy("table"),
      ...t,
      mutations: {
        setData(t, n) {
          const r = Vt(t._data) !== n;
          t.data.value = n,
            t._data.value = n,
            e.store.execQuery(),
            e.store.updateCurrentRowData(),
            e.store.updateExpandRows(),
            e.store.updateTreeData(e.store.states.defaultExpandAll.value),
            Vt(t.reserveSelection) ? (e.store.assertRowKey(),
              e.store.updateSelectionByRowKey()) : r ? e.store.clearSelection() : e.store.cleanSelection(),
            e.store.updateAllSelected(),
          e.$ready && e.store.scheduleLayout()
        },
        insertColumn(t, n, r, o) {
          const a = Vt(t._columns);
          let i = [];
          r ? (r && !r.children && (r.children = []),
            r.children.push(n),
            i = xV(a, r)) : (a.push(n),
            i = a),
            SV(i),
            t._columns.value = i,
            t.updateOrderFns.push(o),
          "selection" === n.type && (t.selectable.value = n.selectable,
            t.reserveSelection.value = n.reserveSelection),
          e.$ready && (e.store.updateColumns(),
            e.store.scheduleLayout())
        },
        updateColumnOrder(t, n) {
          var r;
          (null == (r = n.getColumnIndex) ? void 0 : r.call(n)) !== n.no && (SV(t._columns.value),
          e.$ready && e.store.updateColumns())
        },
        removeColumn(t, n, r, o) {
          const a = Vt(t._columns) || [];
          if (r)
            r.children.splice(r.children.findIndex((e=>e.id === n.id)), 1),
              hn((()=>{
                  var e;
                  0 === (null == (e = r.children) ? void 0 : e.length) && delete r.children
                }
              )),
              t._columns.value = xV(a, r);
          else {
            const e = a.indexOf(n);
            e > -1 && (a.splice(e, 1),
              t._columns.value = a)
          }
          const i = t.updateOrderFns.indexOf(o);
          i > -1 && t.updateOrderFns.splice(i, 1),
          e.$ready && (e.store.updateColumns(),
            e.store.scheduleLayout())
        },
        sort(t, n) {
          const {prop: r, order: o, init: a} = n;
          if (r) {
            const n = Vt(t.columns).find((e=>e.property === r));
            n && (n.order = o,
              e.store.updateSort(n, r, o),
              e.store.commit("changeSortCondition", {
                init: a
              }))
          }
        },
        changeSortCondition(t, n) {
          const {sortingColumn: r, sortProp: o, sortOrder: a} = t
            , i = Vt(r)
            , s = Vt(o)
            , l = Vt(a);
          null === l && (t.sortingColumn.value = null,
            t.sortProp.value = null),
            e.store.execQuery({
              filter: !0
            }),
          n && (n.silent || n.init) || e.emit("sort-change", {
            column: i,
            prop: s,
            order: l
          }),
            e.store.updateTableScrollY()
        },
        filterChange(t, n) {
          const {column: r, values: o, silent: a} = n
            , i = e.store.updateFilters(r, o);
          e.store.execQuery(),
          a || e.emit("filter-change", i),
            e.store.updateTableScrollY()
        },
        toggleAllSelection() {
          e.store.toggleAllSelection()
        },
        rowSelectedChanged(t, n) {
          e.store.toggleRowSelection(n),
            e.store.updateAllSelected()
        },
        setHoverRow(e, t) {
          e.hoverRow.value = t
        },
        setCurrentRow(t, n) {
          e.store.updateCurrentRow(n)
        }
      },
      commit: function(t, ...n) {
        const r = e.store.mutations;
        if (!r[t])
          throw new Error(`Action not found: ${t}`);
        r[t].apply(e, [e.store.states].concat(n))
      },
      updateTableScrollY: function() {
        hn((()=>e.layout.updateScrollY.apply(e.layout)))
      }
    }
  }();
  return n.toggleAllSelection = ug(n._toggleAllSelection, 10),
    Object.keys(EV).forEach((e=>{
        CV(kV(t, e), e, n)
      }
    )),
    function(e, t) {
      Object.keys(EV).forEach((n=>{
          Jn((()=>kV(t, n)), (t=>{
              CV(t, n, e)
            }
          ))
        }
      ))
    }(n, t),
    n
}
function CV(e, t, n) {
  let r = e
    , o = EV[t];
  "object" == typeof EV[t] && (o = o.key,
    r = r || EV[t].default),
    n.states[o].value = r
}
function kV(e, t) {
  if (t.includes(".")) {
    const n = t.split(".");
    let r = e;
    return n.forEach((e=>{
        r = r[e]
      }
    )),
      r
  }
  return e[t]
}
class TV {
  constructor(e) {
    this.observers = [],
      this.table = null,
      this.store = null,
      this.columns = [],
      this.fit = !0,
      this.showHeader = !0,
      this.height = Ft(null),
      this.scrollX = Ft(!1),
      this.scrollY = Ft(!1),
      this.bodyWidth = Ft(null),
      this.fixedWidth = Ft(null),
      this.rightFixedWidth = Ft(null),
      this.gutterWidth = 0;
    for (const t in e)
      p(e, t) && (Pt(this[t]) ? this[t].value = e[t] : this[t] = e[t]);
    if (!this.table)
      throw new Error("Table is required for Table Layout");
    if (!this.store)
      throw new Error("Store is required for Table Layout")
  }
  updateScrollY() {
    if (null === this.height.value)
      return !1;
    const e = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && (null == e ? void 0 : e.wrapRef)) {
      let t = !0;
      const n = this.scrollY.value;
      return t = e.wrapRef.scrollHeight > e.wrapRef.clientHeight,
        this.scrollY.value = t,
      n !== t
    }
    return !1
  }
  setHeight(e, t="height") {
    if (!mc)
      return;
    const n = this.table.vnode.el;
    var r;
    if (e = "number" == typeof (r = e) ? r : "string" == typeof r ? /^\d+(?:px)?$/.test(r) ? Number.parseInt(r, 10) : r : null,
      this.height.value = Number(e),
    !n && (e || 0 === e))
      return hn((()=>this.setHeight(e, t)));
    "number" == typeof e ? (n.style[t] = `${e}px`,
      this.updateElsHeight()) : "string" == typeof e && (n.style[t] = e,
      this.updateElsHeight())
  }
  setMaxHeight(e) {
    this.setHeight(e, "max-height")
  }
  getFlattenColumns() {
    const e = [];
    return this.table.store.states.columns.value.forEach((t=>{
        t.isColumnGroup ? e.push.apply(e, t.columns) : e.push(t)
      }
    )),
      e
  }
  updateElsHeight() {
    this.updateScrollY(),
      this.notifyObservers("scrollable")
  }
  headerDisplayNone(e) {
    if (!e)
      return !0;
    let t = e;
    for (; "DIV" !== t.tagName; ) {
      if ("none" === getComputedStyle(t).display)
        return !0;
      t = t.parentElement
    }
    return !1
  }
  updateColumnsWidth() {
    if (!mc)
      return;
    const e = this.fit
      , t = this.table.vnode.el.clientWidth;
    let n = 0;
    const r = this.getFlattenColumns()
      , o = r.filter((e=>"number" != typeof e.width));
    if (r.forEach((e=>{
        "number" == typeof e.width && e.realWidth && (e.realWidth = null)
      }
    )),
    o.length > 0 && e) {
      if (r.forEach((e=>{
          n += Number(e.width || e.minWidth || 80)
        }
      )),
      n <= t) {
        this.scrollX.value = !1;
        const e = t - n;
        if (1 === o.length)
          o[0].realWidth = Number(o[0].minWidth || 80) + e;
        else {
          const t = e / o.reduce(((e,t)=>e + Number(t.minWidth || 80)), 0);
          let n = 0;
          o.forEach(((e,r)=>{
              if (0 === r)
                return;
              const o = Math.floor(Number(e.minWidth || 80) * t);
              n += o,
                e.realWidth = Number(e.minWidth || 80) + o
            }
          )),
            o[0].realWidth = Number(o[0].minWidth || 80) + e - n
        }
      } else
        this.scrollX.value = !0,
          o.forEach((e=>{
              e.realWidth = Number(e.minWidth)
            }
          ));
      this.bodyWidth.value = Math.max(n, t),
        this.table.state.resizeState.value.width = this.bodyWidth.value
    } else
      r.forEach((e=>{
          e.width || e.minWidth ? e.realWidth = Number(e.width || e.minWidth) : e.realWidth = 80,
            n += e.realWidth
        }
      )),
        this.scrollX.value = n > t,
        this.bodyWidth.value = n;
    const a = this.store.states.fixedColumns.value;
    if (a.length > 0) {
      let e = 0;
      a.forEach((t=>{
          e += Number(t.realWidth || t.width)
        }
      )),
        this.fixedWidth.value = e
    }
    const i = this.store.states.rightFixedColumns.value;
    if (i.length > 0) {
      let e = 0;
      i.forEach((t=>{
          e += Number(t.realWidth || t.width)
        }
      )),
        this.rightFixedWidth.value = e
    }
    this.notifyObservers("columns")
  }
  addObserver(e) {
    this.observers.push(e)
  }
  removeObserver(e) {
    const t = this.observers.indexOf(e);
    -1 !== t && this.observers.splice(t, 1)
  }
  notifyObservers(e) {
    this.observers.forEach((t=>{
        var n, r;
        switch (e) {
          case "columns":
            null == (n = t.state) || n.onColumnsChange(this);
            break;
          case "scrollable":
            null == (r = t.state) || r.onScrollableChange(this);
            break;
          default:
            throw new Error(`Table Layout don't have event ${e}.`)
        }
      }
    ))
  }
}
const {CheckboxGroup: DV} = AD
  , OV = vr({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: AD,
    ElCheckboxGroup: DV,
    ElScrollbar: DE,
    ElTooltip: MA,
    ElIcon: sS,
    ArrowDown: hm,
    ArrowUp: mm
  },
  directives: {
    ClickOutside: Rk
  },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(e) {
    const t = ei()
      , {t: n} = Hy()
      , r = qy("table-filter")
      , o = null == t ? void 0 : t.parent;
    o.filterPanels.value[e.column.id] || (o.filterPanels.value[e.column.id] = t);
    const a = Ft(!1)
      , i = Ft(null)
      , s = yi((()=>e.column && e.column.filters))
      , l = yi((()=>e.column.filterClassName ? `${r.b()} ${e.column.filterClassName}` : r.b()))
      , u = yi({
        get: ()=>{
          var t;
          return ((null == (t = e.column) ? void 0 : t.filteredValue) || [])[0]
        }
        ,
        set: e=>{
          c.value && (null != e ? c.value.splice(0, 1, e) : c.value.splice(0, 1))
        }
      })
      , c = yi({
        get: ()=>e.column && e.column.filteredValue || [],
        set(t) {
          e.column && e.upDataColumn("filteredValue", t)
        }
      })
      , d = yi((()=>!e.column || e.column.filterMultiple))
      , f = ()=>{
        a.value = !1
      }
      , p = t=>{
        e.store.commit("filterChange", {
          column: e.column,
          values: t
        }),
          e.store.updateAllSelected()
      }
    ;
    Jn(a, (t=>{
        e.column && e.upDataColumn("filterOpened", t)
      }
    ), {
      immediate: !0
    });
    const h = yi((()=>{
        var e, t;
        return null == (t = null == (e = i.value) ? void 0 : e.popperRef) ? void 0 : t.contentRef
      }
    ));
    return {
      tooltipVisible: a,
      multiple: d,
      filterClassName: l,
      filteredValue: c,
      filterValue: u,
      filters: s,
      handleConfirm: ()=>{
        p(c.value),
          f()
      }
      ,
      handleReset: ()=>{
        c.value = [],
          p(c.value),
          f()
      }
      ,
      handleSelect: e=>{
        u.value = e,
          p(null != e ? c.value : []),
          f()
      }
      ,
      isActive: e=>e.value === u.value,
      t: n,
      ns: r,
      showFilterPanel: e=>{
        e.stopPropagation(),
          a.value = !a.value
      }
      ,
      hideFilterPanel: ()=>{
        a.value = !1
      }
      ,
      popperPaneRef: h,
      tooltip: i
    }
  }
})
  , _V = {
  key: 0
}
  , RV = ["disabled"]
  , LV = ["label", "onClick"];
var IV = tS(OV, [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-checkbox")
    , s = Hr("el-checkbox-group")
    , l = Hr("el-scrollbar")
    , u = Hr("arrow-up")
    , c = Hr("arrow-down")
    , d = Hr("el-icon")
    , f = Hr("el-tooltip")
    , p = Wr("click-outside");
  return Ca(),
    Ra(f, {
      ref: "tooltip",
      visible: e.tooltipVisible,
      offset: 0,
      placement: e.placement,
      "show-arrow": !1,
      "stop-popper-mouse-event": !1,
      teleported: "",
      effect: "light",
      pure: "",
      "popper-class": e.filterClassName,
      persistent: ""
    }, {
      content: Fn((()=>[e.multiple ? (Ca(),
        _a("div", _V, [Ma("div", {
          class: Y(e.ns.e("content"))
        }, [ja(l, {
          "wrap-class": e.ns.e("wrap")
        }, {
          default: Fn((()=>[ja(s, {
            modelValue: e.filteredValue,
            "onUpdate:modelValue": t[0] || (t[0] = t=>e.filteredValue = t),
            class: Y(e.ns.e("checkbox-group"))
          }, {
            default: Fn((()=>[(Ca(!0),
              _a(ba, null, Yr(e.filters, (e=>(Ca(),
                Ra(i, {
                  key: e.value,
                  label: e.value
                }, {
                  default: Fn((()=>[$a(te(e.text), 1)])),
                  _: 2
                }, 1032, ["label"])))), 128))])),
            _: 1
          }, 8, ["modelValue", "class"])])),
          _: 1
        }, 8, ["wrap-class"])], 2), Ma("div", {
          class: Y(e.ns.e("bottom"))
        }, [Ma("button", {
          class: Y({
            [e.ns.is("disabled")]: 0 === e.filteredValue.length
          }),
          disabled: 0 === e.filteredValue.length,
          type: "button",
          onClick: t[1] || (t[1] = (...t)=>e.handleConfirm && e.handleConfirm(...t))
        }, te(e.t("el.table.confirmFilter")), 11, RV), Ma("button", {
          type: "button",
          onClick: t[2] || (t[2] = (...t)=>e.handleReset && e.handleReset(...t))
        }, te(e.t("el.table.resetFilter")), 1)], 2)])) : (Ca(),
        _a("ul", {
          key: 1,
          class: Y(e.ns.e("list"))
        }, [Ma("li", {
          class: Y([e.ns.e("list-item"), {
            [e.ns.is("active")]: void 0 === e.filterValue || null === e.filterValue
          }]),
          onClick: t[3] || (t[3] = t=>e.handleSelect(null))
        }, te(e.t("el.table.clearFilter")), 3), (Ca(!0),
          _a(ba, null, Yr(e.filters, (t=>(Ca(),
            _a("li", {
              key: t.value,
              class: Y([e.ns.e("list-item"), e.ns.is("active", e.isActive(t))]),
              label: t.value,
              onClick: n=>e.handleSelect(t.value)
            }, te(t.text), 11, LV)))), 128))], 2))])),
      default: Fn((()=>[rr((Ca(),
        _a("span", {
          class: Y([`${e.ns.namespace.value}-table__column-filter-trigger`, `${e.ns.namespace.value}-none-outline`]),
          onClick: t[4] || (t[4] = (...t)=>e.showFilterPanel && e.showFilterPanel(...t))
        }, [ja(d, null, {
          default: Fn((()=>[e.column.filterOpened ? (Ca(),
            Ra(u, {
              key: 0
            })) : (Ca(),
            Ra(c, {
              key: 1
            }))])),
          _: 1
        })], 2)), [[p, e.hideFilterPanel, e.popperPaneRef]])])),
      _: 1
    }, 8, ["visible", "placement", "popper-class"])
}
], ["__file", "filter-panel.vue"]]);
function PV(e) {
  const t = ei();
  Rr((()=>{
      n.value.addObserver(t)
    }
  )),
    Lr((()=>{
        r(n.value),
          o(n.value)
      }
    )),
    Pr((()=>{
        r(n.value),
          o(n.value)
      }
    )),
    Br((()=>{
        n.value.removeObserver(t)
      }
    ));
  const n = yi((()=>{
        const t = e.layout;
        if (!t)
          throw new Error("Can not find table layout.");
        return t
      }
    ))
    , r = t=>{
      var n;
      const r = (null == (n = e.vnode.el) ? void 0 : n.querySelectorAll("colgroup > col")) || [];
      if (!r.length)
        return;
      const o = t.getFlattenColumns()
        , a = {};
      o.forEach((e=>{
          a[e.id] = e
        }
      ));
      for (let e = 0, i = r.length; e < i; e++) {
        const t = r[e]
          , n = t.getAttribute("name")
          , o = a[n];
        o && t.setAttribute("width", o.realWidth || o.width)
      }
    }
    , o = t=>{
      var n, r;
      const o = (null == (n = e.vnode.el) ? void 0 : n.querySelectorAll("colgroup > col[name=gutter]")) || [];
      for (let e = 0, i = o.length; e < i; e++) {
        o[e].setAttribute("width", t.scrollY.value ? t.gutterWidth : "0")
      }
      const a = (null == (r = e.vnode.el) ? void 0 : r.querySelectorAll("th.gutter")) || [];
      for (let e = 0, i = a.length; e < i; e++) {
        const n = a[e];
        n.style.width = t.scrollY.value ? `${t.gutterWidth}px` : "0",
          n.style.display = t.scrollY.value ? "" : "none"
      }
    }
  ;
  return {
    tableLayout: n.value,
    onColumnsChange: r,
    onScrollableChange: o
  }
}
const FV = Symbol("ElTable");
const BV = e=>{
    const t = [];
    return e.forEach((e=>{
        e.children ? (t.push(e),
          t.push.apply(t, BV(e.children))) : t.push(e)
      }
    )),
      t
  }
;
function NV(e) {
  const t = jo(FV)
    , n = yi((()=>(e=>{
      let t = 1;
      const n = (e,r)=>{
          if (r && (e.level = r.level + 1,
          t < e.level && (t = e.level)),
            e.children) {
            let t = 0;
            e.children.forEach((r=>{
                n(r, e),
                  t += r.colSpan
              }
            )),
              e.colSpan = t
          } else
            e.colSpan = 1
        }
      ;
      e.forEach((e=>{
          e.level = 1,
            n(e, void 0)
        }
      ));
      const r = [];
      for (let o = 0; o < t; o++)
        r.push([]);
      return BV(e).forEach((e=>{
          e.children ? (e.rowSpan = 1,
            e.children.forEach((e=>e.isSubColumn = !0))) : e.rowSpan = t - e.level + 1,
            r[e.level - 1].push(e)
        }
      )),
        r
    }
  )(e.store.states.originColumns.value)));
  return {
    isGroup: yi((()=>{
        const e = n.value.length > 1;
        return e && t && (t.state.isGroup.value = !0),
          e
      }
    )),
    toggleAllSelection: e=>{
      e.stopPropagation(),
      null == t || t.store.commit("toggleAllSelection")
    }
    ,
    columnRows: n
  }
}
var MV = vr({
  name: "ElTableHeader",
  components: {
    ElCheckbox: AD
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: ()=>({
        prop: "",
        order: ""
      })
    }
  },
  setup(e, {emit: t}) {
    const n = ei()
      , r = jo(FV)
      , o = qy("table")
      , a = Ft({})
      , {onColumnsChange: i, onScrollableChange: s} = PV(r);
    Lr((async()=>{
        await hn(),
          await hn();
        const {prop: t, order: n} = e.defaultSort;
        null == r || r.store.commit("sort", {
          prop: t,
          order: n,
          init: !0
        })
      }
    ));
    const {handleHeaderClick: l, handleHeaderContextMenu: u, handleMouseDown: c, handleMouseMove: d, handleMouseOut: f, handleSortClick: p, handleFilterClick: h} = function(e, t) {
      const n = ei()
        , r = jo(FV)
        , o = e=>{
          e.stopPropagation()
        }
        , a = Ft(null)
        , i = Ft(!1)
        , s = Ft({})
        , l = (t,n,o)=>{
          var a;
          t.stopPropagation();
          const i = n.order === o ? null : o || (({order: e, sortOrders: t})=>{
              if ("" === e)
                return t[0];
              const n = t.indexOf(e || null);
              return t[n > t.length - 2 ? 0 : n + 1]
            }
          )(n)
            , s = null == (a = t.target) ? void 0 : a.closest("th");
          if (s && em(s, "noclick"))
            return void nm(s, "noclick");
          if (!n.sortable)
            return;
          const l = e.store.states;
          let u, c = l.sortProp.value;
          const d = l.sortingColumn.value;
          (d !== n || d === n && null === d.order) && (d && (d.order = null),
            l.sortingColumn.value = n,
            c = n.property),
            u = n.order = i || null,
            l.sortProp.value = c,
            l.sortOrder.value = u,
          null == r || r.store.commit("changeSortCondition")
        }
      ;
      return {
        handleHeaderClick: (e,t)=>{
          !t.filters && t.sortable ? l(e, t, !1) : t.filterable && !t.sortable && o(e),
          null == r || r.emit("header-click", t, e)
        }
        ,
        handleHeaderContextMenu: (e,t)=>{
          null == r || r.emit("header-contextmenu", t, e)
        }
        ,
        handleMouseDown: (o,l)=>{
          if (mc && !(l.children && l.children.length > 0) && a.value && e.border) {
            i.value = !0;
            const u = r;
            t("set-drag-visible", !0);
            const c = (null == u ? void 0 : u.vnode.el).getBoundingClientRect().left
              , d = n.vnode.el.querySelector(`th.${l.id}`)
              , f = d.getBoundingClientRect()
              , p = f.left - c + 30;
            tm(d, "noclick"),
              s.value = {
                startMouseLeft: o.clientX,
                startLeft: f.right - c,
                startColumnLeft: f.left - c,
                tableLeft: c
              };
            const h = null == u ? void 0 : u.refs.resizeProxy;
            h.style.left = `${s.value.startLeft}px`,
              document.onselectstart = function() {
                return !1
              }
              ,
              document.ondragstart = function() {
                return !1
              }
            ;
            const v = e=>{
                const t = e.clientX - s.value.startMouseLeft
                  , n = s.value.startLeft + t;
                h.style.left = `${Math.max(p, n)}px`
              }
              , g = ()=>{
                if (i.value) {
                  const {startColumnLeft: n, startLeft: r} = s.value
                    , c = Number.parseInt(h.style.left, 10) - n;
                  l.width = l.realWidth = c,
                  null == u || u.emit("header-dragend", l.width, r - n, l, o),
                    requestAnimationFrame((()=>{
                        e.store.scheduleLayout(!1, !0)
                      }
                    )),
                    document.body.style.cursor = "",
                    i.value = !1,
                    a.value = null,
                    s.value = {},
                    t("set-drag-visible", !1)
                }
                document.removeEventListener("mousemove", v),
                  document.removeEventListener("mouseup", g),
                  document.onselectstart = null,
                  document.ondragstart = null,
                  setTimeout((()=>{
                      nm(d, "noclick")
                    }
                  ), 0)
              }
            ;
            document.addEventListener("mousemove", v),
              document.addEventListener("mouseup", g)
          }
        }
        ,
        handleMouseMove: (t,n)=>{
          if (n.children && n.children.length > 0)
            return;
          const r = t.target;
          if (!$g(r))
            return;
          const o = null == r ? void 0 : r.closest("th");
          if (n && n.resizable && !i.value && e.border) {
            const e = o.getBoundingClientRect()
              , r = document.body.style;
            e.width > 12 && e.right - t.pageX < 8 ? (r.cursor = "col-resize",
            em(o, "is-sortable") && (o.style.cursor = "col-resize"),
              a.value = n) : i.value || (r.cursor = "",
            em(o, "is-sortable") && (o.style.cursor = "pointer"),
              a.value = null)
          }
        }
        ,
        handleMouseOut: ()=>{
          mc && (document.body.style.cursor = "")
        }
        ,
        handleSortClick: l,
        handleFilterClick: o
      }
    }(e, t)
      , {getHeaderRowStyle: v, getHeaderRowClass: g, getHeaderCellStyle: m, getHeaderCellClass: y} = function(e) {
      const t = jo(FV)
        , n = qy("table");
      return {
        getHeaderRowStyle: e=>{
          const n = null == t ? void 0 : t.props.headerRowStyle;
          return "function" == typeof n ? n.call(null, {
            rowIndex: e
          }) : n
        }
        ,
        getHeaderRowClass: e=>{
          const n = []
            , r = null == t ? void 0 : t.props.headerRowClassName;
          return "string" == typeof r ? n.push(r) : "function" == typeof r && n.push(r.call(null, {
            rowIndex: e
          })),
            n.join(" ")
        }
        ,
        getHeaderCellStyle: (n,r,o,a)=>{
          var i;
          let s = null != (i = null == t ? void 0 : t.props.headerCellStyle) ? i : {};
          "function" == typeof s && (s = s.call(null, {
            rowIndex: n,
            columnIndex: r,
            row: o,
            column: a
          }));
          const l = gV(r, a.fixed, e.store, o);
          return mV(l, "left"),
            mV(l, "right"),
            Object.assign({}, s, l)
        }
        ,
        getHeaderCellClass: (r,o,a,i)=>{
          const s = hV(n.b(), o, i.fixed, e.store, a)
            , l = [i.id, i.order, i.headerAlign, i.className, i.labelClassName, ...s];
          i.children || l.push("is-leaf"),
          i.sortable && l.push("is-sortable");
          const u = null == t ? void 0 : t.props.headerCellClassName;
          return "string" == typeof u ? l.push(u) : "function" == typeof u && l.push(u.call(null, {
            rowIndex: r,
            columnIndex: o,
            row: a,
            column: i
          })),
            l.push(n.e("cell")),
            l.filter((e=>Boolean(e))).join(" ")
        }
      }
    }(e)
      , {isGroup: b, toggleAllSelection: w, columnRows: x} = NV(e);
    return n.state = {
      onColumnsChange: i,
      onScrollableChange: s
    },
      n.filterPanels = a,
      {
        ns: o,
        filterPanels: a,
        onColumnsChange: i,
        onScrollableChange: s,
        columnRows: x,
        getHeaderRowClass: g,
        getHeaderRowStyle: v,
        getHeaderCellClass: y,
        getHeaderCellStyle: m,
        handleHeaderClick: l,
        handleHeaderContextMenu: u,
        handleMouseDown: c,
        handleMouseMove: d,
        handleMouseOut: f,
        handleSortClick: p,
        handleFilterClick: h,
        isGroup: b,
        toggleAllSelection: w
      }
  },
  render() {
    const {ns: e, isGroup: t, columnRows: n, getHeaderCellStyle: r, getHeaderCellClass: o, getHeaderRowClass: a, getHeaderRowStyle: i, handleHeaderClick: s, handleHeaderContextMenu: l, handleMouseDown: u, handleMouseMove: c, handleSortClick: d, handleMouseOut: f, store: p, $parent: h} = this;
    let v = 1;
    return bi("thead", {
      class: {
        [e.is("group")]: t
      }
    }, n.map(((e,t)=>bi("tr", {
      class: a(t),
      key: t,
      style: i(t)
    }, e.map(((n,a)=>(n.rowSpan > v && (v = n.rowSpan),
      bi("th", {
        class: o(t, a, e, n),
        colspan: n.colSpan,
        key: `${n.id}-thead`,
        rowspan: n.rowSpan,
        style: r(t, a, e, n),
        onClick: e=>s(e, n),
        onContextmenu: e=>l(e, n),
        onMousedown: e=>u(e, n),
        onMousemove: e=>c(e, n),
        onMouseout: f
      }, [bi("div", {
        class: ["cell", n.filteredValue && n.filteredValue.length > 0 ? "highlight" : ""]
      }, [n.renderHeader ? n.renderHeader({
        column: n,
        $index: a,
        store: p,
        _self: h
      }) : n.label, n.sortable && bi("span", {
        onClick: e=>d(e, n),
        class: "caret-wrapper"
      }, [bi("i", {
        onClick: e=>d(e, n, "ascending"),
        class: "sort-caret ascending"
      }), bi("i", {
        onClick: e=>d(e, n, "descending"),
        class: "sort-caret descending"
      })]), n.filterable && bi(IV, {
        store: p,
        placement: n.filterPlacement || "bottom-start",
        column: n,
        upDataColumn: (e,t)=>{
          n[e] = t
        }
      })])]))))))))
  }
});
function jV(e) {
  const t = jo(FV)
    , n = Ft("")
    , r = Ft(bi("div"))
    , o = (n,r,o)=>{
      var a;
      const i = t
        , s = Zj(n);
      let l;
      const u = null == (a = null == i ? void 0 : i.vnode.el) ? void 0 : a.dataset.prefix;
      s && (l = rV({
        columns: e.store.states.columns.value
      }, s, u),
      l && (null == i || i.emit(`cell-${o}`, r, l, s, n))),
      null == i || i.emit(`row-${o}`, r, l, n)
    }
    , a = ug((t=>{
        e.store.commit("setHoverRow", t)
      }
    ), 30)
    , i = ug((()=>{
        e.store.commit("setHoverRow", null)
      }
    ), 30)
    , s = (e,t,n)=>{
      let r = t.target.parentNode;
      for (; e > 1 && (r = null == r ? void 0 : r.nextSibling,
      r && "TR" === r.nodeName); )
        n(r, "hover-row hover-fixed-row"),
          e--
    }
  ;
  return {
    handleDoubleClick: (e,t)=>{
      o(e, t, "dblclick")
    }
    ,
    handleClick: (t,n)=>{
      e.store.commit("setCurrentRow", n),
        o(t, n, "click")
    }
    ,
    handleContextMenu: (e,t)=>{
      o(e, t, "contextmenu")
    }
    ,
    handleMouseEnter: a,
    handleMouseLeave: i,
    handleCellMouseEnter: (n,r,o)=>{
      var a;
      const i = t
        , l = Zj(n)
        , u = null == (a = null == i ? void 0 : i.vnode.el) ? void 0 : a.dataset.prefix;
      if (l) {
        const t = rV({
          columns: e.store.states.columns.value
        }, l, u);
        l.rowSpan > 1 && s(l.rowSpan, n, tm);
        const o = i.hoverState = {
          cell: l,
          column: t,
          row: r
        };
        null == i || i.emit("cell-mouse-enter", o.row, o.column, o.cell, n)
      }
      if (!o)
        return;
      const c = n.target.querySelector(".cell");
      if (!em(c, `${u}-tooltip`) || !c.childNodes.length)
        return;
      const d = document.createRange();
      d.setStart(c, 0),
        d.setEnd(c, c.childNodes.length);
      let f = d.getBoundingClientRect().width
        , p = d.getBoundingClientRect().height;
      f - Math.floor(f) < .001 && (f = Math.floor(f));
      p - Math.floor(p) < .001 && (p = Math.floor(p));
      const {top: h, left: v, right: g, bottom: m} = (e=>{
          const t = window.getComputedStyle(e, null);
          return {
            left: Number.parseInt(t.paddingLeft, 10) || 0,
            right: Number.parseInt(t.paddingRight, 10) || 0,
            top: Number.parseInt(t.paddingTop, 10) || 0,
            bottom: Number.parseInt(t.paddingBottom, 10) || 0
          }
        }
      )(c)
        , y = h + m;
      (f + (v + g) > c.offsetWidth || p + y > c.offsetHeight || c.scrollWidth > c.offsetWidth) && function(e, t, n, r) {
        if ((null == cV ? void 0 : cV.trigger) === n)
          return;
        null == cV || cV();
        const o = null == r ? void 0 : r.refs.tableWrapper
          , a = null == o ? void 0 : o.dataset.prefix
          , i = {
          strategy: "fixed",
          ...e.popperOptions
        }
          , s = ja(MA, {
          content: t,
          virtualTriggering: !0,
          virtualRef: n,
          appendTo: o,
          placement: "top",
          transition: "none",
          offset: 0,
          hideAfter: 0,
          ...e,
          popperOptions: i,
          onHide: ()=>{
            null == cV || cV()
          }
        });
        s.appContext = {
          ...r.appContext,
          ...r
        };
        const l = document.createElement("div");
        Ys(s, l),
          s.component.exposed.onOpen();
        const u = null == o ? void 0 : o.querySelector(`.${a}-scrollbar__wrap`);
        cV = ()=>{
          Ys(null, l),
          null == u || u.removeEventListener("scroll", cV),
            cV = null
        }
          ,
          cV.trigger = n,
        null == u || u.addEventListener("scroll", cV)
      }(o, l.innerText || l.textContent, l, i)
    }
    ,
    handleCellMouseLeave: e=>{
      const n = Zj(e);
      if (!n)
        return;
      n.rowSpan > 1 && s(n.rowSpan, e, nm);
      const r = null == t ? void 0 : t.hoverState;
      null == t || t.emit("cell-mouse-leave", null == r ? void 0 : r.row, null == r ? void 0 : r.column, null == r ? void 0 : r.cell, e)
    }
    ,
    tooltipContent: n,
    tooltipTrigger: r
  }
}
function VV(e) {
  const t = jo(FV)
    , n = qy("table")
    , {handleDoubleClick: r, handleClick: o, handleContextMenu: a, handleMouseEnter: i, handleMouseLeave: s, handleCellMouseEnter: l, handleCellMouseLeave: u, tooltipContent: c, tooltipTrigger: d} = jV(e)
    , {getRowStyle: f, getRowClass: p, getCellStyle: h, getCellClass: v, getSpan: g, getColspanRealWidth: m} = function(e) {
    const t = jo(FV)
      , n = qy("table");
    return {
      getRowStyle: (e,n)=>{
        const r = null == t ? void 0 : t.props.rowStyle;
        return "function" == typeof r ? r.call(null, {
          row: e,
          rowIndex: n
        }) : r || null
      }
      ,
      getRowClass: (r,o)=>{
        const a = [n.e("row")];
        (null == t ? void 0 : t.props.highlightCurrentRow) && r === e.store.states.currentRow.value && a.push("current-row"),
        e.stripe && o % 2 == 1 && a.push(n.em("row", "striped"));
        const i = null == t ? void 0 : t.props.rowClassName;
        return "string" == typeof i ? a.push(i) : "function" == typeof i && a.push(i.call(null, {
          row: r,
          rowIndex: o
        })),
          a
      }
      ,
      getCellStyle: (n,r,o,a)=>{
        const i = null == t ? void 0 : t.props.cellStyle;
        let s = null != i ? i : {};
        "function" == typeof i && (s = i.call(null, {
          rowIndex: n,
          columnIndex: r,
          row: o,
          column: a
        }));
        const l = gV(r, null == e ? void 0 : e.fixed, e.store);
        return mV(l, "left"),
          mV(l, "right"),
          Object.assign({}, s, l)
      }
      ,
      getCellClass: (r,o,a,i,s)=>{
        const l = hV(n.b(), o, null == e ? void 0 : e.fixed, e.store, void 0, s)
          , u = [i.id, i.align, i.className, ...l]
          , c = null == t ? void 0 : t.props.cellClassName;
        return "string" == typeof c ? u.push(c) : "function" == typeof c && u.push(c.call(null, {
          rowIndex: r,
          columnIndex: o,
          row: a,
          column: i
        })),
          u.push(n.e("cell")),
          u.filter((e=>Boolean(e))).join(" ")
      }
      ,
      getSpan: (e,n,r,o)=>{
        let a = 1
          , i = 1;
        const s = null == t ? void 0 : t.props.spanMethod;
        if ("function" == typeof s) {
          const t = s({
            row: e,
            column: n,
            rowIndex: r,
            columnIndex: o
          });
          Array.isArray(t) ? (a = t[0],
            i = t[1]) : "object" == typeof t && (a = t.rowspan,
            i = t.colspan)
        }
        return {
          rowspan: a,
          colspan: i
        }
      }
      ,
      getColspanRealWidth: (e,t,n)=>{
        if (t < 1)
          return e[n].realWidth;
        const r = e.map((({realWidth: e, width: t})=>e || t)).slice(n, n + t);
        return Number(r.reduce(((e,t)=>Number(e) + Number(t)), -1))
      }
    }
  }(e)
    , y = yi((()=>e.store.states.columns.value.findIndex((({type: e})=>"default" === e))))
    , b = (e,n)=>{
    const r = t.props.rowKey;
    return r ? oV(e, r) : n
  }
    , w = (c,d,w,S=!1)=>{
    const {tooltipEffect: E, tooltipOptions: A, store: C} = e
      , {indent: k, columns: T} = C.states
      , D = p(c, d);
    let O = !0;
    w && (D.push(n.em("row", `level-${w.level}`)),
      O = w.display);
    return bi("tr", {
      style: [O ? null : {
        display: "none"
      }, f(c, d)],
      class: D,
      key: b(c, d),
      onDblclick: e=>r(e, c),
      onClick: e=>o(e, c),
      onContextmenu: e=>a(e, c),
      onMouseenter: ()=>i(d),
      onMouseleave: s
    }, T.value.map(((n,r)=>{
        const {rowspan: o, colspan: a} = g(c, n, d, r);
        if (!o || !a)
          return null;
        const i = Object.assign({}, n);
        i.realWidth = m(T.value, a, r);
        const s = {
          store: e.store,
          _self: e.context || t,
          column: i,
          row: c,
          $index: d,
          cellIndex: r,
          expanded: S
        };
        r === y.value && w && (s.treeNode = {
          indent: w.level * k.value,
          level: w.level
        },
        "boolean" == typeof w.expanded && (s.treeNode.expanded = w.expanded,
        "loading"in w && (s.treeNode.loading = w.loading),
        "noLazyChildren"in w && (s.treeNode.noLazyChildren = w.noLazyChildren)));
        const f = `${d},${r}`
          , p = i.columnKey || i.rawColumnKey || ""
          , b = x(r, n, s)
          , C = n.showOverflowTooltip && Tg({
          effect: E
        }, A, n.showOverflowTooltip);
        return bi("td", {
          style: h(d, r, c, n),
          class: v(d, r, c, n, a - 1),
          key: `${p}${f}`,
          rowspan: o,
          colspan: a,
          onMouseenter: e=>l(e, c, C),
          onMouseleave: u
        }, [b])
      }
    )))
  }
    , x = (e,t,n)=>t.renderCell(n);
  return {
    wrappedRowRender: (r,o)=>{
      const a = e.store
        , {isRowExpanded: i, assertRowKey: s} = a
        , {treeData: l, lazyTreeNodeMap: u, childrenColumnName: c, rowKey: d} = a.states
        , f = a.states.columns.value;
      if (f.some((({type: e})=>"expand" === e))) {
        const e = i(r)
          , s = w(r, o, void 0, e)
          , l = t.renderExpanded;
        return e ? l ? [[s, bi("tr", {
          key: `expanded-row__${s.key}`
        }, [bi("td", {
          colspan: f.length,
          class: `${n.e("cell")} ${n.e("expanded-cell")}`
        }, [l({
          row: r,
          $index: o,
          store: a,
          expanded: e
        })])])]] : (console.error("[Element Error]renderExpanded is required."),
          s) : [[s]]
      }
      if (Object.keys(l.value).length) {
        s();
        const e = oV(r, d.value);
        let t = l.value[e]
          , n = null;
        t && (n = {
          expanded: t.expanded,
          level: t.level,
          display: !0
        },
        "boolean" == typeof t.lazy && ("boolean" == typeof t.loaded && t.loaded && (n.noLazyChildren = !(t.children && t.children.length)),
          n.loading = t.loading));
        const a = [w(r, o, n)];
        if (t) {
          let n = 0;
          const i = (e,r)=>{
              e && e.length && r && e.forEach((e=>{
                  const s = {
                    display: r.display && r.expanded,
                    level: r.level + 1,
                    expanded: !1,
                    noLazyChildren: !1,
                    loading: !1
                  }
                    , f = oV(e, d.value);
                  if (null == f)
                    throw new Error("For nested data item, row-key is required.");
                  if (t = {
                    ...l.value[f]
                  },
                  t && (s.expanded = t.expanded,
                    t.level = t.level || s.level,
                    t.display = !(!t.expanded || !s.display),
                  "boolean" == typeof t.lazy && ("boolean" == typeof t.loaded && t.loaded && (s.noLazyChildren = !(t.children && t.children.length)),
                    s.loading = t.loading)),
                    n++,
                    a.push(w(e, o + n, s)),
                    t) {
                    const n = u.value[f] || e[c.value];
                    i(n, t)
                  }
                }
              ))
            }
          ;
          t.display = !0;
          const s = u.value[e] || r[c.value];
          i(s, t)
        }
        return a
      }
      return w(r, o, void 0)
    }
    ,
    tooltipContent: c,
    tooltipTrigger: d
  }
}
var UV = vr({
  name: "ElTableBody",
  props: {
    store: {
      required: !0,
      type: Object
    },
    stripe: Boolean,
    tooltipEffect: String,
    tooltipOptions: {
      type: Object
    },
    context: {
      default: ()=>({}),
      type: Object
    },
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    fixed: {
      type: String,
      default: ""
    },
    highlight: Boolean
  },
  setup(e) {
    const t = ei()
      , n = jo(FV)
      , r = qy("table")
      , {wrappedRowRender: o, tooltipContent: a, tooltipTrigger: i} = VV(e)
      , {onColumnsChange: s, onScrollableChange: l} = PV(n)
      , u = [];
    return Jn(e.store.states.hoverRow, ((n,o)=>{
        var a;
        const i = null == t ? void 0 : t.vnode.el
          , s = Array.from((null == i ? void 0 : i.children) || []).filter((e=>null == e ? void 0 : e.classList.contains(`${r.e("row")}`)));
        let l = n;
        const c = null == (a = s[l]) ? void 0 : a.childNodes;
        if (null == c ? void 0 : c.length) {
          Array.from(c).reduce(((e,t,n)=>{
              var r, o;
              const a = (null == (r = c[n - 1]) ? void 0 : r.colSpan) > 1
                , i = (null == (o = c[n + 1]) ? void 0 : o.colSpan) > 1;
              return "TD" === t.nodeName || a || i || e.push(n),
                e
            }
          ), []).forEach((e=>{
              for (var t; l > 0; ) {
                const n = null == (t = s[l - 1]) ? void 0 : t.childNodes;
                if (n[e] && "TD" === n[e].nodeName) {
                  tm(n[e], "hover-cell"),
                    u.push(n[e]);
                  break
                }
                l--
              }
            }
          ))
        } else
          u.forEach((e=>nm(e, "hover-cell"))),
            u.length = 0;
        e.store.states.isComplex.value && mc && Kg((()=>{
            const e = s[o]
              , t = s[n];
            e && !e.classList.contains("hover-fixed-row") && nm(e, "hover-row"),
            t && tm(t, "hover-row")
          }
        ))
      }
    )),
      Br((()=>{
          var e;
          null == (e = cV) || e()
        }
      )),
      {
        ns: r,
        onColumnsChange: s,
        onScrollableChange: l,
        wrappedRowRender: o,
        tooltipContent: a,
        tooltipTrigger: i
      }
  },
  render() {
    const {wrappedRowRender: e, store: t} = this;
    return bi("tbody", {
      tabIndex: -1
    }, [(t.states.data.value || []).reduce(((t,n)=>t.concat(e(n, t.length))), [])])
  }
});
function $V(e) {
  const {columns: t} = function() {
    const e = jo(FV)
      , t = null == e ? void 0 : e.store;
    return {
      leftFixedLeafCount: yi((()=>t.states.fixedLeafColumnsLength.value)),
      rightFixedLeafCount: yi((()=>t.states.rightFixedColumns.value.length)),
      columnsCount: yi((()=>t.states.columns.value.length)),
      leftFixedCount: yi((()=>t.states.fixedColumns.value.length)),
      rightFixedCount: yi((()=>t.states.rightFixedColumns.value.length)),
      columns: t.states.columns
    }
  }()
    , n = qy("table");
  return {
    getCellClasses: (t,r)=>{
      const o = t[r]
        , a = [n.e("cell"), o.id, o.align, o.labelClassName, ...hV(n.b(), r, o.fixed, e.store)];
      return o.className && a.push(o.className),
      o.children || a.push(n.is("leaf")),
        a
    }
    ,
    getCellStyles: (t,n)=>{
      const r = gV(n, t.fixed, e.store);
      return mV(r, "left"),
        mV(r, "right"),
        r
    }
    ,
    columns: t
  }
}
var HV = vr({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: ()=>({
        prop: "",
        order: ""
      })
    }
  },
  setup(e) {
    const {getCellClasses: t, getCellStyles: n, columns: r} = $V(e);
    return {
      ns: qy("table"),
      getCellClasses: t,
      getCellStyles: n,
      columns: r
    }
  },
  render() {
    const {columns: e, getCellStyles: t, getCellClasses: n, summaryMethod: r, sumText: o} = this
      , a = this.store.states.data.value;
    let i = [];
    return r ? i = r({
      columns: e,
      data: a
    }) : e.forEach(((e,t)=>{
        if (0 === t)
          return void (i[t] = o);
        const n = a.map((t=>Number(t[e.property])))
          , r = [];
        let s = !0;
        n.forEach((e=>{
            if (!Number.isNaN(+e)) {
              s = !1;
              const t = `${e}`.split(".")[1];
              r.push(t ? t.length : 0)
            }
          }
        ));
        const l = Math.max.apply(null, r);
        i[t] = s ? "" : n.reduce(((e,t)=>{
            const n = Number(t);
            return Number.isNaN(+n) ? e : Number.parseFloat((e + t).toFixed(Math.min(l, 20)))
          }
        ), 0)
      }
    )),
      bi(bi("tfoot", [bi("tr", {}, [...e.map(((r,o)=>bi("td", {
        key: o,
        colspan: r.colSpan,
        rowspan: r.rowSpan,
        class: n(e, o),
        style: t(r, o)
      }, [bi("div", {
        class: ["cell", r.labelClassName]
      }, [i[o]])])))])]))
  }
});
function zV(e, t, n, r) {
  const o = Ft(!1)
    , a = Ft(null)
    , i = Ft(!1)
    , s = Ft({
    width: null,
    height: null,
    headerHeight: null
  })
    , l = Ft(!1)
    , u = Ft()
    , c = Ft(0)
    , d = Ft(0)
    , f = Ft(0)
    , p = Ft(0)
    , h = Ft(0);
  qn((()=>{
      t.setHeight(e.height)
    }
  )),
    qn((()=>{
        t.setMaxHeight(e.maxHeight)
      }
    )),
    Jn((()=>[e.currentRowKey, n.states.rowKey]), (([e,t])=>{
        Vt(t) && Vt(e) && n.setCurrentRowKey(`${e}`)
      }
    ), {
      immediate: !0
    }),
    Jn((()=>e.data), (e=>{
        r.store.commit("setData", e)
      }
    ), {
      immediate: !0,
      deep: !0
    }),
    qn((()=>{
        e.expandRowKeys && n.setExpandRowKeysAdapter(e.expandRowKeys)
      }
    ));
  const v = yi((()=>e.height || e.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0))
    , g = yi((()=>({
      width: t.bodyWidth.value ? `${t.bodyWidth.value}px` : ""
    })))
    , m = ()=>{
      v.value && t.updateElsHeight(),
        t.updateColumnsWidth(),
        requestAnimationFrame(b)
    }
  ;
  Lr((async()=>{
      await hn(),
        n.updateColumns(),
        w(),
        requestAnimationFrame(m);
      const t = r.vnode.el
        , o = r.refs.headerWrapper;
      e.flexible && t && t.parentElement && (t.parentElement.style.minWidth = "0"),
        s.value = {
          width: u.value = t.offsetWidth,
          height: t.offsetHeight,
          headerHeight: e.showHeader && o ? o.offsetHeight : null
        },
        n.states.columns.value.forEach((e=>{
            e.filteredValue && e.filteredValue.length && r.store.commit("filterChange", {
              column: e,
              values: e.filteredValue,
              silent: !0
            })
          }
        )),
        r.$ready = !0
    }
  ));
  const y = e=>{
    const {tableWrapper: n} = r.refs;
    ((e,n)=>{
        if (!e)
          return;
        const r = Array.from(e.classList).filter((e=>!e.startsWith("is-scrolling-")));
        r.push(t.scrollX.value ? n : "is-scrolling-none"),
          e.className = r.join(" ")
      }
    )(n, e)
  }
    , b = function() {
    if (!r.refs.scrollBarRef)
      return;
    if (!t.scrollX.value) {
      const e = "is-scrolling-none";
      return void ((e=>{
          const {tableWrapper: t} = r.refs;
          return !(!t || !t.classList.contains(e))
        }
      )(e) || y(e))
    }
    const e = r.refs.scrollBarRef.wrapRef;
    if (!e)
      return;
    const {scrollLeft: n, offsetWidth: o, scrollWidth: a} = e
      , {headerWrapper: i, footerWrapper: s} = r.refs;
    i && (i.scrollLeft = n),
    s && (s.scrollLeft = n);
    y(n >= a - o - 1 ? "is-scrolling-right" : 0 === n ? "is-scrolling-left" : "is-scrolling-middle")
  }
    , w = ()=>{
    r.refs.scrollBarRef && (r.refs.scrollBarRef.wrapRef && Rc(r.refs.scrollBarRef.wrapRef, "scroll", b, {
      passive: !0
    }),
      e.fit ? Uc(r.vnode.el, x) : Rc(window, "resize", x),
      Uc(r.refs.bodyWrapper, (()=>{
          var e, t;
          x(),
          null == (t = null == (e = r.refs) ? void 0 : e.scrollBarRef) || t.update()
        }
      )))
  }
    , x = ()=>{
    var t, n, o, a;
    const i = r.vnode.el;
    if (!r.$ready || !i)
      return;
    let l = !1;
    const {width: g, height: y, headerHeight: b} = s.value
      , w = u.value = i.offsetWidth;
    g !== w && (l = !0);
    const x = i.offsetHeight;
    (e.height || v.value) && y !== x && (l = !0);
    const S = "fixed" === e.tableLayout ? r.refs.headerWrapper : null == (t = r.refs.tableHeaderRef) ? void 0 : t.$el;
    e.showHeader && (null == S ? void 0 : S.offsetHeight) !== b && (l = !0),
      c.value = (null == (n = r.refs.tableWrapper) ? void 0 : n.scrollHeight) || 0,
      f.value = (null == S ? void 0 : S.scrollHeight) || 0,
      p.value = (null == (o = r.refs.footerWrapper) ? void 0 : o.offsetHeight) || 0,
      h.value = (null == (a = r.refs.appendWrapper) ? void 0 : a.offsetHeight) || 0,
      d.value = c.value - f.value - p.value - h.value,
    l && (s.value = {
      width: w,
      height: x,
      headerHeight: e.showHeader && (null == S ? void 0 : S.offsetHeight) || 0
    },
      m())
  }
    , S = hS()
    , E = yi((()=>{
      const {bodyWidth: e, scrollY: n, gutterWidth: r} = t;
      return e.value ? e.value - (n.value ? r : 0) + "px" : ""
    }
  ))
    , A = yi((()=>e.maxHeight ? "fixed" : e.tableLayout))
    , C = yi((()=>{
      if (e.data && e.data.length)
        return null;
      let t = "100%";
      e.height && d.value && (t = `${d.value}px`);
      const n = u.value;
      return {
        width: n ? `${n}px` : "",
        height: t
      }
    }
  ))
    , k = yi((()=>e.height ? {
    height: Number.isNaN(Number(e.height)) ? e.height : `${e.height}px`
  } : e.maxHeight ? {
    maxHeight: Number.isNaN(Number(e.maxHeight)) ? e.maxHeight : `${e.maxHeight}px`
  } : {}))
    , T = yi((()=>e.height ? {
    height: "100%"
  } : e.maxHeight ? Number.isNaN(Number(e.maxHeight)) ? {
    maxHeight: `calc(${e.maxHeight} - ${f.value + p.value}px)`
  } : {
    maxHeight: e.maxHeight - f.value - p.value + "px"
  } : {}));
  return {
    isHidden: o,
    renderExpanded: a,
    setDragVisible: e=>{
      i.value = e
    }
    ,
    isGroup: l,
    handleMouseLeave: ()=>{
      r.store.commit("setHoverRow", null),
      r.hoverState && (r.hoverState = null)
    }
    ,
    handleHeaderFooterMousewheel: (e,t)=>{
      const {pixelX: n, pixelY: o} = t;
      Math.abs(n) >= Math.abs(o) && (r.refs.bodyWrapper.scrollLeft += t.pixelX / 5)
    }
    ,
    tableSize: S,
    emptyBlockStyle: C,
    handleFixedMousewheel: (e,t)=>{
      const n = r.refs.bodyWrapper;
      if (Math.abs(t.spinY) > 0) {
        const r = n.scrollTop;
        t.pixelY < 0 && 0 !== r && e.preventDefault(),
        t.pixelY > 0 && n.scrollHeight - n.clientHeight > r && e.preventDefault(),
          n.scrollTop += Math.ceil(t.pixelY / 5)
      } else
        n.scrollLeft += Math.ceil(t.pixelX / 5)
    }
    ,
    resizeProxyVisible: i,
    bodyWidth: E,
    resizeState: s,
    doLayout: m,
    tableBodyStyles: g,
    tableLayout: A,
    scrollbarViewStyle: {
      display: "inline-block",
      verticalAlign: "middle"
    },
    tableInnerStyle: k,
    scrollbarStyle: T
  }
}
function KV(e) {
  const t = Ft();
  Lr((()=>{
      (()=>{
          const n = e.vnode.el.querySelector(".hidden-columns")
            , r = e.store.states.updateOrderFns;
          t.value = new MutationObserver((()=>{
              r.forEach((e=>e()))
            }
          )),
            t.value.observe(n, {
              childList: !0,
              subtree: !0
            })
        }
      )()
    }
  )),
    Br((()=>{
        var e;
        null == (e = t.value) || e.disconnect()
      }
    ))
}
var WV = {
  data: {
    type: Array,
    default: ()=>[]
  },
  size: Ux,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: !0
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: !0
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: !0
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: ()=>({
      hasChildren: "hasChildren",
      children: "children"
    })
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: ()=>({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: Boolean,
  flexible: Boolean,
  showOverflowTooltip: [Boolean, Object]
};
function GV(e) {
  const t = "auto" === e.tableLayout;
  let n = e.columns || [];
  t && n.every((e=>void 0 === e.width)) && (n = []);
  return bi("colgroup", {}, n.map((n=>bi("col", (n=>{
      const r = {
        key: `${e.tableLayout}_${n.id}`,
        style: {},
        name: void 0
      };
      return t ? r.style = {
        width: `${n.width}px`
      } : r.name = n.id,
        r
    }
  )(n)))))
}
GV.props = ["columns", "tableLayout"];
let qV = 1;
const YV = vr({
  name: "ElTable",
  directives: {
    Mousewheel: cT
  },
  components: {
    TableHeader: MV,
    TableBody: UV,
    TableFooter: HV,
    ElScrollbar: DE,
    hColgroup: GV
  },
  props: WV,
  emits: ["select", "select-all", "selection-change", "cell-mouse-enter", "cell-mouse-leave", "cell-contextmenu", "cell-click", "cell-dblclick", "row-click", "row-contextmenu", "row-dblclick", "header-click", "header-contextmenu", "sort-change", "filter-change", "current-change", "header-dragend", "expand-change"],
  setup(e) {
    const {t: t} = Hy()
      , n = qy("table")
      , r = ei();
    Mo(FV, r);
    const o = AV(r, e);
    r.store = o;
    const a = new TV({
      store: r.store,
      table: r,
      fit: e.fit,
      showHeader: e.showHeader
    });
    r.layout = a;
    const i = yi((()=>0 === (o.states.data.value || []).length))
      , {setCurrentRow: s, getSelectionRows: l, toggleRowSelection: u, clearSelection: c, clearFilter: d, toggleAllSelection: f, toggleRowExpansion: p, clearSort: h, sort: v} = function(e) {
      return {
        setCurrentRow: t=>{
          e.commit("setCurrentRow", t)
        }
        ,
        getSelectionRows: ()=>e.getSelectionRows(),
        toggleRowSelection: (t,n)=>{
          e.toggleRowSelection(t, n, !1),
            e.updateAllSelected()
        }
        ,
        clearSelection: ()=>{
          e.clearSelection()
        }
        ,
        clearFilter: t=>{
          e.clearFilter(t)
        }
        ,
        toggleAllSelection: ()=>{
          e.commit("toggleAllSelection")
        }
        ,
        toggleRowExpansion: (t,n)=>{
          e.toggleRowExpansionAdapter(t, n)
        }
        ,
        clearSort: ()=>{
          e.clearSort()
        }
        ,
        sort: (t,n)=>{
          e.commit("sort", {
            prop: t,
            order: n
          })
        }
      }
    }(o)
      , {isHidden: g, renderExpanded: m, setDragVisible: y, isGroup: b, handleMouseLeave: w, handleHeaderFooterMousewheel: x, tableSize: S, emptyBlockStyle: E, handleFixedMousewheel: A, resizeProxyVisible: C, bodyWidth: k, resizeState: T, doLayout: D, tableBodyStyles: O, tableLayout: _, scrollbarViewStyle: R, tableInnerStyle: L, scrollbarStyle: I} = zV(e, a, o, r)
      , {scrollBarRef: P, scrollTo: F, setScrollLeft: B, setScrollTop: N} = (()=>{
        const e = Ft()
          , t = (t,n)=>{
            const r = e.value;
            r && Vg(n) && ["Top", "Left"].includes(t) && r[`setScroll${t}`](n)
          }
        ;
        return {
          scrollBarRef: e,
          scrollTo: (t,n)=>{
            const r = e.value;
            r && r.scrollTo(t, n)
          }
          ,
          setScrollTop: e=>t("Top", e),
          setScrollLeft: e=>t("Left", e)
        }
      }
    )()
      , M = ug(D, 50)
      , j = `${n.namespace.value}-table_${qV++}`;
    r.tableId = j,
      r.state = {
        isGroup: b,
        resizeState: T,
        doLayout: D,
        debouncedUpdateLayout: M
      };
    const V = yi((()=>e.sumText || t("el.table.sumText")))
      , U = yi((()=>e.emptyText || t("el.table.emptyText")));
    return KV(r),
      {
        ns: n,
        layout: a,
        store: o,
        handleHeaderFooterMousewheel: x,
        handleMouseLeave: w,
        tableId: j,
        tableSize: S,
        isHidden: g,
        isEmpty: i,
        renderExpanded: m,
        resizeProxyVisible: C,
        resizeState: T,
        isGroup: b,
        bodyWidth: k,
        tableBodyStyles: O,
        emptyBlockStyle: E,
        debouncedUpdateLayout: M,
        handleFixedMousewheel: A,
        setCurrentRow: s,
        getSelectionRows: l,
        toggleRowSelection: u,
        clearSelection: c,
        clearFilter: d,
        toggleAllSelection: f,
        toggleRowExpansion: p,
        clearSort: h,
        doLayout: D,
        sort: v,
        t: t,
        setDragVisible: y,
        context: r,
        computedSumText: V,
        computedEmptyText: U,
        tableLayout: _,
        scrollbarViewStyle: R,
        tableInnerStyle: L,
        scrollbarStyle: I,
        scrollBarRef: P,
        scrollTo: F,
        setScrollLeft: B,
        setScrollTop: N
      }
  }
})
  , XV = ["data-prefix"]
  , QV = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
var JV = tS(YV, [["render", function(e, t, n, r, o, a) {
  const i = Hr("hColgroup")
    , s = Hr("table-header")
    , l = Hr("table-body")
    , u = Hr("table-footer")
    , c = Hr("el-scrollbar")
    , d = Wr("mousewheel");
  return Ca(),
    _a("div", {
      ref: "tableWrapper",
      class: Y([{
        [e.ns.m("fit")]: e.fit,
        [e.ns.m("striped")]: e.stripe,
        [e.ns.m("border")]: e.border || e.isGroup,
        [e.ns.m("hidden")]: e.isHidden,
        [e.ns.m("group")]: e.isGroup,
        [e.ns.m("fluid-height")]: e.maxHeight,
        [e.ns.m("scrollable-x")]: e.layout.scrollX.value,
        [e.ns.m("scrollable-y")]: e.layout.scrollY.value,
        [e.ns.m("enable-row-hover")]: !e.store.states.isComplex.value,
        [e.ns.m("enable-row-transition")]: 0 !== (e.store.states.data.value || []).length && (e.store.states.data.value || []).length < 100,
        "has-footer": e.showSummary
      }, e.ns.m(e.tableSize), e.className, e.ns.b(), e.ns.m(`layout-${e.tableLayout}`)]),
      style: z(e.style),
      "data-prefix": e.ns.namespace.value,
      onMouseleave: t[0] || (t[0] = (...t)=>e.handleMouseLeave && e.handleMouseLeave(...t))
    }, [Ma("div", {
      class: Y(e.ns.e("inner-wrapper")),
      style: z(e.tableInnerStyle)
    }, [Ma("div", QV, [Qr(e.$slots, "default")], 512), e.showHeader && "fixed" === e.tableLayout ? rr((Ca(),
      _a("div", {
        key: 0,
        ref: "headerWrapper",
        class: Y(e.ns.e("header-wrapper"))
      }, [Ma("table", {
        ref: "tableHeader",
        class: Y(e.ns.e("header")),
        style: z(e.tableBodyStyles),
        border: "0",
        cellpadding: "0",
        cellspacing: "0"
      }, [ja(i, {
        columns: e.store.states.columns.value,
        "table-layout": e.tableLayout
      }, null, 8, ["columns", "table-layout"]), ja(s, {
        ref: "tableHeaderRef",
        border: e.border,
        "default-sort": e.defaultSort,
        store: e.store,
        onSetDragVisible: e.setDragVisible
      }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])], 6)], 2)), [[d, e.handleHeaderFooterMousewheel]]) : za("v-if", !0), Ma("div", {
      ref: "bodyWrapper",
      class: Y(e.ns.e("body-wrapper"))
    }, [ja(c, {
      ref: "scrollBarRef",
      "view-style": e.scrollbarViewStyle,
      "wrap-style": e.scrollbarStyle,
      always: e.scrollbarAlwaysOn
    }, {
      default: Fn((()=>[Ma("table", {
        ref: "tableBody",
        class: Y(e.ns.e("body")),
        cellspacing: "0",
        cellpadding: "0",
        border: "0",
        style: z({
          width: e.bodyWidth,
          tableLayout: e.tableLayout
        })
      }, [ja(i, {
        columns: e.store.states.columns.value,
        "table-layout": e.tableLayout
      }, null, 8, ["columns", "table-layout"]), e.showHeader && "auto" === e.tableLayout ? (Ca(),
        Ra(s, {
          key: 0,
          ref: "tableHeaderRef",
          class: Y(e.ns.e("body-header")),
          border: e.border,
          "default-sort": e.defaultSort,
          store: e.store,
          onSetDragVisible: e.setDragVisible
        }, null, 8, ["class", "border", "default-sort", "store", "onSetDragVisible"])) : za("v-if", !0), ja(l, {
        context: e.context,
        highlight: e.highlightCurrentRow,
        "row-class-name": e.rowClassName,
        "tooltip-effect": e.tooltipEffect,
        "tooltip-options": e.tooltipOptions,
        "row-style": e.rowStyle,
        store: e.store,
        stripe: e.stripe
      }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]), e.showSummary && "auto" === e.tableLayout ? (Ca(),
        Ra(u, {
          key: 1,
          class: Y(e.ns.e("body-footer")),
          border: e.border,
          "default-sort": e.defaultSort,
          store: e.store,
          "sum-text": e.computedSumText,
          "summary-method": e.summaryMethod
        }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : za("v-if", !0)], 6), e.isEmpty ? (Ca(),
        _a("div", {
          key: 0,
          ref: "emptyBlock",
          style: z(e.emptyBlockStyle),
          class: Y(e.ns.e("empty-block"))
        }, [Ma("span", {
          class: Y(e.ns.e("empty-text"))
        }, [Qr(e.$slots, "empty", {}, (()=>[$a(te(e.computedEmptyText), 1)]))], 2)], 6)) : za("v-if", !0), e.$slots.append ? (Ca(),
        _a("div", {
          key: 1,
          ref: "appendWrapper",
          class: Y(e.ns.e("append-wrapper"))
        }, [Qr(e.$slots, "append")], 2)) : za("v-if", !0)])),
      _: 3
    }, 8, ["view-style", "wrap-style", "always"])], 2), e.showSummary && "fixed" === e.tableLayout ? rr((Ca(),
      _a("div", {
        key: 1,
        ref: "footerWrapper",
        class: Y(e.ns.e("footer-wrapper"))
      }, [Ma("table", {
        class: Y(e.ns.e("footer")),
        cellspacing: "0",
        cellpadding: "0",
        border: "0",
        style: z(e.tableBodyStyles)
      }, [ja(i, {
        columns: e.store.states.columns.value,
        "table-layout": e.tableLayout
      }, null, 8, ["columns", "table-layout"]), ja(u, {
        border: e.border,
        "default-sort": e.defaultSort,
        store: e.store,
        "sum-text": e.computedSumText,
        "summary-method": e.summaryMethod
      }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])], 6)], 2)), [[$s, !e.isEmpty], [d, e.handleHeaderFooterMousewheel]]) : za("v-if", !0), e.border || e.isGroup ? (Ca(),
      _a("div", {
        key: 2,
        class: Y(e.ns.e("border-left-patch"))
      }, null, 2)) : za("v-if", !0)], 6), rr(Ma("div", {
      ref: "resizeProxy",
      class: Y(e.ns.e("column-resize-proxy"))
    }, null, 2), [[$s, e.resizeProxyVisible]])], 46, XV)
}
], ["__file", "table.vue"]]);
const ZV = {
  selection: "table-column--selection",
  expand: "table__expand-column"
}
  , eU = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
}
  , tU = {
  selection: {
    renderHeader: ({store: e, column: t})=>bi(AD, {
      disabled: e.states.data.value && 0 === e.states.data.value.length,
      size: e.states.tableSize.value,
      indeterminate: e.states.selection.value.length > 0 && !e.states.isAllSelected.value,
      "onUpdate:modelValue": e.toggleAllSelection,
      modelValue: e.states.isAllSelected.value,
      ariaLabel: t.label
    }),
    renderCell: ({row: e, column: t, store: n, $index: r})=>bi(AD, {
      disabled: !!t.selectable && !t.selectable.call(null, e, r),
      size: n.states.tableSize.value,
      onChange: ()=>{
        n.commit("rowSelectedChanged", e)
      }
      ,
      onClick: e=>e.stopPropagation(),
      modelValue: n.isSelected(e),
      ariaLabel: t.label
    }),
    sortable: !1,
    resizable: !1
  },
  index: {
    renderHeader: ({column: e})=>e.label || "#",
    renderCell({column: e, $index: t}) {
      let n = t + 1;
      const r = e.index;
      return "number" == typeof r ? n = t + r : "function" == typeof r && (n = r(t)),
        bi("div", {}, [n])
    },
    sortable: !1
  },
  expand: {
    renderHeader: ({column: e})=>e.label || "",
    renderCell({row: e, store: t, expanded: n}) {
      const {ns: r} = t
        , o = [r.e("expand-icon")];
      n && o.push(r.em("expand-icon", "expanded"));
      return bi("div", {
        class: o,
        onClick: function(n) {
          n.stopPropagation(),
            t.toggleRowExpansion(e)
        }
      }, {
        default: ()=>[bi(sS, null, {
          default: ()=>[bi(gm)]
        })]
      })
    },
    sortable: !1,
    resizable: !1
  }
};
function nU({row: e, column: t, $index: n}) {
  var r;
  const o = t.property
    , a = o && Xg(e, o).value;
  return t && t.formatter ? t.formatter(e, t, a, n) : (null == (r = null == a ? void 0 : a.toString) ? void 0 : r.call(a)) || ""
}
function rU(e, t) {
  return e.reduce(((e,t)=>(e[t] = t,
    e)), t)
}
function oU(e, t, n) {
  const r = ei()
    , o = Ft("")
    , a = Ft(!1)
    , i = Ft()
    , s = Ft()
    , l = qy("table");
  qn((()=>{
      i.value = e.align ? `is-${e.align}` : null,
        i.value
    }
  )),
    qn((()=>{
        s.value = e.headerAlign ? `is-${e.headerAlign}` : i.value,
          s.value
      }
    ));
  const u = yi((()=>{
      let e = r.vnode.vParent || r.parent;
      for (; e && !e.tableId && !e.columnId; )
        e = e.vnode.vParent || e.parent;
      return e
    }
  ))
    , c = yi((()=>{
      const {store: e} = r.parent;
      if (!e)
        return !1;
      const {treeData: t} = e.states
        , n = t.value;
      return n && Object.keys(n).length > 0
    }
  ))
    , d = Ft(iV(e.width))
    , f = Ft(sV(e.minWidth));
  return {
    columnId: o,
    realAlign: i,
    isSubColumn: a,
    realHeaderAlign: s,
    columnOrTableParent: u,
    setColumnWidth: e=>(d.value && (e.width = d.value),
    f.value && (e.minWidth = f.value),
    !d.value && f.value && (e.width = void 0),
    e.minWidth || (e.minWidth = 80),
      e.realWidth = Number(void 0 === e.width ? e.minWidth : e.width),
      e),
    setColumnForcedProps: e=>{
      const t = e.type
        , n = tU[t] || {};
      Object.keys(n).forEach((t=>{
          const r = n[t];
          "className" !== t && void 0 !== r && (e[t] = r)
        }
      ));
      const r = (e=>ZV[e] || "")(t);
      if (r) {
        const t = `${Vt(l.namespace)}-${r}`;
        e.className = e.className ? `${e.className} ${t}` : t
      }
      return e
    }
    ,
    setColumnRenders: o=>{
      e.renderHeader || "selection" !== o.type && (o.renderHeader = e=>(r.columnConfig.value.label,
        Qr(t, "header", e, (()=>[o.label]))));
      let a = o.renderCell;
      return "expand" === o.type ? (o.renderCell = e=>bi("div", {
        class: "cell"
      }, [a(e)]),
        n.value.renderExpanded = e=>t.default ? t.default(e) : t.default) : (a = a || nU,
          o.renderCell = e=>{
            let i = null;
            if (t.default) {
              const n = t.default(e);
              i = n.some((e=>e.type !== xa)) ? n : a(e)
            } else
              i = a(e);
            const {columns: s} = n.value.store.states
              , u = s.value.findIndex((e=>"default" === e.type))
              , d = function({row: e, treeNode: t, store: n}, r=!1) {
              const {ns: o} = n;
              if (!t)
                return r ? [bi("span", {
                  class: o.e("placeholder")
                })] : null;
              const a = []
                , i = function(r) {
                r.stopPropagation(),
                t.loading || n.loadOrToggle(e)
              };
              if (t.indent && a.push(bi("span", {
                class: o.e("indent"),
                style: {
                  "padding-left": `${t.indent}px`
                }
              })),
              "boolean" != typeof t.expanded || t.noLazyChildren)
                a.push(bi("span", {
                  class: o.e("placeholder")
                }));
              else {
                const e = [o.e("expand-icon"), t.expanded ? o.em("expand-icon", "expanded") : ""];
                let n = gm;
                t.loading && (n = Mm),
                  a.push(bi("div", {
                    class: e,
                    onClick: i
                  }, {
                    default: ()=>[bi(sS, {
                      class: {
                        [o.is("loading")]: t.loading
                      }
                    }, {
                      default: ()=>[bi(n)]
                    })]
                  }))
              }
              return a
            }(e, c.value && e.cellIndex === u)
              , f = {
              class: "cell",
              style: {}
            };
            return o.showOverflowTooltip && (f.class = `${f.class} ${Vt(l.namespace)}-tooltip`,
              f.style = {
                width: (e.column.realWidth || Number(e.column.width)) - 1 + "px"
              }),
              (e=>{
                  function t(e) {
                    var t;
                    "ElTableColumn" === (null == (t = null == e ? void 0 : e.type) ? void 0 : t.name) && (e.vParent = r)
                  }
                  Array.isArray(e) ? e.forEach((e=>t(e))) : t(e)
                }
              )(i),
              bi("div", f, [d, i])
          }
      ),
        o
    }
    ,
    getPropsData: (...t)=>t.reduce(((t,n)=>(Array.isArray(n) && n.forEach((n=>{
        t[n] = e[n]
      }
    )),
      t)), {}),
    getColumnElIndex: (e,t)=>Array.prototype.indexOf.call(e, t),
    updateColumnOrder: ()=>{
      n.value.store.commit("updateColumnOrder", r.columnConfig.value)
    }
  }
}
var aU = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: !1
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: !0
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: {
    type: [Boolean, Object],
    default: void 0
  },
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: !0
  },
  filterClassName: String,
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: ()=>["ascending", "descending", null],
    validator: e=>e.every((e=>["ascending", "descending", null].includes(e)))
  }
};
let iU = 1;
var sU = vr({
  name: "ElTableColumn",
  components: {
    ElCheckbox: AD
  },
  props: aU,
  setup(e, {slots: t}) {
    const n = ei()
      , r = Ft({})
      , o = yi((()=>{
        let e = n.parent;
        for (; e && !e.tableId; )
          e = e.parent;
        return e
      }
    ))
      , {registerNormalWatchers: a, registerComplexWatchers: i} = function(e, t) {
      const n = ei();
      return {
        registerComplexWatchers: ()=>{
          const r = {
            realWidth: "width",
            realMinWidth: "minWidth"
          }
            , o = rU(["fixed"], r);
          Object.keys(o).forEach((o=>{
              const a = r[o];
              p(t, a) && Jn((()=>t[a]), (t=>{
                  let r = t;
                  "width" === a && "realWidth" === o && (r = iV(t)),
                  "minWidth" === a && "realMinWidth" === o && (r = sV(t)),
                    n.columnConfig.value[a] = r,
                    n.columnConfig.value[o] = r;
                  const i = "fixed" === a;
                  e.value.store.scheduleLayout(i)
                }
              ))
            }
          ))
        }
        ,
        registerNormalWatchers: ()=>{
          const e = {
            property: "prop",
            align: "realAlign",
            headerAlign: "realHeaderAlign"
          }
            , r = rU(["label", "filters", "filterMultiple", "filteredValue", "sortable", "index", "formatter", "className", "labelClassName", "filterClassName", "showOverflowTooltip"], e);
          Object.keys(r).forEach((r=>{
              const o = e[r];
              p(t, o) && Jn((()=>t[o]), (e=>{
                  n.columnConfig.value[r] = e
                }
              ))
            }
          ))
        }
      }
    }(o, e)
      , {columnId: s, isSubColumn: l, realHeaderAlign: u, columnOrTableParent: c, setColumnWidth: d, setColumnForcedProps: f, setColumnRenders: h, getPropsData: v, getColumnElIndex: g, realAlign: m, updateColumnOrder: y} = oU(e, t, o)
      , b = c.value;
    s.value = `${b.tableId || b.columnId}_column_${iU++}`,
      Rr((()=>{
          l.value = o.value !== b;
          const t = e.type || "default"
            , c = "" === e.sortable || e.sortable
            , g = Mg(e.showOverflowTooltip) ? b.props.showOverflowTooltip : e.showOverflowTooltip
            , y = {
            ...eU[t],
            id: s.value,
            type: t,
            property: e.prop || e.property,
            align: m,
            headerAlign: u,
            showOverflowTooltip: g,
            filterable: e.filters || e.filterMethod,
            filteredValue: [],
            filterPlacement: "",
            filterClassName: "",
            isColumnGroup: !1,
            isSubColumn: !1,
            filterOpened: !1,
            sortable: c,
            index: e.index,
            rawColumnKey: n.vnode.key
          };
          let w = v(["columnKey", "label", "className", "labelClassName", "type", "renderHeader", "formatter", "fixed", "resizable"], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], ["filterMethod", "filters", "filterMultiple", "filterOpened", "filteredValue", "filterPlacement", "filterClassName"]);
          w = function(e, t) {
            const n = {};
            let r;
            for (r in e)
              n[r] = e[r];
            for (r in t)
              if (p(t, r)) {
                const e = t[r];
                void 0 !== e && (n[r] = e)
              }
            return n
          }(y, w);
          const x = function(...e) {
            return 0 === e.length ? e=>e : 1 === e.length ? e[0] : e.reduce(((e,t)=>(...n)=>e(t(...n))))
          }(h, d, f);
          w = x(w),
            r.value = w,
            a(),
            i()
        }
      )),
      Lr((()=>{
          var e;
          const t = c.value
            , a = l.value ? t.vnode.el.children : null == (e = t.refs.hiddenColumns) ? void 0 : e.children
            , i = ()=>g(a || [], n.vnode.el);
          r.value.getColumnIndex = i;
          i() > -1 && o.value.store.commit("insertColumn", r.value, l.value ? t.columnConfig.value : null, y)
        }
      )),
      Fr((()=>{
          o.value.store.commit("removeColumn", r.value, l.value ? b.columnConfig.value : null, y)
        }
      )),
      n.columnId = s.value,
      n.columnConfig = r
  },
  render() {
    var e, t, n;
    try {
      const r = null == (t = (e = this.$slots).default) ? void 0 : t.call(e, {
        row: {},
        column: {},
        $index: -1
      })
        , o = [];
      if (Array.isArray(r))
        for (const e of r)
          "ElTableColumn" === (null == (n = e.type) ? void 0 : n.name) || 2 & e.shapeFlag ? o.push(e) : e.type === ba && Array.isArray(e.children) && e.children.forEach((e=>{
              1024 === (null == e ? void 0 : e.patchFlag) || b(null == e ? void 0 : e.children) || o.push(e)
            }
          ));
      return bi("div", o)
    } catch (Y_) {
      return bi("div", [])
    }
  }
});
const lU = vy(JV, {
  TableColumn: sU
})
  , uU = my(sU);
var cU = (e=>(e.ASC = "asc",
  e.DESC = "desc",
  e))(cU || {})
  , dU = (e=>(e.CENTER = "center",
  e.RIGHT = "right",
  e))(dU || {})
  , fU = (e=>(e.LEFT = "left",
  e.RIGHT = "right",
  e))(fU || {});
const pU = {
    asc: "desc",
    desc: "asc"
  }
  , hU = Symbol("placeholder")
  , vU = (e,t,n)=>{
    var r;
    const o = {
      flexGrow: 0,
      flexShrink: 0,
      ...n ? {} : {
        flexGrow: e.flexGrow || 0,
        flexShrink: e.flexShrink || 1
      }
    };
    n || (o.flexShrink = 1);
    const a = {
      ...null != (r = e.style) ? r : {},
      ...o,
      flexBasis: "auto",
      width: e.width
    };
    return t || (e.maxWidth && (a.maxWidth = e.maxWidth),
    e.minWidth && (a.minWidth = e.minWidth)),
      a
  }
;
const gU = (e,{mainTableRef: t, leftTableRef: n, rightTableRef: r})=>{
  const o = ei()
    , {emit: a} = o
    , i = Bt(!1)
    , s = Bt(null)
    , l = Ft(e.defaultExpandedRowKeys || [])
    , u = Ft(-1)
    , c = Bt(null)
    , d = Ft({})
    , f = Ft({})
    , p = Bt({})
    , h = Bt({})
    , v = Bt({})
    , g = yi((()=>Vg(e.estimatedRowHeight)));
  const m = ug((()=>{
      var e, a, s, l;
      i.value = !0,
        d.value = {
          ...Vt(d),
          ...Vt(f)
        },
        y(Vt(c), !1),
        f.value = {},
        c.value = null,
      null == (e = t.value) || e.forceUpdate(),
      null == (a = n.value) || a.forceUpdate(),
      null == (s = r.value) || s.forceUpdate(),
      null == (l = o.proxy) || l.$forceUpdate(),
        i.value = !1
    }
  ), 0);
  function y(e, o=!1) {
    Vt(g) && [t, n, r].forEach((t=>{
        const n = Vt(t);
        n && n.resetAfterRowIndex(e, o)
      }
    ))
  }
  return {
    hoveringRowKey: s,
    expandedRowKeys: l,
    lastRenderedRowIndex: u,
    isDynamic: g,
    isResetting: i,
    rowHeights: d,
    resetAfterIndex: y,
    onRowExpanded: function({expanded: t, rowData: n, rowIndex: r, rowKey: o}) {
      var i, s;
      const u = [...Vt(l)]
        , c = u.indexOf(o);
      t ? -1 === c && u.push(o) : c > -1 && u.splice(c, 1),
        l.value = u,
        a("update:expandedRowKeys", u),
      null == (i = e.onRowExpand) || i.call(e, {
        expanded: t,
        rowData: n,
        rowIndex: r,
        rowKey: o
      }),
      null == (s = e.onExpandedRowsChange) || s.call(e, u)
    },
    onRowHovered: function({hovered: e, rowKey: t}) {
      s.value = e ? t : null
    },
    onRowsRendered: function(t) {
      var n;
      null == (n = e.onRowsRendered) || n.call(e, t),
      t.rowCacheEnd > Vt(u) && (u.value = t.rowCacheEnd)
    },
    onRowHeightChange: function({rowKey: e, height: t, rowIndex: n}, r) {
      r ? r === fU.RIGHT ? v.value[e] = t : p.value[e] = t : h.value[e] = t;
      const o = Math.max(...[p, v, h].map((t=>t.value[e] || 0)));
      Vt(d)[e] !== o && (!function(e, t, n) {
        const r = Vt(c);
        (null === r || r > n) && (c.value = n),
          f.value[e] = t
      }(e, o, n),
        m())
    }
  }
}
  , mU = (e,t)=>e + t
  , yU = e=>h(e) ? e.reduce(mU, 0) : e
  , bU = (e,t,n={})=>y(e) ? e(t) : null != e ? e : n
  , wU = e=>(["width", "maxWidth", "minWidth", "height"].forEach((t=>{
    e[t] = om(e[t])
  }
)),
  e)
  , xU = e=>La(e) ? t=>bi(e, t) : e;
function SU(e) {
  const t = Ft()
    , n = Ft()
    , r = Ft()
    , {columns: o, columnsStyles: a, columnsTotalWidth: i, fixedColumnsOnLeft: s, fixedColumnsOnRight: l, hasFixedColumns: u, mainColumns: c, onColumnSorted: d} = function(e, t, n) {
    const r = yi((()=>Vt(t).filter((e=>!e.hidden))))
      , o = yi((()=>Vt(r).filter((e=>"left" === e.fixed || !0 === e.fixed))))
      , a = yi((()=>Vt(r).filter((e=>"right" === e.fixed))))
      , i = yi((()=>Vt(r).filter((e=>!e.fixed))))
      , s = yi((()=>{
        const e = [];
        return Vt(o).forEach((t=>{
            e.push({
              ...t,
              placeholderSign: hU
            })
          }
        )),
          Vt(i).forEach((t=>{
              e.push(t)
            }
          )),
          Vt(a).forEach((t=>{
              e.push({
                ...t,
                placeholderSign: hU
              })
            }
          )),
          e
      }
    ))
      , l = yi((()=>Vt(o).length || Vt(a).length))
      , u = yi((()=>Vt(t).reduce(((t,r)=>(t[r.key] = vU(r, Vt(n), e.fixed),
      t)), {})))
      , c = yi((()=>Vt(r).reduce(((e,t)=>e + t.width), 0)))
      , d = e=>Vt(t).find((t=>t.key === e));
    return {
      columns: t,
      columnsStyles: u,
      columnsTotalWidth: c,
      fixedColumnsOnLeft: o,
      fixedColumnsOnRight: a,
      hasFixedColumns: l,
      mainColumns: s,
      normalColumns: i,
      visibleColumns: r,
      getColumn: d,
      getColumnStyle: e=>Vt(u)[e],
      updateColumnWidth: (e,t)=>{
        e.width = t
      }
      ,
      onColumnSorted: function(t) {
        var n;
        const {key: r} = t.currentTarget.dataset;
        if (!r)
          return;
        const {sortState: o, sortBy: a} = e;
        let i = cU.ASC;
        i = x(o) ? pU[o[r]] : pU[a.order],
        null == (n = e.onColumnSort) || n.call(e, {
          column: d(r),
          key: r,
          order: i
        })
      }
    }
  }(e, Yt(e, "columns"), Yt(e, "fixed"))
    , {scrollTo: f, scrollToLeft: p, scrollToTop: v, scrollToRow: g, onScroll: m, onVerticalScroll: y, scrollPos: b} = ((e,{mainTableRef: t, leftTableRef: n, rightTableRef: r, onMaybeEndReached: o})=>{
      const a = Ft({
        scrollLeft: 0,
        scrollTop: 0
      });
      function i(e) {
        var o, a, i;
        const {scrollTop: s} = e;
        null == (o = t.value) || o.scrollTo(e),
        null == (a = n.value) || a.scrollToTop(s),
        null == (i = r.value) || i.scrollToTop(s)
      }
      function s(e) {
        a.value = e,
          i(e)
      }
      function l(e) {
        a.value.scrollTop = e,
          i(Vt(a))
      }
      return Jn((()=>Vt(a).scrollTop), ((e,t)=>{
          e > t && o()
        }
      )),
        {
          scrollPos: a,
          scrollTo: s,
          scrollToLeft: function(e) {
            var n, r;
            a.value.scrollLeft = e,
            null == (r = null == (n = t.value) ? void 0 : n.scrollTo) || r.call(n, Vt(a))
          },
          scrollToTop: l,
          scrollToRow: function(e, n="auto") {
            var r;
            null == (r = t.value) || r.scrollToRow(e, n)
          },
          onScroll: function(t) {
            var n;
            s(t),
            null == (n = e.onScroll) || n.call(e, t)
          },
          onVerticalScroll: function({scrollTop: e}) {
            const {scrollTop: t} = Vt(a);
            e !== t && l(e)
          }
        }
    }
  )(e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: r,
    onMaybeEndReached: function() {
      const {onEndReached: t} = e;
      if (!t)
        return;
      const {scrollTop: n} = Vt(b)
        , r = Vt(V)
        , o = Vt(U)
        , a = r - (n + o) + e.hScrollbarSize;
      Vt(E) >= 0 && r === n + Vt(B) - Vt(K) && t(a)
    }
  })
    , {expandedRowKeys: w, hoveringRowKey: S, lastRenderedRowIndex: E, isDynamic: A, isResetting: C, rowHeights: k, resetAfterIndex: T, onRowExpanded: D, onRowHeightChange: O, onRowHovered: _, onRowsRendered: R} = gU(e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: r
  })
    , {data: L, depthMap: I} = ((e,{expandedRowKeys: t, lastRenderedRowIndex: n, resetAfterIndex: r})=>{
      const o = Ft({})
        , a = yi((()=>{
          const n = {}
            , {data: r, rowKey: a} = e
            , i = Vt(t);
          if (!i || !i.length)
            return r;
          const s = []
            , l = new Set;
          i.forEach((e=>l.add(e)));
          let u = r.slice();
          for (u.forEach((e=>n[e[a]] = 0)); u.length > 0; ) {
            const e = u.shift();
            s.push(e),
            l.has(e[a]) && Array.isArray(e.children) && e.children.length > 0 && (u = [...e.children, ...u],
              e.children.forEach((t=>n[t[a]] = n[e[a]] + 1)))
          }
          return o.value = n,
            s
        }
      ))
        , i = yi((()=>{
          const {data: t, expandColumnKey: n} = e;
          return n ? Vt(a) : t
        }
      ));
      return Jn(i, ((e,t)=>{
          e !== t && (n.value = -1,
            r(0, !0))
        }
      )),
        {
          data: i,
          depthMap: o
        }
    }
  )(e, {
    expandedRowKeys: w,
    lastRenderedRowIndex: E,
    resetAfterIndex: T
  })
    , {bodyWidth: P, fixedTableHeight: F, mainTableHeight: B, leftTableWidth: N, rightTableWidth: M, headerWidth: j, rowsHeight: V, windowHeight: U, footerHeight: $, emptyStyle: H, rootStyle: z, headerHeight: K} = ((e,{columnsTotalWidth: t, data: n, fixedColumnsOnLeft: r, fixedColumnsOnRight: o})=>{
      const a = yi((()=>{
          const {fixed: n, width: r, vScrollbarSize: o} = e
            , a = r - o;
          return n ? Math.max(Math.round(Vt(t)), a) : a
        }
      ))
        , i = yi((()=>Vt(a) + e.vScrollbarSize))
        , s = yi((()=>{
          const {height: t=0, maxHeight: n=0, footerHeight: r, hScrollbarSize: o} = e;
          if (n > 0) {
            const e = Vt(h)
              , t = Vt(l)
              , a = Vt(p) + e + t + o;
            return Math.min(a, n - r)
          }
          return t - r
        }
      ))
        , l = yi((()=>{
          const {rowHeight: t, estimatedRowHeight: r} = e
            , o = Vt(n);
          return Vg(r) ? o.length * r : o.length * t
        }
      ))
        , u = yi((()=>{
          const {maxHeight: t} = e
            , n = Vt(s);
          if (Vg(t) && t > 0)
            return n;
          const r = Vt(l) + Vt(p) + Vt(h);
          return Math.min(n, r)
        }
      ))
        , c = e=>e.width
        , d = yi((()=>yU(Vt(r).map(c))))
        , f = yi((()=>yU(Vt(o).map(c))))
        , p = yi((()=>yU(e.headerHeight)))
        , h = yi((()=>{
          var t;
          return ((null == (t = e.fixedData) ? void 0 : t.length) || 0) * e.rowHeight
        }
      ))
        , v = yi((()=>Vt(s) - Vt(p) - Vt(h)))
        , g = yi((()=>{
          const {style: t={}, height: n, width: r} = e;
          return wU({
            ...t,
            height: n,
            width: r
          })
        }
      ))
        , m = yi((()=>wU({
        height: e.footerHeight
      })))
        , y = yi((()=>({
        top: om(Vt(p)),
        bottom: om(e.footerHeight),
        width: om(e.width)
      })));
      return {
        bodyWidth: a,
        fixedTableHeight: u,
        mainTableHeight: s,
        leftTableWidth: d,
        rightTableWidth: f,
        headerWidth: i,
        rowsHeight: l,
        windowHeight: v,
        footerHeight: m,
        emptyStyle: y,
        rootStyle: g,
        headerHeight: p
      }
    }
  )(e, {
    columnsTotalWidth: i,
    data: L,
    fixedColumnsOnLeft: s,
    fixedColumnsOnRight: l
  })
    , W = Bt(!1)
    , G = Ft()
    , q = yi((()=>{
      const t = 0 === Vt(L).length;
      return h(e.fixedData) ? 0 === e.fixedData.length && t : t
    }
  ));
  return Jn((()=>e.expandedRowKeys), (e=>w.value = e), {
    deep: !0
  }),
    {
      columns: o,
      containerRef: G,
      mainTableRef: t,
      leftTableRef: n,
      rightTableRef: r,
      isDynamic: A,
      isResetting: C,
      isScrolling: W,
      hoveringRowKey: S,
      hasFixedColumns: u,
      columnsStyles: a,
      columnsTotalWidth: i,
      data: L,
      expandedRowKeys: w,
      depthMap: I,
      fixedColumnsOnLeft: s,
      fixedColumnsOnRight: l,
      mainColumns: c,
      bodyWidth: P,
      emptyStyle: H,
      rootStyle: z,
      headerWidth: j,
      footerHeight: $,
      mainTableHeight: B,
      fixedTableHeight: F,
      leftTableWidth: N,
      rightTableWidth: M,
      showEmpty: q,
      getRowHeight: function(t) {
        const {estimatedRowHeight: n, rowHeight: r, rowKey: o} = e;
        return n ? Vt(k)[Vt(L)[t][o]] || n : r
      },
      onColumnSorted: d,
      onRowHovered: _,
      onRowExpanded: D,
      onRowsRendered: R,
      onRowHeightChange: O,
      scrollTo: f,
      scrollToLeft: p,
      scrollToTop: v,
      scrollToRow: g,
      onScroll: m,
      onVerticalScroll: y
    }
}
const EU = Symbol("tableV2")
  , AU = String
  , CU = {
    type: Array,
    required: !0
  }
  , kU = {
    type: Array
  }
  , TU = {
    ...kU,
    required: !0
  }
  , DU = {
    type: Array,
    default: ()=>[]
  }
  , OU = {
    type: Number,
    required: !0
  }
  , _U = {
    type: [String, Number, Symbol],
    default: "id"
  }
  , RU = {
    type: Object
  }
  , LU = uy({
    class: String,
    columns: CU,
    columnsStyles: {
      type: Object,
      required: !0
    },
    depth: Number,
    expandColumnKey: String,
    estimatedRowHeight: {
      ...qN.estimatedRowHeight,
      default: void 0
    },
    isScrolling: Boolean,
    onRowExpand: {
      type: Function
    },
    onRowHover: {
      type: Function
    },
    onRowHeightChange: {
      type: Function
    },
    rowData: {
      type: Object,
      required: !0
    },
    rowEventHandlers: {
      type: Object
    },
    rowIndex: {
      type: Number,
      required: !0
    },
    rowKey: _U,
    style: {
      type: Object
    }
  })
  , IU = {
    type: Number,
    required: !0
  }
  , PU = uy({
    class: String,
    columns: CU,
    fixedHeaderData: {
      type: Array
    },
    headerData: {
      type: Array,
      required: !0
    },
    headerHeight: {
      type: [Number, Array],
      default: 50
    },
    rowWidth: IU,
    rowHeight: {
      type: Number,
      default: 50
    },
    height: IU,
    width: IU
  })
  , FU = uy({
    columns: CU,
    data: TU,
    fixedData: kU,
    estimatedRowHeight: LU.estimatedRowHeight,
    width: OU,
    height: OU,
    headerWidth: OU,
    headerHeight: PU.headerHeight,
    bodyWidth: OU,
    rowHeight: OU,
    cache: zN.cache,
    useIsScrolling: Boolean,
    scrollbarAlwaysOn: qN.scrollbarAlwaysOn,
    scrollbarStartGap: qN.scrollbarStartGap,
    scrollbarEndGap: qN.scrollbarEndGap,
    class: AU,
    style: RU,
    containerStyle: RU,
    getRowHeight: {
      type: Function,
      required: !0
    },
    rowKey: LU.rowKey,
    onRowsRendered: {
      type: Function
    },
    onScroll: {
      type: Function
    }
  })
  , BU = uy({
    cache: FU.cache,
    estimatedRowHeight: LU.estimatedRowHeight,
    rowKey: _U,
    headerClass: {
      type: [String, Function]
    },
    headerProps: {
      type: [Object, Function]
    },
    headerCellProps: {
      type: [Object, Function]
    },
    headerHeight: PU.headerHeight,
    footerHeight: {
      type: Number,
      default: 0
    },
    rowClass: {
      type: [String, Function]
    },
    rowProps: {
      type: [Object, Function]
    },
    rowHeight: {
      type: Number,
      default: 50
    },
    cellProps: {
      type: [Object, Function]
    },
    columns: CU,
    data: TU,
    dataGetter: {
      type: Function
    },
    fixedData: kU,
    expandColumnKey: LU.expandColumnKey,
    expandedRowKeys: DU,
    defaultExpandedRowKeys: DU,
    class: AU,
    fixed: Boolean,
    style: {
      type: Object
    },
    width: OU,
    height: OU,
    maxHeight: Number,
    useIsScrolling: Boolean,
    indentSize: {
      type: Number,
      default: 12
    },
    iconSize: {
      type: Number,
      default: 12
    },
    hScrollbarSize: qN.hScrollbarSize,
    vScrollbarSize: qN.vScrollbarSize,
    scrollbarAlwaysOn: YN.alwaysOn,
    sortBy: {
      type: Object,
      default: ()=>({})
    },
    sortState: {
      type: Object,
      default: void 0
    },
    onColumnSort: {
      type: Function
    },
    onExpandedRowsChange: {
      type: Function
    },
    onEndReached: {
      type: Function
    },
    onRowExpand: LU.onRowExpand,
    onScroll: FU.onScroll,
    onRowsRendered: FU.onRowsRendered,
    rowEventHandlers: LU.rowEventHandlers
  })
  , NU = (e,{slots: t})=>{
    var n;
    const {cellData: r, style: o} = e
      , a = (null == (n = null == r ? void 0 : r.toString) ? void 0 : n.call(r)) || ""
      , i = Qr(t, "default", e, (()=>[a]));
    return ja("div", {
      class: e.class,
      title: a,
      style: o
    }, [i])
  }
;
NU.displayName = "ElTableV2Cell",
  NU.inheritAttrs = !1;
const MU = (e,{slots: t})=>Qr(t, "default", e, (()=>{
    var t, n;
    return [ja("div", {
      class: e.class,
      title: null == (t = e.column) ? void 0 : t.title
    }, [null == (n = e.column) ? void 0 : n.title])]
  }
));
MU.displayName = "ElTableV2HeaderCell",
  MU.inheritAttrs = !1;
const jU = vr({
  name: "ElTableV2HeaderRow",
  props: uy({
    class: String,
    columns: CU,
    columnsStyles: {
      type: Object,
      required: !0
    },
    headerIndex: Number,
    style: {
      type: Object
    }
  }),
  setup: (e,{slots: t})=>()=>{
    const {columns: n, columnsStyles: r, headerIndex: o, style: a} = e;
    let i = n.map(((e,a)=>t.cell({
      columns: n,
      column: e,
      columnIndex: a,
      headerIndex: o,
      style: r[e.key]
    })));
    return t.header && (i = t.header({
      cells: i.map((e=>h(e) && 1 === e.length ? e[0] : e)),
      columns: n,
      headerIndex: o
    })),
      ja("div", {
        class: e.class,
        style: a,
        role: "row"
      }, [i])
  }
})
  , VU = vr({
  name: "ElTableV2Header",
  props: PU,
  setup(e, {slots: t, expose: n}) {
    const r = qy("table-v2")
      , o = Ft()
      , a = yi((()=>wU({
        width: e.width,
        height: e.height
      })))
      , i = yi((()=>wU({
        width: e.rowWidth,
        height: e.height
      })))
      , s = yi((()=>Gp(Vt(e.headerHeight))))
      , l = ()=>{
        const n = r.e("fixed-header-row")
          , {columns: o, fixedHeaderData: a, rowHeight: i} = e;
        return null == a ? void 0 : a.map(((e,r)=>{
            var a;
            const s = wU({
              height: i,
              width: "100%"
            });
            return null == (a = t.fixed) ? void 0 : a.call(t, {
              class: n,
              columns: o,
              rowData: e,
              rowIndex: -(r + 1),
              style: s
            })
          }
        ))
      }
      , u = ()=>{
        const n = r.e("dynamic-header-row")
          , {columns: o} = e;
        return Vt(s).map(((e,r)=>{
            var a;
            const i = wU({
              width: "100%",
              height: e
            });
            return null == (a = t.dynamic) ? void 0 : a.call(t, {
              class: n,
              columns: o,
              headerIndex: r,
              style: i
            })
          }
        ))
      }
    ;
    return n({
      scrollToLeft: e=>{
        const t = Vt(o);
        hn((()=>{
            (null == t ? void 0 : t.scroll) && t.scroll({
              left: e
            })
          }
        ))
      }
    }),
      ()=>{
        if (!(e.height <= 0))
          return ja("div", {
            ref: o,
            class: e.class,
            style: Vt(a),
            role: "rowgroup"
          }, [ja("div", {
            style: Vt(i),
            class: r.e("header")
          }, [u(), l()])])
      }
  }
})
  , UU = e=>{
  const {isScrolling: t} = jo(EU)
    , n = Ft(!1)
    , r = Ft()
    , o = yi((()=>Vg(e.estimatedRowHeight) && e.rowIndex >= 0))
    , a = yi((()=>{
      const {rowData: t, rowIndex: n, rowKey: r, onRowHover: o} = e
        , a = e.rowEventHandlers || {}
        , i = {};
      return Object.entries(a).forEach((([e,o])=>{
          y(o) && (i[e] = e=>{
              o({
                event: e,
                rowData: t,
                rowIndex: n,
                rowKey: r
              })
            }
          )
        }
      )),
      o && [{
        name: "onMouseleave",
        hovered: !1
      }, {
        name: "onMouseenter",
        hovered: !0
      }].forEach((({name: e, hovered: a})=>{
          const s = i[e];
          i[e] = e=>{
            o({
              event: e,
              hovered: a,
              rowData: t,
              rowIndex: n,
              rowKey: r
            }),
            null == s || s(e)
          }
        }
      )),
        i
    }
  ));
  return Lr((()=>{
      Vt(o) && ((t=!1)=>{
          const o = Vt(r);
          if (!o)
            return;
          const {columns: a, onRowHeightChange: i, rowKey: s, rowIndex: l, style: u} = e
            , {height: c} = o.getBoundingClientRect();
          n.value = !0,
            hn((()=>{
                if (t || c !== Number.parseInt(u.height)) {
                  const e = a[0]
                    , t = (null == e ? void 0 : e.placeholderSign) === hU;
                  null == i || i({
                    rowKey: s,
                    height: c,
                    rowIndex: l
                  }, e && !t && e.fixed)
                }
              }
            ))
        }
      )(!0)
    }
  )),
    {
      isScrolling: t,
      measurable: o,
      measured: n,
      rowRef: r,
      eventHandlers: a,
      onExpand: t=>{
        const {onRowExpand: n, rowData: r, rowIndex: o, rowKey: a} = e;
        null == n || n({
          expanded: t,
          rowData: r,
          rowIndex: o,
          rowKey: a
        })
      }
    }
}
  , $U = vr({
  name: "ElTableV2TableRow",
  props: LU,
  setup(e, {expose: t, slots: n, attrs: r}) {
    const {eventHandlers: o, isScrolling: a, measurable: i, measured: s, rowRef: l, onExpand: u} = UU(e);
    return t({
      onExpand: u
    }),
      ()=>{
        const {columns: t, columnsStyles: c, expandColumnKey: d, depth: f, rowData: p, rowIndex: v, style: g} = e;
        let m = t.map(((e,r)=>{
            const o = h(p.children) && p.children.length > 0 && e.key === d;
            return n.cell({
              column: e,
              columns: t,
              columnIndex: r,
              depth: f,
              style: c[e.key],
              rowData: p,
              rowIndex: v,
              isScrolling: Vt(a),
              expandIconProps: o ? {
                rowData: p,
                rowIndex: v,
                onExpand: u
              } : void 0
            })
          }
        ));
        if (n.row && (m = n.row({
          cells: m.map((e=>h(e) && 1 === e.length ? e[0] : e)),
          style: g,
          columns: t,
          depth: f,
          rowData: p,
          rowIndex: v,
          isScrolling: Vt(a)
        })),
          Vt(i)) {
          const {height: t, ...n} = g || {}
            , a = Vt(s);
          return ja("div", qa({
            ref: l,
            class: e.class,
            style: a ? g : n,
            role: "row"
          }, r, Vt(o)), [m])
        }
        return ja("div", qa(r, {
          ref: l,
          class: e.class,
          style: g,
          role: "row"
        }, Vt(o)), [m])
      }
  }
})
  , HU = e=>{
  const {sortOrder: t} = e;
  return ja(sS, {
    size: 14,
    class: e.class
  }, {
    default: ()=>[t === cU.ASC ? ja(Xm, null, null) : ja(Ym, null, null)]
  })
}
  , zU = e=>{
  const {expanded: t, expandable: n, onExpand: r, style: o, size: a} = e
    , i = {
    onClick: n ? ()=>r(!t) : void 0,
    class: e.class
  };
  return ja(sS, qa(i, {
    size: a,
    style: o
  }), {
    default: ()=>[ja(gm, null, null)]
  })
}
  , KU = vr({
  name: "ElTableV2Grid",
  props: FU,
  setup(e, {slots: t, expose: n}) {
    const {ns: r} = jo(EU)
      , {bodyRef: o, fixedRowHeight: a, gridHeight: i, hasHeader: s, headerRef: l, headerHeight: u, totalHeight: c, forceUpdate: d, itemKey: f, onItemRendered: p, resetAfterRowIndex: h, scrollTo: v, scrollToTop: g, scrollToRow: m} = (e=>{
        const t = Ft()
          , n = Ft()
          , r = yi((()=>{
            const {data: t, rowHeight: n, estimatedRowHeight: r} = e;
            if (!r)
              return t.length * n
          }
        ))
          , o = yi((()=>{
            const {fixedData: t, rowHeight: n} = e;
            return ((null == t ? void 0 : t.length) || 0) * n
          }
        ))
          , a = yi((()=>yU(e.headerHeight)))
          , i = yi((()=>{
            const {height: t} = e;
            return Math.max(0, t - Vt(a) - Vt(o))
          }
        ))
          , s = yi((()=>Vt(a) + Vt(o) > 0));
        return {
          bodyRef: n,
          forceUpdate: function() {
            var e, r;
            null == (e = Vt(n)) || e.$forceUpdate(),
            null == (r = Vt(t)) || r.$forceUpdate()
          },
          fixedRowHeight: o,
          gridHeight: i,
          hasHeader: s,
          headerHeight: a,
          headerRef: t,
          totalHeight: r,
          itemKey: ({data: t, rowIndex: n})=>t[n][e.rowKey],
          onItemRendered: function({rowCacheStart: t, rowCacheEnd: n, rowVisibleStart: r, rowVisibleEnd: o}) {
            var a;
            null == (a = e.onRowsRendered) || a.call(e, {
              rowCacheStart: t,
              rowCacheEnd: n,
              rowVisibleStart: r,
              rowVisibleEnd: o
            })
          },
          resetAfterRowIndex: function(e, t) {
            var r;
            null == (r = n.value) || r.resetAfterRowIndex(e, t)
          },
          scrollTo: function(e, r) {
            const o = Vt(t)
              , a = Vt(n);
            o && a && (x(e) ? (o.scrollToLeft(e.scrollLeft),
              a.scrollTo(e)) : (o.scrollToLeft(e),
              a.scrollTo({
                scrollLeft: e,
                scrollTop: r
              })))
          },
          scrollToTop: function(e) {
            var t;
            null == (t = Vt(n)) || t.scrollTo({
              scrollTop: e
            })
          },
          scrollToRow: function(e, t) {
            var r;
            null == (r = Vt(n)) || r.scrollToItem(e, 1, t)
          }
        }
      }
    )(e);
    n({
      forceUpdate: d,
      totalHeight: c,
      scrollTo: v,
      scrollToTop: g,
      scrollToRow: m,
      resetAfterRowIndex: h
    });
    const y = ()=>e.bodyWidth;
    return ()=>{
      const {cache: n, columns: c, data: d, fixedData: h, useIsScrolling: v, scrollbarAlwaysOn: g, scrollbarEndGap: m, scrollbarStartGap: b, style: w, rowHeight: x, bodyWidth: S, estimatedRowHeight: E, headerWidth: A, height: C, width: k, getRowHeight: T, onScroll: D} = e
        , O = Vg(E)
        , _ = O ? EM : cM
        , R = Vt(u);
      return ja("div", {
        role: "table",
        class: [r.e("table"), e.class],
        style: w
      }, [ja(_, {
        ref: o,
        data: d,
        useIsScrolling: v,
        itemKey: f,
        columnCache: 0,
        columnWidth: O ? y : S,
        totalColumn: 1,
        totalRow: d.length,
        rowCache: n,
        rowHeight: O ? T : x,
        width: k,
        height: Vt(i),
        class: r.e("body"),
        role: "rowgroup",
        scrollbarStartGap: b,
        scrollbarEndGap: m,
        scrollbarAlwaysOn: g,
        onScroll: D,
        onItemRendered: p,
        perfMode: !1
      }, {
        default: e=>{
          var n;
          const r = d[e.rowIndex];
          return null == (n = t.row) ? void 0 : n.call(t, {
            ...e,
            columns: c,
            rowData: r
          })
        }
      }), Vt(s) && ja(VU, {
        ref: l,
        class: r.e("header-wrapper"),
        columns: c,
        headerData: d,
        headerHeight: e.headerHeight,
        fixedHeaderData: h,
        rowWidth: A,
        rowHeight: x,
        width: k,
        height: Math.min(R + Vt(a), C)
      }, {
        dynamic: t.header,
        fixed: t.row
      })])
    }
  }
});
const WU = (e,{slots: t})=>{
    const {mainTableRef: n, ...r} = e;
    return ja(KU, qa({
      ref: n
    }, r), "function" == typeof (o = t) || "[object Object]" === Object.prototype.toString.call(o) && !La(o) ? t : {
      default: ()=>[t]
    });
    var o
  }
;
const GU = (e,{slots: t})=>{
    if (!e.columns.length)
      return;
    const {leftTableRef: n, ...r} = e;
    return ja(KU, qa({
      ref: n
    }, r), "function" == typeof (o = t) || "[object Object]" === Object.prototype.toString.call(o) && !La(o) ? t : {
      default: ()=>[t]
    });
    var o
  }
;
const qU = (e,{slots: t})=>{
    if (!e.columns.length)
      return;
    const {rightTableRef: n, ...r} = e;
    return ja(KU, qa({
      ref: n
    }, r), "function" == typeof (o = t) || "[object Object]" === Object.prototype.toString.call(o) && !La(o) ? t : {
      default: ()=>[t]
    });
    var o
  }
;
const YU = (e,{slots: t})=>{
    const {columns: n, columnsStyles: r, depthMap: o, expandColumnKey: a, expandedRowKeys: i, estimatedRowHeight: s, hasFixedColumns: l, hoveringRowKey: u, rowData: c, rowIndex: d, style: f, isScrolling: p, rowProps: h, rowClass: v, rowKey: g, rowEventHandlers: m, ns: y, onRowHovered: b, onRowExpanded: w} = e
      , x = bU(v, {
      columns: n,
      rowData: c,
      rowIndex: d
    }, "")
      , S = bU(h, {
      columns: n,
      rowData: c,
      rowIndex: d
    })
      , E = c[g]
      , A = o[E] || 0
      , C = Boolean(a)
      , k = d < 0
      , T = {
      ...S,
      columns: n,
      columnsStyles: r,
      class: [y.e("row"), x, {
        [y.e(`row-depth-${A}`)]: C && d >= 0,
        [y.is("expanded")]: C && i.includes(E),
        [y.is("hovered")]: !p && E === u,
        [y.is("fixed")]: !A && k,
        [y.is("customized")]: Boolean(t.row)
      }],
      depth: A,
      expandColumnKey: a,
      estimatedRowHeight: k ? void 0 : s,
      isScrolling: p,
      rowIndex: d,
      rowData: c,
      rowKey: E,
      rowEventHandlers: m,
      style: f
    };
    return ja($U, qa(T, {
      onRowHover: l ? b : void 0,
      onRowExpand: w
    }), "function" == typeof (D = t) || "[object Object]" === Object.prototype.toString.call(D) && !La(D) ? t : {
      default: ()=>[t]
    });
    var D
  }
  , XU = ({columns: e, column: t, columnIndex: n, depth: r, expandIconProps: o, isScrolling: a, rowData: i, rowIndex: s, style: l, expandedRowKeys: u, ns: c, cellProps: d, expandColumnKey: f, indentSize: p, iconSize: h, rowKey: v},{slots: g})=>{
    const m = wU(l);
    if (t.placeholderSign === hU)
      return ja("div", {
        class: c.em("row-cell", "placeholder"),
        style: m
      }, null);
    const {cellRenderer: b, dataKey: w, dataGetter: S} = t
      , E = y(S) ? S({
      columns: e,
      column: t,
      columnIndex: n,
      rowData: i,
      rowIndex: s
    }) : Lp(i, null != w ? w : "")
      , A = bU(d, {
      cellData: E,
      columns: e,
      column: t,
      columnIndex: n,
      rowIndex: s,
      rowData: i
    })
      , C = {
      class: c.e("cell-text"),
      columns: e,
      column: t,
      columnIndex: n,
      cellData: E,
      isScrolling: a,
      rowData: i,
      rowIndex: s
    }
      , k = xU(b)
      , T = k ? k(C) : Qr(g, "default", C, (()=>[ja(NU, C, null)]))
      , D = [c.e("row-cell"), t.class, t.align === dU.CENTER && c.is("align-center"), t.align === dU.RIGHT && c.is("align-right")]
      , O = s >= 0 && f && t.key === f
      , _ = s >= 0 && u.includes(i[v]);
    let R;
    const L = `margin-inline-start: ${r * p}px;`;
    return O && (R = x(o) ? ja(zU, qa(o, {
      class: [c.e("expand-icon"), c.is("expanded", _)],
      size: h,
      expanded: _,
      style: L,
      expandable: !0
    }), null) : ja("div", {
      style: [L, `width: ${h}px; height: ${h}px;`].join(" ")
    }, null)),
      ja("div", qa({
        class: D,
        style: m
      }, A, {
        role: "cell"
      }), [R, T])
  }
;
XU.inheritAttrs = !1;
const QU = ({columns: e, columnsStyles: t, headerIndex: n, style: r, headerClass: o, headerProps: a, ns: i},{slots: s})=>{
    const l = {
      columns: e,
      headerIndex: n
    }
      , u = [i.e("header-row"), bU(o, l, ""), {
      [i.is("customized")]: Boolean(s.header)
    }]
      , c = {
      ...bU(a, l),
      columnsStyles: t,
      class: u,
      columns: e,
      headerIndex: n,
      style: r
    };
    return ja(jU, c, "function" == typeof (d = s) || "[object Object]" === Object.prototype.toString.call(d) && !La(d) ? s : {
      default: ()=>[s]
    });
    var d
  }
  , JU = (e,{slots: t})=>{
    const {column: n, ns: r, style: o, onColumnSorted: a} = e
      , i = wU(o);
    if (n.placeholderSign === hU)
      return ja("div", {
        class: r.em("header-row-cell", "placeholder"),
        style: i
      }, null);
    const {headerCellRenderer: s, headerClass: l, sortable: u} = n
      , c = {
      ...e,
      class: r.e("header-cell-text")
    }
      , d = xU(s)
      , f = d ? d(c) : Qr(t, "default", c, (()=>[ja(MU, c, null)]))
      , {sortBy: p, sortState: h, headerCellProps: v} = e;
    let g, m;
    if (h) {
      const e = h[n.key];
      g = Boolean(pU[e]),
        m = g ? e : cU.ASC
    } else
      g = n.key === p.key,
        m = g ? p.order : cU.ASC;
    const y = [r.e("header-cell"), bU(l, e, ""), n.align === dU.CENTER && r.is("align-center"), n.align === dU.RIGHT && r.is("align-right"), u && r.is("sortable")]
      , b = {
      ...bU(v, e),
      onClick: n.sortable ? a : void 0,
      class: y,
      style: i,
      "data-key": n.key
    };
    return ja("div", qa(b, {
      role: "columnheader"
    }), [f, u && ja(HU, {
      class: [r.e("sort-icon"), g && r.is("sorting")],
      sortOrder: m
    }, null)])
  }
  , ZU = (e,{slots: t})=>{
    var n;
    return ja("div", {
      class: e.class,
      style: e.style
    }, [null == (n = t.default) ? void 0 : n.call(t)])
  }
;
ZU.displayName = "ElTableV2Footer";
const e$ = (e,{slots: t})=>{
    const n = Qr(t, "default", {}, (()=>[ja(RP, null, null)]));
    return ja("div", {
      class: e.class,
      style: e.style
    }, [n])
  }
;
e$.displayName = "ElTableV2Empty";
const t$ = (e,{slots: t})=>{
    var n;
    return ja("div", {
      class: e.class,
      style: e.style
    }, [null == (n = t.default) ? void 0 : n.call(t)])
  }
;
function n$(e) {
  return "function" == typeof e || "[object Object]" === Object.prototype.toString.call(e) && !La(e)
}
t$.displayName = "ElTableV2Overlay";
const r$ = vr({
  name: "ElTableV2",
  props: BU,
  setup(e, {slots: t, expose: n}) {
    const r = qy("table-v2")
      , {columnsStyles: o, fixedColumnsOnLeft: a, fixedColumnsOnRight: i, mainColumns: s, mainTableHeight: l, fixedTableHeight: u, leftTableWidth: c, rightTableWidth: d, data: f, depthMap: p, expandedRowKeys: h, hasFixedColumns: v, hoveringRowKey: g, mainTableRef: m, leftTableRef: y, rightTableRef: b, isDynamic: w, isResetting: x, isScrolling: S, bodyWidth: E, emptyStyle: A, rootStyle: C, headerWidth: k, footerHeight: T, showEmpty: D, scrollTo: O, scrollToLeft: _, scrollToTop: R, scrollToRow: L, getRowHeight: I, onColumnSorted: P, onRowHeightChange: F, onRowHovered: B, onRowExpanded: N, onRowsRendered: M, onScroll: j, onVerticalScroll: V} = SU(e);
    return n({
      scrollTo: O,
      scrollToLeft: _,
      scrollToTop: R,
      scrollToRow: L
    }),
      Mo(EU, {
        ns: r,
        isResetting: x,
        hoveringRowKey: g,
        isScrolling: S
      }),
      ()=>{
        const {cache: n, cellProps: x, estimatedRowHeight: S, expandColumnKey: O, fixedData: _, headerHeight: R, headerClass: L, headerProps: U, headerCellProps: $, sortBy: H, sortState: z, rowHeight: K, rowClass: W, rowEventHandlers: G, rowKey: q, rowProps: Y, scrollbarAlwaysOn: X, indentSize: Q, iconSize: J, useIsScrolling: Z, vScrollbarSize: ee, width: te} = e
          , ne = Vt(f)
          , re = {
          cache: n,
          class: r.e("main"),
          columns: Vt(s),
          data: ne,
          fixedData: _,
          estimatedRowHeight: S,
          bodyWidth: Vt(E) + ee,
          headerHeight: R,
          headerWidth: Vt(k),
          height: Vt(l),
          mainTableRef: m,
          rowKey: q,
          rowHeight: K,
          scrollbarAlwaysOn: X,
          scrollbarStartGap: 2,
          scrollbarEndGap: ee,
          useIsScrolling: Z,
          width: te,
          getRowHeight: I,
          onRowsRendered: M,
          onScroll: j
        }
          , oe = Vt(c)
          , ae = Vt(u)
          , ie = {
          cache: n,
          class: r.e("left"),
          columns: Vt(a),
          data: ne,
          estimatedRowHeight: S,
          leftTableRef: y,
          rowHeight: K,
          bodyWidth: oe,
          headerWidth: oe,
          headerHeight: R,
          height: ae,
          rowKey: q,
          scrollbarAlwaysOn: X,
          scrollbarStartGap: 2,
          scrollbarEndGap: ee,
          useIsScrolling: Z,
          width: oe,
          getRowHeight: I,
          onScroll: V
        }
          , se = Vt(d) + ee
          , le = {
          cache: n,
          class: r.e("right"),
          columns: Vt(i),
          data: ne,
          estimatedRowHeight: S,
          rightTableRef: b,
          rowHeight: K,
          bodyWidth: se,
          headerWidth: se,
          headerHeight: R,
          height: ae,
          rowKey: q,
          scrollbarAlwaysOn: X,
          scrollbarStartGap: 2,
          scrollbarEndGap: ee,
          width: se,
          style: `--${Vt(r.namespace)}-table-scrollbar-size: ${ee}px`,
          useIsScrolling: Z,
          getRowHeight: I,
          onScroll: V
        }
          , ue = Vt(o)
          , ce = {
          ns: r,
          depthMap: Vt(p),
          columnsStyles: ue,
          expandColumnKey: O,
          expandedRowKeys: Vt(h),
          estimatedRowHeight: S,
          hasFixedColumns: Vt(v),
          hoveringRowKey: Vt(g),
          rowProps: Y,
          rowClass: W,
          rowKey: q,
          rowEventHandlers: G,
          onRowHovered: B,
          onRowExpanded: N,
          onRowHeightChange: F
        }
          , de = {
          cellProps: x,
          expandColumnKey: O,
          indentSize: Q,
          iconSize: J,
          rowKey: q,
          expandedRowKeys: Vt(h),
          ns: r
        }
          , fe = {
          ns: r,
          headerClass: L,
          headerProps: U,
          columnsStyles: ue
        }
          , pe = {
          ns: r,
          sortBy: H,
          sortState: z,
          headerCellProps: $,
          onColumnSorted: P
        }
          , he = {
          row: e=>ja(YU, qa(e, ce), {
            row: t.row,
            cell: e=>{
              let n;
              return t.cell ? ja(XU, qa(e, de, {
                style: ue[e.column.key]
              }), n$(n = t.cell(e)) ? n : {
                default: ()=>[n]
              }) : ja(XU, qa(e, de, {
                style: ue[e.column.key]
              }), null)
            }
          }),
          header: e=>ja(QU, qa(e, fe), {
            header: t.header,
            cell: e=>{
              let n;
              return t["header-cell"] ? ja(JU, qa(e, pe, {
                style: ue[e.column.key]
              }), n$(n = t["header-cell"](e)) ? n : {
                default: ()=>[n]
              }) : ja(JU, qa(e, pe, {
                style: ue[e.column.key]
              }), null)
            }
          })
        }
          , ve = [e.class, r.b(), r.e("root"), {
          [r.is("dynamic")]: Vt(w)
        }]
          , ge = {
          class: r.e("footer"),
          style: Vt(T)
        };
        return ja("div", {
          class: ve,
          style: Vt(C)
        }, [ja(WU, re, n$(he) ? he : {
          default: ()=>[he]
        }), ja(GU, ie, n$(he) ? he : {
          default: ()=>[he]
        }), ja(qU, le, n$(he) ? he : {
          default: ()=>[he]
        }), t.footer && ja(ZU, ge, {
          default: t.footer
        }), Vt(D) && ja(e$, {
          class: r.e("empty"),
          style: Vt(A)
        }, {
          default: t.empty
        }), t.overlay && ja(t$, {
          class: r.e("overlay")
        }, {
          default: t.overlay
        })])
      }
  }
})
  , o$ = vr({
  name: "ElAutoResizer",
  props: uy({
    disableWidth: Boolean,
    disableHeight: Boolean,
    onResize: {
      type: Function
    }
  }),
  setup(e, {slots: t}) {
    const n = qy("auto-resizer")
      , {height: r, width: o, sizer: a} = (e=>{
        const t = Ft()
          , n = Ft(0)
          , r = Ft(0);
        let o;
        return Lr((()=>{
            o = Uc(t, (([e])=>{
                const {width: t, height: o} = e.contentRect
                  , {paddingLeft: a, paddingRight: i, paddingTop: s, paddingBottom: l} = getComputedStyle(e.target)
                  , u = Number.parseInt(a) || 0
                  , c = Number.parseInt(i) || 0
                  , d = Number.parseInt(s) || 0
                  , f = Number.parseInt(l) || 0;
                n.value = t - u - c,
                  r.value = o - d - f
              }
            )).stop
          }
        )),
          Fr((()=>{
              null == o || o()
            }
          )),
          Jn([n, r], (([t,n])=>{
              var r;
              null == (r = e.onResize) || r.call(e, {
                width: t,
                height: n
              })
            }
          )),
          {
            sizer: t,
            width: n,
            height: r
          }
      }
    )(e)
      , i = {
      width: "100%",
      height: "100%"
    };
    return ()=>{
      var e;
      return ja("div", {
        ref: a,
        class: n.b(),
        style: i
      }, [null == (e = t.default) ? void 0 : e.call(t, {
        height: r.value,
        width: o.value
      })])
    }
  }
})
  , a$ = vy(r$)
  , i$ = vy(o$)
  , s$ = Symbol("tabsRootContextKey")
  , l$ = uy({
  tabs: {
    type: Array,
    default: ()=>[]
  }
})
  , u$ = "ElTabBar"
  , c$ = vr({
  name: u$
});
var d$ = tS(vr({
  ...c$,
  props: l$,
  setup(e, {expose: t}) {
    const n = e
      , r = ei()
      , o = jo(s$);
    o || Jg(u$, "<el-tabs><el-tab-bar /></el-tabs>");
    const a = qy("tabs")
      , i = Ft()
      , s = Ft()
      , l = ()=>s.value = (()=>{
        let e = 0
          , t = 0;
        const a = ["top", "bottom"].includes(o.props.tabPosition) ? "width" : "height"
          , i = "width" === a ? "x" : "y"
          , s = "x" === i ? "left" : "top";
        return n.tabs.every((o=>{
            var i, l;
            const u = null == (l = null == (i = r.parent) ? void 0 : i.refs) ? void 0 : l[`tab-${o.uid}`];
            if (!u)
              return !1;
            if (!o.active)
              return !0;
            e = u[`offset${qg(s)}`],
              t = u[`client${qg(a)}`];
            const c = window.getComputedStyle(u);
            return "width" === a && (n.tabs.length > 1 && (t -= Number.parseFloat(c.paddingLeft) + Number.parseFloat(c.paddingRight)),
              e += Number.parseFloat(c.paddingLeft)),
              !1
          }
        )),
          {
            [a]: `${t}px`,
            transform: `translate${qg(i)}(${e}px)`
          }
      }
    )();
    return Jn((()=>n.tabs), (async()=>{
        await hn(),
          l()
      }
    ), {
      immediate: !0
    }),
      Uc(i, (()=>l())),
      t({
        ref: i,
        update: l
      }),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "barRef",
          ref: i,
          class: Y([Vt(a).e("active-bar"), Vt(a).is(Vt(o).props.tabPosition)]),
          style: z(s.value)
        }, null, 6))
  }
}), [["__file", "tab-bar.vue"]]);
const f$ = uy({
  panes: {
    type: Array,
    default: ()=>[]
  },
  currentName: {
    type: [String, Number],
    default: ""
  },
  editable: Boolean,
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  stretch: Boolean
})
  , p$ = "ElTabNav"
  , h$ = vr({
  name: p$,
  props: f$,
  emits: {
    tabClick: (e,t,n)=>n instanceof Event,
    tabRemove: (e,t)=>t instanceof Event
  },
  setup(e, {expose: t, emit: n}) {
    const r = ei()
      , o = jo(s$);
    o || Jg(p$, "<el-tabs><tab-nav /></el-tabs>");
    const a = qy("tabs")
      , i = function({document: e=_c}={}) {
      if (!e)
        return Ft("visible");
      const t = Ft(e.visibilityState);
      return Rc(e, "visibilitychange", (()=>{
          t.value = e.visibilityState
        }
      )),
        t
    }()
      , s = function({window: e=Oc}={}) {
      if (!e)
        return Ft(!1);
      const t = Ft(e.document.hasFocus());
      return Rc(e, "blur", (()=>{
          t.value = !1
        }
      )),
        Rc(e, "focus", (()=>{
            t.value = !0
          }
        )),
        t
    }()
      , l = Ft()
      , u = Ft()
      , c = Ft()
      , d = Ft()
      , f = Ft(!1)
      , p = Ft(0)
      , h = Ft(!1)
      , v = Ft(!0)
      , g = yi((()=>["top", "bottom"].includes(o.props.tabPosition) ? "width" : "height"))
      , m = yi((()=>({
      transform: `translate${"width" === g.value ? "X" : "Y"}(-${p.value}px)`
    })))
      , y = ()=>{
      if (!l.value)
        return;
      const e = l.value[`offset${qg(g.value)}`]
        , t = p.value;
      if (!t)
        return;
      const n = t > e ? t - e : 0;
      p.value = n
    }
      , b = ()=>{
      if (!l.value || !u.value)
        return;
      const e = u.value[`offset${qg(g.value)}`]
        , t = l.value[`offset${qg(g.value)}`]
        , n = p.value;
      if (e - n <= t)
        return;
      const r = e - n > 2 * t ? n + t : e - t;
      p.value = r
    }
      , w = async()=>{
      const e = u.value;
      if (!(f.value && c.value && l.value && e))
        return;
      await hn();
      const t = c.value.querySelector(".is-active");
      if (!t)
        return;
      const n = l.value
        , r = ["top", "bottom"].includes(o.props.tabPosition)
        , a = t.getBoundingClientRect()
        , i = n.getBoundingClientRect()
        , s = r ? e.offsetWidth - i.width : e.offsetHeight - i.height
        , d = p.value;
      let h = d;
      r ? (a.left < i.left && (h = d - (i.left - a.left)),
      a.right > i.right && (h = d + a.right - i.right)) : (a.top < i.top && (h = d - (i.top - a.top)),
      a.bottom > i.bottom && (h = d + (a.bottom - i.bottom))),
        h = Math.max(h, 0),
        p.value = Math.min(h, s)
    }
      , x = ()=>{
      var t;
      if (!u.value || !l.value)
        return;
      e.stretch && (null == (t = d.value) || t.update());
      const n = u.value[`offset${qg(g.value)}`]
        , r = l.value[`offset${qg(g.value)}`]
        , o = p.value;
      r < n ? (f.value = f.value || {},
        f.value.prev = o,
        f.value.next = o + r < n,
      n - o < r && (p.value = n - r)) : (f.value = !1,
      o > 0 && (p.value = 0))
    }
      , S = e=>{
      const t = e.code
        , {up: n, down: r, left: o, right: a} = by;
      if (![n, r, o, a].includes(t))
        return;
      const i = Array.from(e.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"))
        , s = i.indexOf(e.target);
      let l;
      l = t === o || t === n ? 0 === s ? i.length - 1 : s - 1 : s < i.length - 1 ? s + 1 : 0,
        i[l].focus({
          preventScroll: !0
        }),
        i[l].click(),
        E()
    }
      , E = ()=>{
      v.value && (h.value = !0)
    }
      , A = ()=>h.value = !1;
    return Jn(i, (e=>{
        "hidden" === e ? v.value = !1 : "visible" === e && setTimeout((()=>v.value = !0), 50)
      }
    )),
      Jn(s, (e=>{
          e ? setTimeout((()=>v.value = !0), 50) : v.value = !1
        }
      )),
      Uc(c, x),
      Lr((()=>setTimeout((()=>w()), 0))),
      Pr((()=>x())),
      t({
        scrollToActiveTab: w,
        removeFocus: A
      }),
      Jn((()=>e.panes), (()=>r.update()), {
        flush: "post",
        deep: !0
      }),
      ()=>{
        const t = f.value ? [ja("span", {
          class: [a.e("nav-prev"), a.is("disabled", !f.value.prev)],
          onClick: y
        }, [ja(sS, null, {
          default: ()=>[ja(vm, null, null)]
        })]), ja("span", {
          class: [a.e("nav-next"), a.is("disabled", !f.value.next)],
          onClick: b
        }, [ja(sS, null, {
          default: ()=>[ja(gm, null, null)]
        })])] : null
          , r = e.panes.map(((t,r)=>{
            var i, s, l, u;
            const c = t.uid
              , d = t.props.disabled
              , f = null != (s = null != (i = t.props.name) ? i : t.index) ? s : `${r}`
              , p = !d && (t.isClosable || e.editable);
            t.index = `${r}`;
            const v = p ? ja(sS, {
              class: "is-icon-close",
              onClick: e=>n("tabRemove", t, e)
            }, {
              default: ()=>[ja(Dm, null, null)]
            }) : null
              , g = (null == (u = (l = t.slots).label) ? void 0 : u.call(l)) || t.props.label
              , m = !d && t.active ? 0 : -1;
            return ja("div", {
              ref: `tab-${c}`,
              class: [a.e("item"), a.is(o.props.tabPosition), a.is("active", t.active), a.is("disabled", d), a.is("closable", p), a.is("focus", h.value)],
              id: `tab-${f}`,
              key: `tab-${c}`,
              "aria-controls": `pane-${f}`,
              role: "tab",
              "aria-selected": t.active,
              tabindex: m,
              onFocus: ()=>E(),
              onBlur: ()=>A(),
              onClick: e=>{
                A(),
                  n("tabClick", t, f, e)
              }
              ,
              onKeydown: e=>{
                !p || e.code !== by.delete && e.code !== by.backspace || n("tabRemove", t, e)
              }
            }, [g, v])
          }
        ));
        return ja("div", {
          ref: c,
          class: [a.e("nav-wrap"), a.is("scrollable", !!f.value), a.is(o.props.tabPosition)]
        }, [t, ja("div", {
          class: a.e("nav-scroll"),
          ref: l
        }, [ja("div", {
          class: [a.e("nav"), a.is(o.props.tabPosition), a.is("stretch", e.stretch && ["top", "bottom"].includes(o.props.tabPosition))],
          ref: u,
          style: m.value,
          role: "tablist",
          onKeydown: S
        }, [e.type ? null : ja(d$, {
          ref: d,
          tabs: [...e.panes]
        }, null), r])])])
      }
  }
})
  , v$ = uy({
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  closable: Boolean,
  addable: Boolean,
  modelValue: {
    type: [String, Number]
  },
  editable: Boolean,
  tabPosition: {
    type: String,
    values: ["top", "right", "bottom", "left"],
    default: "top"
  },
  beforeLeave: {
    type: Function,
    default: ()=>!0
  },
  stretch: Boolean
})
  , g$ = e=>b(e) || Vg(e)
  , m$ = {
  [xy]: e=>g$(e),
  tabClick: (e,t)=>t instanceof Event,
  tabChange: e=>g$(e),
  edit: (e,t)=>["remove", "add"].includes(t),
  tabRemove: e=>g$(e),
  tabAdd: ()=>!0
}
  , y$ = vr({
  name: "ElTabs",
  props: v$,
  emits: m$,
  setup(e, {emit: t, slots: n, expose: r}) {
    var o;
    const a = qy("tabs")
      , {children: i, addChild: s, removeChild: l} = Vx(ei(), "ElTabPane")
      , u = Ft()
      , c = Ft(null != (o = e.modelValue) ? o : "0")
      , d = async(n,r=!1)=>{
        var o, a, i;
        if (c.value !== n && !Mg(n))
          try {
            !1 !== await (null == (o = e.beforeLeave) ? void 0 : o.call(e, n, c.value)) && (c.value = n,
            r && (t(xy, n),
              t("tabChange", n)),
            null == (i = null == (a = u.value) ? void 0 : a.removeFocus) || i.call(a))
          } catch (Y_) {}
      }
      , f = (e,n,r)=>{
        e.props.disabled || (d(n, !0),
          t("tabClick", e, r))
      }
      , p = (e,n)=>{
        e.props.disabled || Mg(e.props.name) || (n.stopPropagation(),
          t("edit", e.props.name, "remove"),
          t("tabRemove", e.props.name))
      }
      , h = ()=>{
        t("edit", void 0, "add"),
          t("tabAdd")
      }
    ;
    return Jn((()=>e.modelValue), (e=>d(e))),
      Jn(c, (async()=>{
          var e;
          await hn(),
          null == (e = u.value) || e.scrollToActiveTab()
        }
      )),
      Mo(s$, {
        props: e,
        currentName: c,
        registerPane: s,
        unregisterPane: l
      }),
      r({
        currentName: c
      }),
      ()=>{
        const t = n["add-icon"]
          , r = e.editable || e.addable ? ja("span", {
          class: a.e("new-tab"),
          tabindex: "0",
          onClick: h,
          onKeydown: e=>{
            e.code === by.enter && h()
          }
        }, [t ? Qr(n, "add-icon") : ja(sS, {
          class: a.is("icon-plus")
        }, {
          default: ()=>[ja(Hm, null, null)]
        })]) : null
          , o = ja("div", {
          class: [a.e("header"), a.is(e.tabPosition)]
        }, [r, ja(h$, {
          ref: u,
          currentName: c.value,
          editable: e.editable,
          type: e.type,
          panes: i.value,
          stretch: e.stretch,
          onTabClick: f,
          onTabRemove: p
        }, null)])
          , s = ja("div", {
          class: a.e("content")
        }, [Qr(n, "default")]);
        return ja("div", {
          class: [a.b(), a.m(e.tabPosition), {
            [a.m("card")]: "card" === e.type,
            [a.m("border-card")]: "border-card" === e.type
          }]
        }, [..."bottom" !== e.tabPosition ? [o, s] : [s, o]])
      }
  }
})
  , b$ = uy({
  label: {
    type: String,
    default: ""
  },
  name: {
    type: [String, Number]
  },
  closable: Boolean,
  disabled: Boolean,
  lazy: Boolean
})
  , w$ = ["id", "aria-hidden", "aria-labelledby"]
  , x$ = "ElTabPane"
  , S$ = vr({
  name: x$
});
var E$ = tS(vr({
  ...S$,
  props: b$,
  setup(e) {
    const t = e
      , n = ei()
      , r = po()
      , o = jo(s$);
    o || Jg(x$, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
    const a = qy("tab-pane")
      , i = Ft()
      , s = yi((()=>t.closable || o.props.closable))
      , l = gc((()=>{
        var e;
        return o.currentName.value === (null != (e = t.name) ? e : i.value)
      }
    ))
      , u = Ft(l.value)
      , c = yi((()=>{
        var e;
        return null != (e = t.name) ? e : i.value
      }
    ))
      , d = gc((()=>!t.lazy || u.value || l.value));
    Jn(l, (e=>{
        e && (u.value = !0)
      }
    ));
    const f = bt({
      uid: n.uid,
      slots: r,
      props: t,
      paneName: c,
      active: l,
      index: i,
      isClosable: s
    });
    return Lr((()=>{
        o.registerPane(f)
      }
    )),
      Br((()=>{
          o.unregisterPane(f.uid)
        }
      )),
      (e,t)=>Vt(d) ? rr((Ca(),
        _a("div", {
          key: 0,
          id: `pane-${Vt(c)}`,
          class: Y(Vt(a).b()),
          role: "tabpanel",
          "aria-hidden": !Vt(l),
          "aria-labelledby": `tab-${Vt(c)}`
        }, [Qr(e.$slots, "default")], 10, w$)), [[$s, Vt(l)]]) : za("v-if", !0)
  }
}), [["__file", "tab-pane.vue"]]);
const A$ = vy(y$, {
  TabPane: E$
})
  , C$ = my(E$)
  , k$ = uy({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger", ""],
    default: ""
  },
  size: {
    type: String,
    values: Cy,
    default: ""
  },
  truncated: {
    type: Boolean
  },
  lineClamp: {
    type: [String, Number]
  },
  tag: {
    type: String,
    default: "span"
  }
})
  , T$ = vr({
  name: "ElText"
});
const D$ = vy(tS(vr({
  ...T$,
  props: k$,
  setup(e) {
    const t = e
      , n = hS()
      , r = qy("text")
      , o = yi((()=>[r.b(), r.m(t.type), r.m(n.value), r.is("truncated", t.truncated), r.is("line-clamp", !Mg(t.lineClamp))]));
    return (e,t)=>(Ca(),
      Ra(Kr(e.tag), {
        class: Y(Vt(o)),
        style: z({
          "-webkit-line-clamp": e.lineClamp
        })
      }, {
        default: Fn((()=>[Qr(e.$slots, "default")])),
        _: 3
      }, 8, ["class", "style"]))
  }
}), [["__file", "text.vue"]]))
  , O$ = uy({
  format: {
    type: String,
    default: "HH:mm"
  },
  modelValue: String,
  disabled: Boolean,
  editable: {
    type: Boolean,
    default: !0
  },
  effect: {
    type: String,
    default: "light"
  },
  clearable: {
    type: Boolean,
    default: !0
  },
  size: Ux,
  placeholder: String,
  start: {
    type: String,
    default: "09:00"
  },
  end: {
    type: String,
    default: "18:00"
  },
  step: {
    type: String,
    default: "00:30"
  },
  minTime: String,
  maxTime: String,
  name: String,
  prefixIcon: {
    type: [String, Object],
    default: ()=>Tm
  },
  clearIcon: {
    type: [String, Object],
    default: ()=>km
  }
})
  , _$ = e=>{
  const t = (e || "").split(":");
  if (t.length >= 2) {
    let n = Number.parseInt(t[0], 10);
    const r = Number.parseInt(t[1], 10)
      , o = e.toUpperCase();
    return o.includes("AM") && 12 === n ? n = 0 : o.includes("PM") && 12 !== n && (n += 12),
      {
        hours: n,
        minutes: r
      }
  }
  return null
}
  , R$ = (e,t)=>{
  const n = _$(e);
  if (!n)
    return -1;
  const r = _$(t);
  if (!r)
    return -1;
  const o = n.minutes + 60 * n.hours
    , a = r.minutes + 60 * r.hours;
  return o === a ? 0 : o > a ? 1 : -1
}
  , L$ = e=>`${e}`.padStart(2, "0")
  , I$ = e=>`${L$(e.hours)}:${L$(e.minutes)}`
  , P$ = (e,t)=>{
  const n = _$(e);
  if (!n)
    return "";
  const r = _$(t);
  if (!r)
    return "";
  const o = {
    hours: n.hours,
    minutes: n.minutes
  };
  return o.minutes += r.minutes,
    o.hours += r.hours,
    o.hours += Math.floor(o.minutes / 60),
    o.minutes = o.minutes % 60,
    I$(o)
}
  , F$ = vr({
  name: "ElTimeSelect"
});
var B$ = tS(vr({
  ...F$,
  props: O$,
  emits: ["change", "blur", "focus", "update:modelValue"],
  setup(e, {expose: t}) {
    const n = e;
    JC.extend(ek);
    const {Option: r} = nB
      , o = qy("input")
      , a = Ft()
      , i = vS()
      , {lang: s} = Hy()
      , l = yi((()=>n.modelValue))
      , u = yi((()=>{
        const e = _$(n.start);
        return e ? I$(e) : null
      }
    ))
      , c = yi((()=>{
        const e = _$(n.end);
        return e ? I$(e) : null
      }
    ))
      , d = yi((()=>{
        const e = _$(n.step);
        return e ? I$(e) : null
      }
    ))
      , f = yi((()=>{
        const e = _$(n.minTime || "");
        return e ? I$(e) : null
      }
    ))
      , p = yi((()=>{
        const e = _$(n.maxTime || "");
        return e ? I$(e) : null
      }
    ))
      , h = yi((()=>{
        const e = [];
        if (n.start && n.end && n.step) {
          let t, r = u.value;
          for (; r && c.value && R$(r, c.value) <= 0; )
            t = JC(r, "HH:mm").locale(s.value).format(n.format),
              e.push({
                value: t,
                disabled: R$(r, f.value || "-1:-1") <= 0 || R$(r, p.value || "100:100") >= 0
              }),
              r = P$(r, d.value)
        }
        return e
      }
    ));
    return t({
      blur: ()=>{
        var e, t;
        null == (t = null == (e = a.value) ? void 0 : e.blur) || t.call(e)
      }
      ,
      focus: ()=>{
        var e, t;
        null == (t = null == (e = a.value) ? void 0 : e.focus) || t.call(e)
      }
    }),
      (e,t)=>(Ca(),
        Ra(Vt(nB), {
          ref_key: "select",
          ref: a,
          "model-value": Vt(l),
          disabled: Vt(i),
          clearable: e.clearable,
          "clear-icon": e.clearIcon,
          size: e.size,
          effect: e.effect,
          placeholder: e.placeholder,
          "default-first-option": "",
          filterable: e.editable,
          "onUpdate:modelValue": t[0] || (t[0] = t=>e.$emit("update:modelValue", t)),
          onChange: t[1] || (t[1] = t=>e.$emit("change", t)),
          onBlur: t[2] || (t[2] = t=>e.$emit("blur", t)),
          onFocus: t[3] || (t[3] = t=>e.$emit("focus", t))
        }, {
          prefix: Fn((()=>[e.prefixIcon ? (Ca(),
            Ra(Vt(sS), {
              key: 0,
              class: Y(Vt(o).e("prefix-icon"))
            }, {
              default: Fn((()=>[(Ca(),
                Ra(Kr(e.prefixIcon)))])),
              _: 1
            }, 8, ["class"])) : za("v-if", !0)])),
          default: Fn((()=>[(Ca(!0),
            _a(ba, null, Yr(Vt(h), (e=>(Ca(),
              Ra(Vt(r), {
                key: e.value,
                label: e.value,
                value: e.value,
                disabled: e.disabled
              }, null, 8, ["label", "value", "disabled"])))), 128))])),
          _: 1
        }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable"]))
  }
}), [["__file", "time-select.vue"]]);
B$.install = e=>{
  e.component(B$.name, B$)
}
;
const N$ = B$
  , M$ = vr({
  name: "ElTimeline",
  setup(e, {slots: t}) {
    const n = qy("timeline");
    return Mo("timeline", t),
      ()=>bi("ul", {
        class: [n.b()]
      }, [Qr(t, "default")])
  }
})
  , j$ = uy({
  timestamp: {
    type: String,
    default: ""
  },
  hideTimestamp: {
    type: Boolean,
    default: !1
  },
  center: {
    type: Boolean,
    default: !1
  },
  placement: {
    type: String,
    values: ["top", "bottom"],
    default: "bottom"
  },
  type: {
    type: String,
    values: ["primary", "success", "warning", "danger", "info"],
    default: ""
  },
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: ["normal", "large"],
    default: "normal"
  },
  icon: {
    type: cy
  },
  hollow: {
    type: Boolean,
    default: !1
  }
})
  , V$ = vr({
  name: "ElTimelineItem"
});
var U$ = tS(vr({
  ...V$,
  props: j$,
  setup(e) {
    const t = e
      , n = qy("timeline-item")
      , r = yi((()=>[n.e("node"), n.em("node", t.size || ""), n.em("node", t.type || ""), n.is("hollow", t.hollow)]));
    return (e,t)=>(Ca(),
      _a("li", {
        class: Y([Vt(n).b(), {
          [Vt(n).e("center")]: e.center
        }])
      }, [Ma("div", {
        class: Y(Vt(n).e("tail"))
      }, null, 2), e.$slots.dot ? za("v-if", !0) : (Ca(),
        _a("div", {
          key: 0,
          class: Y(Vt(r)),
          style: z({
            backgroundColor: e.color
          })
        }, [e.icon ? (Ca(),
          Ra(Vt(sS), {
            key: 0,
            class: Y(Vt(n).e("icon"))
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(e.icon)))])),
            _: 1
          }, 8, ["class"])) : za("v-if", !0)], 6)), e.$slots.dot ? (Ca(),
        _a("div", {
          key: 1,
          class: Y(Vt(n).e("dot"))
        }, [Qr(e.$slots, "dot")], 2)) : za("v-if", !0), Ma("div", {
        class: Y(Vt(n).e("wrapper"))
      }, [e.hideTimestamp || "top" !== e.placement ? za("v-if", !0) : (Ca(),
        _a("div", {
          key: 0,
          class: Y([Vt(n).e("timestamp"), Vt(n).is("top")])
        }, te(e.timestamp), 3)), Ma("div", {
        class: Y(Vt(n).e("content"))
      }, [Qr(e.$slots, "default")], 2), e.hideTimestamp || "bottom" !== e.placement ? za("v-if", !0) : (Ca(),
        _a("div", {
          key: 1,
          class: Y([Vt(n).e("timestamp"), Vt(n).is("bottom")])
        }, te(e.timestamp), 3))], 2)], 2))
  }
}), [["__file", "timeline-item.vue"]]);
const $$ = vy(M$, {
  TimelineItem: U$
})
  , H$ = my(U$)
  , z$ = uy({
  nowrap: Boolean
});
var K$ = (e=>(e.top = "top",
  e.bottom = "bottom",
  e.left = "left",
  e.right = "right",
  e))(K$ || {});
const W$ = Object.values(K$)
  , G$ = uy({
  width: {
    type: Number,
    default: 10
  },
  height: {
    type: Number,
    default: 10
  },
  style: {
    type: Object,
    default: null
  }
})
  , q$ = uy({
  side: {
    type: String,
    values: W$,
    required: !0
  }
})
  , Y$ = uy({
  ariaLabel: String,
  arrowPadding: {
    type: Number,
    default: 5
  },
  effect: {
    type: String,
    default: ""
  },
  contentClass: String,
  placement: {
    type: String,
    values: ["top-start", "top-end", "top", "bottom-start", "bottom-end", "bottom", "left-start", "left-end", "left", "right-start", "right-end", "right"],
    default: "bottom"
  },
  reference: {
    type: Object,
    default: null
  },
  offset: {
    type: Number,
    default: 8
  },
  strategy: {
    type: String,
    values: ["absolute", "fixed"],
    default: "absolute"
  },
  showArrow: {
    type: Boolean,
    default: !1
  }
})
  , X$ = uy({
  delayDuration: {
    type: Number,
    default: 300
  },
  defaultOpen: Boolean,
  open: {
    type: Boolean,
    default: void 0
  },
  onOpenChange: {
    type: Function
  },
  "onUpdate:open": {
    type: Function
  }
})
  , Q$ = {
  type: Function
}
  , J$ = uy({
  onBlur: Q$,
  onClick: Q$,
  onFocus: Q$,
  onMouseDown: Q$,
  onMouseEnter: Q$,
  onMouseLeave: Q$
})
  , Z$ = uy({
  ...X$,
  ...G$,
  ...J$,
  ...Y$,
  alwaysOn: Boolean,
  fullTransition: Boolean,
  transitionProps: {
    type: Object,
    default: null
  },
  teleported: Boolean,
  to: {
    type: String,
    default: "body"
  }
})
  , eH = Symbol("tooltipV2")
  , tH = Symbol("tooltipV2Content")
  , nH = "tooltip_v2.open"
  , rH = vr({
  name: "ElTooltipV2Root"
});
var oH = tS(vr({
  ...rH,
  props: X$,
  setup(e, {expose: t}) {
    const n = e
      , r = Ft(n.defaultOpen)
      , o = Ft(null)
      , a = yi({
        get: ()=>Hg(n.open) ? r.value : n.open,
        set: e=>{
          var t;
          r.value = e,
          null == (t = n["onUpdate:open"]) || t.call(n, e)
        }
      })
      , i = yi((()=>Vg(n.delayDuration) && n.delayDuration > 0))
      , {start: s, stop: l} = Tc((()=>{
          a.value = !0
        }
      ), yi((()=>n.delayDuration)), {
        immediate: !1
      })
      , u = qy("tooltip-v2")
      , c = Cw()
      , d = ()=>{
        l(),
          a.value = !0
      }
      , f = d
      , p = ()=>{
        l(),
          a.value = !1
      }
    ;
    return Jn(a, (e=>{
        var t;
        e && (document.dispatchEvent(new CustomEvent(nH)),
          f()),
        null == (t = n.onOpenChange) || t.call(n, e)
      }
    )),
      Lr((()=>{
          document.addEventListener(nH, p)
        }
      )),
      Fr((()=>{
          l(),
            document.removeEventListener(nH, p)
        }
      )),
      Mo(eH, {
        contentId: c,
        triggerRef: o,
        ns: u,
        onClose: p,
        onDelayOpen: ()=>{
          Vt(i) ? s() : d()
        }
        ,
        onOpen: f
      }),
      t({
        onOpen: f,
        onClose: p
      }),
      (e,t)=>Qr(e.$slots, "default", {
        open: Vt(a)
      })
  }
}), [["__file", "root.vue"]]);
const aH = vr({
  name: "ElTooltipV2Arrow"
});
var iH = tS(vr({
  ...aH,
  props: {
    ...G$,
    ...q$
  },
  setup(e) {
    const t = e
      , {ns: n} = jo(eH)
      , {arrowRef: r} = jo(tH)
      , o = yi((()=>{
        const {style: e, width: r, height: o} = t
          , a = n.namespace.value;
        return {
          [`--${a}-tooltip-v2-arrow-width`]: `${r}px`,
          [`--${a}-tooltip-v2-arrow-height`]: `${o}px`,
          [`--${a}-tooltip-v2-arrow-border-width`]: r / 2 + "px",
          [`--${a}-tooltip-v2-arrow-cover-width`]: r / 2 - 1,
          ...e || {}
        }
      }
    ));
    return (e,t)=>(Ca(),
      _a("span", {
        ref_key: "arrowRef",
        ref: r,
        style: z(Vt(o)),
        class: Y(Vt(n).e("arrow"))
      }, null, 6))
  }
}), [["__file", "arrow.vue"]]);
const sH = uy({
  style: {
    type: [String, Object, Array],
    default: ()=>({})
  }
})
  , lH = vr({
  name: "ElVisuallyHidden"
});
var uH = tS(vr({
  ...lH,
  props: sH,
  setup(e) {
    const t = e
      , n = yi((()=>[t.style, {
      position: "absolute",
      border: 0,
      width: 1,
      height: 1,
      padding: 0,
      margin: -1,
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      wordWrap: "normal"
    }]));
    return (e,t)=>(Ca(),
      _a("span", qa(e.$attrs, {
        style: Vt(n)
      }), [Qr(e.$slots, "default")], 16))
  }
}), [["__file", "visual-hidden.vue"]]);
const cH = ["data-side"]
  , dH = vr({
  name: "ElTooltipV2Content"
});
var fH = tS(vr({
  ...dH,
  props: {
    ...Y$,
    ...z$
  },
  setup(e) {
    const t = e
      , {triggerRef: n, contentId: r} = jo(eH)
      , o = Ft(t.placement)
      , a = Ft(t.strategy)
      , i = Ft(null)
      , {referenceRef: s, contentRef: l, middlewareData: u, x: c, y: d, update: f} = jx({
      placement: o,
      strategy: a,
      middleware: yi((()=>{
          const e = [tx(t.offset)];
          return t.showArrow && e.push((({arrowRef: e, padding: t})=>({
            name: "arrow",
            options: {
              element: e,
              padding: t
            },
            fn(n) {
              const r = Vt(e);
              return r ? Yw({
                element: r,
                padding: t
              }).fn(n) : {}
            }
          }))({
            arrowRef: i
          })),
            e
        }
      ))
    })
      , p = Bw().nextZIndex()
      , h = qy("tooltip-v2")
      , v = yi((()=>o.value.split("-")[0]))
      , g = yi((()=>({
      position: Vt(a),
      top: `${Vt(d) || 0}px`,
      left: `${Vt(c) || 0}px`,
      zIndex: p
    })))
      , m = yi((()=>{
        if (!t.showArrow)
          return {};
        const {arrow: e} = Vt(u);
        return {
          [`--${h.namespace.value}-tooltip-v2-arrow-x`]: `${null == e ? void 0 : e.x}px` || "",
          [`--${h.namespace.value}-tooltip-v2-arrow-y`]: `${null == e ? void 0 : e.y}px` || ""
        }
      }
    ))
      , y = yi((()=>[h.e("content"), h.is("dark", "dark" === t.effect), h.is(Vt(a)), t.contentClass]));
    return Jn(i, (()=>f())),
      Jn((()=>t.placement), (e=>o.value = e)),
      Lr((()=>{
          Jn((()=>t.reference || n.value), (e=>{
              s.value = e || void 0
            }
          ), {
            immediate: !0
          })
        }
      )),
      Mo(tH, {
        arrowRef: i
      }),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "contentRef",
          ref: l,
          style: z(Vt(g)),
          "data-tooltip-v2-root": ""
        }, [e.nowrap ? za("v-if", !0) : (Ca(),
          _a("div", {
            key: 0,
            "data-side": Vt(v),
            class: Y(Vt(y))
          }, [Qr(e.$slots, "default", {
            contentStyle: Vt(g),
            contentClass: Vt(y)
          }), ja(Vt(uH), {
            id: Vt(r),
            role: "tooltip"
          }, {
            default: Fn((()=>[e.ariaLabel ? (Ca(),
              _a(ba, {
                key: 0
              }, [$a(te(e.ariaLabel), 1)], 64)) : Qr(e.$slots, "default", {
              key: 1
            })])),
            _: 3
          }, 8, ["id"]), Qr(e.$slots, "arrow", {
            style: z(Vt(m)),
            side: Vt(v)
          })], 10, cH))], 4))
  }
}), [["__file", "content.vue"]]);
var pH = vr({
  props: uy({
    setRef: {
      type: Function,
      required: !0
    },
    onlyChild: Boolean
  }),
  setup(e, {slots: t}) {
    const n = Ft()
      , r = yy(n, (t=>{
        t ? e.setRef(t.nextElementSibling) : e.setRef(null)
      }
    ));
    return ()=>{
      var n;
      const [o] = (null == (n = t.default) ? void 0 : n.call(t)) || []
        , a = e.onlyChild ? (e=>{
          if (!h(e) || e.length > 1)
            throw new Error("expect to receive a single Vue element child");
          return e[0]
        }
      )(o.children) : o.children;
      return ja(ba, {
        ref: r
      }, [a])
    }
  }
});
const hH = vr({
  name: "ElTooltipV2Trigger"
})
  , vH = vr({
  ...hH,
  props: {
    ...z$,
    ...J$
  },
  setup(e) {
    const t = e
      , {onClose: n, onOpen: r, onDelayOpen: o, triggerRef: a, contentId: i} = jo(eH);
    let s = !1;
    const l = e=>{
        a.value = e
      }
      , u = ()=>{
        s = !1
      }
      , c = ic(t.onMouseEnter, o)
      , d = ic(t.onMouseLeave, n)
      , f = ic(t.onMouseDown, (()=>{
          n(),
            s = !0,
            document.addEventListener("mouseup", u, {
              once: !0
            })
        }
      ))
      , p = ic(t.onFocus, (()=>{
          s || r()
        }
      ))
      , h = ic(t.onBlur, n)
      , v = ic(t.onClick, (e=>{
          0 === e.detail && n()
        }
      ))
      , g = {
        blur: h,
        click: v,
        focus: p,
        mousedown: f,
        mouseenter: c,
        mouseleave: d
      }
      , m = (e,t,n)=>{
        e && Object.entries(t).forEach((([t,r])=>{
            e[n](t, r)
          }
        ))
      }
    ;
    return Jn(a, ((e,t)=>{
        m(e, g, "addEventListener"),
          m(t, g, "removeEventListener"),
        e && e.setAttribute("aria-describedby", i.value)
      }
    )),
      Fr((()=>{
          m(a.value, g, "removeEventListener"),
            document.removeEventListener("mouseup", u)
        }
      )),
      (e,t)=>e.nowrap ? (Ca(),
        Ra(Vt(pH), {
          key: 0,
          "set-ref": l,
          "only-child": ""
        }, {
          default: Fn((()=>[Qr(e.$slots, "default")])),
          _: 3
        })) : (Ca(),
        _a("button", qa({
          key: 1,
          ref_key: "triggerRef",
          ref: a
        }, e.$attrs), [Qr(e.$slots, "default")], 16))
  }
});
var gH = tS(vH, [["__file", "trigger.vue"]]);
const mH = vr({
  name: "ElTooltipV2"
});
const yH = vy(tS(vr({
  ...mH,
  props: Z$,
  setup(e) {
    const t = Wt(e)
      , n = bt(Ig(t, Object.keys(G$)))
      , r = bt(Ig(t, Object.keys(Y$)))
      , o = bt(Ig(t, Object.keys(X$)))
      , a = bt(Ig(t, Object.keys(J$)));
    return (e,t)=>(Ca(),
      Ra(oH, X(Va(o)), {
        default: Fn((({open: t})=>[ja(gH, qa(a, {
          nowrap: ""
        }), {
          default: Fn((()=>[Qr(e.$slots, "trigger")])),
          _: 3
        }, 16), (Ca(),
          Ra(ma, {
            to: e.to,
            disabled: !e.teleported
          }, [e.fullTransition ? (Ca(),
            Ra(es, X(qa({
              key: 0
            }, e.transitionProps)), {
              default: Fn((()=>[e.alwaysOn || t ? (Ca(),
                Ra(fH, X(qa({
                  key: 0
                }, r)), {
                  arrow: Fn((({style: t, side: r})=>[e.showArrow ? (Ca(),
                    Ra(iH, qa({
                      key: 0
                    }, n, {
                      style: t,
                      side: r
                    }), null, 16, ["style", "side"])) : za("v-if", !0)])),
                  default: Fn((()=>[Qr(e.$slots, "default")])),
                  _: 3
                }, 16)) : za("v-if", !0)])),
              _: 2
            }, 1040)) : (Ca(),
            _a(ba, {
              key: 1
            }, [e.alwaysOn || t ? (Ca(),
              Ra(fH, X(qa({
                key: 0
              }, r)), {
                arrow: Fn((({style: t, side: r})=>[e.showArrow ? (Ca(),
                  Ra(iH, qa({
                    key: 0
                  }, n, {
                    style: t,
                    side: r
                  }), null, 16, ["style", "side"])) : za("v-if", !0)])),
                default: Fn((()=>[Qr(e.$slots, "default")])),
                _: 3
              }, 16)) : za("v-if", !0)], 64))], 8, ["to", "disabled"]))])),
        _: 3
      }, 16))
  }
}), [["__file", "tooltip.vue"]]))
  , bH = "left-check-change"
  , wH = "right-check-change"
  , xH = uy({
  data: {
    type: Array,
    default: ()=>[]
  },
  titles: {
    type: Array,
    default: ()=>[]
  },
  buttonTexts: {
    type: Array,
    default: ()=>[]
  },
  filterPlaceholder: String,
  filterMethod: {
    type: Function
  },
  leftDefaultChecked: {
    type: Array,
    default: ()=>[]
  },
  rightDefaultChecked: {
    type: Array,
    default: ()=>[]
  },
  renderContent: {
    type: Function
  },
  modelValue: {
    type: Array,
    default: ()=>[]
  },
  format: {
    type: Object,
    default: ()=>({})
  },
  filterable: Boolean,
  props: {
    type: Object,
    default: ()=>({
      label: "label",
      key: "key",
      disabled: "disabled"
    })
  },
  targetOrder: {
    type: String,
    values: ["original", "push", "unshift"],
    default: "original"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
})
  , SH = (e,t)=>[e, t].every(h) || h(e) && Cg(t)
  , EH = {
  [Sy]: (e,t,n)=>[e, n].every(h) && ["left", "right"].includes(t),
  [xy]: e=>h(e),
  [bH]: SH,
  [wH]: SH
}
  , AH = "checked-change"
  , CH = uy({
  data: xH.data,
  optionRender: {
    type: Function
  },
  placeholder: String,
  title: String,
  filterable: Boolean,
  format: xH.format,
  filterMethod: xH.filterMethod,
  defaultChecked: xH.leftDefaultChecked,
  props: xH.props
})
  , kH = {
  [AH]: SH
}
  , TH = e=>{
  const t = {
    label: "label",
    key: "key",
    disabled: "disabled"
  };
  return yi((()=>({
    ...t,
    ...e.props
  })))
}
  , DH = vr({
  name: "ElTransferPanel"
})
  , OH = vr({
  ...DH,
  props: CH,
  emits: kH,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = po()
      , a = ({option: e})=>e
      , {t: i} = Hy()
      , s = qy("transfer")
      , l = bt({
      checked: [],
      allChecked: !1,
      query: "",
      checkChangeByUser: !0
    })
      , u = TH(r)
      , {filteredData: c, checkedSummary: d, isIndeterminate: f, handleAllCheckedChange: p} = ((e,t,n)=>{
        const r = TH(e)
          , o = yi((()=>e.data.filter((n=>y(e.filterMethod) ? e.filterMethod(t.query, n) : String(n[r.value.label] || n[r.value.key]).toLowerCase().includes(t.query.toLowerCase())))))
          , a = yi((()=>o.value.filter((e=>!e[r.value.disabled]))))
          , i = yi((()=>{
              const n = t.checked.length
                , r = e.data.length
                , {noChecked: o, hasChecked: a} = e.format;
              return o && a ? n > 0 ? a.replace(/\${checked}/g, n.toString()).replace(/\${total}/g, r.toString()) : o.replace(/\${total}/g, r.toString()) : `${n}/${r}`
            }
          ))
          , s = yi((()=>{
              const e = t.checked.length;
              return e > 0 && e < a.value.length
            }
          ))
          , l = ()=>{
            const e = a.value.map((e=>e[r.value.key]));
            t.allChecked = e.length > 0 && e.every((e=>t.checked.includes(e)))
          }
        ;
        return Jn((()=>t.checked), ((e,r)=>{
            if (l(),
              t.checkChangeByUser) {
              const t = e.concat(r).filter((t=>!e.includes(t) || !r.includes(t)));
              n(AH, e, t)
            } else
              n(AH, e),
                t.checkChangeByUser = !0
          }
        )),
          Jn(a, (()=>{
              l()
            }
          )),
          Jn((()=>e.data), (()=>{
              const e = []
                , n = o.value.map((e=>e[r.value.key]));
              t.checked.forEach((t=>{
                  n.includes(t) && e.push(t)
                }
              )),
                t.checkChangeByUser = !1,
                t.checked = e
            }
          )),
          Jn((()=>e.defaultChecked), ((e,n)=>{
              if (n && e.length === n.length && e.every((e=>n.includes(e))))
                return;
              const o = []
                , i = a.value.map((e=>e[r.value.key]));
              e.forEach((e=>{
                  i.includes(e) && o.push(e)
                }
              )),
                t.checkChangeByUser = !1,
                t.checked = o
            }
          ), {
            immediate: !0
          }),
          {
            filteredData: o,
            checkableData: a,
            checkedSummary: i,
            isIndeterminate: s,
            updateAllChecked: l,
            handleAllCheckedChange: e=>{
              t.checked = e ? a.value.map((e=>e[r.value.key])) : []
            }
          }
      }
    )(r, l, n)
      , h = yi((()=>!Ug(l.query) && Ug(c.value)))
      , v = yi((()=>!Ug(o.default()[0].children)))
      , {checked: g, allChecked: m, query: b} = Wt(l);
    return t({
      query: b
    }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y(Vt(s).b("panel"))
        }, [Ma("p", {
          class: Y(Vt(s).be("panel", "header"))
        }, [ja(Vt(AD), {
          modelValue: Vt(m),
          "onUpdate:modelValue": t[0] || (t[0] = e=>Pt(m) ? m.value = e : null),
          indeterminate: Vt(f),
          "validate-event": !1,
          onChange: Vt(p)
        }, {
          default: Fn((()=>[$a(te(e.title) + " ", 1), Ma("span", null, te(Vt(d)), 1)])),
          _: 1
        }, 8, ["modelValue", "indeterminate", "onChange"])], 2), Ma("div", {
          class: Y([Vt(s).be("panel", "body"), Vt(s).is("with-footer", Vt(v))])
        }, [e.filterable ? (Ca(),
          Ra(Vt(yE), {
            key: 0,
            modelValue: Vt(b),
            "onUpdate:modelValue": t[1] || (t[1] = e=>Pt(b) ? b.value = e : null),
            class: Y(Vt(s).be("panel", "filter")),
            size: "default",
            placeholder: e.placeholder,
            "prefix-icon": Vt(qm),
            clearable: "",
            "validate-event": !1
          }, null, 8, ["modelValue", "class", "placeholder", "prefix-icon"])) : za("v-if", !0), rr(ja(Vt(kD), {
          modelValue: Vt(g),
          "onUpdate:modelValue": t[2] || (t[2] = e=>Pt(g) ? g.value = e : null),
          "validate-event": !1,
          class: Y([Vt(s).is("filterable", e.filterable), Vt(s).be("panel", "list")])
        }, {
          default: Fn((()=>[(Ca(!0),
            _a(ba, null, Yr(Vt(c), (t=>(Ca(),
              Ra(Vt(AD), {
                key: t[Vt(u).key],
                class: Y(Vt(s).be("panel", "item")),
                label: t[Vt(u).key],
                disabled: t[Vt(u).disabled],
                "validate-event": !1
              }, {
                default: Fn((()=>{
                    var n;
                    return [ja(a, {
                      option: null == (n = e.optionRender) ? void 0 : n.call(e, t)
                    }, null, 8, ["option"])]
                  }
                )),
                _: 2
              }, 1032, ["class", "label", "disabled"])))), 128))])),
          _: 1
        }, 8, ["modelValue", "class"]), [[$s, !Vt(h) && !Vt(Ug)(e.data)]]), rr(Ma("p", {
          class: Y(Vt(s).be("panel", "empty"))
        }, te(Vt(h) ? Vt(i)("el.transfer.noMatch") : Vt(i)("el.transfer.noData")), 3), [[$s, Vt(h) || Vt(Ug)(e.data)]])], 2), Vt(v) ? (Ca(),
          _a("p", {
            key: 0,
            class: Y(Vt(s).be("panel", "footer"))
          }, [Qr(e.$slots, "default")], 2)) : za("v-if", !0)], 2))
  }
});
var _H = tS(OH, [["__file", "transfer-panel.vue"]]);
const RH = {
  key: 0
}
  , LH = {
  key: 0
}
  , IH = vr({
  name: "ElTransfer"
})
  , PH = vr({
  ...IH,
  props: xH,
  emits: EH,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = po()
      , {t: a} = Hy()
      , i = qy("transfer")
      , {formItem: s} = gS()
      , l = bt({
      leftChecked: [],
      rightChecked: []
    })
      , u = TH(r)
      , {sourceData: c, targetData: d} = (e=>{
        const t = TH(e)
          , n = yi((()=>e.data.reduce(((e,n)=>(e[n[t.value.key]] = n) && e), {})));
        return {
          sourceData: yi((()=>e.data.filter((n=>!e.modelValue.includes(n[t.value.key]))))),
          targetData: yi((()=>"original" === e.targetOrder ? e.data.filter((n=>e.modelValue.includes(n[t.value.key]))) : e.modelValue.reduce(((e,t)=>{
              const r = n.value[t];
              return r && e.push(r),
                e
            }
          ), [])))
        }
      }
    )(r)
      , {onSourceCheckedChange: f, onTargetCheckedChange: p} = ((e,t)=>({
      onSourceCheckedChange: (n,r)=>{
        e.leftChecked = n,
        r && t(bH, n, r)
      }
      ,
      onTargetCheckedChange: (n,r)=>{
        e.rightChecked = n,
        r && t(wH, n, r)
      }
    }))(l, n)
      , {addToLeft: h, addToRight: v} = ((e,t,n)=>{
        const r = TH(e)
          , o = (e,t,r)=>{
            n(xy, e),
              n(Sy, e, t, r)
          }
        ;
        return {
          addToLeft: ()=>{
            const n = e.modelValue.slice();
            t.rightChecked.forEach((e=>{
                const t = n.indexOf(e);
                t > -1 && n.splice(t, 1)
              }
            )),
              o(n, "left", t.rightChecked)
          }
          ,
          addToRight: ()=>{
            let n = e.modelValue.slice();
            const a = e.data.filter((n=>{
                const o = n[r.value.key];
                return t.leftChecked.includes(o) && !e.modelValue.includes(o)
              }
            )).map((e=>e[r.value.key]));
            n = "unshift" === e.targetOrder ? a.concat(n) : n.concat(a),
            "original" === e.targetOrder && (n = e.data.filter((e=>n.includes(e[r.value.key]))).map((e=>e[r.value.key]))),
              o(n, "right", t.leftChecked)
          }
        }
      }
    )(r, l, n)
      , g = Ft()
      , m = Ft()
      , y = yi((()=>2 === r.buttonTexts.length))
      , b = yi((()=>r.titles[0] || a("el.transfer.titles.0")))
      , w = yi((()=>r.titles[1] || a("el.transfer.titles.1")))
      , x = yi((()=>r.filterPlaceholder || a("el.transfer.filterPlaceholder")));
    Jn((()=>r.modelValue), (()=>{
        var e;
        r.validateEvent && (null == (e = null == s ? void 0 : s.validate) || e.call(s, "change").catch((e=>{}
        )))
      }
    ));
    const S = yi((()=>e=>r.renderContent ? r.renderContent(bi, e) : o.default ? o.default({
      option: e
    }) : bi("span", e[u.value.label] || e[u.value.key])));
    return t({
      clearQuery: e=>{
        switch (e) {
          case "left":
            g.value.query = "";
            break;
          case "right":
            m.value.query = ""
        }
      }
      ,
      leftPanel: g,
      rightPanel: m
    }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y(Vt(i).b())
        }, [ja(_H, {
          ref_key: "leftPanel",
          ref: g,
          data: Vt(c),
          "option-render": Vt(S),
          placeholder: Vt(x),
          title: Vt(b),
          filterable: e.filterable,
          format: e.format,
          "filter-method": e.filterMethod,
          "default-checked": e.leftDefaultChecked,
          props: r.props,
          onCheckedChange: Vt(f)
        }, {
          default: Fn((()=>[Qr(e.$slots, "left-footer")])),
          _: 3
        }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]), Ma("div", {
          class: Y(Vt(i).e("buttons"))
        }, [ja(Vt(WC), {
          type: "primary",
          class: Y([Vt(i).e("button"), Vt(i).is("with-texts", Vt(y))]),
          disabled: Vt(Ug)(l.rightChecked),
          onClick: Vt(h)
        }, {
          default: Fn((()=>[ja(Vt(sS), null, {
            default: Fn((()=>[ja(Vt(vm))])),
            _: 1
          }), Vt(Mg)(e.buttonTexts[0]) ? za("v-if", !0) : (Ca(),
            _a("span", RH, te(e.buttonTexts[0]), 1))])),
          _: 1
        }, 8, ["class", "disabled", "onClick"]), ja(Vt(WC), {
          type: "primary",
          class: Y([Vt(i).e("button"), Vt(i).is("with-texts", Vt(y))]),
          disabled: Vt(Ug)(l.leftChecked),
          onClick: Vt(v)
        }, {
          default: Fn((()=>[Vt(Mg)(e.buttonTexts[1]) ? za("v-if", !0) : (Ca(),
            _a("span", LH, te(e.buttonTexts[1]), 1)), ja(Vt(sS), null, {
            default: Fn((()=>[ja(Vt(gm))])),
            _: 1
          })])),
          _: 1
        }, 8, ["class", "disabled", "onClick"])], 2), ja(_H, {
          ref_key: "rightPanel",
          ref: m,
          data: Vt(d),
          "option-render": Vt(S),
          placeholder: Vt(x),
          filterable: e.filterable,
          format: e.format,
          "filter-method": e.filterMethod,
          title: Vt(w),
          "default-checked": e.rightDefaultChecked,
          props: r.props,
          onCheckedChange: Vt(p)
        }, {
          default: Fn((()=>[Qr(e.$slots, "right-footer")])),
          _: 3
        }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])], 2))
  }
});
const FH = vy(tS(PH, [["__file", "transfer.vue"]]))
  , BH = "$treeNodeId"
  , NH = function(e, t) {
  t && !t[BH] && Object.defineProperty(t, BH, {
    value: e.id,
    enumerable: !1,
    configurable: !1,
    writable: !1
  })
}
  , MH = function(e, t) {
  return e ? t[e] : t[BH]
}
  , jH = (e,t,n)=>{
  const r = e.value.currentNode;
  n();
  const o = e.value.currentNode;
  r !== o && t("current-change", o ? o.data : null, o)
}
  , VH = e=>{
  let t = !0
    , n = !0
    , r = !0;
  for (let o = 0, a = e.length; o < a; o++) {
    const a = e[o];
    (!0 !== a.checked || a.indeterminate) && (t = !1,
    a.disabled || (r = !1)),
    (!1 !== a.checked || a.indeterminate) && (n = !1)
  }
  return {
    all: t,
    none: n,
    allWithoutDisable: r,
    half: !t && !n
  }
}
  , UH = function(e) {
  if (0 === e.childNodes.length || e.loading)
    return;
  const {all: t, none: n, half: r} = VH(e.childNodes);
  t ? (e.checked = !0,
    e.indeterminate = !1) : r ? (e.checked = !1,
    e.indeterminate = !0) : n && (e.checked = !1,
    e.indeterminate = !1);
  const o = e.parent;
  o && 0 !== o.level && (e.store.checkStrictly || UH(o))
}
  , $H = function(e, t) {
  const n = e.store.props
    , r = e.data || {}
    , o = n[t];
  if ("function" == typeof o)
    return o(r, e);
  if ("string" == typeof o)
    return r[o];
  if (void 0 === o) {
    const e = r[t];
    return void 0 === e ? "" : e
  }
};
let HH = 0
  , zH = class e {
    constructor(e) {
      this.id = HH++,
        this.text = null,
        this.checked = !1,
        this.indeterminate = !1,
        this.data = null,
        this.expanded = !1,
        this.parent = null,
        this.visible = !0,
        this.isCurrent = !1,
        this.canFocus = !1;
      for (const t in e)
        p(e, t) && (this[t] = e[t]);
      this.level = 0,
        this.loaded = !1,
        this.childNodes = [],
        this.loading = !1,
      this.parent && (this.level = this.parent.level + 1)
    }
    initialize() {
      const e = this.store;
      if (!e)
        throw new Error("[Node]store is required!");
      e.registerNode(this);
      const t = e.props;
      if (t && void 0 !== t.isLeaf) {
        const e = $H(this, "isLeaf");
        "boolean" == typeof e && (this.isLeafByUser = e)
      }
      if (!0 !== e.lazy && this.data ? (this.setData(this.data),
      e.defaultExpandAll && (this.expanded = !0,
        this.canFocus = !0)) : this.level > 0 && e.lazy && e.defaultExpandAll && this.expand(),
      Array.isArray(this.data) || NH(this, this.data),
        !this.data)
        return;
      const n = e.defaultExpandedKeys
        , r = e.key;
      r && n && n.includes(this.key) && this.expand(null, e.autoExpandParent),
      r && void 0 !== e.currentNodeKey && this.key === e.currentNodeKey && (e.currentNode = this,
        e.currentNode.isCurrent = !0),
      e.lazy && e._initDefaultCheckedNode(this),
        this.updateLeafState(),
      !this.parent || 1 !== this.level && !0 !== this.parent.expanded || (this.canFocus = !0)
    }
    setData(e) {
      let t;
      Array.isArray(e) || NH(this, e),
        this.data = e,
        this.childNodes = [],
        t = 0 === this.level && Array.isArray(this.data) ? this.data : $H(this, "children") || [];
      for (let n = 0, r = t.length; n < r; n++)
        this.insertChild({
          data: t[n]
        })
    }
    get label() {
      return $H(this, "label")
    }
    get key() {
      const e = this.store.key;
      return this.data ? this.data[e] : null
    }
    get disabled() {
      return $H(this, "disabled")
    }
    get nextSibling() {
      const e = this.parent;
      if (e) {
        const t = e.childNodes.indexOf(this);
        if (t > -1)
          return e.childNodes[t + 1]
      }
      return null
    }
    get previousSibling() {
      const e = this.parent;
      if (e) {
        const t = e.childNodes.indexOf(this);
        if (t > -1)
          return t > 0 ? e.childNodes[t - 1] : null
      }
      return null
    }
    contains(e, t=!0) {
      return (this.childNodes || []).some((n=>n === e || t && n.contains(e)))
    }
    remove() {
      const e = this.parent;
      e && e.removeChild(this)
    }
    insertChild(t, n, r) {
      if (!t)
        throw new Error("InsertChild error: child is required.");
      if (!(t instanceof e)) {
        if (!r) {
          const e = this.getChildren(!0);
          e.includes(t.data) || (void 0 === n || n < 0 ? e.push(t.data) : e.splice(n, 0, t.data))
        }
        Object.assign(t, {
          parent: this,
          store: this.store
        }),
        (t = bt(new e(t)))instanceof e && t.initialize()
      }
      t.level = this.level + 1,
        void 0 === n || n < 0 ? this.childNodes.push(t) : this.childNodes.splice(n, 0, t),
        this.updateLeafState()
    }
    insertBefore(e, t) {
      let n;
      t && (n = this.childNodes.indexOf(t)),
        this.insertChild(e, n)
    }
    insertAfter(e, t) {
      let n;
      t && (n = this.childNodes.indexOf(t),
      -1 !== n && (n += 1)),
        this.insertChild(e, n)
    }
    removeChild(e) {
      const t = this.getChildren() || []
        , n = t.indexOf(e.data);
      n > -1 && t.splice(n, 1);
      const r = this.childNodes.indexOf(e);
      r > -1 && (this.store && this.store.deregisterNode(e),
        e.parent = null,
        this.childNodes.splice(r, 1)),
        this.updateLeafState()
    }
    removeChildByData(e) {
      let t = null;
      for (let n = 0; n < this.childNodes.length; n++)
        if (this.childNodes[n].data === e) {
          t = this.childNodes[n];
          break
        }
      t && this.removeChild(t)
    }
    expand(e, t) {
      const n = ()=>{
          if (t) {
            let e = this.parent;
            for (; e.level > 0; )
              e.expanded = !0,
                e = e.parent
          }
          this.expanded = !0,
          e && e(),
            this.childNodes.forEach((e=>{
                e.canFocus = !0
              }
            ))
        }
      ;
      this.shouldLoadData() ? this.loadData((e=>{
          Array.isArray(e) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || UH(this),
            n())
        }
      )) : n()
    }
    doCreateChildren(e, t={}) {
      e.forEach((e=>{
          this.insertChild(Object.assign({
            data: e
          }, t), void 0, !0)
        }
      ))
    }
    collapse() {
      this.expanded = !1,
        this.childNodes.forEach((e=>{
            e.canFocus = !1
          }
        ))
    }
    shouldLoadData() {
      return !0 === this.store.lazy && this.store.load && !this.loaded
    }
    updateLeafState() {
      if (!0 === this.store.lazy && !0 !== this.loaded && void 0 !== this.isLeafByUser)
        return void (this.isLeaf = this.isLeafByUser);
      const e = this.childNodes;
      !this.store.lazy || !0 === this.store.lazy && !0 === this.loaded ? this.isLeaf = !e || 0 === e.length : this.isLeaf = !1
    }
    setChecked(e, t, n, r) {
      if (this.indeterminate = "half" === e,
        this.checked = !0 === e,
        this.store.checkStrictly)
        return;
      if (!this.shouldLoadData() || this.store.checkDescendants) {
        const {all: n, allWithoutDisable: o} = VH(this.childNodes);
        this.isLeaf || n || !o || (this.checked = !1,
          e = !1);
        const a = ()=>{
            if (t) {
              const n = this.childNodes;
              for (let i = 0, s = n.length; i < s; i++) {
                const o = n[i];
                r = r || !1 !== e;
                const a = o.disabled ? o.checked : r;
                o.setChecked(a, t, !0, r)
              }
              const {half: o, all: a} = VH(n);
              a || (this.checked = a,
                this.indeterminate = o)
            }
          }
        ;
        if (this.shouldLoadData())
          return void this.loadData((()=>{
              a(),
                UH(this)
            }
          ), {
            checked: !1 !== e
          });
        a()
      }
      const o = this.parent;
      o && 0 !== o.level && (n || UH(o))
    }
    getChildren(e=!1) {
      if (0 === this.level)
        return this.data;
      const t = this.data;
      if (!t)
        return null;
      const n = this.store.props;
      let r = "children";
      return n && (r = n.children || "children"),
      void 0 === t[r] && (t[r] = null),
      e && !t[r] && (t[r] = []),
        t[r]
    }
    updateChildren() {
      const e = this.getChildren() || []
        , t = this.childNodes.map((e=>e.data))
        , n = {}
        , r = [];
      e.forEach(((e,o)=>{
          const a = e[BH];
          !!a && t.findIndex((e=>e[BH] === a)) >= 0 ? n[a] = {
            index: o,
            data: e
          } : r.push({
            index: o,
            data: e
          })
        }
      )),
      this.store.lazy || t.forEach((e=>{
          n[e[BH]] || this.removeChildByData(e)
        }
      )),
        r.forEach((({index: e, data: t})=>{
            this.insertChild({
              data: t
            }, e)
          }
        )),
        this.updateLeafState()
    }
    loadData(e, t={}) {
      if (!0 !== this.store.lazy || !this.store.load || this.loaded || this.loading && !Object.keys(t).length)
        e && e.call(this);
      else {
        this.loading = !0;
        const n = n=>{
            this.childNodes = [],
              this.doCreateChildren(n, t),
              this.loaded = !0,
              this.loading = !1,
              this.updateLeafState(),
            e && e.call(this, n)
          }
        ;
        this.store.load(this, n)
      }
    }
  }
;
class KH {
  constructor(e) {
    this.currentNode = null,
      this.currentNodeKey = null;
    for (const t in e)
      p(e, t) && (this[t] = e[t]);
    this.nodesMap = {}
  }
  initialize() {
    if (this.root = new zH({
      data: this.data,
      store: this
    }),
      this.root.initialize(),
    this.lazy && this.load) {
      (0,
        this.load)(this.root, (e=>{
          this.root.doCreateChildren(e),
            this._initDefaultCheckedNodes()
        }
      ))
    } else
      this._initDefaultCheckedNodes()
  }
  filter(e) {
    const t = this.filterNodeMethod
      , n = this.lazy
      , r = function(o) {
      const a = o.root ? o.root.childNodes : o.childNodes;
      if (a.forEach((n=>{
          n.visible = t.call(n, e, n.data, n),
            r(n)
        }
      )),
      !o.visible && a.length) {
        let e = !0;
        e = !a.some((e=>e.visible)),
          o.root ? o.root.visible = !1 === e : o.visible = !1 === e
      }
      e && o.visible && !o.isLeaf && (n && !o.loaded || o.expand())
    };
    r(this)
  }
  setData(e) {
    e !== this.root.data ? (this.root.setData(e),
      this._initDefaultCheckedNodes()) : this.root.updateChildren()
  }
  getNode(e) {
    if (e instanceof zH)
      return e;
    const t = x(e) ? MH(this.key, e) : e;
    return this.nodesMap[t] || null
  }
  insertBefore(e, t) {
    const n = this.getNode(t);
    n.parent.insertBefore({
      data: e
    }, n)
  }
  insertAfter(e, t) {
    const n = this.getNode(t);
    n.parent.insertAfter({
      data: e
    }, n)
  }
  remove(e) {
    const t = this.getNode(e);
    t && t.parent && (t === this.currentNode && (this.currentNode = null),
      t.parent.removeChild(t))
  }
  append(e, t) {
    const n = t ? this.getNode(t) : this.root;
    n && n.insertChild({
      data: e
    })
  }
  _initDefaultCheckedNodes() {
    const e = this.defaultCheckedKeys || []
      , t = this.nodesMap;
    e.forEach((e=>{
        const n = t[e];
        n && n.setChecked(!0, !this.checkStrictly)
      }
    ))
  }
  _initDefaultCheckedNode(e) {
    (this.defaultCheckedKeys || []).includes(e.key) && e.setChecked(!0, !this.checkStrictly)
  }
  setDefaultCheckedKey(e) {
    e !== this.defaultCheckedKeys && (this.defaultCheckedKeys = e,
      this._initDefaultCheckedNodes())
  }
  registerNode(e) {
    const t = this.key;
    if (e && e.data)
      if (t) {
        void 0 !== e.key && (this.nodesMap[e.key] = e)
      } else
        this.nodesMap[e.id] = e
  }
  deregisterNode(e) {
    this.key && e && e.data && (e.childNodes.forEach((e=>{
        this.deregisterNode(e)
      }
    )),
      delete this.nodesMap[e.key])
  }
  getCheckedNodes(e=!1, t=!1) {
    const n = []
      , r = function(o) {
      (o.root ? o.root.childNodes : o.childNodes).forEach((o=>{
          (o.checked || t && o.indeterminate) && (!e || e && o.isLeaf) && n.push(o.data),
            r(o)
        }
      ))
    };
    return r(this),
      n
  }
  getCheckedKeys(e=!1) {
    return this.getCheckedNodes(e).map((e=>(e || {})[this.key]))
  }
  getHalfCheckedNodes() {
    const e = []
      , t = function(n) {
      (n.root ? n.root.childNodes : n.childNodes).forEach((n=>{
          n.indeterminate && e.push(n.data),
            t(n)
        }
      ))
    };
    return t(this),
      e
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((e=>(e || {})[this.key]))
  }
  _getAllNodes() {
    const e = []
      , t = this.nodesMap;
    for (const n in t)
      p(t, n) && e.push(t[n]);
    return e
  }
  updateChildren(e, t) {
    const n = this.nodesMap[e];
    if (!n)
      return;
    const r = n.childNodes;
    for (let o = r.length - 1; o >= 0; o--) {
      const e = r[o];
      this.remove(e.data)
    }
    for (let o = 0, a = t.length; o < a; o++) {
      const e = t[o];
      this.append(e, n.data)
    }
  }
  _setCheckedKeys(e, t=!1, n) {
    const r = this._getAllNodes().sort(((e,t)=>e.level - t.level))
      , o = Object.create(null)
      , a = Object.keys(n);
    r.forEach((e=>e.setChecked(!1, !1)));
    const i = t=>{
        t.childNodes.forEach((t=>{
            var n;
            o[t.data[e]] = !0,
            (null == (n = t.childNodes) ? void 0 : n.length) && i(t)
          }
        ))
      }
    ;
    for (let s = 0, l = r.length; s < l; s++) {
      const n = r[s]
        , l = n.data[e].toString();
      if (a.includes(l)) {
        if (n.childNodes.length && i(n),
        n.isLeaf || this.checkStrictly)
          n.setChecked(!0, !1);
        else if (n.setChecked(!0, !0),
          t) {
          n.setChecked(!1, !1);
          const e = function(t) {
            t.childNodes.forEach((t=>{
                t.isLeaf || t.setChecked(!1, !1),
                  e(t)
              }
            ))
          };
          e(n)
        }
      } else
        n.checked && !o[l] && n.setChecked(!1, !1)
    }
  }
  setCheckedNodes(e, t=!1) {
    const n = this.key
      , r = {};
    e.forEach((e=>{
        r[(e || {})[n]] = !0
      }
    )),
      this._setCheckedKeys(n, t, r)
  }
  setCheckedKeys(e, t=!1) {
    this.defaultCheckedKeys = e;
    const n = this.key
      , r = {};
    e.forEach((e=>{
        r[e] = !0
      }
    )),
      this._setCheckedKeys(n, t, r)
  }
  setDefaultExpandedKeys(e) {
    e = e || [],
      this.defaultExpandedKeys = e,
      e.forEach((e=>{
          const t = this.getNode(e);
          t && t.expand(null, this.autoExpandParent)
        }
      ))
  }
  setChecked(e, t, n) {
    const r = this.getNode(e);
    r && r.setChecked(!!t, n)
  }
  getCurrentNode() {
    return this.currentNode
  }
  setCurrentNode(e) {
    const t = this.currentNode;
    t && (t.isCurrent = !1),
      this.currentNode = e,
      this.currentNode.isCurrent = !0
  }
  setUserCurrentNode(e, t=!0) {
    const n = e[this.key]
      , r = this.nodesMap[n];
    this.setCurrentNode(r),
    t && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0)
  }
  setCurrentNodeKey(e, t=!0) {
    if (null == e)
      return this.currentNode && (this.currentNode.isCurrent = !1),
        void (this.currentNode = null);
    const n = this.getNode(e);
    n && (this.setCurrentNode(n),
    t && this.currentNode.level > 1 && this.currentNode.parent.expand(null, !0))
  }
}
var WH = tS(vr({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: !0
    },
    renderContent: Function
  },
  setup(e) {
    const t = qy("tree")
      , n = jo("NodeInstance")
      , r = jo("RootTree");
    return ()=>{
      const o = e.node
        , {data: a, store: i} = o;
      return e.renderContent ? e.renderContent(bi, {
        _self: n,
        node: o,
        data: a,
        store: i
      }) : Qr(r.ctx.slots, "default", {
        node: o,
        data: a
      }, (()=>[bi("span", {
        class: t.be("node", "label")
      }, [o.label])]))
    }
  }
}), [["__file", "tree-node-content.vue"]]);
function GH(e) {
  const t = jo("TreeNodeMap", null)
    , n = {
    treeNodeExpand: t=>{
      e.node !== t && e.node.collapse()
    }
    ,
    children: []
  };
  return t && t.children.push(n),
    Mo("TreeNodeMap", n),
    {
      broadcastExpanded: t=>{
        if (e.accordion)
          for (const e of n.children)
            e.treeNodeExpand(t)
      }
    }
}
const qH = Symbol("dragEvents");
const YH = vr({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: KO,
    ElCheckbox: AD,
    NodeContent: WH,
    ElIcon: sS,
    Loading: Mm
  },
  props: {
    node: {
      type: zH,
      default: ()=>({})
    },
    props: {
      type: Object,
      default: ()=>({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["node-expand"],
  setup(e, t) {
    const n = qy("tree")
      , {broadcastExpanded: r} = GH(e)
      , o = jo("RootTree")
      , a = Ft(!1)
      , i = Ft(!1)
      , s = Ft(null)
      , l = Ft(null)
      , u = Ft(null)
      , c = jo(qH)
      , d = ei();
    Mo("NodeInstance", d),
    e.node.expanded && (a.value = !0,
      i.value = !0);
    const f = o.props.props.children || "children";
    Jn((()=>{
        const t = e.node.data[f];
        return t && [...t]
      }
    ), (()=>{
        e.node.updateChildren()
      }
    )),
      Jn((()=>e.node.indeterminate), (t=>{
          p(e.node.checked, t)
        }
      )),
      Jn((()=>e.node.checked), (t=>{
          p(t, e.node.indeterminate)
        }
      )),
      Jn((()=>e.node.expanded), (e=>{
          hn((()=>a.value = e)),
          e && (i.value = !0)
        }
      ));
    const p = (t,n)=>{
        s.value === t && l.value === n || o.ctx.emit("check-change", e.node.data, t, n),
          s.value = t,
          l.value = n
      }
      , h = ()=>{
        e.node.isLeaf || (a.value ? (o.ctx.emit("node-collapse", e.node.data, e.node, d),
          e.node.collapse()) : (e.node.expand(),
          t.emit("node-expand", e.node.data, e.node, d)))
      }
      , v = (t,n)=>{
        e.node.setChecked(n.target.checked, !o.props.checkStrictly),
          hn((()=>{
              const t = o.store.value;
              o.ctx.emit("check", e.node.data, {
                checkedNodes: t.getCheckedNodes(),
                checkedKeys: t.getCheckedKeys(),
                halfCheckedNodes: t.getHalfCheckedNodes(),
                halfCheckedKeys: t.getHalfCheckedKeys()
              })
            }
          ))
      }
    ;
    return {
      ns: n,
      node$: u,
      tree: o,
      expanded: a,
      childNodeRendered: i,
      oldChecked: s,
      oldIndeterminate: l,
      getNodeKey: e=>MH(o.props.nodeKey, e.data),
      getNodeClass: t=>{
        const n = e.props.class;
        if (!n)
          return {};
        let r;
        if (y(n)) {
          const {data: e} = t;
          r = n(e, t)
        } else
          r = n;
        return b(r) ? {
          [r]: !0
        } : r
      }
      ,
      handleSelectChange: p,
      handleClick: t=>{
        jH(o.store, o.ctx.emit, (()=>o.store.value.setCurrentNode(e.node))),
          o.currentNode.value = e.node,
        o.props.expandOnClickNode && h(),
        o.props.checkOnClickNode && !e.node.disabled && v(null, {
          target: {
            checked: !e.node.checked
          }
        }),
          o.ctx.emit("node-click", e.node.data, e.node, d, t)
      }
      ,
      handleContextMenu: t=>{
        o.instance.vnode.props.onNodeContextmenu && (t.stopPropagation(),
          t.preventDefault()),
          o.ctx.emit("node-contextmenu", t, e.node.data, e.node, d)
      }
      ,
      handleExpandIconClick: h,
      handleCheckChange: v,
      handleChildNodeExpand: (e,t,n)=>{
        r(t),
          o.ctx.emit("node-expand", e, t, n)
      }
      ,
      handleDragStart: t=>{
        o.props.draggable && c.treeNodeDragStart({
          event: t,
          treeNode: e
        })
      }
      ,
      handleDragOver: t=>{
        t.preventDefault(),
        o.props.draggable && c.treeNodeDragOver({
          event: t,
          treeNode: {
            $el: u.value,
            node: e.node
          }
        })
      }
      ,
      handleDrop: e=>{
        e.preventDefault()
      }
      ,
      handleDragEnd: e=>{
        o.props.draggable && c.treeNodeDragEnd(e)
      }
      ,
      CaretRight: wm
    }
  }
})
  , XH = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"]
  , QH = ["aria-expanded"];
const JH = vr({
  name: "ElTree",
  components: {
    ElTreeNode: tS(YH, [["render", function(e, t, n, r, o, a) {
      const i = Hr("el-icon")
        , s = Hr("el-checkbox")
        , l = Hr("loading")
        , u = Hr("node-content")
        , c = Hr("el-tree-node")
        , d = Hr("el-collapse-transition");
      return rr((Ca(),
        _a("div", {
          ref: "node$",
          class: Y([e.ns.b("node"), e.ns.is("expanded", e.expanded), e.ns.is("current", e.node.isCurrent), e.ns.is("hidden", !e.node.visible), e.ns.is("focusable", !e.node.disabled), e.ns.is("checked", !e.node.disabled && e.node.checked), e.getNodeClass(e.node)]),
          role: "treeitem",
          tabindex: "-1",
          "aria-expanded": e.expanded,
          "aria-disabled": e.node.disabled,
          "aria-checked": e.node.checked,
          draggable: e.tree.props.draggable,
          "data-key": e.getNodeKey(e.node),
          onClick: t[1] || (t[1] = js(((...t)=>e.handleClick && e.handleClick(...t)), ["stop"])),
          onContextmenu: t[2] || (t[2] = (...t)=>e.handleContextMenu && e.handleContextMenu(...t)),
          onDragstart: t[3] || (t[3] = js(((...t)=>e.handleDragStart && e.handleDragStart(...t)), ["stop"])),
          onDragover: t[4] || (t[4] = js(((...t)=>e.handleDragOver && e.handleDragOver(...t)), ["stop"])),
          onDragend: t[5] || (t[5] = js(((...t)=>e.handleDragEnd && e.handleDragEnd(...t)), ["stop"])),
          onDrop: t[6] || (t[6] = js(((...t)=>e.handleDrop && e.handleDrop(...t)), ["stop"]))
        }, [Ma("div", {
          class: Y(e.ns.be("node", "content")),
          style: z({
            paddingLeft: (e.node.level - 1) * e.tree.props.indent + "px"
          })
        }, [e.tree.props.icon || e.CaretRight ? (Ca(),
          Ra(i, {
            key: 0,
            class: Y([e.ns.be("node", "expand-icon"), e.ns.is("leaf", e.node.isLeaf), {
              expanded: !e.node.isLeaf && e.expanded
            }]),
            onClick: js(e.handleExpandIconClick, ["stop"])
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(e.tree.props.icon || e.CaretRight)))])),
            _: 1
          }, 8, ["class", "onClick"])) : za("v-if", !0), e.showCheckbox ? (Ca(),
          Ra(s, {
            key: 1,
            "model-value": e.node.checked,
            indeterminate: e.node.indeterminate,
            disabled: !!e.node.disabled,
            onClick: t[0] || (t[0] = js((()=>{}
            ), ["stop"])),
            onChange: e.handleCheckChange
          }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : za("v-if", !0), e.node.loading ? (Ca(),
          Ra(i, {
            key: 2,
            class: Y([e.ns.be("node", "loading-icon"), e.ns.is("loading")])
          }, {
            default: Fn((()=>[ja(l)])),
            _: 1
          }, 8, ["class"])) : za("v-if", !0), ja(u, {
          node: e.node,
          "render-content": e.renderContent
        }, null, 8, ["node", "render-content"])], 6), ja(d, null, {
          default: Fn((()=>[!e.renderAfterExpand || e.childNodeRendered ? rr((Ca(),
            _a("div", {
              key: 0,
              class: Y(e.ns.be("node", "children")),
              role: "group",
              "aria-expanded": e.expanded
            }, [(Ca(!0),
              _a(ba, null, Yr(e.node.childNodes, (t=>(Ca(),
                Ra(c, {
                  key: e.getNodeKey(t),
                  "render-content": e.renderContent,
                  "render-after-expand": e.renderAfterExpand,
                  "show-checkbox": e.showCheckbox,
                  node: t,
                  accordion: e.accordion,
                  props: e.props,
                  onNodeExpand: e.handleChildNodeExpand
                }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"])))), 128))], 10, QH)), [[$s, e.expanded]]) : za("v-if", !0)])),
          _: 1
        })], 42, XH)), [[$s, e.node.visible]])
    }
    ], ["__file", "tree-node.vue"]])
  },
  props: {
    data: {
      type: Array,
      default: ()=>[]
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: !0
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: !1
    },
    autoExpandParent: {
      type: Boolean,
      default: !0
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: ()=>({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: cy
    }
  },
  emits: ["check-change", "current-change", "node-click", "node-contextmenu", "node-collapse", "node-expand", "check", "node-drag-start", "node-drag-end", "node-drop", "node-drag-leave", "node-drag-enter", "node-drag-over"],
  setup(e, t) {
    const {t: n} = Hy()
      , r = qy("tree")
      , o = Ft(new KH({
      key: e.nodeKey,
      data: e.data,
      lazy: e.lazy,
      props: e.props,
      load: e.load,
      currentNodeKey: e.currentNodeKey,
      checkStrictly: e.checkStrictly,
      checkDescendants: e.checkDescendants,
      defaultCheckedKeys: e.defaultCheckedKeys,
      defaultExpandedKeys: e.defaultExpandedKeys,
      autoExpandParent: e.autoExpandParent,
      defaultExpandAll: e.defaultExpandAll,
      filterNodeMethod: e.filterNodeMethod
    }));
    o.value.initialize();
    const a = Ft(o.value.root)
      , i = Ft(null)
      , s = Ft(null)
      , l = Ft(null)
      , {broadcastExpanded: u} = GH(e)
      , {dragState: c} = function({props: e, ctx: t, el$: n, dropIndicator$: r, store: o}) {
      const a = qy("tree")
        , i = Ft({
        showDropIndicator: !1,
        draggingNode: null,
        dropNode: null,
        allowDrop: !0,
        dropType: null
      });
      return Mo(qH, {
        treeNodeDragStart: ({event: n, treeNode: r})=>{
          if ("function" == typeof e.allowDrag && !e.allowDrag(r.node))
            return n.preventDefault(),
              !1;
          n.dataTransfer.effectAllowed = "move";
          try {
            n.dataTransfer.setData("text/plain", "")
          } catch (Y_) {}
          i.value.draggingNode = r,
            t.emit("node-drag-start", r.node, n)
        }
        ,
        treeNodeDragOver: ({event: o, treeNode: s})=>{
          const l = s
            , u = i.value.dropNode;
          u && u.node.id !== l.node.id && nm(u.$el, a.is("drop-inner"));
          const c = i.value.draggingNode;
          if (!c || !l)
            return;
          let d = !0
            , f = !0
            , p = !0
            , h = !0;
          "function" == typeof e.allowDrop && (d = e.allowDrop(c.node, l.node, "prev"),
            h = f = e.allowDrop(c.node, l.node, "inner"),
            p = e.allowDrop(c.node, l.node, "next")),
            o.dataTransfer.dropEffect = f || d || p ? "move" : "none",
          (d || f || p) && (null == u ? void 0 : u.node.id) !== l.node.id && (u && t.emit("node-drag-leave", c.node, u.node, o),
            t.emit("node-drag-enter", c.node, l.node, o)),
            i.value.dropNode = d || f || p ? l : null,
          l.node.nextSibling === c.node && (p = !1),
          l.node.previousSibling === c.node && (d = !1),
          l.node.contains(c.node, !1) && (f = !1),
          (c.node === l.node || c.node.contains(l.node)) && (d = !1,
            f = !1,
            p = !1);
          const v = l.$el.querySelector(`.${a.be("node", "content")}`).getBoundingClientRect()
            , g = n.value.getBoundingClientRect();
          let m;
          const y = d ? f ? .25 : p ? .45 : 1 : -1
            , b = p ? f ? .75 : d ? .55 : 0 : 1;
          let w = -9999;
          const x = o.clientY - v.top;
          m = x < v.height * y ? "before" : x > v.height * b ? "after" : f ? "inner" : "none";
          const S = l.$el.querySelector(`.${a.be("node", "expand-icon")}`).getBoundingClientRect()
            , E = r.value;
          "before" === m ? w = S.top - g.top : "after" === m && (w = S.bottom - g.top),
            E.style.top = `${w}px`,
            E.style.left = S.right - g.left + "px",
            "inner" === m ? tm(l.$el, a.is("drop-inner")) : nm(l.$el, a.is("drop-inner")),
            i.value.showDropIndicator = "before" === m || "after" === m,
            i.value.allowDrop = i.value.showDropIndicator || h,
            i.value.dropType = m,
            t.emit("node-drag-over", c.node, l.node, o)
        }
        ,
        treeNodeDragEnd: e=>{
          const {draggingNode: n, dropType: r, dropNode: s} = i.value;
          if (e.preventDefault(),
            e.dataTransfer.dropEffect = "move",
          n && s) {
            const i = {
              data: n.node.data
            };
            "none" !== r && n.node.remove(),
              "before" === r ? s.node.parent.insertBefore(i, s.node) : "after" === r ? s.node.parent.insertAfter(i, s.node) : "inner" === r && s.node.insertChild(i),
            "none" !== r && o.value.registerNode(i),
              nm(s.$el, a.is("drop-inner")),
              t.emit("node-drag-end", n.node, s.node, r, e),
            "none" !== r && t.emit("node-drop", n.node, s.node, r, e)
          }
          n && !s && t.emit("node-drag-end", n.node, null, r, e),
            i.value.showDropIndicator = !1,
            i.value.draggingNode = null,
            i.value.dropNode = null,
            i.value.allowDrop = !0
        }
      }),
        {
          dragState: i
        }
    }({
      props: e,
      ctx: t,
      el$: s,
      dropIndicator$: l,
      store: o
    });
    !function({el$: e}, t) {
      const n = qy("tree")
        , r = Bt([])
        , o = Bt([]);
      Lr((()=>{
          a()
        }
      )),
        Pr((()=>{
            r.value = Array.from(e.value.querySelectorAll("[role=treeitem]")),
              o.value = Array.from(e.value.querySelectorAll("input[type=checkbox]"))
          }
        )),
        Jn(o, (e=>{
            e.forEach((e=>{
                e.setAttribute("tabindex", "-1")
              }
            ))
          }
        )),
        Rc(e, "keydown", (o=>{
            const a = o.target;
            if (!a.className.includes(n.b("node")))
              return;
            const i = o.code;
            r.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));
            const s = r.value.indexOf(a);
            let l;
            if ([by.up, by.down].includes(i)) {
              if (o.preventDefault(),
              i === by.up) {
                l = -1 === s ? 0 : 0 !== s ? s - 1 : r.value.length - 1;
                const e = l;
                for (; !t.value.getNode(r.value[l].dataset.key).canFocus; ) {
                  if (l--,
                  l === e) {
                    l = -1;
                    break
                  }
                  l < 0 && (l = r.value.length - 1)
                }
              } else {
                l = -1 === s ? 0 : s < r.value.length - 1 ? s + 1 : 0;
                const e = l;
                for (; !t.value.getNode(r.value[l].dataset.key).canFocus; ) {
                  if (l++,
                  l === e) {
                    l = -1;
                    break
                  }
                  l >= r.value.length && (l = 0)
                }
              }
              -1 !== l && r.value[l].focus()
            }
            [by.left, by.right].includes(i) && (o.preventDefault(),
              a.click());
            const u = a.querySelector('[type="checkbox"]');
            [by.enter, by.space].includes(i) && u && (o.preventDefault(),
              u.click())
          }
        ));
      const a = ()=>{
        var t;
        r.value = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)),
          o.value = Array.from(e.value.querySelectorAll("input[type=checkbox]"));
        const a = e.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);
        a.length ? a[0].setAttribute("tabindex", "0") : null == (t = r.value[0]) || t.setAttribute("tabindex", "0")
      }
    }({
      el$: s
    }, o);
    const d = yi((()=>{
        const {childNodes: e} = a.value;
        return !e || 0 === e.length || e.every((({visible: e})=>!e))
      }
    ));
    Jn((()=>e.currentNodeKey), (e=>{
        o.value.setCurrentNodeKey(e)
      }
    )),
      Jn((()=>e.defaultCheckedKeys), (e=>{
          o.value.setDefaultCheckedKey(e)
        }
      )),
      Jn((()=>e.defaultExpandedKeys), (e=>{
          o.value.setDefaultExpandedKeys(e)
        }
      )),
      Jn((()=>e.data), (e=>{
          o.value.setData(e)
        }
      ), {
        deep: !0
      }),
      Jn((()=>e.checkStrictly), (e=>{
          o.value.checkStrictly = e
        }
      ));
    const f = ()=>{
        const e = o.value.getCurrentNode();
        return e ? e.data : null
      }
    ;
    return Mo("RootTree", {
      ctx: t,
      props: e,
      store: o,
      root: a,
      currentNode: i,
      instance: ei()
    }),
      Mo(pS, void 0),
      {
        ns: r,
        store: o,
        root: a,
        currentNode: i,
        dragState: c,
        el$: s,
        dropIndicator$: l,
        isEmpty: d,
        filter: t=>{
          if (!e.filterNodeMethod)
            throw new Error("[Tree] filterNodeMethod is required when filter");
          o.value.filter(t)
        }
        ,
        getNodeKey: t=>MH(e.nodeKey, t.data),
        getNodePath: t=>{
          if (!e.nodeKey)
            throw new Error("[Tree] nodeKey is required in getNodePath");
          const n = o.value.getNode(t);
          if (!n)
            return [];
          const r = [n.data];
          let i = n.parent;
          for (; i && i !== a.value; )
            r.push(i.data),
              i = i.parent;
          return r.reverse()
        }
        ,
        getCheckedNodes: (e,t)=>o.value.getCheckedNodes(e, t),
        getCheckedKeys: e=>o.value.getCheckedKeys(e),
        getCurrentNode: f,
        getCurrentKey: ()=>{
          if (!e.nodeKey)
            throw new Error("[Tree] nodeKey is required in getCurrentKey");
          const t = f();
          return t ? t[e.nodeKey] : null
        }
        ,
        setCheckedNodes: (t,n)=>{
          if (!e.nodeKey)
            throw new Error("[Tree] nodeKey is required in setCheckedNodes");
          o.value.setCheckedNodes(t, n)
        }
        ,
        setCheckedKeys: (t,n)=>{
          if (!e.nodeKey)
            throw new Error("[Tree] nodeKey is required in setCheckedKeys");
          o.value.setCheckedKeys(t, n)
        }
        ,
        setChecked: (e,t,n)=>{
          o.value.setChecked(e, t, n)
        }
        ,
        getHalfCheckedNodes: ()=>o.value.getHalfCheckedNodes(),
        getHalfCheckedKeys: ()=>o.value.getHalfCheckedKeys(),
        setCurrentNode: (n,r=!0)=>{
          if (!e.nodeKey)
            throw new Error("[Tree] nodeKey is required in setCurrentNode");
          jH(o, t.emit, (()=>o.value.setUserCurrentNode(n, r)))
        }
        ,
        setCurrentKey: (n,r=!0)=>{
          if (!e.nodeKey)
            throw new Error("[Tree] nodeKey is required in setCurrentKey");
          jH(o, t.emit, (()=>o.value.setCurrentNodeKey(n, r)))
        }
        ,
        t: n,
        getNode: e=>o.value.getNode(e),
        remove: e=>{
          o.value.remove(e)
        }
        ,
        append: (e,t)=>{
          o.value.append(e, t)
        }
        ,
        insertBefore: (e,t)=>{
          o.value.insertBefore(e, t)
        }
        ,
        insertAfter: (e,t)=>{
          o.value.insertAfter(e, t)
        }
        ,
        handleNodeExpand: (e,n,r)=>{
          u(n),
            t.emit("node-expand", e, n, r)
        }
        ,
        updateKeyChildren: (t,n)=>{
          if (!e.nodeKey)
            throw new Error("[Tree] nodeKey is required in updateKeyChild");
          o.value.updateChildren(t, n)
        }
      }
  }
});
var ZH = tS(JH, [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-tree-node");
  return Ca(),
    _a("div", {
      ref: "el$",
      class: Y([e.ns.b(), e.ns.is("dragging", !!e.dragState.draggingNode), e.ns.is("drop-not-allow", !e.dragState.allowDrop), e.ns.is("drop-inner", "inner" === e.dragState.dropType), {
        [e.ns.m("highlight-current")]: e.highlightCurrent
      }]),
      role: "tree"
    }, [(Ca(!0),
      _a(ba, null, Yr(e.root.childNodes, (t=>(Ca(),
        Ra(i, {
          key: e.getNodeKey(t),
          node: t,
          props: e.props,
          accordion: e.accordion,
          "render-after-expand": e.renderAfterExpand,
          "show-checkbox": e.showCheckbox,
          "render-content": e.renderContent,
          onNodeExpand: e.handleNodeExpand
        }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"])))), 128)), e.isEmpty ? (Ca(),
      _a("div", {
        key: 0,
        class: Y(e.ns.e("empty-block"))
      }, [Qr(e.$slots, "empty", {}, (()=>{
          var t;
          return [Ma("span", {
            class: Y(e.ns.e("empty-text"))
          }, te(null != (t = e.emptyText) ? t : e.t("el.tree.emptyText")), 3)]
        }
      ))], 2)) : za("v-if", !0), rr(Ma("div", {
      ref: "dropIndicator$",
      class: Y(e.ns.e("drop-indicator"))
    }, null, 2), [[$s, e.dragState.showDropIndicator]])], 2)
}
], ["__file", "tree.vue"]]);
ZH.install = e=>{
  e.component(ZH.name, ZH)
}
;
const ez = ZH
  , tz = ez
  , nz = vr({
  extends: rB,
  setup(e, t) {
    const n = rB.setup(e, t);
    delete n.selectOptionClick;
    const r = ei().proxy;
    return hn((()=>{
        n.select.states.cachedOptions.get(r.value) || n.select.onOptionCreate(r)
      }
    )),
      n
  },
  methods: {
    selectOptionClick() {
      this.$el.parentElement.click()
    }
  }
});
function rz(e) {
  return e || 0 === e
}
function oz(e) {
  return Array.isArray(e) && e.length
}
function az(e) {
  return Array.isArray(e) ? e : rz(e) ? [e] : []
}
function iz(e, t, n, r, o) {
  for (let a = 0; a < e.length; a++) {
    const i = e[a];
    if (t(i, a, e, o))
      return r ? r(i, a, e, o) : i;
    {
      const e = n(i);
      if (oz(e)) {
        const o = iz(e, t, n, r, i);
        if (o)
          return o
      }
    }
  }
}
function sz(e, t, n, r) {
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    t(a, o, e, r);
    const i = n(a);
    oz(i) && sz(i, t, n, a)
  }
}
var lz = vr({
  props: {
    data: {
      type: Array,
      default: ()=>[]
    }
  },
  setup(e) {
    const t = jo(UF);
    return Jn((()=>e.data), (()=>{
        var n;
        e.data.forEach((e=>{
            t.states.cachedOptions.has(e.value) || t.states.cachedOptions.set(e.value, e)
          }
        ));
        const r = (null == (n = t.selectRef) ? void 0 : n.querySelectorAll("input")) || [];
        Array.from(r).includes(document.activeElement) || t.setSelected()
      }
    ), {
      flush: "post",
      immediate: !0
    }),
      ()=>{}
  }
});
const uz = vr({
  name: "ElTreeSelect",
  inheritAttrs: !1,
  props: {
    ...nB.props,
    ...ez.props,
    cacheData: {
      type: Array,
      default: ()=>[]
    }
  },
  setup(e, t) {
    const {slots: n, expose: r} = t
      , o = Ft()
      , a = Ft()
      , i = yi((()=>e.nodeKey || e.valueKey || "value"))
      , s = ((e,{attrs: t, emit: n},{select: r, tree: o, key: a})=>{
        const i = qy("tree-select");
        return Jn((()=>e.data), (()=>{
            e.filterable && hn((()=>{
                var e, t;
                null == (t = o.value) || t.filter(null == (e = r.value) ? void 0 : e.states.inputValue)
              }
            ))
          }
        ), {
          flush: "post"
        }),
          {
            ...Ig(Wt(e), Object.keys(nB.props)),
            ...t,
            "onUpdate:modelValue": e=>n(xy, e),
            valueKey: a,
            popperClass: yi((()=>{
                const t = [i.e("popper")];
                return e.popperClass && t.push(e.popperClass),
                  t.join(" ")
              }
            )),
            filterMethod: (t="")=>{
              var n;
              e.filterMethod ? e.filterMethod(t) : e.remoteMethod ? e.remoteMethod(t) : null == (n = o.value) || n.filter(t)
            }
          }
      }
    )(e, t, {
      select: o,
      tree: a,
      key: i
    })
      , {cacheOptions: l, ...u} = ((e,{attrs: t, slots: n, emit: r},{select: o, tree: a, key: i})=>{
        Jn((()=>e.modelValue), (()=>{
            e.showCheckbox && hn((()=>{
                const t = a.value;
                t && !Ag(t.getCheckedKeys(), az(e.modelValue)) && t.setCheckedKeys(az(e.modelValue))
              }
            ))
          }
        ), {
          immediate: !0,
          deep: !0
        });
        const s = yi((()=>({
          value: i.value,
          label: "label",
          children: "children",
          disabled: "disabled",
          isLeaf: "isLeaf",
          ...e.props
        })))
          , l = (e,t)=>{
          var n;
          const r = s.value[e];
          return y(r) ? r(t, null == (n = a.value) ? void 0 : n.getNode(l("value", t))) : t[r]
        }
          , u = az(e.modelValue).map((t=>iz(e.data || [], (e=>l("value", e) === t), (e=>l("children", e)), ((e,t,n,r)=>r && l("value", r))))).filter((e=>rz(e)))
          , c = yi((()=>{
            if (!e.renderAfterExpand && !e.lazy)
              return [];
            const t = [];
            return sz(e.data.concat(e.cacheData), (e=>{
                const n = l("value", e);
                t.push({
                  value: n,
                  currentLabel: l("label", e),
                  isDisabled: l("disabled", e)
                })
              }
            ), (e=>l("children", e))),
              t
          }
        ));
        return {
          ...Ig(Wt(e), Object.keys(ez.props)),
          ...t,
          nodeKey: i,
          expandOnClickNode: yi((()=>!e.checkStrictly && e.expandOnClickNode)),
          defaultExpandedKeys: yi((()=>e.defaultExpandedKeys ? e.defaultExpandedKeys.concat(u) : u)),
          renderContent: (t,{node: r, data: o, store: a})=>t(nz, {
            value: l("value", o),
            label: l("label", o),
            disabled: l("disabled", o)
          }, e.renderContent ? ()=>e.renderContent(t, {
            node: r,
            data: o,
            store: a
          }) : n.default ? ()=>n.default({
            node: r,
            data: o,
            store: a
          }) : void 0),
          filterNodeMethod: (t,n,r)=>e.filterNodeMethod ? e.filterNodeMethod(t, n, r) : !t || new RegExp(Gg(t),"i").test(l("label", n) || ""),
          onNodeClick: (n,r,a)=>{
            var i, s, u, c;
            if (null == (i = t.onNodeClick) || i.call(t, n, r, a),
            !e.showCheckbox || !e.checkOnClickNode) {
              if (e.showCheckbox || !e.checkStrictly && !r.isLeaf)
                e.expandOnClickNode && a.proxy.handleExpandIconClick();
              else if (!l("disabled", n)) {
                const e = null == (s = o.value) ? void 0 : s.states.options.get(l("value", n));
                null == (u = o.value) || u.handleOptionSelect(e)
              }
              null == (c = o.value) || c.focus()
            }
          }
          ,
          onCheck: (n,i)=>{
            var s;
            if (!e.showCheckbox)
              return;
            const u = l("value", n)
              , c = {};
            sz([a.value.store.root], (e=>c[e.key] = e), (e=>e.childNodes));
            const d = i.checkedKeys
              , f = e.multiple ? az(e.modelValue).filter((e=>!(e in c) && !d.includes(e))) : []
              , p = f.concat(d);
            if (e.checkStrictly)
              r(xy, e.multiple ? p : p.includes(u) ? u : void 0);
            else if (e.multiple)
              r(xy, f.concat(a.value.getCheckedKeys(!0)));
            else {
              const t = iz([n], (e=>!oz(l("children", e)) && !l("disabled", e)), (e=>l("children", e)))
                , o = t ? l("value", t) : void 0
                , a = rz(e.modelValue) && !!iz([n], (t=>l("value", t) === e.modelValue), (e=>l("children", e)));
              r(xy, o === e.modelValue || a ? void 0 : o)
            }
            hn((()=>{
                var r;
                const o = az(e.modelValue);
                a.value.setCheckedKeys(o),
                null == (r = t.onCheck) || r.call(t, n, {
                  checkedKeys: a.value.getCheckedKeys(),
                  checkedNodes: a.value.getCheckedNodes(),
                  halfCheckedKeys: a.value.getHalfCheckedKeys(),
                  halfCheckedNodes: a.value.getHalfCheckedNodes()
                })
              }
            )),
            null == (s = o.value) || s.focus()
          }
          ,
          cacheOptions: c
        }
      }
    )(e, t, {
      select: o,
      tree: a,
      key: i
    })
      , c = bt({});
    return r(c),
      Lr((()=>{
          Object.assign(c, {
            ...Ig(a.value, ["filter", "updateKeyChildren", "getCheckedNodes", "setCheckedNodes", "getCheckedKeys", "setCheckedKeys", "setChecked", "getHalfCheckedNodes", "getHalfCheckedKeys", "getCurrentKey", "getCurrentNode", "setCurrentKey", "setCurrentNode", "getNode", "remove", "append", "insertBefore", "insertAfter"]),
            ...Ig(o.value, ["focus", "blur"])
          })
        }
      )),
      ()=>bi(nB, bt({
        ...s,
        ref: e=>o.value = e
      }), {
        ...n,
        default: ()=>[bi(lz, {
          data: l.value
        }), bi(ez, bt({
          ...u,
          ref: e=>a.value = e
        }))]
      })
  }
});
var cz = tS(uz, [["__file", "tree-select.vue"]]);
cz.install = e=>{
  e.component(cz.name, cz)
}
;
const dz = cz
  , fz = Symbol()
  , pz = {
  key: -1,
  level: -1,
  data: {}
};
var hz = (e=>(e.KEY = "id",
  e.LABEL = "label",
  e.CHILDREN = "children",
  e.DISABLED = "disabled",
  e))(hz || {})
  , vz = (e=>(e.ADD = "add",
  e.DELETE = "delete",
  e))(vz || {});
const gz = {
  type: Number,
  default: 26
}
  , mz = uy({
  data: {
    type: Array,
    default: ()=>[]
  },
  emptyText: {
    type: String
  },
  height: {
    type: Number,
    default: 200
  },
  props: {
    type: Object,
    default: ()=>({
      children: "children",
      label: "label",
      disabled: "disabled",
      value: "id"
    })
  },
  highlightCurrent: {
    type: Boolean,
    default: !1
  },
  showCheckbox: {
    type: Boolean,
    default: !1
  },
  defaultCheckedKeys: {
    type: Array,
    default: ()=>[]
  },
  checkStrictly: {
    type: Boolean,
    default: !1
  },
  defaultExpandedKeys: {
    type: Array,
    default: ()=>[]
  },
  indent: {
    type: Number,
    default: 16
  },
  itemSize: gz,
  icon: {
    type: cy
  },
  expandOnClickNode: {
    type: Boolean,
    default: !0
  },
  checkOnClickNode: {
    type: Boolean,
    default: !1
  },
  currentNodeKey: {
    type: [String, Number]
  },
  accordion: {
    type: Boolean,
    default: !1
  },
  filterMethod: {
    type: Function
  },
  perfMode: {
    type: Boolean,
    default: !0
  }
})
  , yz = uy({
  node: {
    type: Object,
    default: ()=>pz
  },
  expanded: {
    type: Boolean,
    default: !1
  },
  checked: {
    type: Boolean,
    default: !1
  },
  indeterminate: {
    type: Boolean,
    default: !1
  },
  showCheckbox: {
    type: Boolean,
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  current: {
    type: Boolean,
    default: !1
  },
  hiddenExpandIcon: {
    type: Boolean,
    default: !1
  },
  itemSize: gz
})
  , bz = uy({
  node: {
    type: Object,
    required: !0
  }
})
  , wz = "node-click"
  , xz = "node-expand"
  , Sz = "node-collapse"
  , Ez = "current-change"
  , Az = "check"
  , Cz = "check-change"
  , kz = "node-contextmenu"
  , Tz = {
  [wz]: (e,t,n)=>e && t && n,
  [xz]: (e,t)=>e && t,
  [Sz]: (e,t)=>e && t,
  [Ez]: (e,t)=>e && t,
  [Az]: (e,t)=>e && t,
  [Cz]: (e,t)=>e && "boolean" == typeof t,
  [kz]: (e,t,n)=>e && t && n
};
function Dz(e, t) {
  const n = Ft(new Set(e.defaultExpandedKeys))
    , r = Ft()
    , o = Bt();
  Jn((()=>e.currentNodeKey), (e=>{
      r.value = e
    }
  ), {
    immediate: !0
  }),
    Jn((()=>e.data), (e=>{
        I(e)
      }
    ), {
      immediate: !0
    });
  const {isIndeterminate: a, isChecked: i, toggleCheckbox: s, getCheckedKeys: l, getCheckedNodes: u, getHalfCheckedKeys: c, getHalfCheckedNodes: d, setChecked: f, setCheckedKeys: p} = function(e, t) {
    const n = Ft(new Set)
      , r = Ft(new Set)
      , {emit: o} = ei();
    Jn([()=>t.value, ()=>e.defaultCheckedKeys], (()=>hn((()=>{
        d(e.defaultCheckedKeys)
      }
    ))), {
      immediate: !0
    });
    const a = ()=>{
        if (!t.value || !e.showCheckbox || e.checkStrictly)
          return;
        const {levelTreeNodeMap: o, maxLevel: a} = t.value
          , i = n.value
          , s = new Set;
        for (let e = a - 1; e >= 1; --e) {
          const t = o.get(e);
          t && t.forEach((e=>{
              const t = e.children;
              if (t) {
                let n = !0
                  , r = !1;
                for (const e of t) {
                  const t = e.key;
                  if (i.has(t))
                    r = !0;
                  else {
                    if (s.has(t)) {
                      n = !1,
                        r = !0;
                      break
                    }
                    n = !1
                  }
                }
                n ? i.add(e.key) : r ? (s.add(e.key),
                  i.delete(e.key)) : (i.delete(e.key),
                  s.delete(e.key))
              }
            }
          ))
        }
        r.value = s
      }
      , i = e=>n.value.has(e.key)
      , s = (t,r,o=!0)=>{
        const i = n.value
          , s = (t,n)=>{
            i[n ? vz.ADD : vz.DELETE](t.key);
            const r = t.children;
            !e.checkStrictly && r && r.forEach((e=>{
                e.disabled || s(e, n)
              }
            ))
          }
        ;
        s(t, r),
          a(),
        o && l(t, r)
      }
      , l = (e,t)=>{
        const {checkedNodes: n, checkedKeys: r} = u()
          , {halfCheckedNodes: a, halfCheckedKeys: i} = c();
        o(Az, e.data, {
          checkedKeys: r,
          checkedNodes: n,
          halfCheckedKeys: i,
          halfCheckedNodes: a
        }),
          o(Cz, e.data, t)
      }
    ;
    function u(r=!1) {
      const o = []
        , a = [];
      if ((null == t ? void 0 : t.value) && e.showCheckbox) {
        const {treeNodeMap: e} = t.value;
        n.value.forEach((t=>{
            const n = e.get(t);
            n && (!r || r && n.isLeaf) && (a.push(t),
              o.push(n.data))
          }
        ))
      }
      return {
        checkedKeys: a,
        checkedNodes: o
      }
    }
    function c() {
      const n = []
        , o = [];
      if ((null == t ? void 0 : t.value) && e.showCheckbox) {
        const {treeNodeMap: e} = t.value;
        r.value.forEach((t=>{
            const r = e.get(t);
            r && (o.push(t),
              n.push(r.data))
          }
        ))
      }
      return {
        halfCheckedNodes: n,
        halfCheckedKeys: o
      }
    }
    function d(n) {
      if (null == t ? void 0 : t.value) {
        const {treeNodeMap: r} = t.value;
        if (e.showCheckbox && r && n)
          for (const e of n) {
            const t = r.get(e);
            t && !i(t) && s(t, !0, !1)
          }
      }
    }
    return {
      updateCheckedKeys: a,
      toggleCheckbox: s,
      isChecked: i,
      isIndeterminate: e=>r.value.has(e.key),
      getCheckedKeys: function(e=!1) {
        return u(e).checkedKeys
      },
      getCheckedNodes: function(e=!1) {
        return u(e).checkedNodes
      },
      getHalfCheckedKeys: function() {
        return c().halfCheckedKeys
      },
      getHalfCheckedNodes: function() {
        return c().halfCheckedNodes
      },
      setChecked: function(n, r) {
        if ((null == t ? void 0 : t.value) && e.showCheckbox) {
          const e = t.value.treeNodeMap.get(n);
          e && s(e, r, !1)
        }
      },
      setCheckedKeys: function(e) {
        n.value.clear(),
          r.value.clear(),
          hn((()=>{
              d(e)
            }
          ))
      }
    }
  }(e, o)
    , {doFilter: h, hiddenNodeKeySet: v, isForceHiddenExpandIcon: g} = function(e, t) {
    const n = Ft(new Set([]))
      , r = Ft(new Set([]))
      , o = yi((()=>y(e.filterMethod)));
    return {
      hiddenExpandIconKeySet: r,
      hiddenNodeKeySet: n,
      doFilter: function(a) {
        var i;
        if (!o.value)
          return;
        const s = new Set
          , l = r.value
          , u = n.value
          , c = []
          , d = (null == (i = t.value) ? void 0 : i.treeNodes) || []
          , f = e.filterMethod;
        return u.clear(),
          function e(t) {
            t.forEach((t=>{
                c.push(t),
                  (null == f ? void 0 : f(a, t.data)) ? c.forEach((e=>{
                      s.add(e.key)
                    }
                  )) : t.isLeaf && u.add(t.key);
                const n = t.children;
                if (n && e(n),
                  !t.isLeaf)
                  if (s.has(t.key)) {
                    if (n) {
                      let e = !0;
                      for (const t of n)
                        if (!u.has(t.key)) {
                          e = !1;
                          break
                        }
                      e ? l.add(t.key) : l.delete(t.key)
                    }
                  } else
                    u.add(t.key);
                c.pop()
              }
            ))
          }(d),
          s
      },
      isForceHiddenExpandIcon: function(e) {
        return r.value.has(e.key)
      }
    }
  }(e, o)
    , m = yi((()=>{
      var t;
      return (null == (t = e.props) ? void 0 : t.value) || hz.KEY
    }
  ))
    , b = yi((()=>{
      var t;
      return (null == (t = e.props) ? void 0 : t.children) || hz.CHILDREN
    }
  ))
    , w = yi((()=>{
      var t;
      return (null == (t = e.props) ? void 0 : t.disabled) || hz.DISABLED
    }
  ))
    , S = yi((()=>{
      var t;
      return (null == (t = e.props) ? void 0 : t.label) || hz.LABEL
    }
  ))
    , E = yi((()=>{
      const e = n.value
        , t = v.value
        , r = []
        , a = o.value && o.value.treeNodes || [];
      return function() {
        const n = [];
        for (let e = a.length - 1; e >= 0; --e)
          n.push(a[e]);
        for (; n.length; ) {
          const o = n.pop();
          if (o && (t.has(o.key) || r.push(o),
            e.has(o.key))) {
            const e = o.children;
            if (e) {
              for (let t = e.length - 1; t >= 0; --t)
                n.push(e[t])
            }
          }
        }
      }(),
        r
    }
  ))
    , A = yi((()=>E.value.length > 0));
  function C(e) {
    return e[b.value]
  }
  function k(e) {
    return e ? e[m.value] : ""
  }
  function T(e) {
    return e[w.value]
  }
  function D(e) {
    return e[S.value]
  }
  function O(e) {
    n.value.has(e.key) ? R(e) : _(e)
  }
  function _(r) {
    const a = n.value;
    if (o.value && e.accordion) {
      const {treeNodeMap: e} = o.value;
      a.forEach((t=>{
          const n = e.get(t);
          r && r.level === (null == n ? void 0 : n.level) && a.delete(t)
        }
      ))
    }
    a.add(r.key),
      t(xz, r.data, r)
  }
  function R(e) {
    n.value.delete(e.key),
      t(Sz, e.data, e)
  }
  function L(e) {
    const t = r.value;
    return void 0 !== t && t === e.key
  }
  function I(e) {
    hn((()=>o.value = function(e) {
      const t = new Map
        , n = new Map;
      let r = 1;
      const o = function e(o, a=1, i) {
        var s;
        const l = [];
        for (const r of o) {
          const o = k(r)
            , u = {
            level: a,
            key: o,
            data: r
          };
          u.label = D(r),
            u.parent = i;
          const c = C(r);
          u.disabled = T(r),
            u.isLeaf = !c || 0 === c.length,
          c && c.length && (u.children = e(c, a + 1, u)),
            l.push(u),
            t.set(o, u),
          n.has(a) || n.set(a, []),
          null == (s = n.get(a)) || s.push(u)
        }
        return a > r && (r = a),
          l
      }(e);
      return {
        treeNodeMap: t,
        levelTreeNodeMap: n,
        maxLevel: r,
        treeNodes: o
      }
    }(e)))
  }
  return {
    tree: o,
    flattenTree: E,
    isNotEmpty: A,
    getKey: k,
    getChildren: C,
    toggleExpand: O,
    toggleCheckbox: s,
    isExpanded: function(e) {
      return n.value.has(e.key)
    },
    isChecked: i,
    isIndeterminate: a,
    isDisabled: function(e) {
      return !!e.disabled
    },
    isCurrent: L,
    isForceHiddenExpandIcon: g,
    handleNodeClick: function(n, o) {
      t(wz, n.data, n, o),
        function(e) {
          L(e) || (r.value = e.key,
            t(Ez, e.data, e))
        }(n),
      e.expandOnClickNode && O(n),
      e.showCheckbox && e.checkOnClickNode && !n.disabled && s(n, !i(n), !0)
    },
    handleNodeCheck: function(e, t) {
      s(e, t)
    },
    getCurrentNode: function() {
      var e, t;
      if (r.value)
        return null == (t = null == (e = o.value) ? void 0 : e.treeNodeMap.get(r.value)) ? void 0 : t.data
    },
    getCurrentKey: function() {
      return r.value
    },
    setCurrentKey: function(e) {
      r.value = e
    },
    getCheckedKeys: l,
    getCheckedNodes: u,
    getHalfCheckedKeys: c,
    getHalfCheckedNodes: d,
    setChecked: f,
    setCheckedKeys: p,
    filter: function(e) {
      const t = h(e);
      t && (n.value = t)
    },
    setData: I,
    getNode: function(e) {
      var t;
      const n = x(e) ? k(e) : e;
      return null == (t = o.value) ? void 0 : t.treeNodeMap.get(n)
    },
    expandNode: _,
    collapseNode: R,
    setExpandedKeys: function(e) {
      n.value = new Set(e)
    }
  }
}
var Oz = vr({
  name: "ElTreeNodeContent",
  props: bz,
  setup(e) {
    const t = jo(fz)
      , n = qy("tree");
    return ()=>{
      const r = e.node
        , {data: o} = r;
      return (null == t ? void 0 : t.ctx.slots.default) ? t.ctx.slots.default({
        node: r,
        data: o
      }) : bi("span", {
        class: n.be("node", "label")
      }, [null == r ? void 0 : r.label])
    }
  }
});
const _z = ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick"]
  , Rz = vr({
  name: "ElTreeNode"
})
  , Lz = vr({
  ...Rz,
  props: yz,
  emits: {
    click: (e,t)=>!(!e || !t),
    toggle: e=>!!e,
    check: (e,t)=>e && "boolean" == typeof t
  },
  setup(e, {emit: t}) {
    const n = e
      , r = jo(fz)
      , o = qy("tree")
      , a = yi((()=>{
          var e;
          return null != (e = null == r ? void 0 : r.props.indent) ? e : 16
        }
      ))
      , i = yi((()=>{
          var e;
          return null != (e = null == r ? void 0 : r.props.icon) ? e : wm
        }
      ))
      , s = e=>{
        t("click", n.node, e)
      }
      , l = ()=>{
        t("toggle", n.node)
      }
      , u = e=>{
        t("check", n.node, e)
      }
      , c = e=>{
        var t, o, a, i;
        (null == (a = null == (o = null == (t = null == r ? void 0 : r.instance) ? void 0 : t.vnode) ? void 0 : o.props) ? void 0 : a.onNodeContextmenu) && (e.stopPropagation(),
          e.preventDefault()),
        null == r || r.ctx.emit(kz, e, null == (i = n.node) ? void 0 : i.data, n.node)
      }
    ;
    return (e,t)=>{
      var n, r, d;
      return Ca(),
        _a("div", {
          ref: "node$",
          class: Y([Vt(o).b("node"), Vt(o).is("expanded", e.expanded), Vt(o).is("current", e.current), Vt(o).is("focusable", !e.disabled), Vt(o).is("checked", !e.disabled && e.checked)]),
          role: "treeitem",
          tabindex: "-1",
          "aria-expanded": e.expanded,
          "aria-disabled": e.disabled,
          "aria-checked": e.checked,
          "data-key": null == (n = e.node) ? void 0 : n.key,
          onClick: js(s, ["stop"]),
          onContextmenu: c
        }, [Ma("div", {
          class: Y(Vt(o).be("node", "content")),
          style: z({
            paddingLeft: (e.node.level - 1) * Vt(a) + "px",
            height: e.itemSize + "px"
          })
        }, [Vt(i) ? (Ca(),
          Ra(Vt(sS), {
            key: 0,
            class: Y([Vt(o).is("leaf", !!(null == (r = e.node) ? void 0 : r.isLeaf)), Vt(o).is("hidden", e.hiddenExpandIcon), {
              expanded: !(null == (d = e.node) ? void 0 : d.isLeaf) && e.expanded
            }, Vt(o).be("node", "expand-icon")]),
            onClick: js(l, ["stop"])
          }, {
            default: Fn((()=>[(Ca(),
              Ra(Kr(Vt(i))))])),
            _: 1
          }, 8, ["class", "onClick"])) : za("v-if", !0), e.showCheckbox ? (Ca(),
          Ra(Vt(AD), {
            key: 1,
            "model-value": e.checked,
            indeterminate: e.indeterminate,
            disabled: e.disabled,
            onChange: u,
            onClick: t[0] || (t[0] = js((()=>{}
            ), ["stop"]))
          }, null, 8, ["model-value", "indeterminate", "disabled"])) : za("v-if", !0), ja(Vt(Oz), {
          node: e.node
        }, null, 8, ["node"])], 6)], 42, _z)
    }
  }
});
var Iz = tS(Lz, [["__file", "tree-node.vue"]]);
const Pz = vr({
  name: "ElTreeV2"
})
  , Fz = vr({
  ...Pz,
  props: mz,
  emits: Tz,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = po()
      , a = yi((()=>r.itemSize));
    Mo(fz, {
      ctx: {
        emit: n,
        slots: o
      },
      props: r,
      instance: ei()
    }),
      Mo(pS, void 0);
    const {t: i} = Hy()
      , s = qy("tree")
      , {flattenTree: l, isNotEmpty: u, toggleExpand: c, isExpanded: d, isIndeterminate: f, isChecked: p, isDisabled: h, isCurrent: v, isForceHiddenExpandIcon: g, handleNodeClick: m, handleNodeCheck: y, toggleCheckbox: b, getCurrentNode: w, getCurrentKey: x, setCurrentKey: S, getCheckedKeys: E, getCheckedNodes: A, getHalfCheckedKeys: C, getHalfCheckedNodes: k, setChecked: T, setCheckedKeys: D, filter: O, setData: _, getNode: R, expandNode: L, collapseNode: I, setExpandedKeys: P} = Dz(r, n);
    return t({
      toggleCheckbox: b,
      getCurrentNode: w,
      getCurrentKey: x,
      setCurrentKey: S,
      getCheckedKeys: E,
      getCheckedNodes: A,
      getHalfCheckedKeys: C,
      getHalfCheckedNodes: k,
      setChecked: T,
      setCheckedKeys: D,
      filter: O,
      setData: _,
      getNode: R,
      expandNode: L,
      collapseNode: I,
      setExpandedKeys: P
    }),
      (e,t)=>{
        var n;
        return Ca(),
          _a("div", {
            class: Y([Vt(s).b(), {
              [Vt(s).m("highlight-current")]: e.highlightCurrent
            }]),
            role: "tree"
          }, [Vt(u) ? (Ca(),
            Ra(Vt(rM), {
              key: 0,
              "class-name": Vt(s).b("virtual-list"),
              data: Vt(l),
              total: Vt(l).length,
              height: e.height,
              "item-size": Vt(a),
              "perf-mode": e.perfMode
            }, {
              default: Fn((({data: t, index: n, style: r})=>[(Ca(),
                Ra(Iz, {
                  key: t[n].key,
                  style: z(r),
                  node: t[n],
                  expanded: Vt(d)(t[n]),
                  "show-checkbox": e.showCheckbox,
                  checked: Vt(p)(t[n]),
                  indeterminate: Vt(f)(t[n]),
                  "item-size": Vt(a),
                  disabled: Vt(h)(t[n]),
                  current: Vt(v)(t[n]),
                  "hidden-expand-icon": Vt(g)(t[n]),
                  onClick: Vt(m),
                  onToggle: Vt(c),
                  onCheck: Vt(y)
                }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck"]))])),
              _: 1
            }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode"])) : (Ca(),
            _a("div", {
              key: 1,
              class: Y(Vt(s).e("empty-block"))
            }, [Ma("span", {
              class: Y(Vt(s).e("empty-text"))
            }, te(null != (n = e.emptyText) ? n : Vt(i)("el.tree.emptyText")), 3)], 2))], 2)
      }
  }
});
const Bz = vy(tS(Fz, [["__file", "tree.vue"]]))
  , Nz = Symbol("uploadContextKey");
class Mz extends Error {
  constructor(e, t, n, r) {
    super(e),
      this.name = "UploadAjaxError",
      this.status = t,
      this.method = n,
      this.url = r
  }
}
function jz(e, t, n) {
  let r;
  return r = n.response ? `${n.response.error || n.response}` : n.responseText ? `${n.responseText}` : `fail to ${t.method} ${e} ${n.status}`,
    new Mz(r,n.status,t.method,e)
}
const Vz = ["text", "picture", "picture-card"];
let Uz = 1;
const $z = ()=>Date.now() + Uz++
  , Hz = uy({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: Object
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: [Object, Function, Promise],
    default: ()=>({})
  },
  multiple: {
    type: Boolean,
    default: !1
  },
  name: {
    type: String,
    default: "file"
  },
  drag: {
    type: Boolean,
    default: !1
  },
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: !0
  },
  accept: {
    type: String,
    default: ""
  },
  fileList: {
    type: Array,
    default: ()=>[]
  },
  autoUpload: {
    type: Boolean,
    default: !0
  },
  listType: {
    type: String,
    values: Vz,
    default: "text"
  },
  httpRequest: {
    type: Function,
    default: e=>{
      "undefined" == typeof XMLHttpRequest && Jg("ElUpload", "XMLHttpRequest is undefined");
      const t = new XMLHttpRequest
        , n = e.action;
      t.upload && t.upload.addEventListener("progress", (t=>{
          const n = t;
          n.percent = t.total > 0 ? t.loaded / t.total * 100 : 0,
            e.onProgress(n)
        }
      ));
      const r = new FormData;
      if (e.data)
        for (const [a,i] of Object.entries(e.data))
          h(i) && i.length ? r.append(a, ...i) : r.append(a, i);
      r.append(e.filename, e.file, e.file.name),
        t.addEventListener("error", (()=>{
            e.onError(jz(n, e, t))
          }
        )),
        t.addEventListener("load", (()=>{
            if (t.status < 200 || t.status >= 300)
              return e.onError(jz(n, e, t));
            e.onSuccess(function(e) {
              const t = e.responseText || e.response;
              if (!t)
                return t;
              try {
                return JSON.parse(t)
              } catch (Y_) {
                return t
              }
            }(t))
          }
        )),
        t.open(e.method, n, !0),
      e.withCredentials && "withCredentials"in t && (t.withCredentials = !0);
      const o = e.headers || {};
      if (o instanceof Headers)
        o.forEach(((e,n)=>t.setRequestHeader(n, e)));
      else
        for (const [a,i] of Object.entries(o))
          Cg(i) || t.setRequestHeader(a, String(i));
      return t.send(r),
        t
    }
  },
  disabled: Boolean,
  limit: Number
})
  , zz = uy({
  ...Hz,
  beforeUpload: {
    type: Function,
    default: a
  },
  beforeRemove: {
    type: Function
  },
  onRemove: {
    type: Function,
    default: a
  },
  onChange: {
    type: Function,
    default: a
  },
  onPreview: {
    type: Function,
    default: a
  },
  onSuccess: {
    type: Function,
    default: a
  },
  onProgress: {
    type: Function,
    default: a
  },
  onError: {
    type: Function,
    default: a
  },
  onExceed: {
    type: Function,
    default: a
  },
  crossorigin: {
    type: String
  }
})
  , Kz = uy({
  files: {
    type: Array,
    default: ()=>[]
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  handlePreview: {
    type: Function,
    default: a
  },
  listType: {
    type: String,
    values: Vz,
    default: "text"
  },
  crossorigin: {
    type: String
  }
})
  , Wz = ["onKeydown"]
  , Gz = ["src", "crossorigin"]
  , qz = ["onClick"]
  , Yz = ["title"]
  , Xz = ["onClick"]
  , Qz = ["onClick"]
  , Jz = vr({
  name: "ElUploadList"
})
  , Zz = vr({
  ...Jz,
  props: Kz,
  emits: {
    remove: e=>!!e
  },
  setup(e, {emit: t}) {
    const n = e
      , {t: r} = Hy()
      , o = qy("upload")
      , a = qy("icon")
      , i = qy("list")
      , s = vS()
      , l = Ft(!1)
      , u = yi((()=>[o.b("list"), o.bm("list", n.listType), o.is("disabled", n.disabled)]))
      , c = e=>{
        t("remove", e)
      }
    ;
    return (e,t)=>(Ca(),
      Ra(bs, {
        tag: "ul",
        class: Y(Vt(u)),
        name: Vt(i).b()
      }, {
        default: Fn((()=>[(Ca(!0),
          _a(ba, null, Yr(e.files, (n=>(Ca(),
            _a("li", {
              key: n.uid || n.name,
              class: Y([Vt(o).be("list", "item"), Vt(o).is(n.status), {
                focusing: l.value
              }]),
              tabindex: "0",
              onKeydown: Us((e=>!Vt(s) && c(n)), ["delete"]),
              onFocus: t[0] || (t[0] = e=>l.value = !0),
              onBlur: t[1] || (t[1] = e=>l.value = !1),
              onClick: t[2] || (t[2] = e=>l.value = !1)
            }, [Qr(e.$slots, "default", {
              file: n
            }, (()=>["picture" === e.listType || "uploading" !== n.status && "picture-card" === e.listType ? (Ca(),
              _a("img", {
                key: 0,
                class: Y(Vt(o).be("list", "item-thumbnail")),
                src: n.url,
                crossorigin: e.crossorigin,
                alt: ""
              }, null, 10, Gz)) : za("v-if", !0), "uploading" === n.status || "picture-card" !== e.listType ? (Ca(),
              _a("div", {
                key: 1,
                class: Y(Vt(o).be("list", "item-info"))
              }, [Ma("a", {
                class: Y(Vt(o).be("list", "item-name")),
                onClick: js((t=>e.handlePreview(n)), ["prevent"])
              }, [ja(Vt(sS), {
                class: Y(Vt(a).m("document"))
              }, {
                default: Fn((()=>[ja(Vt(Lm))])),
                _: 1
              }, 8, ["class"]), Ma("span", {
                class: Y(Vt(o).be("list", "item-file-name")),
                title: n.name
              }, te(n.name), 11, Yz)], 10, qz), "uploading" === n.status ? (Ca(),
                Ra(Vt(rN), {
                  key: 0,
                  type: "picture-card" === e.listType ? "circle" : "line",
                  "stroke-width": "picture-card" === e.listType ? 6 : 2,
                  percentage: Number(n.percentage),
                  style: z("picture-card" === e.listType ? "" : "margin-top: 0.5rem")
                }, null, 8, ["type", "stroke-width", "percentage", "style"])) : za("v-if", !0)], 2)) : za("v-if", !0), Ma("label", {
              class: Y(Vt(o).be("list", "item-status-label"))
            }, ["text" === e.listType ? (Ca(),
              Ra(Vt(sS), {
                key: 0,
                class: Y([Vt(a).m("upload-success"), Vt(a).m("circle-check")])
              }, {
                default: Fn((()=>[ja(Vt(Am))])),
                _: 1
              }, 8, ["class"])) : ["picture-card", "picture"].includes(e.listType) ? (Ca(),
              Ra(Vt(sS), {
                key: 1,
                class: Y([Vt(a).m("upload-success"), Vt(a).m("check")])
              }, {
                default: Fn((()=>[ja(Vt(Sm))])),
                _: 1
              }, 8, ["class"])) : za("v-if", !0)], 2), Vt(s) ? za("v-if", !0) : (Ca(),
              Ra(Vt(sS), {
                key: 2,
                class: Y(Vt(a).m("close")),
                onClick: e=>c(n)
              }, {
                default: Fn((()=>[ja(Vt(Dm))])),
                _: 2
              }, 1032, ["class", "onClick"])), za(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"), za(" This is a bug which needs to be fixed "), za(" TODO: Fix the incorrect navigation interaction "), Vt(s) ? za("v-if", !0) : (Ca(),
              _a("i", {
                key: 3,
                class: Y(Vt(a).m("close-tip"))
              }, te(Vt(r)("el.upload.deleteTip")), 3)), "picture-card" === e.listType ? (Ca(),
              _a("span", {
                key: 4,
                class: Y(Vt(o).be("list", "item-actions"))
              }, [Ma("span", {
                class: Y(Vt(o).be("list", "item-preview")),
                onClick: t=>e.handlePreview(n)
              }, [ja(Vt(sS), {
                class: Y(Vt(a).m("zoom-in"))
              }, {
                default: Fn((()=>[ja(Vt(ay))])),
                _: 1
              }, 8, ["class"])], 10, Xz), Vt(s) ? za("v-if", !0) : (Ca(),
                _a("span", {
                  key: 0,
                  class: Y(Vt(o).be("list", "item-delete")),
                  onClick: e=>c(n)
                }, [ja(Vt(sS), {
                  class: Y(Vt(a).m("delete"))
                }, {
                  default: Fn((()=>[ja(Vt(Rm))])),
                  _: 1
                }, 8, ["class"])], 10, Qz))], 2)) : za("v-if", !0)]))], 42, Wz)))), 128)), Qr(e.$slots, "append")])),
        _: 3
      }, 8, ["class", "name"]))
  }
});
var eK = tS(Zz, [["__file", "upload-list.vue"]]);
const tK = uy({
  disabled: {
    type: Boolean,
    default: !1
  }
})
  , nK = {
  file: e=>h(e)
}
  , rK = ["onDrop", "onDragover"]
  , oK = "ElUploadDrag"
  , aK = vr({
  name: oK
})
  , iK = vr({
  ...aK,
  props: tK,
  emits: nK,
  setup(e, {emit: t}) {
    jo(Nz) || Jg(oK, "usage: <el-upload><el-upload-dragger /></el-upload>");
    const n = qy("upload")
      , r = Ft(!1)
      , o = vS()
      , a = e=>{
        if (o.value)
          return;
        r.value = !1,
          e.stopPropagation();
        const n = Array.from(e.dataTransfer.files);
        t("file", n)
      }
      , i = ()=>{
        o.value || (r.value = !0)
      }
    ;
    return (e,t)=>(Ca(),
      _a("div", {
        class: Y([Vt(n).b("dragger"), Vt(n).is("dragover", r.value)]),
        onDrop: js(a, ["prevent"]),
        onDragover: js(i, ["prevent"]),
        onDragleave: t[0] || (t[0] = js((e=>r.value = !1), ["prevent"]))
      }, [Qr(e.$slots, "default")], 42, rK))
  }
});
var sK = tS(iK, [["__file", "upload-dragger.vue"]]);
const lK = uy({
  ...Hz,
  beforeUpload: {
    type: Function,
    default: a
  },
  onRemove: {
    type: Function,
    default: a
  },
  onStart: {
    type: Function,
    default: a
  },
  onSuccess: {
    type: Function,
    default: a
  },
  onProgress: {
    type: Function,
    default: a
  },
  onError: {
    type: Function,
    default: a
  },
  onExceed: {
    type: Function,
    default: a
  }
})
  , uK = ["onKeydown"]
  , cK = ["name", "multiple", "accept"]
  , dK = vr({
  name: "ElUploadContent",
  inheritAttrs: !1
})
  , fK = vr({
  ...dK,
  props: lK,
  setup(e, {expose: t}) {
    const n = e
      , r = qy("upload")
      , o = vS()
      , a = Bt({})
      , i = Bt()
      , s = e=>{
        if (0 === e.length)
          return;
        const {autoUpload: t, limit: r, fileList: o, multiple: a, onStart: i, onExceed: s} = n;
        if (r && o.length + e.length > r)
          s(e, o);
        else {
          a || (e = e.slice(0, 1));
          for (const n of e) {
            const e = n;
            e.uid = $z(),
              i(e),
            t && l(e)
          }
        }
      }
      , l = async e=>{
        if (i.value.value = "",
          !n.beforeUpload)
          return u(e);
        let t, r = {};
        try {
          const o = n.data
            , a = n.beforeUpload(e);
          r = k(n.data) ? dv(n.data) : n.data,
            t = await a,
          k(n.data) && Ag(o, r) && (r = dv(n.data))
        } catch (Y_) {
          t = !1
        }
        if (!1 === t)
          return void n.onRemove(e);
        let o = e;
        t instanceof Blob && (o = t instanceof File ? t : new File([t],e.name,{
          type: e.type
        })),
          u(Object.assign(o, {
            uid: e.uid
          }), r)
      }
      , u = async(e,t)=>{
        const {headers: r, data: o, method: i, withCredentials: s, name: l, action: u, onProgress: c, onSuccess: d, onError: f, httpRequest: p} = n;
        try {
          t = await (async(e,t)=>y(e) ? e(t) : e)(null != t ? t : o, e)
        } catch (Y_) {
          return void n.onRemove(e)
        }
        const {uid: h} = e
          , v = {
          headers: r || {},
          withCredentials: s,
          file: e,
          data: t,
          method: i,
          filename: l,
          action: u,
          onProgress: t=>{
            c(t, e)
          }
          ,
          onSuccess: t=>{
            d(t, e),
              delete a.value[h]
          }
          ,
          onError: t=>{
            f(t, e),
              delete a.value[h]
          }
        }
          , g = p(v);
        a.value[h] = g,
        g instanceof Promise && g.then(v.onSuccess, v.onError)
      }
      , c = e=>{
        const t = e.target.files;
        t && s(Array.from(t))
      }
      , d = ()=>{
        o.value || (i.value.value = "",
          i.value.click())
      }
      , f = ()=>{
        d()
      }
    ;
    return t({
      abort: e=>{
        const t = (n = a.value,
          Object.entries(n)).filter(e ? ([t])=>String(e.uid) === t : ()=>!0);
        var n;
        t.forEach((([e,t])=>{
            t instanceof XMLHttpRequest && t.abort(),
              delete a.value[e]
          }
        ))
      }
      ,
      upload: l
    }),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y([Vt(r).b(), Vt(r).m(e.listType), Vt(r).is("drag", e.drag)]),
          tabindex: "0",
          onClick: d,
          onKeydown: Us(js(f, ["self"]), ["enter", "space"])
        }, [e.drag ? (Ca(),
          Ra(sK, {
            key: 0,
            disabled: Vt(o),
            onFile: s
          }, {
            default: Fn((()=>[Qr(e.$slots, "default")])),
            _: 3
          }, 8, ["disabled"])) : Qr(e.$slots, "default", {
          key: 1
        }), Ma("input", {
          ref_key: "inputRef",
          ref: i,
          class: Y(Vt(r).e("input")),
          name: e.name,
          multiple: e.multiple,
          accept: e.accept,
          type: "file",
          onChange: c,
          onClick: t[0] || (t[0] = js((()=>{}
          ), ["stop"]))
        }, null, 42, cK)], 42, uK))
  }
});
var pK = tS(fK, [["__file", "upload-content.vue"]]);
const hK = "ElUpload"
  , vK = e=>{
  var t;
  (null == (t = e.url) ? void 0 : t.startsWith("blob:")) && URL.revokeObjectURL(e.url)
}
  , gK = vr({
  name: "ElUpload"
});
const mK = vy(tS(vr({
  ...gK,
  props: zz,
  setup(e, {expose: t}) {
    const n = e
      , r = vS()
      , o = Bt()
      , {abort: a, submit: i, clearFiles: s, uploadFiles: l, handleStart: u, handleError: c, handleRemove: d, handleSuccess: f, handleProgress: p, revokeFileObjectURL: h} = ((e,t)=>{
        const n = ed(e, "fileList", void 0, {
          passive: !0
        })
          , r = e=>n.value.find((t=>t.uid === e.uid));
        function o(e) {
          var n;
          null == (n = t.value) || n.abort(e)
        }
        return Jn((()=>e.listType), (t=>{
            "picture-card" !== t && "picture" !== t || (n.value = n.value.map((t=>{
                const {raw: r, url: o} = t;
                if (!o && r)
                  try {
                    t.url = URL.createObjectURL(r)
                  } catch (a) {
                    e.onError(a, t, n.value)
                  }
                return t
              }
            )))
          }
        )),
          Jn(n, (e=>{
              for (const t of e)
                t.uid || (t.uid = $z()),
                t.status || (t.status = "success")
            }
          ), {
            immediate: !0,
            deep: !0
          }),
          {
            uploadFiles: n,
            abort: o,
            clearFiles: function(e=["ready", "uploading", "success", "fail"]) {
              n.value = n.value.filter((t=>!e.includes(t.status)))
            },
            handleError: (t,o)=>{
              const a = r(o);
              a && (console.error(t),
                a.status = "fail",
                n.value.splice(n.value.indexOf(a), 1),
                e.onError(t, a, n.value),
                e.onChange(a, n.value))
            }
            ,
            handleProgress: (t,o)=>{
              const a = r(o);
              a && (e.onProgress(t, a, n.value),
                a.status = "uploading",
                a.percentage = Math.round(t.percent))
            }
            ,
            handleStart: t=>{
              Cg(t.uid) && (t.uid = $z());
              const r = {
                name: t.name,
                percentage: 0,
                status: "ready",
                size: t.size,
                raw: t,
                uid: t.uid
              };
              if ("picture-card" === e.listType || "picture" === e.listType)
                try {
                  r.url = URL.createObjectURL(t)
                } catch (o) {
                  o.message,
                    e.onError(o, r, n.value)
                }
              n.value = [...n.value, r],
                e.onChange(r, n.value)
            }
            ,
            handleSuccess: (t,o)=>{
              const a = r(o);
              a && (a.status = "success",
                a.response = t,
                e.onSuccess(t, a, n.value),
                e.onChange(a, n.value))
            }
            ,
            handleRemove: async t=>{
              const a = t instanceof File ? r(t) : t;
              a || Jg(hK, "file to be removed not found");
              const i = t=>{
                  o(t);
                  const r = n.value;
                  r.splice(r.indexOf(t), 1),
                    e.onRemove(t, r),
                    vK(t)
                }
              ;
              e.beforeRemove ? !1 !== await e.beforeRemove(a, n.value) && i(a) : i(a)
            }
            ,
            submit: function() {
              n.value.filter((({status: e})=>"ready" === e)).forEach((({raw: e})=>{
                  var n;
                  return e && (null == (n = t.value) ? void 0 : n.upload(e))
                }
              ))
            },
            revokeFileObjectURL: vK
          }
      }
    )(n, o)
      , v = yi((()=>"picture-card" === n.listType))
      , g = yi((()=>({
      ...n,
      fileList: l.value,
      onStart: u,
      onProgress: p,
      onSuccess: f,
      onError: c,
      onRemove: d
    })));
    return Fr((()=>{
        l.value.forEach(h)
      }
    )),
      Mo(Nz, {
        accept: Yt(n, "accept")
      }),
      t({
        abort: a,
        submit: i,
        clearFiles: s,
        handleStart: u,
        handleRemove: d
      }),
      (e,t)=>(Ca(),
        _a("div", null, [Vt(v) && e.showFileList ? (Ca(),
          Ra(eK, {
            key: 0,
            disabled: Vt(r),
            "list-type": e.listType,
            files: Vt(l),
            crossorigin: e.crossorigin,
            "handle-preview": e.onPreview,
            onRemove: Vt(d)
          }, Xr({
            append: Fn((()=>[ja(pK, qa({
              ref_key: "uploadRef",
              ref: o
            }, Vt(g)), {
              default: Fn((()=>[e.$slots.trigger ? Qr(e.$slots, "trigger", {
                key: 0
              }) : za("v-if", !0), !e.$slots.trigger && e.$slots.default ? Qr(e.$slots, "default", {
                key: 1
              }) : za("v-if", !0)])),
              _: 3
            }, 16)])),
            _: 2
          }, [e.$slots.file ? {
            name: "default",
            fn: Fn((({file: t})=>[Qr(e.$slots, "file", {
              file: t
            })]))
          } : void 0]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : za("v-if", !0), !Vt(v) || Vt(v) && !e.showFileList ? (Ca(),
          Ra(pK, qa({
            key: 1,
            ref_key: "uploadRef",
            ref: o
          }, Vt(g)), {
            default: Fn((()=>[e.$slots.trigger ? Qr(e.$slots, "trigger", {
              key: 0
            }) : za("v-if", !0), !e.$slots.trigger && e.$slots.default ? Qr(e.$slots, "default", {
              key: 1
            }) : za("v-if", !0)])),
            _: 3
          }, 16)) : za("v-if", !0), e.$slots.trigger ? Qr(e.$slots, "default", {
          key: 2
        }) : za("v-if", !0), Qr(e.$slots, "tip"), !Vt(v) && e.showFileList ? (Ca(),
          Ra(eK, {
            key: 3,
            disabled: Vt(r),
            "list-type": e.listType,
            files: Vt(l),
            crossorigin: e.crossorigin,
            "handle-preview": e.onPreview,
            onRemove: Vt(d)
          }, Xr({
            _: 2
          }, [e.$slots.file ? {
            name: "default",
            fn: Fn((({file: t})=>[Qr(e.$slots, "file", {
              file: t
            })]))
          } : void 0]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : za("v-if", !0)]))
  }
}), [["__file", "upload.vue"]]))
  , yK = uy({
  zIndex: {
    type: Number,
    default: 9
  },
  rotate: {
    type: Number,
    default: -22
  },
  width: Number,
  height: Number,
  image: String,
  content: {
    type: [String, Array],
    default: "Element Plus"
  },
  font: {
    type: Object
  },
  gap: {
    type: Array,
    default: ()=>[100, 100]
  },
  offset: {
    type: Array
  }
});
function bK(e, t, n=1) {
  const r = document.createElement("canvas")
    , o = r.getContext("2d")
    , a = e * n
    , i = t * n;
  return r.setAttribute("width", `${a}px`),
    r.setAttribute("height", `${i}px`),
    o.save(),
    [o, r, a, i]
}
function wK() {
  return function(e, t, n, r, o, a, i, s) {
    const [l,u,c,d] = bK(r, o, n);
    if (e instanceof HTMLImageElement)
      l.drawImage(e, 0, 0, c, d);
    else {
      const {color: t, fontSize: r, fontStyle: i, fontWeight: s, fontFamily: u, textAlign: d, textBaseline: f} = a
        , p = Number(r) * n;
      l.font = `${i} normal ${s} ${p}px/${o}px ${u}`,
        l.fillStyle = t,
        l.textAlign = d,
        l.textBaseline = f;
      const h = Array.isArray(e) ? e : [e];
      null == h || h.forEach(((e,t)=>{
          l.fillText(null != e ? e : "", c / 2, t * (p + 3 * n))
        }
      ))
    }
    const f = Math.PI / 180 * Number(t)
      , p = Math.max(r, o)
      , [h,v,g] = bK(p, p, n);
    h.translate(g / 2, g / 2),
      h.rotate(f),
    c > 0 && d > 0 && h.drawImage(u, -c / 2, -d / 2);
    let m = 0
      , y = 0
      , b = 0
      , w = 0;
    const x = c / 2
      , S = d / 2;
    [[0 - x, 0 - S], [0 + x, 0 - S], [0 + x, 0 + S], [0 - x, 0 + S]].forEach((([e,t])=>{
        const [n,r] = function(e, t) {
          return [e * Math.cos(f) - t * Math.sin(f), e * Math.sin(f) + t * Math.cos(f)]
        }(e, t);
        m = Math.min(m, n),
          y = Math.max(y, n),
          b = Math.min(b, r),
          w = Math.max(w, r)
      }
    ));
    const E = m + g / 2
      , A = b + g / 2
      , C = y - m
      , k = w - b
      , T = i * n
      , D = s * n
      , O = 2 * (C + T)
      , _ = k + D
      , [R,L] = bK(O, _);
    function I(e=0, t=0) {
      R.drawImage(v, E, A, C, k, e, t, C, k)
    }
    return I(),
      I(C + T, -k / 2 - D / 2),
      I(C + T, +k / 2 + D / 2),
      [L.toDataURL(), O / n, _ / n]
  }
}
const xK = vr({
  name: "ElWatermark"
});
const SK = vy(tS(vr({
  ...xK,
  props: yK,
  setup(e) {
    const t = e
      , n = {
        position: "relative"
      }
      , r = yi((()=>{
          var e, n;
          return null != (n = null == (e = t.font) ? void 0 : e.color) ? n : "rgba(0,0,0,.15)"
        }
      ))
      , o = yi((()=>{
          var e, n;
          return null != (n = null == (e = t.font) ? void 0 : e.fontSize) ? n : 16
        }
      ))
      , a = yi((()=>{
          var e, n;
          return null != (n = null == (e = t.font) ? void 0 : e.fontWeight) ? n : "normal"
        }
      ))
      , i = yi((()=>{
          var e, n;
          return null != (n = null == (e = t.font) ? void 0 : e.fontStyle) ? n : "normal"
        }
      ))
      , s = yi((()=>{
          var e, n;
          return null != (n = null == (e = t.font) ? void 0 : e.fontFamily) ? n : "sans-serif"
        }
      ))
      , l = yi((()=>{
          var e, n;
          return null != (n = null == (e = t.font) ? void 0 : e.textAlign) ? n : "center"
        }
      ))
      , u = yi((()=>{
          var e, n;
          return null != (n = null == (e = t.font) ? void 0 : e.textBaseline) ? n : "top"
        }
      ))
      , c = yi((()=>t.gap[0]))
      , d = yi((()=>t.gap[1]))
      , f = yi((()=>c.value / 2))
      , p = yi((()=>d.value / 2))
      , h = yi((()=>{
          var e, n;
          return null != (n = null == (e = t.offset) ? void 0 : e[0]) ? n : f.value
        }
      ))
      , v = yi((()=>{
          var e, n;
          return null != (n = null == (e = t.offset) ? void 0 : e[1]) ? n : p.value
        }
      ))
      , g = ()=>{
        const e = {
          zIndex: t.zIndex,
          position: "absolute",
          left: 0,
          top: 0,
          width: "100%",
          height: "100%",
          pointerEvents: "none",
          backgroundRepeat: "repeat"
        };
        let n = h.value - f.value
          , r = v.value - p.value;
        return n > 0 && (e.left = `${n}px`,
          e.width = `calc(100% - ${n}px)`,
          n = 0),
        r > 0 && (e.top = `${r}px`,
          e.height = `calc(100% - ${r}px)`,
          r = 0),
          e.backgroundPosition = `${n}px ${r}px`,
          e
      }
      , m = Bt(null)
      , y = Bt()
      , b = Ft(!1)
      , w = ()=>{
        y.value && (y.value.remove(),
          y.value = void 0)
      }
      , x = (e,t)=>{
        var n;
        m.value && y.value && (b.value = !0,
          y.value.setAttribute("style", function(e) {
            return Object.keys(e).map((t=>`${function(e) {
              return e.replace(/([A-Z])/g, "-$1").toLowerCase()
            }(t)}: ${e[t]};`)).join(" ")
          }({
            ...g(),
            backgroundImage: `url('${e}')`,
            backgroundSize: `${Math.floor(t)}px`
          })),
        null == (n = m.value) || n.append(y.value),
          setTimeout((()=>{
              b.value = !1
            }
          )))
      }
      , S = wK()
      , E = ()=>{
        const e = document.createElement("canvas").getContext("2d")
          , n = t.image
          , f = t.content
          , p = t.rotate;
        if (e) {
          y.value || (y.value = document.createElement("div"));
          const h = window.devicePixelRatio || 1
            , [v,g] = (e=>{
                let n = 120
                  , r = 64;
                const a = t.image
                  , i = t.content
                  , l = t.width
                  , u = t.height;
                if (!a && e.measureText) {
                  e.font = `${Number(o.value)}px ${s.value}`;
                  const t = Array.isArray(i) ? i : [i]
                    , a = t.map((t=>{
                      const n = e.measureText(t);
                      return [n.width, void 0 !== n.fontBoundingBoxAscent ? n.fontBoundingBoxAscent + n.fontBoundingBoxDescent : n.actualBoundingBoxAscent + n.actualBoundingBoxDescent]
                    }
                  ));
                  n = Math.ceil(Math.max(...a.map((e=>e[0])))),
                    r = Math.ceil(Math.max(...a.map((e=>e[1])))) * t.length + 3 * (t.length - 1)
                }
                return [null != l ? l : n, null != u ? u : r]
              }
            )(e)
            , m = e=>{
              const [t,n] = S(e || "", p, h, v, g, {
                color: r.value,
                fontSize: o.value,
                fontStyle: i.value,
                fontWeight: a.value,
                fontFamily: s.value,
                textAlign: l.value,
                textBaseline: u.value
              }, c.value, d.value);
              x(t, n)
            }
          ;
          if (n) {
            const e = new Image;
            e.onload = ()=>{
              m(e)
            }
              ,
              e.onerror = ()=>{
                m(f)
              }
              ,
              e.crossOrigin = "anonymous",
              e.referrerPolicy = "no-referrer",
              e.src = n
          } else
            m(f)
        }
      }
    ;
    Lr((()=>{
        E()
      }
    )),
      Jn((()=>t), (()=>{
          E()
        }
      ), {
        deep: !0,
        flush: "post"
      }),
      Fr((()=>{
          w()
        }
      ));
    return qc(m, (e=>{
        b.value || e.forEach((e=>{
            ((e,t)=>{
                let n = !1;
                return e.removedNodes.length && t && (n = Array.from(e.removedNodes).includes(t)),
                "attributes" === e.type && e.target === t && (n = !0),
                  n
              }
            )(e, y.value) && (w(),
              E())
          }
        ))
      }
    ), {
      attributes: !0,
      subtree: !0,
      childList: !0
    }),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "containerRef",
          ref: m,
          style: z([n])
        }, [Qr(e.$slots, "default")], 4))
  }
}), [["__file", "watermark.vue"]]))
  , EK = uy({
  zIndex: {
    type: Number,
    default: 1001
  },
  visible: Boolean,
  fill: {
    type: String,
    default: "rgba(0,0,0,0.5)"
  },
  pos: {
    type: Object
  },
  targetAreaClickable: {
    type: Boolean,
    default: !0
  }
})
  , AK = (e,t,n,r,o)=>{
  const a = Ft(null)
    , i = ()=>{
      let t;
      return t = b(e.value) ? document.querySelector(e.value) : y(e.value) ? e.value() : e.value,
        t
    }
    , s = ()=>{
      const e = i();
      if (!e || !t.value)
        return void (a.value = null);
      !function(e) {
        const t = window.innerWidth || document.documentElement.clientWidth
          , n = window.innerHeight || document.documentElement.clientHeight
          , {top: r, right: o, bottom: a, left: i} = e.getBoundingClientRect();
        return r >= 0 && i >= 0 && o <= t && a <= n
      }(e) && t.value && e.scrollIntoView(o.value);
      const {left: n, top: r, width: s, height: l} = e.getBoundingClientRect();
      a.value = {
        left: n,
        top: r,
        width: s,
        height: l,
        radius: 0
      }
    }
  ;
  Lr((()=>{
      Jn([t, e], (()=>{
          s()
        }
      ), {
        immediate: !0
      }),
        window.addEventListener("resize", s)
    }
  )),
    Fr((()=>{
        window.removeEventListener("resize", s)
      }
    ));
  const l = e=>{
    var t;
    return null != (t = h(n.value.offset) ? n.value.offset[e] : n.value.offset) ? t : 6
  }
    , u = yi((()=>{
      var e;
      if (!a.value)
        return a.value;
      const t = l(0)
        , r = l(1)
        , o = (null == (e = n.value) ? void 0 : e.radius) || 2;
      return {
        left: a.value.left - t,
        top: a.value.top - r,
        width: a.value.width + 2 * t,
        height: a.value.height + 2 * r,
        radius: o
      }
    }
  ))
    , c = yi((()=>{
      const e = i();
      return r.value && e && window.DOMRect ? {
        getBoundingClientRect() {
          var e, t, n, r;
          return window.DOMRect.fromRect({
            width: (null == (e = u.value) ? void 0 : e.width) || 0,
            height: (null == (t = u.value) ? void 0 : t.height) || 0,
            x: (null == (n = u.value) ? void 0 : n.left) || 0,
            y: (null == (r = u.value) ? void 0 : r.top) || 0
          })
        }
      } : e || void 0
    }
  ));
  return {
    mergedPosInfo: u,
    triggerTarget: c
  }
}
  , CK = Symbol("ElTour");
const kK = (e,t,n,r,o,a,i,s)=>{
  const l = Ft()
    , u = Ft()
    , c = Ft({})
    , d = {
    x: l,
    y: u,
    placement: r,
    strategy: o,
    middlewareData: c
  }
    , f = yi((()=>{
      const e = [tx(Vt(a)), ex(), nx(), TK()];
      return Vt(s) && Vt(n) && e.push(Yw({
        element: Vt(n)
      })),
        e
    }
  ))
    , p = async()=>{
    if (!mc)
      return;
    const n = Vt(e)
      , a = Vt(t);
    if (!n || !a)
      return;
    const i = await Mx(n, a, {
      placement: Vt(r),
      strategy: Vt(o),
      middleware: Vt(f)
    });
    Yg(d).forEach((e=>{
        d[e].value = i[e]
      }
    ))
  }
    , h = yi((()=>{
      if (!Vt(e))
        return {
          position: "fixed",
          top: "50%",
          left: "50%",
          transform: "translate3d(-50%, -50%, 0)",
          maxWidth: "100vw",
          zIndex: Vt(i)
        };
      const {overflow: t} = Vt(c);
      return {
        position: Vt(o),
        zIndex: Vt(i),
        top: null != Vt(u) ? `${Vt(u)}px` : "",
        left: null != Vt(l) ? `${Vt(l)}px` : "",
        maxWidth: (null == t ? void 0 : t.maxWidth) ? `${null == t ? void 0 : t.maxWidth}px` : ""
      }
    }
  ))
    , v = yi((()=>{
      if (!Vt(s))
        return {};
      const {arrow: e} = Vt(c);
      return {
        left: null != (null == e ? void 0 : e.x) ? `${null == e ? void 0 : e.x}px` : "",
        top: null != (null == e ? void 0 : e.y) ? `${null == e ? void 0 : e.y}px` : ""
      }
    }
  ));
  let g;
  return Lr((()=>{
      const n = Vt(e)
        , r = Vt(t);
      n && r && (g = function(e, t, n, r) {
        void 0 === r && (r = {});
        const {ancestorScroll: o=!0, ancestorResize: a=!0, elementResize: i="function" == typeof ResizeObserver, layoutShift: s="function" == typeof IntersectionObserver, animationFrame: l=!1} = r
          , u = xx(e)
          , c = o || a ? [...u ? Rx(u) : [], ...Rx(t)] : [];
        c.forEach((e=>{
            o && e.addEventListener("scroll", n, {
              passive: !0
            }),
            a && e.addEventListener("resize", n)
          }
        ));
        const d = u && s ? function(e, t) {
          let n, r = null;
          const o = Tx(e);
          function a() {
            clearTimeout(n),
            r && r.disconnect(),
              r = null
          }
          return function i(s, l) {
            void 0 === s && (s = !1),
            void 0 === l && (l = 1),
              a();
            const {left: u, top: c, width: d, height: f} = e.getBoundingClientRect();
            if (s || t(),
            !d || !f)
              return;
            const p = {
              rootMargin: -mx(c) + "px " + -mx(o.clientWidth - (u + d)) + "px " + -mx(o.clientHeight - (c + f)) + "px " + -mx(u) + "px",
              threshold: vx(0, hx(1, l)) || 1
            };
            let h = !0;
            function v(e) {
              const t = e[0].intersectionRatio;
              if (t !== l) {
                if (!h)
                  return i();
                t ? i(!1, t) : n = setTimeout((()=>{
                    i(!1, 1e-7)
                  }
                ), 100)
              }
              h = !1
            }
            try {
              r = new IntersectionObserver(v,{
                ...p,
                root: o.ownerDocument
              })
            } catch (g) {
              r = new IntersectionObserver(v,p)
            }
            r.observe(e)
          }(!0),
            a
        }(u, n) : null;
        let f, p = -1, h = null;
        i && (h = new ResizeObserver((e=>{
            let[r] = e;
            r && r.target === u && h && (h.unobserve(t),
              cancelAnimationFrame(p),
              p = requestAnimationFrame((()=>{
                  h && h.observe(t)
                }
              ))),
              n()
          }
        )),
        u && !l && h.observe(u),
          h.observe(t));
        let v = l ? Cx(e) : null;
        return l && function t() {
          const r = Cx(e);
          !v || r.x === v.x && r.y === v.y && r.width === v.width && r.height === v.height || n(),
            v = r,
            f = requestAnimationFrame(t)
        }(),
          n(),
          ()=>{
            c.forEach((e=>{
                o && e.removeEventListener("scroll", n),
                a && e.removeEventListener("resize", n)
              }
            )),
            d && d(),
            h && h.disconnect(),
              h = null,
            l && cancelAnimationFrame(f)
          }
      }(n, r, p)),
        qn((()=>{
            p()
          }
        ))
    }
  )),
    Fr((()=>{
        g && g()
      }
    )),
    {
      update: p,
      contentStyle: h,
      arrowStyle: v
    }
}
  , TK = ()=>({
  name: "overflow",
  async fn(e) {
    const t = await Kw(e);
    let n = 0;
    t.left > 0 && (n = t.left),
    t.right > 0 && (n = t.right);
    return {
      data: {
        maxWidth: e.rects.floating.width - n
      }
    }
  }
})
  , DK = {
  style: {
    width: "100%",
    height: "100%"
  }
}
  , OK = ["d"]
  , _K = vr({
  name: "ElTourMask",
  inheritAttrs: !1
});
var RK = tS(vr({
  ..._K,
  props: EK,
  setup(e) {
    const t = e
      , {ns: n} = jo(CK)
      , r = yi((()=>{
        var e, n;
        return null != (n = null == (e = t.pos) ? void 0 : e.radius) ? n : 2
      }
    ))
      , o = yi((()=>{
        const e = r.value
          , t = `a${e},${e} 0 0 1`;
        return {
          topRight: `${t} ${e},${e}`,
          bottomRight: `${t} ${-e},${e}`,
          bottomLeft: `${t} ${-e},${-e}`,
          topLeft: `${t} ${e},${-e}`
        }
      }
    ))
      , a = yi((()=>{
        const e = window.innerWidth
          , n = window.innerHeight
          , a = o.value
          , i = `M${e},0 L0,0 L0,${n} L${e},${n} L${e},0 Z`
          , s = r.value;
        return t.pos ? `${i} M${t.pos.left + s},${t.pos.top} h${t.pos.width - 2 * s} ${a.topRight} v${t.pos.height - 2 * s} ${a.bottomRight} h${-t.pos.width + 2 * s} ${a.bottomLeft} v${-t.pos.height + 2 * s} ${a.topLeft} z` : i
      }
    ))
      , i = yi((()=>({
      fill: t.fill,
      pointerEvents: "auto",
      cursor: "auto"
    })));
    return Yy(Yt(t, "visible"), {
      ns: n
    }),
      (e,t)=>e.visible ? (Ca(),
        _a("div", qa({
          key: 0,
          class: Vt(n).e("mask"),
          style: {
            position: "fixed",
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            zIndex: e.zIndex,
            pointerEvents: e.pos && e.targetAreaClickable ? "none" : "auto"
          }
        }, e.$attrs), [(Ca(),
          _a("svg", DK, [Ma("path", {
            class: Y(Vt(n).e("hollow")),
            style: z(Vt(i)),
            d: Vt(a)
          }, null, 14, OK)]))], 16)) : za("v-if", !0)
  }
}), [["__file", "mask.vue"]]);
const LK = uy({
  placement: {
    type: String,
    values: ["top-start", "top-end", "top", "bottom-start", "bottom-end", "bottom", "left-start", "left-end", "left", "right-start", "right-end", "right"],
    default: "bottom"
  },
  reference: {
    type: Object,
    default: null
  },
  strategy: {
    type: String,
    values: ["absolute", "fixed"],
    default: "absolute"
  },
  offset: {
    type: Number,
    default: 10
  },
  showArrow: Boolean,
  zIndex: {
    type: Number,
    default: 2001
  }
})
  , IK = ["data-side"]
  , PK = vr({
  name: "ElTourContent"
});
var FK = tS(vr({
  ...PK,
  props: LK,
  emits: {
    close: ()=>!0
  },
  setup(e, {emit: t}) {
    const n = e
      , r = Ft(n.placement)
      , o = Ft(n.strategy)
      , a = Ft(null)
      , i = Ft(null);
    Jn((()=>n.placement), (()=>{
        r.value = n.placement
      }
    ));
    const {contentStyle: s, arrowStyle: l} = kK(Yt(n, "reference"), a, i, r, o, Yt(n, "offset"), Yt(n, "zIndex"), Yt(n, "showArrow"))
      , u = yi((()=>r.value.split("-")[0]))
      , {ns: c} = jo(CK)
      , d = ()=>{
        t("close")
      }
      , f = e=>{
        "pointer" === e.detail.focusReason && e.preventDefault()
      }
    ;
    return (e,t)=>(Ca(),
      _a("div", {
        ref_key: "contentRef",
        ref: a,
        style: z(Vt(s)),
        class: Y(Vt(c).e("content")),
        "data-side": Vt(u),
        tabindex: "-1"
      }, [ja(Vt(cA), {
        loop: "",
        trapped: "",
        "focus-start-el": "container",
        "focus-trap-el": a.value || void 0,
        onReleaseRequested: d,
        onFocusoutPrevented: f
      }, {
        default: Fn((()=>[Qr(e.$slots, "default")])),
        _: 3
      }, 8, ["focus-trap-el"]), e.showArrow ? (Ca(),
        _a("span", {
          key: 0,
          ref_key: "arrowRef",
          ref: i,
          style: z(Vt(l)),
          class: Y(Vt(c).e("arrow"))
        }, null, 6)) : za("v-if", !0)], 14, IK))
  }
}), [["__file", "content.vue"]])
  , BK = vr({
  name: "ElTourSteps",
  props: {
    current: {
      type: Number,
      default: 0
    }
  },
  emits: ["update-total"],
  setup(e, {slots: t, emit: n}) {
    let r = 0;
    return ()=>{
      var o, a;
      const i = null == (o = t.default) ? void 0 : o.call(t)
        , s = [];
      let l = 0;
      var u;
      return i.length && (u = _y(null == (a = i[0]) ? void 0 : a.children),
      h(u) && u.forEach((e=>{
          var t;
          "ElTourStep" === (null == (t = (null == e ? void 0 : e.type) || {}) ? void 0 : t.name) && (s.push(e),
            l += 1)
        }
      ))),
      r !== l && (r = l,
        n("update-total", l)),
        s.length ? s[e.current] : null
    }
  }
});
const NK = uy({
  modelValue: Boolean,
  current: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  closeIcon: {
    type: cy
  },
  placement: LK.placement,
  contentStyle: {
    type: [Object]
  },
  mask: {
    type: [Boolean, Object],
    default: !0
  },
  gap: {
    type: Object,
    default: ()=>({
      offset: 6,
      radius: 2
    })
  },
  zIndex: {
    type: Number
  },
  scrollIntoViewOptions: {
    type: [Boolean, Object],
    default: ()=>({
      block: "center"
    })
  },
  type: {
    type: String
  },
  appendTo: {
    type: [String, Object],
    default: "body"
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  targetAreaClickable: {
    type: Boolean,
    default: !0
  }
})
  , MK = {
  [xy]: e=>jg(e),
  "update:current": e=>Vg(e),
  close: e=>Vg(e),
  finish: ()=>!0,
  change: e=>Vg(e)
}
  , jK = vr({
  name: "ElTour"
});
var VK = tS(vr({
  ...jK,
  props: NK,
  emits: MK,
  setup(e, {emit: t}) {
    const n = e
      , r = qy("tour")
      , o = Ft(0)
      , a = Ft()
      , i = ed(n, "current", t, {
      passive: !0
    })
      , s = yi((()=>{
        var e;
        return null == (e = a.value) ? void 0 : e.target
      }
    ))
      , l = yi((()=>[r.b(), "primary" === g.value ? r.m("primary") : ""]))
      , u = yi((()=>{
        var e;
        return (null == (e = a.value) ? void 0 : e.placement) || n.placement
      }
    ))
      , c = yi((()=>{
        var e, t;
        return null != (t = null == (e = a.value) ? void 0 : e.contentStyle) ? t : n.contentStyle
      }
    ))
      , d = yi((()=>{
        var e, t;
        return null != (t = null == (e = a.value) ? void 0 : e.mask) ? t : n.mask
      }
    ))
      , f = yi((()=>!!d.value && n.modelValue))
      , p = yi((()=>jg(d.value) ? void 0 : d.value))
      , h = yi((()=>{
        var e, t;
        return !!s.value && (null != (t = null == (e = a.value) ? void 0 : e.showArrow) ? t : n.showArrow)
      }
    ))
      , v = yi((()=>{
        var e, t;
        return null != (t = null == (e = a.value) ? void 0 : e.scrollIntoViewOptions) ? t : n.scrollIntoViewOptions
      }
    ))
      , g = yi((()=>{
        var e, t;
        return null != (t = null == (e = a.value) ? void 0 : e.type) ? t : n.type
      }
    ))
      , {nextZIndex: m} = Bw()
      , y = m()
      , b = yi((()=>{
        var e;
        return null != (e = n.zIndex) ? e : y
      }
    ))
      , {mergedPosInfo: w, triggerTarget: x} = AK(s, Yt(n, "modelValue"), Yt(n, "gap"), d, v);
    Jn((()=>n.modelValue), (e=>{
        e || (i.value = 0)
      }
    ));
    const S = ()=>{
      n.closeOnPressEscape && (t("update:modelValue", !1),
        t("close", i.value))
    }
      , E = e=>{
      o.value = e
    }
      , A = po();
    return Mo(CK, {
      currentStep: a,
      current: i,
      total: o,
      showClose: Yt(n, "showClose"),
      closeIcon: Yt(n, "closeIcon"),
      mergedType: g,
      ns: r,
      slots: A,
      updateModelValue(e) {
        t("update:modelValue", e)
      },
      onClose() {
        t("close", i.value)
      },
      onFinish() {
        t("finish")
      },
      onChange() {
        t("change", i.value)
      }
    }),
      (e,t)=>{
        var n, r;
        return Ca(),
          _a(ba, null, [(Ca(),
            Ra(ma, {
              to: e.appendTo
            }, [Ma("div", qa({
              class: Vt(l)
            }, e.$attrs), [ja(RK, {
              visible: Vt(f),
              fill: null == (n = Vt(p)) ? void 0 : n.color,
              style: z(null == (r = Vt(p)) ? void 0 : r.style),
              pos: Vt(w),
              "z-index": Vt(b),
              "target-area-clickable": e.targetAreaClickable
            }, null, 8, ["visible", "fill", "style", "pos", "z-index", "target-area-clickable"]), e.modelValue ? (Ca(),
              Ra(FK, {
                key: Vt(i),
                reference: Vt(x),
                placement: Vt(u),
                "show-arrow": Vt(h),
                "z-index": Vt(b),
                style: z(Vt(c)),
                onClose: S
              }, {
                default: Fn((()=>[ja(Vt(BK), {
                  current: Vt(i),
                  onUpdateTotal: E
                }, {
                  default: Fn((()=>[Qr(e.$slots, "default")])),
                  _: 3
                }, 8, ["current"])])),
                _: 3
              }, 8, ["reference", "placement", "show-arrow", "z-index", "style"])) : za("v-if", !0)], 16)], 8, ["to"])), za(" just for IDE "), za("v-if", !0)], 64)
      }
  }
}), [["__file", "tour.vue"]]);
const UK = uy({
  target: {
    type: [String, Object, Function]
  },
  title: String,
  description: String,
  showClose: {
    type: Boolean,
    default: void 0
  },
  closeIcon: {
    type: cy
  },
  showArrow: {
    type: Boolean,
    default: void 0
  },
  placement: LK.placement,
  mask: {
    type: [Boolean, Object],
    default: void 0
  },
  contentStyle: {
    type: [Object]
  },
  prevButtonProps: {
    type: Object
  },
  nextButtonProps: {
    type: Object
  },
  scrollIntoViewOptions: {
    type: [Boolean, Object],
    default: void 0
  },
  type: {
    type: String
  }
})
  , $K = vr({
  name: "ElTourStep"
})
  , HK = vr({
  ...$K,
  props: UK,
  emits: {
    close: ()=>!0
  },
  setup(e, {emit: t}) {
    const n = e
      , {Close: r} = dy
      , {t: o} = Hy()
      , {currentStep: a, current: i, total: s, showClose: l, closeIcon: u, mergedType: c, ns: d, slots: f, updateModelValue: p, onClose: h, onFinish: v, onChange: g} = jo(CK);
    Jn(n, (e=>{
        a.value = e
      }
    ), {
      immediate: !0
    });
    const m = yi((()=>{
          var e;
          return null != (e = n.showClose) ? e : l.value
        }
      ))
      , y = yi((()=>{
          var e, t;
          return null != (t = null != (e = n.closeIcon) ? e : u.value) ? t : r
        }
      ))
      , b = e=>{
        if (e)
          return _g(e, ["children", "onClick"])
      }
      , w = ()=>{
        var e, t;
        i.value -= 1,
        (null == (e = n.prevButtonProps) ? void 0 : e.onClick) && (null == (t = n.prevButtonProps) || t.onClick()),
          g()
      }
      , x = ()=>{
        var e;
        i.value >= s.value - 1 ? S() : i.value += 1,
        (null == (e = n.nextButtonProps) ? void 0 : e.onClick) && n.nextButtonProps.onClick(),
          g()
      }
      , S = ()=>{
        E(),
          v()
      }
      , E = ()=>{
        p(!1),
          h(),
          t("close")
      }
    ;
    return (e,t)=>(Ca(),
      _a(ba, null, [Vt(m) ? (Ca(),
        _a("button", {
          key: 0,
          "aria-label": "Close",
          class: Y(Vt(d).e("closebtn")),
          type: "button",
          onClick: E
        }, [ja(Vt(sS), {
          class: Y(Vt(d).e("close"))
        }, {
          default: Fn((()=>[(Ca(),
            Ra(Kr(Vt(y))))])),
          _: 1
        }, 8, ["class"])], 2)) : za("v-if", !0), Ma("header", {
        class: Y([Vt(d).e("header"), {
          "show-close": Vt(l)
        }])
      }, [Qr(e.$slots, "header", {}, (()=>[Ma("span", {
        role: "heading",
        class: Y(Vt(d).e("title"))
      }, te(e.title), 3)]))], 2), Ma("div", {
        class: Y(Vt(d).e("body"))
      }, [Qr(e.$slots, "default", {}, (()=>[Ma("span", null, te(e.description), 1)]))], 2), Ma("footer", {
        class: Y(Vt(d).e("footer"))
      }, [Ma("div", {
        class: Y(Vt(d).b("indicators"))
      }, [Vt(f).indicators ? (Ca(),
        Ra(Kr(Vt(f).indicators), {
          key: 0,
          current: Vt(i),
          total: Vt(s)
        }, null, 8, ["current", "total"])) : (Ca(!0),
        _a(ba, {
          key: 1
        }, Yr(Vt(s), ((e,t)=>(Ca(),
          _a("span", {
            key: e,
            class: Y([Vt(d).b("indicator"), t === Vt(i) ? "is-active" : ""])
          }, null, 2)))), 128))], 2), Ma("div", {
        class: Y(Vt(d).b("buttons"))
      }, [Vt(i) > 0 ? (Ca(),
        Ra(Vt(WC), qa({
          key: 0,
          size: "small",
          type: Vt(c)
        }, b(e.prevButtonProps), {
          onClick: w
        }), {
          default: Fn((()=>{
              var t, n;
              return [$a(te(null != (n = null == (t = e.prevButtonProps) ? void 0 : t.children) ? n : Vt(o)("el.tour.previous")), 1)]
            }
          )),
          _: 1
        }, 16, ["type"])) : za("v-if", !0), Vt(i) <= Vt(s) - 1 ? (Ca(),
        Ra(Vt(WC), qa({
          key: 1,
          size: "small",
          type: "primary" === Vt(c) ? "default" : "primary"
        }, b(e.nextButtonProps), {
          onClick: x
        }), {
          default: Fn((()=>{
              var t, n;
              return [$a(te(null != (n = null == (t = e.nextButtonProps) ? void 0 : t.children) ? n : Vt(i) === Vt(s) - 1 ? Vt(o)("el.tour.finish") : Vt(o)("el.tour.next")), 1)]
            }
          )),
          _: 1
        }, 16, ["type"])) : za("v-if", !0)], 2)], 2)], 64))
  }
});
var zK = tS(HK, [["__file", "step.vue"]]);
const KK = vy(VK, {
  TourStep: zK
})
  , WK = my(zK)
  , GK = uy({
  container: {
    type: [String, Object]
  },
  offset: {
    type: Number,
    default: 0
  },
  bound: {
    type: Number,
    default: 15
  },
  duration: {
    type: Number,
    default: 300
  },
  marker: {
    type: Boolean,
    default: !0
  },
  type: {
    type: String,
    default: "defalut"
  },
  direction: {
    type: String,
    default: "vertical"
  }
})
  , qK = {
  change: e=>b(e),
  click: (e,t)=>e instanceof MouseEvent && (b(t) || Mg(t))
}
  , YK = Symbol("anchor")
  , XK = vr({
  name: "ElAnchor"
})
  , QK = vr({
  ...XK,
  props: GK,
  emits: qK,
  setup(e, {expose: t, emit: n}) {
    const r = e
      , o = Ft("")
      , a = Ft(null)
      , i = Ft(null)
      , s = Ft()
      , l = {};
    let u = !1
      , c = 0;
    const d = qy("anchor")
      , f = yi((()=>[d.b(), "underline" === r.type ? d.m("underline") : "", d.m(r.direction)]))
      , p = e=>{
        o.value !== e && (o.value = e,
          n("change", e))
      }
      , h = e=>{
        if (!s.value)
          return;
        const t = fm(e);
        if (!t)
          return;
        u = !0;
        const n = cm(t, s.value)
          , o = rd(t, n)
          , a = n.scrollHeight - n.clientHeight
          , i = Math.min(o - r.offset, a);
        !function(e, t, n, r, o) {
          const a = Date.now()
            , i = ()=>{
              const s = Date.now() - a
                , l = function(e, t, n, r) {
                const o = n - t;
                return (e /= r / 2) < 1 ? o / 2 * e * e * e + t : o / 2 * ((e -= 2) * e * e + 2) + t
              }(s > r ? r : s, t, n, r);
              zg(e) ? e.scrollTo(window.pageXOffset, l) : e.scrollTop = l,
                s < r ? Kg(i) : "function" == typeof o && o()
            }
          ;
          i()
        }(s.value, c, i, r.duration, (()=>{
            setTimeout((()=>{
                u = !1
              }
            ), 20)
          }
        ))
      }
      , v = e=>{
        e && (p(e),
          h(e))
      }
      , g = function(e) {
        let t = 0;
        const n = (...n)=>{
            t && Wg(t),
              t = Kg((()=>{
                  e(...n),
                    t = 0
                }
              ))
          }
        ;
        return n.cancel = ()=>{
          Wg(t),
            t = 0
        }
          ,
          n
      }((()=>{
          s.value && (c = dm(s.value));
          const e = m();
          u || Mg(e) || p(e)
        }
      ))
      , m = ()=>{
        if (!s.value)
          return;
        const e = dm(s.value)
          , t = [];
        for (const n of Object.keys(l)) {
          const e = fm(n);
          if (!e)
            continue;
          const o = cm(e, s.value)
            , a = rd(e, o);
          t.push({
            top: a - r.offset - r.bound,
            href: n
          })
        }
        t.sort(((e,t)=>e.top - t.top));
        for (let n = 0; n < t.length; n++) {
          const r = t[n]
            , o = t[n + 1];
          if (0 === n && 0 === e)
            return "";
          if (r.top <= e && (!o || o.top > e))
            return r.href
        }
      }
      , y = ()=>{
        const e = fm(r.container);
        !e || zg(e) ? s.value = window : s.value = e
      }
    ;
    Rc(s, "scroll", g);
    const b = yi((()=>{
        if (!a.value || !i.value || !o.value)
          return {};
        const e = l[o.value];
        if (!e)
          return {};
        const t = a.value.getBoundingClientRect()
          , n = i.value.getBoundingClientRect()
          , s = e.getBoundingClientRect();
        if ("horizontal" === r.direction) {
          return {
            left: `${s.left - t.left}px`,
            width: `${s.width}px`,
            opacity: 1
          }
        }
        return {
          top: `${s.top - t.top + (s.height - n.height) / 2}px`,
          opacity: 1
        }
      }
    ));
    return Lr((()=>{
        y();
        const e = decodeURIComponent(window.location.hash);
        fm(e) ? v(e) : g()
      }
    )),
      Jn((()=>r.container), (()=>{
          y()
        }
      )),
      Mo(YK, {
        ns: d,
        direction: r.direction,
        currentAnchor: o,
        addLink: e=>{
          l[e.href] = e.el
        }
        ,
        removeLink: e=>{
          delete l[e]
        }
        ,
        handleClick: (e,t)=>{
          n("click", e, t),
            v(t)
        }
      }),
      t({
        scrollTo: v
      }),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "anchorRef",
          ref: a,
          class: Y(Vt(f))
        }, [e.marker ? (Ca(),
          _a("div", {
            key: 0,
            ref_key: "markerRef",
            ref: i,
            class: Y(Vt(d).e("marker")),
            style: z(Vt(b))
          }, null, 6)) : za("v-if", !0), Ma("div", {
          class: Y(Vt(d).e("list"))
        }, [Qr(e.$slots, "default")], 2)], 2))
  }
});
var JK = tS(QK, [["__file", "anchor.vue"]]);
const ZK = uy({
  title: String,
  href: String
})
  , eW = ["href"]
  , tW = vr({
  name: "ElAnchorLink"
})
  , nW = vr({
  ...tW,
  props: ZK,
  setup(e) {
    const t = e
      , n = Ft(null)
      , {ns: r, direction: o, currentAnchor: a, addLink: i, removeLink: s, handleClick: l} = jo(YK)
      , u = yi((()=>[r.e("link"), r.is("active", a.value === t.href)]))
      , c = e=>{
        l(e, t.href)
      }
    ;
    return Jn((()=>t.href), ((e,t)=>{
        hn((()=>{
            t && s(t),
            e && i({
              href: e,
              el: n.value
            })
          }
        ))
      }
    )),
      Lr((()=>{
          const {href: e} = t;
          e && i({
            href: e,
            el: n.value
          })
        }
      )),
      Fr((()=>{
          const {href: e} = t;
          e && s(e)
        }
      )),
      (e,t)=>(Ca(),
        _a("div", {
          class: Y(Vt(r).e("item"))
        }, [Ma("a", {
          ref_key: "linkRef",
          ref: n,
          class: Y(Vt(u)),
          href: e.href,
          onClick: c
        }, [Qr(e.$slots, "default", {}, (()=>[$a(te(e.title), 1)]))], 10, eW), e.$slots["sub-link"] && "vertical" === Vt(o) ? (Ca(),
          _a("div", {
            key: 0,
            class: Y(Vt(r).e("list"))
          }, [Qr(e.$slots, "sub-link")], 2)) : za("v-if", !0)], 2))
  }
});
var rW = tS(nW, [["__file", "anchor-link.vue"]]);
const oW = vy(JK, {
  AnchorLink: rW
})
  , aW = my(rW);
var iW = [oS, dS, WA, i$, JA, rC, sC, vC, gC, WC, GC, NT, VT, aD, iD, AO, dO, DO, AD, CD, kD, FO, ZO, e_, WO, R_, Jx, $_, H_, z_, K_, W_, bL, RL, LL, YL, JL, sI, JI, ZI, eP, RP, iE, sE, sS, zP, NP, yE, QP, nF, mF, yF, bF, wF, CF, PB, jB, qB, wA, rN, KD, GD, WD, cN, vN, LO, DE, nB, rB, oB, VM, GM, qM, bj, Sj, Cj, Ij, Uj, $j, Jj, lU, uU, a$, A$, C$, vO, D$, ET, N$, $$, H$, MA, yH, FH, tz, dz, Bz, mK, SK, KK, WK, oW, aW];
const sW = "ElInfiniteScroll"
  , lW = {
    delay: {
      type: Number,
      default: 200
    },
    distance: {
      type: Number,
      default: 0
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    immediate: {
      type: Boolean,
      default: !0
    }
  }
  , uW = (e,t)=>Object.entries(lW).reduce(((n,[r,o])=>{
      var a, i;
      const {type: s, default: l} = o
        , u = e.getAttribute(`infinite-scroll-${r}`);
      let c = null != (i = null != (a = t[u]) ? a : u) ? i : l;
      return c = "false" !== c && c,
        c = s(c),
        n[r] = Number.isNaN(c) ? l : c,
        n
    }
  ), {})
  , cW = e=>{
    const {observer: t} = e[sW];
    t && (t.disconnect(),
      delete e[sW].observer)
  }
  , dW = (e,t)=>{
    const {container: n, containerEl: r, instance: o, observer: a, lastScrollTop: i} = e[sW]
      , {disabled: s, distance: l} = uW(e, o)
      , {clientHeight: u, scrollHeight: c, scrollTop: d} = r
      , f = d - i;
    if (e[sW].lastScrollTop = d,
    a || s || f < 0)
      return;
    let p = !1;
    if (n === e)
      p = c - (u + d) <= l;
    else {
      const {clientTop: t, scrollHeight: n} = e;
      p = d + u >= rd(e, r) + t + n - l
    }
    p && t.call(o)
  }
;
function fW(e, t) {
  const {containerEl: n, instance: r} = e[sW]
    , {disabled: o} = uW(e, r);
  o || 0 === n.clientHeight || (n.scrollHeight <= n.clientHeight ? t.call(r) : cW(e))
}
const pW = {
  async mounted(e, t) {
    const {instance: n, value: r} = t;
    y(r) || Jg(sW, "'v-infinite-scroll' binding value must be a function"),
      await hn();
    const {delay: o, immediate: a} = uW(e, n)
      , i = im(e, !0)
      , s = i === window ? document.documentElement : i
      , l = Pg(dW.bind(null, e, r), o);
    if (i) {
      if (e[sW] = {
        instance: n,
        container: i,
        containerEl: s,
        delay: o,
        cb: r,
        onScroll: l,
        lastScrollTop: s.scrollTop
      },
        a) {
        const t = new MutationObserver(Pg(fW.bind(null, e, r), 50));
        e[sW].observer = t,
          t.observe(e, {
            childList: !0,
            subtree: !0
          }),
          fW(e, r)
      }
      i.addEventListener("scroll", l)
    }
  },
  unmounted(e) {
    const {container: t, onScroll: n} = e[sW];
    null == t || t.removeEventListener("scroll", n),
      cW(e)
  },
  async updated(e) {
    if (e[sW]) {
      const {containerEl: t, cb: n, observer: r} = e[sW];
      t.clientHeight && r && fW(e, n)
    } else
      await hn()
  },
  install: e=>{
    e.directive("InfiniteScroll", pW)
  }
}
  , hW = pW;
function vW(e) {
  let t;
  const n = Ft(!1)
    , r = bt({
    ...e,
    originalPosition: "",
    originalOverflow: "",
    visible: !1
  });
  function o() {
    var e, t;
    null == (t = null == (e = l.$el) ? void 0 : e.parentNode) || t.removeChild(l.$el)
  }
  function a() {
    if (!n.value)
      return;
    const e = r.parent;
    n.value = !1,
      e.vLoadingAddClassList = void 0,
      function() {
        const e = r.parent
          , t = l.ns;
        if (!e.vLoadingAddClassList) {
          let n = e.getAttribute("loading-number");
          n = Number.parseInt(n) - 1,
            n ? e.setAttribute("loading-number", n.toString()) : (nm(e, t.bm("parent", "relative")),
              e.removeAttribute("loading-number")),
            nm(e, t.bm("parent", "hidden"))
        }
        o(),
          s.unmount()
      }()
  }
  const i = vr({
    name: "ElLoading",
    setup(e, {expose: t}) {
      const {ns: n, zIndex: o} = Gx("loading");
      return t({
        ns: n,
        zIndex: o
      }),
        ()=>{
          const e = r.spinner || r.svg
            , t = bi("svg", {
            class: "circular",
            viewBox: r.svgViewBox ? r.svgViewBox : "0 0 50 50",
            ...e ? {
              innerHTML: e
            } : {}
          }, [bi("circle", {
            class: "path",
            cx: "25",
            cy: "25",
            r: "20",
            fill: "none"
          })])
            , o = r.text ? bi("p", {
            class: n.b("text")
          }, [r.text]) : void 0;
          return bi(es, {
            name: n.b("fade"),
            onAfterLeave: a
          }, {
            default: Fn((()=>[rr(ja("div", {
              style: {
                backgroundColor: r.background || ""
              },
              class: [n.b("mask"), r.customClass, r.fullscreen ? "is-fullscreen" : ""]
            }, [bi("div", {
              class: n.b("spinner")
            }, [t, o])]), [[$s, r.visible]])]))
          })
        }
    }
  })
    , s = Qs(i)
    , l = s.mount(document.createElement("div"));
  return {
    ...Wt(r),
    setText: function(e) {
      r.text = e
    },
    removeElLoadingChild: o,
    close: function() {
      var o;
      e.beforeClose && !e.beforeClose() || (n.value = !0,
        clearTimeout(t),
        t = window.setTimeout(a, 400),
        r.visible = !1,
      null == (o = e.closed) || o.call(e))
    },
    handleAfterLeave: a,
    vm: l,
    get $el() {
      return l.$el
    }
  }
}
let gW;
const mW = function(e={}) {
  if (!mc)
    return;
  const t = yW(e);
  if (t.fullscreen && gW)
    return gW;
  const n = vW({
    ...t,
    closed: ()=>{
      var e;
      null == (e = t.closed) || e.call(t),
      t.fullscreen && (gW = void 0)
    }
  });
  bW(t, t.parent, n),
    wW(t, t.parent, n),
    t.parent.vLoadingAddClassList = ()=>wW(t, t.parent, n);
  let r = t.parent.getAttribute("loading-number");
  return r = r ? `${Number.parseInt(r) + 1}` : "1",
    t.parent.setAttribute("loading-number", r),
    t.parent.appendChild(n.$el),
    hn((()=>n.visible.value = t.visible)),
  t.fullscreen && (gW = n),
    n
}
  , yW = e=>{
  var t, n, r, o;
  let a;
  return a = b(e.target) ? null != (t = document.querySelector(e.target)) ? t : document.body : e.target || document.body,
    {
      parent: a === document.body || e.body ? document.body : a,
      background: e.background || "",
      svg: e.svg || "",
      svgViewBox: e.svgViewBox || "",
      spinner: e.spinner || !1,
      text: e.text || "",
      fullscreen: a === document.body && (null == (n = e.fullscreen) || n),
      lock: null != (r = e.lock) && r,
      customClass: e.customClass || "",
      visible: null == (o = e.visible) || o,
      target: a
    }
}
  , bW = async(e,t,n)=>{
  const {nextZIndex: r} = n.vm.zIndex || n.vm._.exposed.zIndex
    , o = {};
  if (e.fullscreen)
    n.originalPosition.value = rm(document.body, "position"),
      n.originalOverflow.value = rm(document.body, "overflow"),
      o.zIndex = r();
  else if (e.parent === document.body) {
    n.originalPosition.value = rm(document.body, "position"),
      await hn();
    for (const t of ["top", "left"]) {
      const n = "top" === t ? "scrollTop" : "scrollLeft";
      o[t] = e.target.getBoundingClientRect()[t] + document.body[n] + document.documentElement[n] - Number.parseInt(rm(document.body, `margin-${t}`), 10) + "px"
    }
    for (const t of ["height", "width"])
      o[t] = `${e.target.getBoundingClientRect()[t]}px`
  } else
    n.originalPosition.value = rm(t, "position");
  for (const [a,i] of Object.entries(o))
    n.$el.style[a] = i
}
  , wW = (e,t,n)=>{
  const r = n.vm.ns || n.vm._.exposed.ns;
  ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? nm(t, r.bm("parent", "relative")) : tm(t, r.bm("parent", "relative")),
    e.fullscreen && e.lock ? tm(t, r.bm("parent", "hidden")) : nm(t, r.bm("parent", "hidden"))
}
  , xW = Symbol("ElLoading")
  , SW = (e,t)=>{
  var n, r, o, a;
  const i = t.instance
    , s = e=>x(t.value) ? t.value[e] : void 0
    , l = t=>(e=>{
      const t = b(e) && (null == i ? void 0 : i[e]) || e;
      return t ? Ft(t) : t
    }
  )(s(t) || e.getAttribute(`element-loading-${I(t)}`))
    , u = null != (n = s("fullscreen")) ? n : t.modifiers.fullscreen
    , c = {
    text: l("text"),
    svg: l("svg"),
    svgViewBox: l("svgViewBox"),
    spinner: l("spinner"),
    background: l("background"),
    customClass: l("customClass"),
    fullscreen: u,
    target: null != (r = s("target")) ? r : u ? void 0 : e,
    body: null != (o = s("body")) ? o : t.modifiers.body,
    lock: null != (a = s("lock")) ? a : t.modifiers.lock
  };
  e[xW] = {
    options: c,
    instance: mW(c)
  }
}
  , EW = {
  mounted(e, t) {
    t.value && SW(e, t)
  },
  updated(e, t) {
    const n = e[xW];
    t.oldValue !== t.value && (t.value && !t.oldValue ? SW(e, t) : t.value && t.oldValue ? x(t.value) && ((e,t)=>{
        for (const n of Object.keys(t))
          Pt(t[n]) && (t[n].value = e[n])
      }
    )(t.value, n.options) : null == n || n.instance.close())
  },
  unmounted(e) {
    var t;
    null == (t = e[xW]) || t.instance.close(),
      e[xW] = null
  }
}
  , AW = {
  install(e) {
    e.directive("loading", EW),
      e.config.globalProperties.$loading = mW
  },
  directive: EW,
  service: mW
}
  , CW = ["success", "info", "warning", "error"]
  , kW = {
  customClass: "",
  center: !1,
  dangerouslyUseHTMLString: !1,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: !1,
  type: "info",
  offset: 16,
  zIndex: 0,
  grouping: !1,
  repeatNum: 1,
  appendTo: mc ? document.body : void 0
}
  , TW = uy({
  customClass: {
    type: String,
    default: kW.customClass
  },
  center: {
    type: Boolean,
    default: kW.center
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: kW.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: kW.duration
  },
  icon: {
    type: cy,
    default: kW.icon
  },
  id: {
    type: String,
    default: kW.id
  },
  message: {
    type: [String, Object, Function],
    default: kW.message
  },
  onClose: {
    type: Function,
    required: !1
  },
  showClose: {
    type: Boolean,
    default: kW.showClose
  },
  type: {
    type: String,
    values: CW,
    default: kW.type
  },
  offset: {
    type: Number,
    default: kW.offset
  },
  zIndex: {
    type: Number,
    default: kW.zIndex
  },
  grouping: {
    type: Boolean,
    default: kW.grouping
  },
  repeatNum: {
    type: Number,
    default: kW.repeatNum
  }
})
  , DW = wt([])
  , OW = e=>{
  const {prev: t} = (e=>{
      const t = DW.findIndex((t=>t.id === e))
        , n = DW[t];
      let r;
      return t > 0 && (r = DW[t - 1]),
        {
          current: n,
          prev: r
        }
    }
  )(e);
  return t ? t.vm.exposed.bottom.value : 0
}
  , _W = ["id"]
  , RW = ["innerHTML"]
  , LW = vr({
  name: "ElMessage"
});
var IW = tS(vr({
  ...LW,
  props: TW,
  emits: {
    destroy: ()=>!0
  },
  setup(e, {expose: t}) {
    const n = e
      , {Close: r} = fy
      , {ns: o, zIndex: a} = Gx("message")
      , {currentZIndex: i, nextZIndex: s} = a
      , l = Ft()
      , u = Ft(!1)
      , c = Ft(0);
    let d;
    const f = yi((()=>n.type ? "error" === n.type ? "danger" : n.type : "info"))
      , p = yi((()=>{
        const e = n.type;
        return {
          [o.bm("icon", e)]: e && py[e]
        }
      }
    ))
      , h = yi((()=>n.icon || py[n.type] || ""))
      , v = yi((()=>OW(n.id)))
      , g = yi((()=>((e,t)=>DW.findIndex((t=>t.id === e)) > 0 ? 16 : t)(n.id, n.offset) + v.value))
      , m = yi((()=>c.value + g.value))
      , y = yi((()=>({
      top: `${g.value}px`,
      zIndex: i.value
    })));
    function b() {
      0 !== n.duration && ({stop: d} = Tc((()=>{
          x()
        }
      ), n.duration))
    }
    function w() {
      null == d || d()
    }
    function x() {
      u.value = !1
    }
    return Lr((()=>{
        b(),
          s(),
          u.value = !0
      }
    )),
      Jn((()=>n.repeatNum), (()=>{
          w(),
            b()
        }
      )),
      Rc(document, "keydown", (function({code: e}) {
          e === by.esc && x()
        }
      )),
      Uc(l, (()=>{
          c.value = l.value.getBoundingClientRect().height
        }
      )),
      t({
        visible: u,
        bottom: m,
        close: x
      }),
      (e,t)=>(Ca(),
        Ra(es, {
          name: Vt(o).b("fade"),
          onBeforeLeave: e.onClose,
          onAfterLeave: t[0] || (t[0] = t=>e.$emit("destroy")),
          persisted: ""
        }, {
          default: Fn((()=>[rr(Ma("div", {
            id: e.id,
            ref_key: "messageRef",
            ref: l,
            class: Y([Vt(o).b(), {
              [Vt(o).m(e.type)]: e.type
            }, Vt(o).is("center", e.center), Vt(o).is("closable", e.showClose), e.customClass]),
            style: z(Vt(y)),
            role: "alert",
            onMouseenter: w,
            onMouseleave: b
          }, [e.repeatNum > 1 ? (Ca(),
            Ra(Vt(sC), {
              key: 0,
              value: e.repeatNum,
              type: Vt(f),
              class: Y(Vt(o).e("badge"))
            }, null, 8, ["value", "type", "class"])) : za("v-if", !0), Vt(h) ? (Ca(),
            Ra(Vt(sS), {
              key: 1,
              class: Y([Vt(o).e("icon"), Vt(p)])
            }, {
              default: Fn((()=>[(Ca(),
                Ra(Kr(Vt(h))))])),
              _: 1
            }, 8, ["class"])) : za("v-if", !0), Qr(e.$slots, "default", {}, (()=>[e.dangerouslyUseHTMLString ? (Ca(),
            _a(ba, {
              key: 1
            }, [za(" Caution here, message could've been compromised, never use user's input as message "), Ma("p", {
              class: Y(Vt(o).e("content")),
              innerHTML: e.message
            }, null, 10, RW)], 2112)) : (Ca(),
            _a("p", {
              key: 0,
              class: Y(Vt(o).e("content"))
            }, te(e.message), 3))])), e.showClose ? (Ca(),
            Ra(Vt(sS), {
              key: 2,
              class: Y(Vt(o).e("closeBtn")),
              onClick: js(x, ["stop"])
            }, {
              default: Fn((()=>[ja(Vt(r))])),
              _: 1
            }, 8, ["class", "onClick"])) : za("v-if", !0)], 46, _W), [[$s, u.value]])])),
          _: 3
        }, 8, ["name", "onBeforeLeave"]))
  }
}), [["__file", "message.vue"]]);
let PW = 1;
const FW = e=>{
    const t = !e || b(e) || La(e) || y(e) ? {
      message: e
    } : e
      , n = {
      ...kW,
      ...t
    };
    if (n.appendTo) {
      if (b(n.appendTo)) {
        let e = document.querySelector(n.appendTo);
        $g(e) || (e = document.body),
          n.appendTo = e
      }
    } else
      n.appendTo = document.body;
    return n
  }
  , BW = ({appendTo: e, ...t},n)=>{
    const r = "message_" + PW++
      , o = t.onClose
      , a = document.createElement("div")
      , i = {
      ...t,
      id: r,
      onClose: ()=>{
        null == o || o(),
          (e=>{
              const t = DW.indexOf(e);
              if (-1 === t)
                return;
              DW.splice(t, 1);
              const {handler: n} = e;
              n.close()
            }
          )(c)
      }
      ,
      onDestroy: ()=>{
        Ys(null, a)
      }
    }
      , s = ja(IW, i, y(i.message) || La(i.message) ? {
      default: y(i.message) ? i.message : ()=>i.message
    } : null);
    s.appContext = n || NW._context,
      Ys(s, a),
      e.appendChild(a.firstElementChild);
    const l = s.component
      , u = {
      close: ()=>{
        l.exposed.visible.value = !1
      }
    }
      , c = {
      id: r,
      vnode: s,
      vm: l,
      handler: u,
      props: s.component.props
    };
    return c
  }
  , NW = (e={},t)=>{
    if (!mc)
      return {
        close: ()=>{}
      };
    if (Vg(Qx.max) && DW.length >= Qx.max)
      return {
        close: ()=>{}
      };
    const n = FW(e);
    if (n.grouping && DW.length) {
      const e = DW.find((({vnode: e})=>{
          var t;
          return (null == (t = e.props) ? void 0 : t.message) === n.message
        }
      ));
      if (e)
        return e.props.repeatNum += 1,
          e.props.type = n.type,
          e.handler
    }
    const r = BW(n, t);
    return DW.push(r),
      r.handler
  }
;
CW.forEach((e=>{
    NW[e] = (t={},n)=>{
      const r = FW(t);
      return NW({
        ...r,
        type: e
      }, n)
    }
  }
)),
  NW.closeAll = function(e) {
    for (const t of DW)
      e && e !== t.props.type || t.handler.close()
  }
  ,
  NW._context = null;
const MW = gy(NW, "$message")
  , jW = vr({
  name: "ElMessageBox",
  directives: {
    TrapFocus: Mk
  },
  components: {
    ElButton: WC,
    ElFocusTrap: cA,
    ElInput: yE,
    ElOverlay: FL,
    ElIcon: sS,
    ...fy
  },
  inheritAttrs: !1,
  props: {
    buttonSize: {
      type: String,
      validator: ky
    },
    modal: {
      type: Boolean,
      default: !0
    },
    lockScroll: {
      type: Boolean,
      default: !0
    },
    showClose: {
      type: Boolean,
      default: !0
    },
    closeOnClickModal: {
      type: Boolean,
      default: !0
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    closeOnHashChange: {
      type: Boolean,
      default: !0
    },
    center: Boolean,
    draggable: Boolean,
    overflow: Boolean,
    roundButton: {
      default: !1,
      type: Boolean
    },
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(e, {emit: t}) {
    const {locale: n, zIndex: r, ns: o, size: a} = Gx("message-box", yi((()=>e.buttonSize)))
      , {t: i} = n
      , {nextZIndex: s} = r
      , l = Ft(!1)
      , u = bt({
      autofocus: !0,
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      customClass: "",
      customStyle: {},
      dangerouslyUseHTMLString: !1,
      distinguishCancelAndClose: !1,
      icon: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: null,
      inputValidator: null,
      inputErrorMessage: "",
      message: null,
      modalFade: !0,
      modalClass: "",
      showCancelButton: !1,
      showConfirmButton: !0,
      type: "",
      title: void 0,
      showInput: !1,
      action: "",
      confirmButtonLoading: !1,
      cancelButtonLoading: !1,
      confirmButtonDisabled: !1,
      editorErrorMessage: "",
      validateError: !1,
      zIndex: s()
    })
      , c = yi((()=>{
        const e = u.type;
        return {
          [o.bm("icon", e)]: e && py[e]
        }
      }
    ))
      , d = Cw()
      , f = Cw()
      , p = yi((()=>u.icon || py[u.type] || ""))
      , h = yi((()=>!!u.message))
      , v = Ft()
      , g = Ft()
      , m = Ft()
      , y = Ft()
      , b = Ft()
      , w = yi((()=>u.confirmButtonClass));
    Jn((()=>u.inputValue), (async t=>{
        await hn(),
        "prompt" === e.boxType && null !== t && T()
      }
    ), {
      immediate: !0
    }),
      Jn((()=>l.value), (t=>{
          var n, r;
          t && ("prompt" !== e.boxType && (u.autofocus ? m.value = null != (r = null == (n = b.value) ? void 0 : n.$el) ? r : v.value : m.value = v.value),
            u.zIndex = s()),
          "prompt" === e.boxType && (t ? hn().then((()=>{
              var e;
              y.value && y.value.$el && (u.autofocus ? m.value = null != (e = D()) ? e : v.value : m.value = v.value)
            }
          )) : (u.editorErrorMessage = "",
            u.validateError = !1))
        }
      ));
    const x = yi((()=>e.draggable))
      , S = yi((()=>e.overflow));
    function E() {
      l.value && (l.value = !1,
        hn((()=>{
            u.action && t("action", u.action)
          }
        )))
    }
    My(v, g, x, S),
      Lr((async()=>{
          await hn(),
          e.closeOnHashChange && window.addEventListener("hashchange", E)
        }
      )),
      Fr((()=>{
          e.closeOnHashChange && window.removeEventListener("hashchange", E)
        }
      ));
    const A = ()=>{
        e.closeOnClickModal && k(u.distinguishCancelAndClose ? "close" : "cancel")
      }
      , C = ww(A)
      , k = t=>{
        var n;
        ("prompt" !== e.boxType || "confirm" !== t || T()) && (u.action = t,
          u.beforeClose ? null == (n = u.beforeClose) || n.call(u, t, u, E) : E())
      }
      , T = ()=>{
        if ("prompt" === e.boxType) {
          const e = u.inputPattern;
          if (e && !e.test(u.inputValue || ""))
            return u.editorErrorMessage = u.inputErrorMessage || i("el.messagebox.error"),
              u.validateError = !0,
              !1;
          const t = u.inputValidator;
          if ("function" == typeof t) {
            const e = t(u.inputValue);
            if (!1 === e)
              return u.editorErrorMessage = u.inputErrorMessage || i("el.messagebox.error"),
                u.validateError = !0,
                !1;
            if ("string" == typeof e)
              return u.editorErrorMessage = e,
                u.validateError = !0,
                !1
          }
        }
        return u.editorErrorMessage = "",
          u.validateError = !1,
          !0
      }
      , D = ()=>{
        const e = y.value.$refs;
        return e.input || e.textarea
      }
      , O = ()=>{
        k("close")
      }
    ;
    return e.lockScroll && Yy(l),
      {
        ...Wt(u),
        ns: o,
        overlayEvent: C,
        visible: l,
        hasMessage: h,
        typeClass: c,
        contentId: d,
        inputId: f,
        btnSize: a,
        iconComponent: p,
        confirmButtonClasses: w,
        rootRef: v,
        focusStartRef: m,
        headerRef: g,
        inputRef: y,
        confirmRef: b,
        doClose: E,
        handleClose: O,
        onCloseRequested: ()=>{
          e.closeOnPressEscape && O()
        }
        ,
        handleWrapperClick: A,
        handleInputEnter: e=>{
          if ("textarea" !== u.inputType)
            return e.preventDefault(),
              k("confirm")
        }
        ,
        handleAction: k,
        t: i
      }
  }
})
  , VW = ["aria-label", "aria-describedby"]
  , UW = ["aria-label"]
  , $W = ["id"];
var HW = tS(jW, [["render", function(e, t, n, r, o, a) {
  const i = Hr("el-icon")
    , s = Hr("close")
    , l = Hr("el-input")
    , u = Hr("el-button")
    , c = Hr("el-focus-trap")
    , d = Hr("el-overlay");
  return Ca(),
    Ra(es, {
      name: "fade-in-linear",
      onAfterLeave: t[11] || (t[11] = t=>e.$emit("vanish")),
      persisted: ""
    }, {
      default: Fn((()=>[rr(ja(d, {
        "z-index": e.zIndex,
        "overlay-class": [e.ns.is("message-box"), e.modalClass],
        mask: e.modal
      }, {
        default: Fn((()=>[Ma("div", {
          role: "dialog",
          "aria-label": e.title,
          "aria-modal": "true",
          "aria-describedby": e.showInput ? void 0 : e.contentId,
          class: Y(`${e.ns.namespace.value}-overlay-message-box`),
          onClick: t[8] || (t[8] = (...t)=>e.overlayEvent.onClick && e.overlayEvent.onClick(...t)),
          onMousedown: t[9] || (t[9] = (...t)=>e.overlayEvent.onMousedown && e.overlayEvent.onMousedown(...t)),
          onMouseup: t[10] || (t[10] = (...t)=>e.overlayEvent.onMouseup && e.overlayEvent.onMouseup(...t))
        }, [ja(c, {
          loop: "",
          trapped: e.visible,
          "focus-trap-el": e.rootRef,
          "focus-start-el": e.focusStartRef,
          onReleaseRequested: e.onCloseRequested
        }, {
          default: Fn((()=>[Ma("div", {
            ref: "rootRef",
            class: Y([e.ns.b(), e.customClass, e.ns.is("draggable", e.draggable), {
              [e.ns.m("center")]: e.center
            }]),
            style: z(e.customStyle),
            tabindex: "-1",
            onClick: t[7] || (t[7] = js((()=>{}
            ), ["stop"]))
          }, [null !== e.title && void 0 !== e.title ? (Ca(),
            _a("div", {
              key: 0,
              ref: "headerRef",
              class: Y([e.ns.e("header"), {
                "show-close": e.showClose
              }])
            }, [Ma("div", {
              class: Y(e.ns.e("title"))
            }, [e.iconComponent && e.center ? (Ca(),
              Ra(i, {
                key: 0,
                class: Y([e.ns.e("status"), e.typeClass])
              }, {
                default: Fn((()=>[(Ca(),
                  Ra(Kr(e.iconComponent)))])),
                _: 1
              }, 8, ["class"])) : za("v-if", !0), Ma("span", null, te(e.title), 1)], 2), e.showClose ? (Ca(),
              _a("button", {
                key: 0,
                type: "button",
                class: Y(e.ns.e("headerbtn")),
                "aria-label": e.t("el.messagebox.close"),
                onClick: t[0] || (t[0] = t=>e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel")),
                onKeydown: t[1] || (t[1] = Us(js((t=>e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel")), ["prevent"]), ["enter"]))
              }, [ja(i, {
                class: Y(e.ns.e("close"))
              }, {
                default: Fn((()=>[ja(s)])),
                _: 1
              }, 8, ["class"])], 42, UW)) : za("v-if", !0)], 2)) : za("v-if", !0), Ma("div", {
            id: e.contentId,
            class: Y(e.ns.e("content"))
          }, [Ma("div", {
            class: Y(e.ns.e("container"))
          }, [e.iconComponent && !e.center && e.hasMessage ? (Ca(),
            Ra(i, {
              key: 0,
              class: Y([e.ns.e("status"), e.typeClass])
            }, {
              default: Fn((()=>[(Ca(),
                Ra(Kr(e.iconComponent)))])),
              _: 1
            }, 8, ["class"])) : za("v-if", !0), e.hasMessage ? (Ca(),
            _a("div", {
              key: 1,
              class: Y(e.ns.e("message"))
            }, [Qr(e.$slots, "default", {}, (()=>[e.dangerouslyUseHTMLString ? (Ca(),
              Ra(Kr(e.showInput ? "label" : "p"), {
                key: 1,
                for: e.showInput ? e.inputId : void 0,
                innerHTML: e.message
              }, null, 8, ["for", "innerHTML"])) : (Ca(),
              Ra(Kr(e.showInput ? "label" : "p"), {
                key: 0,
                for: e.showInput ? e.inputId : void 0
              }, {
                default: Fn((()=>[$a(te(e.dangerouslyUseHTMLString ? "" : e.message), 1)])),
                _: 1
              }, 8, ["for"]))]))], 2)) : za("v-if", !0)], 2), rr(Ma("div", {
            class: Y(e.ns.e("input"))
          }, [ja(l, {
            id: e.inputId,
            ref: "inputRef",
            modelValue: e.inputValue,
            "onUpdate:modelValue": t[2] || (t[2] = t=>e.inputValue = t),
            type: e.inputType,
            placeholder: e.inputPlaceholder,
            "aria-invalid": e.validateError,
            class: Y({
              invalid: e.validateError
            }),
            onKeydown: Us(e.handleInputEnter, ["enter"])
          }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]), Ma("div", {
            class: Y(e.ns.e("errormsg")),
            style: z({
              visibility: e.editorErrorMessage ? "visible" : "hidden"
            })
          }, te(e.editorErrorMessage), 7)], 2), [[$s, e.showInput]])], 10, $W), Ma("div", {
            class: Y(e.ns.e("btns"))
          }, [e.showCancelButton ? (Ca(),
            Ra(u, {
              key: 0,
              loading: e.cancelButtonLoading,
              class: Y([e.cancelButtonClass]),
              round: e.roundButton,
              size: e.btnSize,
              onClick: t[3] || (t[3] = t=>e.handleAction("cancel")),
              onKeydown: t[4] || (t[4] = Us(js((t=>e.handleAction("cancel")), ["prevent"]), ["enter"]))
            }, {
              default: Fn((()=>[$a(te(e.cancelButtonText || e.t("el.messagebox.cancel")), 1)])),
              _: 1
            }, 8, ["loading", "class", "round", "size"])) : za("v-if", !0), rr(ja(u, {
            ref: "confirmRef",
            type: "primary",
            loading: e.confirmButtonLoading,
            class: Y([e.confirmButtonClasses]),
            round: e.roundButton,
            disabled: e.confirmButtonDisabled,
            size: e.btnSize,
            onClick: t[5] || (t[5] = t=>e.handleAction("confirm")),
            onKeydown: t[6] || (t[6] = Us(js((t=>e.handleAction("confirm")), ["prevent"]), ["enter"]))
          }, {
            default: Fn((()=>[$a(te(e.confirmButtonText || e.t("el.messagebox.confirm")), 1)])),
            _: 1
          }, 8, ["loading", "class", "round", "disabled", "size"]), [[$s, e.showConfirmButton]])], 2)], 6)])),
          _: 3
        }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])], 42, VW)])),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask"]), [[$s, e.visible]])])),
      _: 3
    })
}
], ["__file", "index.vue"]]);
const zW = new Map
  , KW = (e,t,n=null)=>{
    const r = ja(HW, e, y(e.message) || La(e.message) ? {
      default: y(e.message) ? e.message : ()=>e.message
    } : null);
    return r.appContext = n,
      Ys(r, t),
      (e=>{
          let t = document.body;
          return e.appendTo && (b(e.appendTo) && (t = document.querySelector(e.appendTo)),
          $g(e.appendTo) && (t = e.appendTo),
          $g(t) || (t = document.body)),
            t
        }
      )(e).appendChild(t.firstElementChild),
      r.component
  }
  , WW = (e,t)=>{
    const n = document.createElement("div");
    e.onVanish = ()=>{
      Ys(null, n),
        zW.delete(o)
    }
      ,
      e.onAction = t=>{
        const n = zW.get(o);
        let a;
        a = e.showInput ? {
          value: o.inputValue,
          action: t
        } : t,
          e.callback ? e.callback(a, r.proxy) : "cancel" === t || "close" === t ? e.distinguishCancelAndClose && "cancel" !== t ? n.reject("close") : n.reject("cancel") : n.resolve(a)
      }
    ;
    const r = KW(e, n, t)
      , o = r.proxy;
    for (const a in e)
      p(e, a) && !p(o.$props, a) && (o[a] = e[a]);
    return o.visible = !0,
      o
  }
;
function GW(e, t=null) {
  if (!mc)
    return Promise.reject();
  let n;
  return b(e) || La(e) ? e = {
    message: e
  } : n = e.callback,
    new Promise(((r,o)=>{
        const a = WW(e, null != t ? t : GW._context);
        zW.set(a, {
          options: e,
          callback: n,
          resolve: r,
          reject: o
        })
      }
    ))
}
const qW = {
  alert: {
    closeOnPressEscape: !1,
    closeOnClickModal: !1
  },
  confirm: {
    showCancelButton: !0
  },
  prompt: {
    showCancelButton: !0,
    showInput: !0
  }
};
["alert", "confirm", "prompt"].forEach((e=>{
    GW[e] = function(e) {
      return (t,n,r,o)=>{
        let a = "";
        return x(n) ? (r = n,
          a = "") : a = Mg(n) ? "" : n,
          GW(Object.assign({
            title: a,
            message: t,
            type: "",
            ...qW[e]
          }, r, {
            boxType: e
          }), o)
      }
    }(e)
  }
)),
  GW.close = ()=>{
    zW.forEach(((e,t)=>{
        t.doClose()
      }
    )),
      zW.clear()
  }
  ,
  GW._context = null;
const YW = GW;
YW.install = e=>{
  YW._context = e._context,
    e.config.globalProperties.$msgbox = YW,
    e.config.globalProperties.$messageBox = YW,
    e.config.globalProperties.$alert = YW.alert,
    e.config.globalProperties.$confirm = YW.confirm,
    e.config.globalProperties.$prompt = YW.prompt
}
;
const XW = YW
  , QW = ["success", "info", "warning", "error"]
  , JW = uy({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: !1
  },
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: cy
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: [String, Object],
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Function,
    default: ()=>{}
  },
  onClose: {
    type: Function,
    required: !0
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...QW, ""],
    default: ""
  },
  zIndex: Number
})
  , ZW = ["id"]
  , eG = ["textContent"]
  , tG = {
  key: 0
}
  , nG = ["innerHTML"]
  , rG = vr({
  name: "ElNotification"
});
var oG = tS(vr({
  ...rG,
  props: JW,
  emits: {
    destroy: ()=>!0
  },
  setup(e, {expose: t}) {
    const n = e
      , {ns: r, zIndex: o} = Gx("notification")
      , {nextZIndex: a, currentZIndex: i} = o
      , {Close: s} = dy
      , l = Ft(!1);
    let u;
    const c = yi((()=>{
        const e = n.type;
        return e && py[n.type] ? r.m(e) : ""
      }
    ))
      , d = yi((()=>n.type && py[n.type] || n.icon))
      , f = yi((()=>n.position.endsWith("right") ? "right" : "left"))
      , p = yi((()=>n.position.startsWith("top") ? "top" : "bottom"))
      , h = yi((()=>{
        var e;
        return {
          [p.value]: `${n.offset}px`,
          zIndex: null != (e = n.zIndex) ? e : i.value
        }
      }
    ));
    function v() {
      n.duration > 0 && ({stop: u} = Tc((()=>{
          l.value && m()
        }
      ), n.duration))
    }
    function g() {
      null == u || u()
    }
    function m() {
      l.value = !1
    }
    return Lr((()=>{
        v(),
          a(),
          l.value = !0
      }
    )),
      Rc(document, "keydown", (function({code: e}) {
          e === by.delete || e === by.backspace ? g() : e === by.esc ? l.value && m() : v()
        }
      )),
      t({
        visible: l,
        close: m
      }),
      (e,t)=>(Ca(),
        Ra(es, {
          name: Vt(r).b("fade"),
          onBeforeLeave: e.onClose,
          onAfterLeave: t[1] || (t[1] = t=>e.$emit("destroy")),
          persisted: ""
        }, {
          default: Fn((()=>[rr(Ma("div", {
            id: e.id,
            class: Y([Vt(r).b(), e.customClass, Vt(f)]),
            style: z(Vt(h)),
            role: "alert",
            onMouseenter: g,
            onMouseleave: v,
            onClick: t[0] || (t[0] = (...t)=>e.onClick && e.onClick(...t))
          }, [Vt(d) ? (Ca(),
            Ra(Vt(sS), {
              key: 0,
              class: Y([Vt(r).e("icon"), Vt(c)])
            }, {
              default: Fn((()=>[(Ca(),
                Ra(Kr(Vt(d))))])),
              _: 1
            }, 8, ["class"])) : za("v-if", !0), Ma("div", {
            class: Y(Vt(r).e("group"))
          }, [Ma("h2", {
            class: Y(Vt(r).e("title")),
            textContent: te(e.title)
          }, null, 10, eG), rr(Ma("div", {
            class: Y(Vt(r).e("content")),
            style: z(e.title ? void 0 : {
              margin: 0
            })
          }, [Qr(e.$slots, "default", {}, (()=>[e.dangerouslyUseHTMLString ? (Ca(),
            _a(ba, {
              key: 1
            }, [za(" Caution here, message could've been compromised, never use user's input as message "), Ma("p", {
              innerHTML: e.message
            }, null, 8, nG)], 2112)) : (Ca(),
            _a("p", tG, te(e.message), 1))]))], 6), [[$s, e.message]]), e.showClose ? (Ca(),
            Ra(Vt(sS), {
              key: 0,
              class: Y(Vt(r).e("closeBtn")),
              onClick: js(m, ["stop"])
            }, {
              default: Fn((()=>[ja(Vt(s))])),
              _: 1
            }, 8, ["class", "onClick"])) : za("v-if", !0)], 2)], 46, ZW), [[$s, l.value]])])),
          _: 3
        }, 8, ["name", "onBeforeLeave"]))
  }
}), [["__file", "notification.vue"]]);
const aG = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
};
let iG = 1;
const sG = function(e={}, t=null) {
  if (!mc)
    return {
      close: ()=>{}
    };
  ("string" == typeof e || La(e)) && (e = {
    message: e
  });
  const n = e.position || "top-right";
  let r = e.offset || 0;
  aG[n].forEach((({vm: e})=>{
      var t;
      r += ((null == (t = e.el) ? void 0 : t.offsetHeight) || 0) + 16
    }
  )),
    r += 16;
  const o = "notification_" + iG++
    , a = e.onClose
    , i = {
    ...e,
    offset: r,
    id: o,
    onClose: ()=>{
      !function(e, t, n) {
        const r = aG[t]
          , o = r.findIndex((({vm: t})=>{
            var n;
            return (null == (n = t.component) ? void 0 : n.props.id) === e
          }
        ));
        if (-1 === o)
          return;
        const {vm: a} = r[o];
        if (!a)
          return;
        null == n || n(a);
        const i = a.el.offsetHeight
          , s = t.split("-")[0];
        r.splice(o, 1);
        const l = r.length;
        if (l < 1)
          return;
        for (let u = o; u < l; u++) {
          const {el: e, component: t} = r[u].vm
            , n = Number.parseInt(e.style[s], 10) - i - 16;
          t.props.offset = n
        }
      }(o, n, a)
    }
  };
  let s = document.body;
  $g(e.appendTo) ? s = e.appendTo : b(e.appendTo) && (s = document.querySelector(e.appendTo)),
  $g(s) || (s = document.body);
  const l = document.createElement("div")
    , u = ja(oG, i, La(i.message) ? {
    default: ()=>i.message
  } : null);
  return u.appContext = null != t ? t : sG._context,
    u.props.onDestroy = ()=>{
      Ys(null, l)
    }
    ,
    Ys(u, l),
    aG[n].push({
      vm: u
    }),
    s.appendChild(l.firstElementChild),
    {
      close: ()=>{
        u.component.exposed.visible.value = !1
      }
    }
};
QW.forEach((e=>{
    sG[e] = (t={})=>(("string" == typeof t || La(t)) && (t = {
      message: t
    }),
      sG({
        ...t,
        type: e
      }))
  }
)),
  sG.closeAll = function() {
    for (const e of Object.values(aG))
      e.forEach((({vm: e})=>{
          e.component.exposed.visible.value = !1
        }
      ))
  }
  ,
  sG._context = null;
const lG = gy(sG, "$notify");
var uG = ((e=[])=>({
  version: "2.6.0",
  install: (t,n)=>{
    t[Ay] || (t[Ay] = !0,
      e.forEach((e=>t.use(e))),
    n && qx(n, t, !0))
  }
}))([...iW, ...[hW, AW, MW, XW, lG, KB]]);
const cG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAAwCAYAAABe6Vn9AAAAAXNSR0IArs4c6QAADutJREFUaEPNWXtwXNV5/3337lO7euzq7RdYkmVbtiSDHT9iiG0ciN3UJoEJkHELA3k2tJkOTJNOM8wo+SNDm0CaDG06OBTSeFJSmKRx2hBMQI4xARRsgS0ZW7YFsrAMegtJ3ue9p/N959xdSZEfIqHkzuzcu7v3nPP9vt/ve5x7CZdxtLS2+s76GydOD0eC2QxgWwB8gGUTyIZ8YPPvCuTj/wiWpX8nH6Es6CCctdD5uguyzDifAvF4/u4HQOZ+mY9kHrIULNtGQTrlWCderf/xrmu7L2UuXeoG/v/jj3T9trb5yg3xKPD8KQdOVhsMA8AzjI0QkGysACLMjwKfrbOgXIXH3wAOdzqwLA2EDfYcAwbG4/38nx7PjolZCgFFeHdiZPjJa6pKL2XvJQF98rFDu7q6lu356Cf9WBojvJNSOHjGgZtmA0iYYSYswxKfmRU2qqbEwqev0EsoAK5SeOos8GKHo5nh8cIYj2GAZi4zviJAiClgTAFvZ4FI74nd/3VT0+cvBuqigHbteamo69zykYl+v3XDLTbqYxYyDjCYVnjpnAs3zRIzsjPS8YxqKCfsqCYBwodrLvh0oF/h4OuGBQNIgPnzoBaECGUWkHI1oLPnAVIK0ZOHrnrizo2vXgjURQFt+/czp946VVbrusD1N/tQXwykFJB2gdE0cGjAhesYIzzJ2ISrqghbylmSelnl5gF5bJ0cB/Yec3XsMDPMEDPtIyyOEMpthYxDst5IVqF3TMk84ezE5C+2lUXnDOgTu9vu635n5TfgEFRW4bqdNpbGLCQdJYDSChjNKHQMKriOEkM4ZtbPB9aVGpkpBRBB8RkkktNXwMKgjX0DDp49reDCGw8sL7FQ6dPMpHgtRRhOK5wZhtjBoErOd//sZ7c23DQbqFkZuu3R1it7Euu6k+NErkxC2LrdRl0JieSSrpIFGdi4o3BiVGvq2isIjSUkCUAfHhgdQyI9AAuCFurDNn49nMGZSeCZXg30qlILHDdpb36z1lgW6O7TYNysJj4+emjTTz+78cBMULMCumHP20PDg8VxlpNyFOASNm+1UBcjpBwNxAPEi49kFPx+wtYqbbgQYg42go+gRYj7CZVBQk2BzQkMA2kXb5x38bsRFycngCUhLTFeIwsgyYAchdEMcOpNDcizJxxMpJ7pLClAC5kVPBfOgLjzh0ceezu55A4IGPaIgnIImzbZAmgaQ47CcJrQ43CAKzRHCCuLTdwoBucJTGc49l5F0MbqYhvxAOHwqIMXBx38clBH1tVFFuIsXSj4LUJfwhXJjaYVTpxkx2qGWAHs7MpgT+ve25ddNxXCNIZu3X1wfV/B6hedNMERIKxbrZNrN9ioFYZ0DLEnB1JA17ALRbqu8EKNpUBjjGVBIi9Pfh5rfI4FCM3FPvy4N4sDZxk5ZwYNf1W5hWWFhKANHB9XhiGF450aBNvEN7KTSQGL/O03PvH5DXs9UHlALcq6YcXI5PlsOMQ3MxCmlzMcX1+zRjPkJYW+SYUjrGvOcmYWyVYErKgGmuJ56c1M3bx4xLLwyGuuHi82MsvaMX/ZZGN+AeFAv6uzXMrFsVcBl2Mzy2cNjCUYiaaydqC9cP+dW5I6as2x80fH949Fr9jEWY2zlgyQD4nsNq6yUVMEZBTh9JjC4S5HgHJm80KeGA1/JaChBmjiqpg7dJbjP3snFV47CUwk+CvlkTPTBNy73ocryglPvpWVWGXJHX3ZSI5tc0mcLTHlAvPKzh1+6gu1q3OAbv5+2y2jVzb+RN8ITa0wZFjKAhsabNTECK8Pu2g75Gopevbw2dQcD5AwtRxoKjfp2mDrnSD89rCCymg3eHgsxgWgJER48i8CCPkJX21Pww4QxlIu2g9qyYmOOZYMQ5IkCKgp7bjr53+z9lH61L+0Rs/XrxlN235bS02ZwONBTDGnYWBtLSGRBV484ApjIjOjNX3SNcfjXAAyU6sIjeVsBeHNd4GXXwKclBlvxKbnUagptfD1j/uxcp72TveQwsPdGQwohfb9RjUCRktP0rgBGY45bkWkM0Y3/vTMifS8yno3k5eZ3GRY4mvOLKVhoOsFvke7OgeIdPaSis9FlGPBE7IBvWIDEAkotO2H9IA8QyxCWFptYWkVobaSsHK+Jd9nO3onFA6fdtHd7+LEORfH+xQGTecwtUTMX9h/irY8dG50ZLzYJNvp03GQevFRWEOILvr9BdlA/jjskAzgZAGHjebrtILL0soAsZUEX8h0EEbW/J/lKFQHLNRFCVvnWVg/A1R7n4t9Z130FCicSypkJMPpNWQdVpSxIZQce5du+s7zNW9OrDqVeFei23jeeNzIhnHZBYSFO3R7M/VwEjwhIStnwEl6HyULukkgmwaqNlrwG7cxEDelpeekzDWDTxFuXGzj3rW8qQJ+0JbFv+7PomqzBX+hXlXqUArIyjpK1uO5KOuoor62erFu54Mv3dY91PSfvBD3FV76FYZENrozjjUSipdNZ0m8xEazgQltoDaSFyM5Z5MKFRttBBiQMoaIV0lAKeNtNpCd8vD2AOIhws5HUvCXAOXrvS6X19DjGRAzL+c0EBs6ctfPv7T20Zy7tz149Ae9A7Wf8YJZ4oAByWaL06mCFSIs2G7lY4Q9xoaJx4y3GVySjSQ5M0MMunydhUDMdB8GNIPJjWdgGQ3wtuU+lAaBB57NoHKDhUBcmymOEueZeXnulELRaPcT//uFFbdMq0P85bp/fuP4wFDlUs2Srt4aoNmhElDSYKGwLi86Tt9aZlMBmbgyv7Eh5WsJgRjl9C73S6xRfizHXQq4upwQDxKeOeOi8hoNRst5igIEDBAeH3zr6bsWLPQsmhYQn2rpDPQVVY6OTxSEvYTgFU6POV+YULWVGxt9SIAyEynNiBdDOQNMHJWtYU9rWboZlqL2NMtFmJTfNEjuuLnX66tSCFfprkXL0cQqM8w75vPJTNmp9vgTLVsmZgWk46m17pz7oa5M2qJcljMtibcZK1oCFNZoXXPadBPGqJwktPemsla6hhAo0gx57Mg1j5GzSSppgDJAvJjgX6OrrY5NzSTfK3GTchDvO7Tuv+/5SNvUJDXr9mH7tw/t6ncb9khfbnaUfJYHI7wZCxGqPjIlUHOSM142cSSZLE1wkwrxqy34o1Okw3JjlkzK5e08G63PQMkKQmSBZpK/5+KRHZBQKO7v/PtffHnNP86sWxfcgm978Mhj/WrJHQzAaxp1MdVbZa5LkUVG396CwsqUmPACOAXEmgn+wryBwggbZ+JGvM81K62TUdVm0v9NkbMHLjLw5m+e+qtlm2crwhcEJEniez0nx9yKOmFmChhhywdUfFizlA9YA8bUBqkz5rq40UIgMkWGXItM/OQSg6lP0cWEwsX5ubzsxnFjj42NPHdnZXw2ML+X5WbexEni7YrqsZQbDuUyHz9LE/kRChYpROZb4knxnqkP+trEBWufJdJA8Ed1WvaKqThCJJeXGycZTjoclzoG9RieU01m3ODJI9X7Wjb2vydAPGjHN1uXDcXXHnNEd6b/lIeM2h/l63h7YeLBK6wmpqRwmvRcuIQ0Q+Y3yW5eHRJgLEcX4WoLhbU67nJFmudLKJScad++9ysf/tWFwFySIW/gn9//8u1DZc0/zHcNukbxU9JQNRCumCo1wwJ7OJfRCIW1gL8gn9W8NknHkFeTgIprLN0HeoBYsmkg0nPiu7+8p/lvLwbmsgHxjdseOLpnLF63i6XmdQ+ybXYgGYwlkusYTHeQC+iUQnQR4I9autUx2U2uxXidHAIlhOIlpsNgZ7BTMkCw72zHvrtrGy8FZk6A+OatD/WcTsUqa3IJQpKFQqjCkj5NvJowqds0kF4TGpkH+Ao1IMlupjjm4iilULaOwDtm3ehq1jE8nth8pqOopWWL2VJeHNZFs9zMoZsfbQ3BbR51ogVBaYskhROcSYXilVaOIenfTGviSSdcDfgjprDOUkx9Aa49loDxYkdNuip04kD90y3bTl0OO3NmiAdsbznQMLlkdQcFbZLXKObBSKAIsMOm/fE6BlND2MBQOeCLaGZyHYKJHzdJiK/ih5KmsZXOHSjseu2O//nauv+4XDDvCRAP+tj9bZ9L1Tc9LG8eDKDUiELxUkuYmVbVefuQAoJxBqQLq1dMJZNxISVCSUMeLLc2/u7TP/n1vStumwuY9wyIB97wQOfjmfraW723DdxzWQEFK8Bxwm2+Nlakl1CyudN1KN+3efuh4iWWPKz35Gn3DvY++9cLFs0VzB8EiAd/9N96e9Ti8kXe3ilx1kW0loPZ25GaDJYC7KhCoIAka3lZzWtIOXZ0RgTUUDJT3jO9g54LsDklhZkT72h5pSBRXzuCinBAPznVz9W4//O6Ys9QK8x1SDPk9WjMYOEi/fpRst6Ei9DxV9Y93TK9g/5/AyT1qeVAU3bth161IiTbjfFuB5GFVv75gkkQ5FciOdnNys4UyE64KFlh57qJcEfnV3513+pvzQXAzHv/IIa8yT72jZe/SJuav8/vSyXouRVSU7ruhJJXl5y29YMTHV+hMgt2WEuNut74zXN/t3zWDnouAP8ogCRJPPj6k/bGxTfzs7nRToXwvClxxLGhFHi3623mMmN6O8+SVL0jI/vvrr5gB/2BABJQu3t7/VdXLMiM87ZBS0tSODeeGQVfgdnjcJIoUAiwBAfTbqjjaPW+b1+4g/7AAHGSSDfXjQRqw4HBV1zTtJotQkpJ4eXnBslhoGQZITuhEOps3/50y8U76A8MEC98/T+8sMr/Z6sPZ7OgzLh+6M/tTDYBzRC/HwHgjxHsI53fee6+1ffMxeBL3ftHi6GpC13/9d/dHfpE40MDbQqhMpJOITvODAHJQaColoBjZztav3p5HfSlQEz9/30BJEx9q3Ov21S7g5nhLJYZVbBDQCYJhNyJ89Y7HcX7L7OD/pMAJKB2v9U35pZWB/lV5pBODgUxR1nHnq/ff//ld9B/MoA2f6k16jauGEBZUSg5wIBcxPqO3v7MP63/0VyMnMu975vkPCOubzm4ZrysuS016aNY4vTjz7Ws/PRcDJzrve87IDZo69cOfzmpij7zwjfrmudq4Fzv/z9+px9+vPI+qQAAAABJRU5ErkJggg=="
  , dG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAAXNSR0IArs4c6QAACuJJREFUaEPNW22MVFcZft4768ICq10ouAnWNlrcD6R87c5+AbttpWKDUtsfCtaojVQ0Ggk0jTbqD2PUNEXTP00DBmwMW9saFWnaBll32WXZnWXBuljYLRj7o0REbVG2fOzO3FfOufeeOffce2fmzsw2vQlh5u6Zc97nvF/P+95zCTN08ejqOUjM6wDQBKY6AHUA1YJQDUY1iMTKlwG6DMIFMCYA+W8UmTmD1HTwykyIJlct18V/aV8Eu2IzbPsBgFpAVAkGHHD6Utpn8Tc5RkjhjeMpAMOA9VtY9CwtP3SxXDKWBTCfbF8HpkcA+hSACglQAYX/s8Tl/l2iIPe7Qu1ukLcBSIP5ZSDxBK061F8q8JIA8/E1XbDsHwK0NitIiCZ1gI4pu5f3WYDWNkZg9zbG2xTxP2MAoO/Tqj8eKRZ4UYB5pLkWVmIXQFt8wktgHG7COiBHeE2ThqZDXUBNIAZ3Yzq9k5J9F+ICjw2YT7RtANvPAnRTVlERJhwApZlzoZr2xvn8XM5zCRneTKt7XokDOhZgHk3uAOhxgBPZIORO4WnX80nPFE2N+/xX13KEqQtT8DQe3MAMCI/Sip6fFQq6IMD8WmMlrsx5GqCvuM7lCsGaaWompwctT0gPuPc9DLipRS+y664i/dsNdFnX2IfKmm209AUR3XNeeQHz6OqbwXwAsNqzYI0A4zNPFV390ViNyRG0BBAzYKkNcteUYM0YIG8MImPfR019/86FOCdgqdl3ZveCyAFrmpSpSRVZfQHG0QijBxY9B5v6Med95+V8V6YXw+J1gPU5AHdnI7MW/MKCm+cuwcg+iFkL7sql6dyAR1bsBVmOGUcubASioFmehU1bKTmUM5XwybWdYN4DYIkCXsiaQY3vo5V/eihKy5GAObV8B4h2+UhEID+a5usGGOVnGEBl5Sa64+jb+XxL7unYmhpM4wDAa1VQzEliwhibtI6dtKo3NJCFAuaROzYA9CJAiaygIeQgzHezAp5FZWVLoWC9dRzQdgqwHE17l4rU2qaGpTZn/QzY2hiWsgKAeaSxFpw4A6KbcvLgUPak+S5TFyWPF8WIeKStEwnqK259tUWXkEaDSU6CgFPL9gPY4lYz+ha7nzU6qO++vwDooebRTxRixlFj+ET7YSeQGSKqjQ4zZ83FnNTVTSt7v+AzFP0LD328CxZ6nXsR/mH+TeVKX6p6mJInRQAq+uIT7VvBvDs8gOXg6z56KwPqnbSyr0/pxgc4tVRUI8GAEeVH5u4r8Il6ah4VtW3RFx/vqINlj6vSUS8zdfYmvchIg/6cP0CrjqwLAOaRBlHiHXFzpqvkEPYklR9CEHT2M+d6NS09PVk0WoHhta55uHrtsi9oRVVRntXpvFuXk9BJq/plaalsg4caDoKwUZlQqOm6G0CWI4fYaR93ds163nTpgI92VGN2+n8arcpudBgw3+4KOd2s4pCeg7S6/zMKMA9+dBESkv1U5PRdHxEwKZ5uDVxPzWMlmnRTHchyTTqKjprdEh21LwalkcgspuXHLsq7PNywHeCf+zfJNNuwlO3upO7jclOshyn5aolBq3krbOz2aSpgdT4jNSzA8GvL2k4r+590Adf1+7sWGvRAO0anme4mmKUhcw+1nCotLR1vPgzw3ZHtIM+tlK9q7mVWaA6cAVo9uI5kdzH9jqB+lbmDjA7O9f7QBp2764QuSp4qkng0d4LsPl/NrRcKnqYDvF2tneX+WTecAl+rIR5uWA/woXgR1Wu8hViCas/wWUxRC609VRCP9mbisWU1mKpMweYlWfKjkx0jUIY1C3WL06M10z3Ew/XfvaHdH8cG7HUiwrScvTeAKWwqFDQPLKvBrIoDkguY3Dmszat4u+HLeprSMwnTY8RD9b8E4UvxAJujDVbmFfLO7bMga2s+8+aRlZ2AKA9pib+DaVZgejAyApOZIoPE6Bmh4SEArSUBNts1Kgf6dr4HZD0Hon5Mps9jkWgAVCwGGw0AFYm9nO9lC62to8YYgUrPFqEWgWEB+O8AbisJsD+f6Y6dbbL7uo+aT+rBSEVX7UmE6Y+eT5obowAaOdvPrd8QgEUPaEH5ALszhXYnwyqfkHsKjFKZ88HXUhKm7jI+JXxIv8vf9PuPAHw9f0oqZTs0IUyhxXc9ypo536fNCPBqjLZxAUbo9siAqXcBcJSW3Pui0pHmrpKqnwebmxIZrUN4fXCsBDwzJp3LKMxqy+e7JoXVHraZ/S2f6ecjRnIRadJlDloxzF+RFF3BOskwrCOyJx1iRWGBlCCDVulpKRqjeBJwFMBhEI0jw+dgVVxElTWJibFrWNhYhSprLohrwZnbQVQP0HowxIN0/2PXMKsI+HiIdXhW4Px+uEzEw4f4AohfBKyXMG0fpjUT2SK+QOXz6Ec+gHTVelh0L9jeCKaFvh5bVD0sOx/a8yozFTJL4lEEtQyV/DxAP0E17aGlp/M+4ykQO7j3ttmomrsN4O8A9MEA8FzN+kBu5seKLB584v4DzD/Fteu76c43rhUKJO44p6q7+g3xtBCghbGfLzvKvydGeRgq4h7Yk9+m9jevxgVQ7HjubZyHKnoKhC9m58jD3JzUNoVERU3+BkC4ZFdB+Dq1jD9TrOCl/o5TjV8D8OQNN5rlOq4W6j1f1omN1U/JVzujWzzREp0D+AFqnRgrVehSf8+puiaw9RuAbnVoZ9RxCwJsbKfWMbfF42vi5RGD6H5qOfO7UoUt1+95uPFBEH7lm0+yNxmuvdtppK3F1DHmNPGkiafq/wDGpwsQ5J+wrBWUPB37QEkBc8cawqONH0ba/jNA89UPwx+6HaSWv2bbtBKwaMTbXGgPqhcVcz9JTSemY0lYxsH80u2zML9CPBZqCwYvo7Iiu5OSZ/yNeAl6OEf30hSW0Y3W8QeJ1CGFMsLJPRU/jwRuqX8BhM9Gj1QkZIBaTgcftUjAQ/VdIO9hWiHy81NomfjmuwmaGRZS9b8A4B6wiZLTBWxzF7WPK8s1yacAvR8E7cBZXuC/xlvpL9O950RdPaOXQz4m9wN0X0ELMbqpbTz6canjy421sDNnfAfP8s5OR2FnPk/trzuHVWbg4sGGW5HA8wAnC5ueL8FKNJjBNaBhCfpY3QZY4sgDtCMPeZd5G8zforYJ8UC9rBcP1z0EkHgU9P4CJ87A5o3UPhE4pRcK2PXnHTfONu8qcIHsMGbRnfwetZ4Zjv1b4wecalwLtn8EQAWdguZk7KS28cIPtXiT8nD93vzBIUIEwisA78WV6wfjFBV87ENVsKo3ge2vgsg5uxXv2ket4/GPLUkti4Npk3YvGO4pvHgru6P/6zQAOIUMjYDTb8KuegvpBZcx61/CROfDSt8CtpIAt4AgHsJVF7USMIhq665c5WmkSSstj37sZqSt3wOyC/FevgZRIY4evl780UMFWmj6sv100eY989u0D9XWtkIaD3k1rMvKQ/UikD0eM3rPJNwMGI9GBaiwhWMBln4tUxb8B8RnElLk3HwJNjaHpZ5c4sQGLEELcpKxd8VkZOXbFsHjE9bOYiq2ogAr35bcm42XPMqHKzgTD4DpB9Q2rg6axV2tJMAKuDzjxY+A4bzGU94rDcLLIHrCK/FKmb4sgBVw2Tmp3ALY98sXtfKeG4kUfUq0JOSLWpmpbur423vrRa0wsZ3K5koHwE1g1IHEq3iodUmFRyxEk178c17FI/EqHo2iQryKd2JGXsX7P8B1xEbC6SVHAAAAAElFTkSuQmCC"
  , fG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEQAAABOCAYAAACZiLDUAAAAAXNSR0IArs4c6QAACdBJREFUeF7dnH9wVFcVx7/n7SZNCB1G0JZghcqPvLcpIzCE7NuAloBl+gOh2FLbIs44dKxKcWwtYju1jlatQEeq/YFaxBkLVitT7Ii11ArVgezbkHQKLbtvgWLTVsnQqSUtITHZfcfct5s0u/t29+3bze4m9z/Yc8695zP33XvuueeGMEYbPzfzIkyq+ALYWAXQXACTAZwH8CaA/YBrF6nHg8nu01jkwX55BYh+BuDyDP4ZYP4NKHoXqafeH5Qbc0BYU+4B8CMAdn0Lwi1dQw1BMXNsK42KicQBzzow78h5sIzXMK5SpTnHuu1SzLmPYinwwcurUF09F4bxaUj0IACXs775cVLD60clEG6d/Qlw9BYYxjIQLQRQ5QxCglY/XFFlVAGJL5YbACwBIBUAQqIJ5u+OCiAxEPh+fPssOIchg4SWsgbChz3TIPGjICwfOQoJljvLFghr8kqAdgEYXyQYopu+sgTCAXkjmH5ia51gvAnCaQCLCwDuTFkB4bb5Feg/vx1E67I4dxZET4B5L6l6O7fIV0Oiv+YPhA6VDRBuuawa0vi/AGjO4FgPiH6KfmMzLQp/MCgXi0Wq3gUwLk8o95YPEE35HYBb0jpE2A2OfIfUU29bybBf3mFjZmXi1Qe3NKssgLCm3A1ga5rRRkC8gbzhX2TyxgzWjEgYQLWzWcIPkxq+s+RAWFOWAXjOOuTmc2BpNflCL9pxkv3yGpC5M+XaXoZxfhE1vd1TUiAckD8JpnYAH7HwoBOG0UxNJ/RcvGO//A0QbbO1Q8UMvww3LaeG0Bnxj9IC0ZQ9AG6wcLgPBpqpSW/JBcbQIuv3fBaEnwPsyaDfD2A73DX3UEP7hUG5kgHh1roFMKRWywEzvkI+/QknMD7ceRa7UdUpEkWrwDwXNCxjRiJjxk+RN/yv5D5KB8QvvwiipSlOE20nb+jr+cDIR7ckQNic0vw3y3XDXTNj+BTOxzknuqUBoikaAG/qgGk9qaHHnThSKJ2iA+HW+itgGK9ZOHAa7hqFGtrFYleyVnwgmvJjACIRnNR4LalhJzFEQeGVAoiIJuuSvLiAnt5J1PxGb0G9c2CsqED4kDwFbvq3xdrxLKmh6x2Mv+AqxQUSUG4FY7fF57KO1PDOgnvnwGBxgWieLQBvTBqngWh/LS18/ayD8RdcJSMQPiLLiEpTQSKNx51w9QWp4XSX01Gwpjw7cHZYkaTfQaqe6crRaXemHrdNn4BoZT1Ak8HcDRd30IKwWMcsWwoQPiRfDDeJ4/iXLO5GxZZ4AODNpIYP5jpS1jxBi/OFRqruy9VWNnnW5GaANsWvLCqS5N8A+ElEsHV4oknIJADh1vqlMAyRqLkkW4cAfg93zbpcokrWlM6BA9WlCbYZe8mnf95Gf7ZEuG3+OES6fw3gZhsKZyFJt1Jj8O+DskNA2C/fBCKx4LltGIqLUCuqK5aIO1E7OqwpQi45zfcYqfoddvSzyfDRT9XgQt9BEBZkkx32ewTMa8gXfnpohnBrvbgbFUdtJ9mmPaTqq7MNgBmEgGKkytH9pIYeyKZv53fWlD8CuNGObJJMDySpiRqDr5gzZCBrJWA4/46JlpM3JBLEaRs/DRemKhELgXtJ1cUldV6NA57rwLwvDyN+UvUmYs1zFcAv5GEIYBwhn95YUiB+pTXHT8ViuLSMWFNE8vb2vIDEPr7nYaAnrR1iAsgqGj0Oxom8+pdQDcbVedmIKf9SzBCrrbAAtkeliaCYIecATBiVwy/8oLsEEJFgdbK7FH44pbfYI4C8DmB66cdSFiM4LYA43bsTPSB0gRHN4tbE1N+5ZyDETr8Y2+FEcIEL8tnvIdbkLwL0pJ1+M8hkPaCNeBziVzpAmJqfH7yWzIrfiW5x+pvm2BhhA3n1R0sahwSUO8B4xLEPos7kvUhdPFKVbwRIfDpO2qu4WGqgK4J9GYEwJASU1E+K+T7yhUWhbV6Nj9dX4n2jHYTZzgzxalLDez483Fknb7LZfheuaCMtOCkqeLI2Dii9YFyUIMjYRj79rqzKNgT4yKzpiLrEbeAkG+LDRGgrqaFvi/9IPP775ftA9AObd74nRTEceXXbUSZryjsAPpo4WP4DqWE7R3VbPnJAqQNDnGlm2VBgMN9PvvAPB2VTE0QtdY1wSVvAuDKNwS4QtqGq8iG7x/5BOxzwnALzjCS7/yRVT9eXDZ9SRcw0QG/f3WDcmTboJPwDhrSJfMHAcAtpU4jxkshlkGgaGOPBODPw1OIoJrgOZFsv0nnBmiIOkVcl/X6SVD35WsIRiGQlc13pii4BSXNAqAXhPAzugEEv0MJQh1UnxU0y+5VHQEhMBhH+B1fNxFwybwWhlcZIcYEE5K+CaXvKWIhWkTf0p5F01K7t4gLxz/KAXCmvmADaSWooWymmXZ/ykisqEDFSy0QzcBZevZYIFinGvPzLWbn4QNKVTzKayae/lLMHBVYoPpDYfckBCz8Kvv06YVV8ILEQXkS2qWcnNq4l34kClGg7QRHTKToQcx3xe24DsVVR3VF49XlEYOcu5adZGiAHF7tR3Xncok4EIP5atqrl/FzOrF0SILHdJu0Juw+ExeTV/fk6zodnXAKpYiUIcwYy6rWxh8zcAcZ+qGG/1a5WOiCxmzxxMm2wcLwTEZ5Pi8L/cQKF2zy16DceANGXM1Q0nwJjE/n0Z4b3UTIg5ixp9XwGBosdx+ppaQDVlUtzP0AqPjBE1Gvnwl4M41fombyeml8ybxVLCsSEEns9tcV6JvArQPRz6Z6EJOtwS/08SMbh3G8RaBepobVlASQevWZ6K3MGxCvIG27L9PnEb/6DjvOq8cW85DPEBCJeU7nGHwZjXhqnRVb+m/DqO9KF9xxLbjmvIiC8g36eURZATCht9VMRMcTOMiXDTHgVhI3k1fcPl+FYsCeed9hdN9J1cXvZAIl9OjMvA1x/tvFgeb+ZtXPVHBCVz6x5VBHuOdmREnQY+8oKiAlFpP96+ncDvDK7g3wOkPaB8YEI6LLLZ5XoKDsgJpTYJ7B5IJASxX/FbL1lCWSQAAc84vGPuHz6eJGo/LesgZizJVYm+j0A4lHRSFcpHCt7IEOzRZt9KRARVdC3jVw9Cz88aoAMgRGvuMdVrQJjTfy9f03BPidC06gDkhB/iHuXblbBUMHGlQBd6xgO4Xny6teMaiApZxlNfgwgJw8Y34Mr2iDuqMcWEPHXJSLdewFcl8NMETmSFYO1+2MKiLkrmQXCngcBFve6WcrUKQQYN5MaPjYIcMwBGVp8W+oUuOhbAK0E42PDZowBUAuYf4u39J10U2IZ2JgFMgTGjHpnTgG5JsMwutFb8RY1B8XfRLRsYx5IDmuJKfp/2vlXJML3k/8AAAAASUVORK5CYII="
  , pG = ml("user", (()=>{
    const e = Ft({
      agent_level: 0,
      bind_time: "",
      company_code: "",
      diamond: 0,
      headimgurl: "",
      identity: "",
      is_agent: !1,
      is_bind: 0,
      member_code: "",
      member_id: 0,
      phone: "",
      token: "",
      username: ""
    });
    return {
      userInfo: e,
      setUserInfo: t=>{
        e.value = t
      }
    }
  }
), {
  persist: !0
})
  , hG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAm1JREFUSEu1lk+ITmEUxn+PfwtWCpHCmgVSLDA0arJgYYoYpVgohlkpRLOYyJ+sZCwQNRKZslFCSMrKYlhgiw2hlDKaxHHP17l67/Xd+33R3M3te+95z3PO85z3eT9R85jZbGAdsBaYB8yK8I/Au2z9MfBQ0oeqNGr2wcw8UR/QDUysKwL4CdwCzkpy4MLzF4CZdQJngGkR+Qt4ATwH8gRewBJgMTAh4r4BByQ9ShEKAGa2Azgcm34A14ELkj5VdDoT2A1sAyYDXswJSUN5/B+AqPw84Gvvs2r3SnrVgp7GZzNbmOnje+cESG/eSQMgOL8btHjyzeWqzWwlsCy6eybpaQpuZt7NcIA4XetdkxzgmCcFnBZP/jrfbGZTgHPAmlI3PkF9ksaSWO/kZtA1LOmoYhRdGJ+WIUnHS5X1A9tj7XO8Z8T7mqSBUvwRwLX06ep0AN/sSVyg1ZLyJE7dJOAOMD+j5zZw0BkFTgMbs9/fgRWlLpyqJ0HlgANcBDqAEUlba6ZlTNLX0Gw5cDViuyS9LXVxA1jqQA5wD1iQVXlF0sk2p2Y/sC+69g4awIkWh4CdwBsHGMlangqcknS5DsDMNgEbgFUR9yCbtt7yHjPbFXSOtg2QUTk3ozI9pU5LT6pZ0kEBoC2KzGxReI7nuQQMShqt0KxAUUuRQ9jpQFckvC/pSxWdZlYQOR3TjhrfaQsgTnRhTN3zKw9awmtKUbeklxX0FA9atJ9axZZmJlfSoClAmF7RKto1u1bno9bsAsQvmsE44u6oe1LTa3E+6u064flfL5wewH2r+sJJQMbvykxAxu/SL5nWf/9t+Q06PEQ2hVscVgAAAABJRU5ErkJggg==";
function vG(e, t) {
  return function() {
    return e.apply(t, arguments)
  }
}
const {toString: gG} = Object.prototype
  , {getPrototypeOf: mG} = Object
  , yG = (bG = Object.create(null),
    e=>{
      const t = gG.call(e);
      return bG[t] || (bG[t] = t.slice(8, -1).toLowerCase())
    }
);
var bG;
const wG = e=>(e = e.toLowerCase(),
  t=>yG(t) === e)
  , xG = e=>t=>typeof t === e
  , {isArray: SG} = Array
  , EG = xG("undefined");
const AG = wG("ArrayBuffer");
const CG = xG("string")
  , kG = xG("function")
  , TG = xG("number")
  , DG = e=>null !== e && "object" == typeof e
  , OG = e=>{
  if ("object" !== yG(e))
    return !1;
  const t = mG(e);
  return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e)
}
  , _G = wG("Date")
  , RG = wG("File")
  , LG = wG("Blob")
  , IG = wG("FileList")
  , PG = wG("URLSearchParams");
function FG(e, t, {allOwnKeys: n=!1}={}) {
  if (null == e)
    return;
  let r, o;
  if ("object" != typeof e && (e = [e]),
    SG(e))
    for (r = 0,
           o = e.length; r < o; r++)
      t.call(null, e[r], r, e);
  else {
    const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e)
      , a = o.length;
    let i;
    for (r = 0; r < a; r++)
      i = o[r],
        t.call(null, e[i], i, e)
  }
}
function BG(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r, o = n.length;
  for (; o-- > 0; )
    if (r = n[o],
    t === r.toLowerCase())
      return r;
  return null
}
const NG = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global
  , MG = e=>!EG(e) && e !== NG;
const jG = (VG = "undefined" != typeof Uint8Array && mG(Uint8Array),
  e=>VG && e instanceof VG);
var VG;
const UG = wG("HTMLFormElement")
  , $G = (({hasOwnProperty: e})=>(t,n)=>e.call(t, n))(Object.prototype)
  , HG = wG("RegExp")
  , zG = (e,t)=>{
  const n = Object.getOwnPropertyDescriptors(e)
    , r = {};
  FG(n, ((n,o)=>{
      !1 !== t(n, o, e) && (r[o] = n)
    }
  )),
    Object.defineProperties(e, r)
}
  , KG = "abcdefghijklmnopqrstuvwxyz"
  , WG = "0123456789"
  , GG = {
  DIGIT: WG,
  ALPHA: KG,
  ALPHA_DIGIT: KG + KG.toUpperCase() + WG
};
const qG = wG("AsyncFunction")
  , YG = {
  isArray: SG,
  isArrayBuffer: AG,
  isBuffer: function(e) {
    return null !== e && !EG(e) && null !== e.constructor && !EG(e.constructor) && kG(e.constructor.isBuffer) && e.constructor.isBuffer(e)
  },
  isFormData: e=>{
    let t;
    return e && ("function" == typeof FormData && e instanceof FormData || kG(e.append) && ("formdata" === (t = yG(e)) || "object" === t && kG(e.toString) && "[object FormData]" === e.toString()))
  }
  ,
  isArrayBufferView: function(e) {
    let t;
    return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && AG(e.buffer),
      t
  },
  isString: CG,
  isNumber: TG,
  isBoolean: e=>!0 === e || !1 === e,
  isObject: DG,
  isPlainObject: OG,
  isUndefined: EG,
  isDate: _G,
  isFile: RG,
  isBlob: LG,
  isRegExp: HG,
  isFunction: kG,
  isStream: e=>DG(e) && kG(e.pipe),
  isURLSearchParams: PG,
  isTypedArray: jG,
  isFileList: IG,
  forEach: FG,
  merge: function e() {
    const {caseless: t} = MG(this) && this || {}
      , n = {}
      , r = (r,o)=>{
        const a = t && BG(n, o) || o;
        OG(n[a]) && OG(r) ? n[a] = e(n[a], r) : OG(r) ? n[a] = e({}, r) : SG(r) ? n[a] = r.slice() : n[a] = r
      }
    ;
    for (let o = 0, a = arguments.length; o < a; o++)
      arguments[o] && FG(arguments[o], r);
    return n
  },
  extend: (e,t,n,{allOwnKeys: r}={})=>(FG(t, ((t,r)=>{
      n && kG(t) ? e[r] = vG(t, n) : e[r] = t
    }
  ), {
    allOwnKeys: r
  }),
    e),
  trim: e=>e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
  stripBOM: e=>(65279 === e.charCodeAt(0) && (e = e.slice(1)),
    e),
  inherits: (e,t,n,r)=>{
    e.prototype = Object.create(t.prototype, r),
      e.prototype.constructor = e,
      Object.defineProperty(e, "super", {
        value: t.prototype
      }),
    n && Object.assign(e.prototype, n)
  }
  ,
  toFlatObject: (e,t,n,r)=>{
    let o, a, i;
    const s = {};
    if (t = t || {},
    null == e)
      return t;
    do {
      for (o = Object.getOwnPropertyNames(e),
             a = o.length; a-- > 0; )
        i = o[a],
        r && !r(i, e, t) || s[i] || (t[i] = e[i],
          s[i] = !0);
      e = !1 !== n && mG(e)
    } while (e && (!n || n(e, t)) && e !== Object.prototype);
    return t
  }
  ,
  kindOf: yG,
  kindOfTest: wG,
  endsWith: (e,t,n)=>{
    e = String(e),
    (void 0 === n || n > e.length) && (n = e.length),
      n -= t.length;
    const r = e.indexOf(t, n);
    return -1 !== r && r === n
  }
  ,
  toArray: e=>{
    if (!e)
      return null;
    if (SG(e))
      return e;
    let t = e.length;
    if (!TG(t))
      return null;
    const n = new Array(t);
    for (; t-- > 0; )
      n[t] = e[t];
    return n
  }
  ,
  forEachEntry: (e,t)=>{
    const n = (e && e[Symbol.iterator]).call(e);
    let r;
    for (; (r = n.next()) && !r.done; ) {
      const n = r.value;
      t.call(e, n[0], n[1])
    }
  }
  ,
  matchAll: (e,t)=>{
    let n;
    const r = [];
    for (; null !== (n = e.exec(t)); )
      r.push(n);
    return r
  }
  ,
  isHTMLForm: UG,
  hasOwnProperty: $G,
  hasOwnProp: $G,
  reduceDescriptors: zG,
  freezeMethods: e=>{
    zG(e, ((t,n)=>{
        if (kG(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
          return !1;
        const r = e[n];
        kG(r) && (t.enumerable = !1,
          "writable"in t ? t.writable = !1 : t.set || (t.set = ()=>{
              throw Error("Can not rewrite read-only method '" + n + "'")
            }
          ))
      }
    ))
  }
  ,
  toObjectSet: (e,t)=>{
    const n = {}
      , r = e=>{
        e.forEach((e=>{
            n[e] = !0
          }
        ))
      }
    ;
    return SG(e) ? r(e) : r(String(e).split(t)),
      n
  }
  ,
  toCamelCase: e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(e, t, n) {
      return t.toUpperCase() + n
    }
  )),
  noop: ()=>{}
  ,
  toFiniteNumber: (e,t)=>(e = +e,
    Number.isFinite(e) ? e : t),
  findKey: BG,
  global: NG,
  isContextDefined: MG,
  ALPHABET: GG,
  generateString: (e=16,t=GG.ALPHA_DIGIT)=>{
    let n = "";
    const {length: r} = t;
    for (; e--; )
      n += t[Math.random() * r | 0];
    return n
  }
  ,
  isSpecCompliantForm: function(e) {
    return !!(e && kG(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator])
  },
  toJSONObject: e=>{
    const t = new Array(10)
      , n = (e,r)=>{
        if (DG(e)) {
          if (t.indexOf(e) >= 0)
            return;
          if (!("toJSON"in e)) {
            t[r] = e;
            const o = SG(e) ? [] : {};
            return FG(e, ((e,t)=>{
                const a = n(e, r + 1);
                !EG(a) && (o[t] = a)
              }
            )),
              t[r] = void 0,
              o
          }
        }
        return e
      }
    ;
    return n(e, 0)
  }
  ,
  isAsyncFn: qG,
  isThenable: e=>e && (DG(e) || kG(e)) && kG(e.then) && kG(e.catch)
};
function XG(e, t, n, r, o) {
  Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
    this.message = e,
    this.name = "AxiosError",
  t && (this.code = t),
  n && (this.config = n),
  r && (this.request = r),
  o && (this.response = o)
}
YG.inherits(XG, Error, {
  toJSON: function() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: YG.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    }
  }
});
const QG = XG.prototype
  , JG = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e=>{
    JG[e] = {
      value: e
    }
  }
)),
  Object.defineProperties(XG, JG),
  Object.defineProperty(QG, "isAxiosError", {
    value: !0
  }),
  XG.from = (e,t,n,r,o,a)=>{
    const i = Object.create(QG);
    return YG.toFlatObject(e, i, (function(e) {
        return e !== Error.prototype
      }
    ), (e=>"isAxiosError" !== e)),
      XG.call(i, e.message, t, n, r, o),
      i.cause = e,
      i.name = e.name,
    a && Object.assign(i, a),
      i
  }
;
function ZG(e) {
  return YG.isPlainObject(e) || YG.isArray(e)
}
function eq(e) {
  return YG.endsWith(e, "[]") ? e.slice(0, -2) : e
}
function tq(e, t, n) {
  return e ? e.concat(t).map((function(e, t) {
      return e = eq(e),
        !n && t ? "[" + e + "]" : e
    }
  )).join(n ? "." : "") : t
}
const nq = YG.toFlatObject(YG, {}, null, (function(e) {
    return /^is[A-Z]/.test(e)
  }
));
function rq(e, t, n) {
  if (!YG.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData;
  const r = (n = YG.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, (function(e, t) {
      return !YG.isUndefined(t[e])
    }
  ))).metaTokens
    , o = n.visitor || u
    , a = n.dots
    , i = n.indexes
    , s = (n.Blob || "undefined" != typeof Blob && Blob) && YG.isSpecCompliantForm(t);
  if (!YG.isFunction(o))
    throw new TypeError("visitor must be a function");
  function l(e) {
    if (null === e)
      return "";
    if (YG.isDate(e))
      return e.toISOString();
    if (!s && YG.isBlob(e))
      throw new XG("Blob is not supported. Use a Buffer instead.");
    return YG.isArrayBuffer(e) || YG.isTypedArray(e) ? s && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e
  }
  function u(e, n, o) {
    let s = e;
    if (e && !o && "object" == typeof e)
      if (YG.endsWith(n, "{}"))
        n = r ? n : n.slice(0, -2),
          e = JSON.stringify(e);
      else if (YG.isArray(e) && function(e) {
        return YG.isArray(e) && !e.some(ZG)
      }(e) || (YG.isFileList(e) || YG.endsWith(n, "[]")) && (s = YG.toArray(e)))
        return n = eq(n),
          s.forEach((function(e, r) {
              !YG.isUndefined(e) && null !== e && t.append(!0 === i ? tq([n], r, a) : null === i ? n : n + "[]", l(e))
            }
          )),
          !1;
    return !!ZG(e) || (t.append(tq(o, n, a), l(e)),
      !1)
  }
  const c = []
    , d = Object.assign(nq, {
    defaultVisitor: u,
    convertValue: l,
    isVisitable: ZG
  });
  if (!YG.isObject(e))
    throw new TypeError("data must be an object");
  return function e(n, r) {
    if (!YG.isUndefined(n)) {
      if (-1 !== c.indexOf(n))
        throw Error("Circular reference detected in " + r.join("."));
      c.push(n),
        YG.forEach(n, (function(n, a) {
            !0 === (!(YG.isUndefined(n) || null === n) && o.call(t, n, YG.isString(a) ? a.trim() : a, r, d)) && e(n, r ? r.concat(a) : [a])
          }
        )),
        c.pop()
    }
  }(e),
    t
}
function oq(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function(e) {
      return t[e]
    }
  ))
}
function aq(e, t) {
  this._pairs = [],
  e && rq(e, this, t)
}
const iq = aq.prototype;
function sq(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function lq(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || sq
    , o = n && n.serialize;
  let a;
  if (a = o ? o(t, n) : YG.isURLSearchParams(t) ? t.toString() : new aq(t,n).toString(r),
    a) {
    const t = e.indexOf("#");
    -1 !== t && (e = e.slice(0, t)),
      e += (-1 === e.indexOf("?") ? "?" : "&") + a
  }
  return e
}
iq.append = function(e, t) {
  this._pairs.push([e, t])
}
  ,
  iq.toString = function(e) {
    const t = e ? function(t) {
        return e.call(this, t, oq)
      }
      : oq;
    return this._pairs.map((function(e) {
        return t(e[0]) + "=" + t(e[1])
      }
    ), "").join("&")
  }
;
const uq = class {
  constructor() {
    this.handlers = []
  }
  use(e, t, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: !!n && n.synchronous,
      runWhen: n ? n.runWhen : null
    }),
    this.handlers.length - 1
  }
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null)
  }
  clear() {
    this.handlers && (this.handlers = [])
  }
  forEach(e) {
    YG.forEach(this.handlers, (function(t) {
        null !== t && e(t)
      }
    ))
  }
}
  , cq = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}
  , dq = {
  isBrowser: !0,
  classes: {
    URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : aq,
    FormData: "undefined" != typeof FormData ? FormData : null,
    Blob: "undefined" != typeof Blob ? Blob : null
  },
  isStandardBrowserEnv: (()=>{
      let e;
      return ("undefined" == typeof navigator || "ReactNative" !== (e = navigator.product) && "NativeScript" !== e && "NS" !== e) && ("undefined" != typeof window && "undefined" != typeof document)
    }
  )(),
  isStandardBrowserWebWorkerEnv: "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function fq(e) {
  function t(e, n, r, o) {
    let a = e[o++];
    const i = Number.isFinite(+a)
      , s = o >= e.length;
    if (a = !a && YG.isArray(r) ? r.length : a,
      s)
      return YG.hasOwnProp(r, a) ? r[a] = [r[a], n] : r[a] = n,
        !i;
    r[a] && YG.isObject(r[a]) || (r[a] = []);
    return t(e, n, r[a], o) && YG.isArray(r[a]) && (r[a] = function(e) {
      const t = {}
        , n = Object.keys(e);
      let r;
      const o = n.length;
      let a;
      for (r = 0; r < o; r++)
        a = n[r],
          t[a] = e[a];
      return t
    }(r[a])),
      !i
  }
  if (YG.isFormData(e) && YG.isFunction(e.entries)) {
    const n = {};
    return YG.forEachEntry(e, ((e,r)=>{
        t(function(e) {
          return YG.matchAll(/\w+|\[(\w*)]/g, e).map((e=>"[]" === e[0] ? "" : e[1] || e[0]))
        }(e), r, n, 0)
      }
    )),
      n
  }
  return null
}
const pq = {
  "Content-Type": void 0
};
const hq = {
  transitional: cq,
  adapter: ["xhr", "http"],
  transformRequest: [function(e, t) {
    const n = t.getContentType() || ""
      , r = n.indexOf("application/json") > -1
      , o = YG.isObject(e);
    o && YG.isHTMLForm(e) && (e = new FormData(e));
    if (YG.isFormData(e))
      return r && r ? JSON.stringify(fq(e)) : e;
    if (YG.isArrayBuffer(e) || YG.isBuffer(e) || YG.isStream(e) || YG.isFile(e) || YG.isBlob(e))
      return e;
    if (YG.isArrayBufferView(e))
      return e.buffer;
    if (YG.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
        e.toString();
    let a;
    if (o) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return function(e, t) {
          return rq(e, new dq.classes.URLSearchParams, Object.assign({
            visitor: function(e, t, n, r) {
              return dq.isNode && YG.isBuffer(e) ? (this.append(t, e.toString("base64")),
                !1) : r.defaultVisitor.apply(this, arguments)
            }
          }, t))
        }(e, this.formSerializer).toString();
      if ((a = YG.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const t = this.env && this.env.FormData;
        return rq(a ? {
          "files[]": e
        } : e, t && new t, this.formSerializer)
      }
    }
    return o || r ? (t.setContentType("application/json", !1),
      function(e, t, n) {
        if (YG.isString(e))
          try {
            return (t || JSON.parse)(e),
              YG.trim(e)
          } catch (Y_) {
            if ("SyntaxError" !== Y_.name)
              throw Y_
          }
        return (n || JSON.stringify)(e)
      }(e)) : e
  }
  ],
  transformResponse: [function(e) {
    const t = this.transitional || hq.transitional
      , n = t && t.forcedJSONParsing
      , r = "json" === this.responseType;
    if (e && YG.isString(e) && (n && !this.responseType || r)) {
      const n = !(t && t.silentJSONParsing) && r;
      try {
        return JSON.parse(e)
      } catch (Y_) {
        if (n) {
          if ("SyntaxError" === Y_.name)
            throw XG.from(Y_, XG.ERR_BAD_RESPONSE, this, null, this.response);
          throw Y_
        }
      }
    }
    return e
  }
  ],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: dq.classes.FormData,
    Blob: dq.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
YG.forEach(["delete", "get", "head"], (function(e) {
    hq.headers[e] = {}
  }
)),
  YG.forEach(["post", "put", "patch"], (function(e) {
      hq.headers[e] = YG.merge(pq)
    }
  ));
const vq = hq
  , gq = YG.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
  , mq = Symbol("internals");
function yq(e) {
  return e && String(e).trim().toLowerCase()
}
function bq(e) {
  return !1 === e || null == e ? e : YG.isArray(e) ? e.map(bq) : String(e)
}
function wq(e, t, n, r, o) {
  return YG.isFunction(r) ? r.call(this, t, n) : (o && (t = n),
    YG.isString(t) ? YG.isString(r) ? -1 !== t.indexOf(r) : YG.isRegExp(r) ? r.test(t) : void 0 : void 0)
}
class xq {
  constructor(e) {
    e && this.set(e)
  }
  set(e, t, n) {
    const r = this;
    function o(e, t, n) {
      const o = yq(t);
      if (!o)
        throw new Error("header name must be a non-empty string");
      const a = YG.findKey(r, o);
      (!a || void 0 === r[a] || !0 === n || void 0 === n && !1 !== r[a]) && (r[a || t] = bq(e))
    }
    const a = (e,t)=>YG.forEach(e, ((e,n)=>o(e, n, t)));
    return YG.isPlainObject(e) || e instanceof this.constructor ? a(e, t) : YG.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()) ? a((e=>{
        const t = {};
        let n, r, o;
        return e && e.split("\n").forEach((function(e) {
            o = e.indexOf(":"),
              n = e.substring(0, o).trim().toLowerCase(),
              r = e.substring(o + 1).trim(),
            !n || t[n] && gq[n] || ("set-cookie" === n ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r)
          }
        )),
          t
      }
    )(e), t) : null != e && o(t, e, n),
      this
  }
  get(e, t) {
    if (e = yq(e)) {
      const n = YG.findKey(this, e);
      if (n) {
        const e = this[n];
        if (!t)
          return e;
        if (!0 === t)
          return function(e) {
            const t = Object.create(null)
              , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
            let r;
            for (; r = n.exec(e); )
              t[r[1]] = r[2];
            return t
          }(e);
        if (YG.isFunction(t))
          return t.call(this, e, n);
        if (YG.isRegExp(t))
          return t.exec(e);
        throw new TypeError("parser must be boolean|regexp|function")
      }
    }
  }
  has(e, t) {
    if (e = yq(e)) {
      const n = YG.findKey(this, e);
      return !(!n || void 0 === this[n] || t && !wq(0, this[n], n, t))
    }
    return !1
  }
  delete(e, t) {
    const n = this;
    let r = !1;
    function o(e) {
      if (e = yq(e)) {
        const o = YG.findKey(n, e);
        !o || t && !wq(0, n[o], o, t) || (delete n[o],
          r = !0)
      }
    }
    return YG.isArray(e) ? e.forEach(o) : o(e),
      r
  }
  clear(e) {
    const t = Object.keys(this);
    let n = t.length
      , r = !1;
    for (; n--; ) {
      const o = t[n];
      e && !wq(0, this[o], o, e, !0) || (delete this[o],
        r = !0)
    }
    return r
  }
  normalize(e) {
    const t = this
      , n = {};
    return YG.forEach(this, ((r,o)=>{
        const a = YG.findKey(n, o);
        if (a)
          return t[a] = bq(r),
            void delete t[o];
        const i = e ? function(e) {
          return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((e,t,n)=>t.toUpperCase() + n))
        }(o) : String(o).trim();
        i !== o && delete t[o],
          t[i] = bq(r),
          n[i] = !0
      }
    )),
      this
  }
  concat(...e) {
    return this.constructor.concat(this, ...e)
  }
  toJSON(e) {
    const t = Object.create(null);
    return YG.forEach(this, ((n,r)=>{
        null != n && !1 !== n && (t[r] = e && YG.isArray(n) ? n.join(", ") : n)
      }
    )),
      t
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]()
  }
  toString() {
    return Object.entries(this.toJSON()).map((([e,t])=>e + ": " + t)).join("\n")
  }
  get[Symbol.toStringTag]() {
    return "AxiosHeaders"
  }
  static from(e) {
    return e instanceof this ? e : new this(e)
  }
  static concat(e, ...t) {
    const n = new this(e);
    return t.forEach((e=>n.set(e))),
      n
  }
  static accessor(e) {
    const t = (this[mq] = this[mq] = {
      accessors: {}
    }).accessors
      , n = this.prototype;
    function r(e) {
      const r = yq(e);
      t[r] || (!function(e, t) {
        const n = YG.toCamelCase(" " + t);
        ["get", "set", "has"].forEach((r=>{
            Object.defineProperty(e, r + n, {
              value: function(e, n, o) {
                return this[r].call(this, t, e, n, o)
              },
              configurable: !0
            })
          }
        ))
      }(n, e),
        t[r] = !0)
    }
    return YG.isArray(e) ? e.forEach(r) : r(e),
      this
  }
}
xq.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
  YG.freezeMethods(xq.prototype),
  YG.freezeMethods(xq);
const Sq = xq;
function Eq(e, t) {
  const n = this || vq
    , r = t || n
    , o = Sq.from(r.headers);
  let a = r.data;
  return YG.forEach(e, (function(e) {
      a = e.call(n, a, o.normalize(), t ? t.status : void 0)
    }
  )),
    o.normalize(),
    a
}
function Aq(e) {
  return !(!e || !e.__CANCEL__)
}
function Cq(e, t, n) {
  XG.call(this, null == e ? "canceled" : e, XG.ERR_CANCELED, t, n),
    this.name = "CanceledError"
}
YG.inherits(Cq, XG, {
  __CANCEL__: !0
});
const kq = dq.isStandardBrowserEnv ? {
  write: function(e, t, n, r, o, a) {
    const i = [];
    i.push(e + "=" + encodeURIComponent(t)),
    YG.isNumber(n) && i.push("expires=" + new Date(n).toGMTString()),
    YG.isString(r) && i.push("path=" + r),
    YG.isString(o) && i.push("domain=" + o),
    !0 === a && i.push("secure"),
      document.cookie = i.join("; ")
  },
  read: function(e) {
    const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
    return t ? decodeURIComponent(t[3]) : null
  },
  remove: function(e) {
    this.write(e, "", Date.now() - 864e5)
  }
} : {
  write: function() {},
  read: function() {
    return null
  },
  remove: function() {}
};
function Tq(e, t) {
  return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? function(e, t) {
    return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e
  }(e, t) : t
}
const Dq = dq.isStandardBrowserEnv ? function() {
    const e = /(msie|trident)/i.test(navigator.userAgent)
      , t = document.createElement("a");
    let n;
    function r(n) {
      let r = n;
      return e && (t.setAttribute("href", r),
        r = t.href),
        t.setAttribute("href", r),
        {
          href: t.href,
          protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
          host: t.host,
          search: t.search ? t.search.replace(/^\?/, "") : "",
          hash: t.hash ? t.hash.replace(/^#/, "") : "",
          hostname: t.hostname,
          port: t.port,
          pathname: "/" === t.pathname.charAt(0) ? t.pathname : "/" + t.pathname
        }
    }
    return n = r(window.location.href),
      function(e) {
        const t = YG.isString(e) ? r(e) : e;
        return t.protocol === n.protocol && t.host === n.host
      }
  }() : function() {
    return !0
  }
;
function Oq(e, t) {
  let n = 0;
  const r = function(e, t) {
    e = e || 10;
    const n = new Array(e)
      , r = new Array(e);
    let o, a = 0, i = 0;
    return t = void 0 !== t ? t : 1e3,
      function(s) {
        const l = Date.now()
          , u = r[i];
        o || (o = l),
          n[a] = s,
          r[a] = l;
        let c = i
          , d = 0;
        for (; c !== a; )
          d += n[c++],
            c %= e;
        if (a = (a + 1) % e,
        a === i && (i = (i + 1) % e),
        l - o < t)
          return;
        const f = u && l - u;
        return f ? Math.round(1e3 * d / f) : void 0
      }
  }(50, 250);
  return o=>{
    const a = o.loaded
      , i = o.lengthComputable ? o.total : void 0
      , s = a - n
      , l = r(s);
    n = a;
    const u = {
      loaded: a,
      total: i,
      progress: i ? a / i : void 0,
      bytes: s,
      rate: l || void 0,
      estimated: l && i && a <= i ? (i - a) / l : void 0,
      event: o
    };
    u[t ? "download" : "upload"] = !0,
      e(u)
  }
}
const _q = {
  http: null,
  xhr: "undefined" != typeof XMLHttpRequest && function(e) {
    return new Promise((function(t, n) {
        let r = e.data;
        const o = Sq.from(e.headers).normalize()
          , a = e.responseType;
        let i;
        function s() {
          e.cancelToken && e.cancelToken.unsubscribe(i),
          e.signal && e.signal.removeEventListener("abort", i)
        }
        YG.isFormData(r) && (dq.isStandardBrowserEnv || dq.isStandardBrowserWebWorkerEnv ? o.setContentType(!1) : o.setContentType("multipart/form-data;", !1));
        let l = new XMLHttpRequest;
        if (e.auth) {
          const t = e.auth.username || ""
            , n = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
          o.set("Authorization", "Basic " + btoa(t + ":" + n))
        }
        const u = Tq(e.baseURL, e.url);
        function c() {
          if (!l)
            return;
          const r = Sq.from("getAllResponseHeaders"in l && l.getAllResponseHeaders());
          !function(e, t, n) {
            const r = n.config.validateStatus;
            n.status && r && !r(n.status) ? t(new XG("Request failed with status code " + n.status,[XG.ERR_BAD_REQUEST, XG.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n)) : e(n)
          }((function(e) {
              t(e),
                s()
            }
          ), (function(e) {
              n(e),
                s()
            }
          ), {
            data: a && "text" !== a && "json" !== a ? l.response : l.responseText,
            status: l.status,
            statusText: l.statusText,
            headers: r,
            config: e,
            request: l
          }),
            l = null
        }
        if (l.open(e.method.toUpperCase(), lq(u, e.params, e.paramsSerializer), !0),
          l.timeout = e.timeout,
          "onloadend"in l ? l.onloadend = c : l.onreadystatechange = function() {
            l && 4 === l.readyState && (0 !== l.status || l.responseURL && 0 === l.responseURL.indexOf("file:")) && setTimeout(c)
          }
          ,
          l.onabort = function() {
            l && (n(new XG("Request aborted",XG.ECONNABORTED,e,l)),
              l = null)
          }
          ,
          l.onerror = function() {
            n(new XG("Network Error",XG.ERR_NETWORK,e,l)),
              l = null
          }
          ,
          l.ontimeout = function() {
            let t = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
            const r = e.transitional || cq;
            e.timeoutErrorMessage && (t = e.timeoutErrorMessage),
              n(new XG(t,r.clarifyTimeoutError ? XG.ETIMEDOUT : XG.ECONNABORTED,e,l)),
              l = null
          }
          ,
          dq.isStandardBrowserEnv) {
          const t = (e.withCredentials || Dq(u)) && e.xsrfCookieName && kq.read(e.xsrfCookieName);
          t && o.set(e.xsrfHeaderName, t)
        }
        void 0 === r && o.setContentType(null),
        "setRequestHeader"in l && YG.forEach(o.toJSON(), (function(e, t) {
            l.setRequestHeader(t, e)
          }
        )),
        YG.isUndefined(e.withCredentials) || (l.withCredentials = !!e.withCredentials),
        a && "json" !== a && (l.responseType = e.responseType),
        "function" == typeof e.onDownloadProgress && l.addEventListener("progress", Oq(e.onDownloadProgress, !0)),
        "function" == typeof e.onUploadProgress && l.upload && l.upload.addEventListener("progress", Oq(e.onUploadProgress)),
        (e.cancelToken || e.signal) && (i = t=>{
          l && (n(!t || t.type ? new Cq(null,e,l) : t),
            l.abort(),
            l = null)
        }
          ,
        e.cancelToken && e.cancelToken.subscribe(i),
        e.signal && (e.signal.aborted ? i() : e.signal.addEventListener("abort", i)));
        const d = function(e) {
          const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
          return t && t[1] || ""
        }(u);
        d && -1 === dq.protocols.indexOf(d) ? n(new XG("Unsupported protocol " + d + ":",XG.ERR_BAD_REQUEST,e)) : l.send(r || null)
      }
    ))
  }
};
YG.forEach(_q, ((e,t)=>{
    if (e) {
      try {
        Object.defineProperty(e, "name", {
          value: t
        })
      } catch (Y_) {}
      Object.defineProperty(e, "adapterName", {
        value: t
      })
    }
  }
));
const Rq = e=>{
    e = YG.isArray(e) ? e : [e];
    const {length: t} = e;
    let n, r;
    for (let o = 0; o < t && (n = e[o],
      !(r = YG.isString(n) ? _q[n.toLowerCase()] : n)); o++)
      ;
    if (!r) {
      if (!1 === r)
        throw new XG(`Adapter ${n} is not supported by the environment`,"ERR_NOT_SUPPORT");
      throw new Error(YG.hasOwnProp(_q, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`)
    }
    if (!YG.isFunction(r))
      throw new TypeError("adapter is not a function");
    return r
  }
;
function Lq(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(),
  e.signal && e.signal.aborted)
    throw new Cq(null,e)
}
function Iq(e) {
  Lq(e),
    e.headers = Sq.from(e.headers),
    e.data = Eq.call(e, e.transformRequest),
  -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1);
  return Rq(e.adapter || vq.adapter)(e).then((function(t) {
      return Lq(e),
        t.data = Eq.call(e, e.transformResponse, t),
        t.headers = Sq.from(t.headers),
        t
    }
  ), (function(t) {
      return Aq(t) || (Lq(e),
      t && t.response && (t.response.data = Eq.call(e, e.transformResponse, t.response),
        t.response.headers = Sq.from(t.response.headers))),
        Promise.reject(t)
    }
  ))
}
const Pq = e=>e instanceof Sq ? e.toJSON() : e;
function Fq(e, t) {
  t = t || {};
  const n = {};
  function r(e, t, n) {
    return YG.isPlainObject(e) && YG.isPlainObject(t) ? YG.merge.call({
      caseless: n
    }, e, t) : YG.isPlainObject(t) ? YG.merge({}, t) : YG.isArray(t) ? t.slice() : t
  }
  function o(e, t, n) {
    return YG.isUndefined(t) ? YG.isUndefined(e) ? void 0 : r(void 0, e, n) : r(e, t, n)
  }
  function a(e, t) {
    if (!YG.isUndefined(t))
      return r(void 0, t)
  }
  function i(e, t) {
    return YG.isUndefined(t) ? YG.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t)
  }
  function s(n, o, a) {
    return a in t ? r(n, o) : a in e ? r(void 0, n) : void 0
  }
  const l = {
    url: a,
    method: a,
    data: a,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: s,
    headers: (e,t)=>o(Pq(e), Pq(t), !0)
  };
  return YG.forEach(Object.keys(Object.assign({}, e, t)), (function(r) {
      const a = l[r] || o
        , i = a(e[r], t[r], r);
      YG.isUndefined(i) && a !== s || (n[r] = i)
    }
  )),
    n
}
const Bq = "1.4.0"
  , Nq = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(((e,t)=>{
    Nq[e] = function(n) {
      return typeof n === e || "a" + (t < 1 ? "n " : " ") + e
    }
  }
));
const Mq = {};
Nq.transitional = function(e, t, n) {
  function r(e, t) {
    return "[Axios v1.4.0] Transitional option '" + e + "'" + t + (n ? ". " + n : "")
  }
  return (n,o,a)=>{
    if (!1 === e)
      throw new XG(r(o, " has been removed" + (t ? " in " + t : "")),XG.ERR_DEPRECATED);
    return t && !Mq[o] && (Mq[o] = !0,
      console.warn(r(o, " has been deprecated since v" + t + " and will be removed in the near future"))),
    !e || e(n, o, a)
  }
}
;
const jq = {
  assertOptions: function(e, t, n) {
    if ("object" != typeof e)
      throw new XG("options must be an object",XG.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(e);
    let o = r.length;
    for (; o-- > 0; ) {
      const a = r[o]
        , i = t[a];
      if (i) {
        const t = e[a]
          , n = void 0 === t || i(t, a, e);
        if (!0 !== n)
          throw new XG("option " + a + " must be " + n,XG.ERR_BAD_OPTION_VALUE)
      } else if (!0 !== n)
        throw new XG("Unknown option " + a,XG.ERR_BAD_OPTION)
    }
  },
  validators: Nq
}
  , Vq = jq.validators;
class Uq {
  constructor(e) {
    this.defaults = e,
      this.interceptors = {
        request: new uq,
        response: new uq
      }
  }
  request(e, t) {
    "string" == typeof e ? (t = t || {}).url = e : t = e || {},
      t = Fq(this.defaults, t);
    const {transitional: n, paramsSerializer: r, headers: o} = t;
    let a;
    void 0 !== n && jq.assertOptions(n, {
      silentJSONParsing: Vq.transitional(Vq.boolean),
      forcedJSONParsing: Vq.transitional(Vq.boolean),
      clarifyTimeoutError: Vq.transitional(Vq.boolean)
    }, !1),
    null != r && (YG.isFunction(r) ? t.paramsSerializer = {
      serialize: r
    } : jq.assertOptions(r, {
      encode: Vq.function,
      serialize: Vq.function
    }, !0)),
      t.method = (t.method || this.defaults.method || "get").toLowerCase(),
      a = o && YG.merge(o.common, o[t.method]),
    a && YG.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e=>{
        delete o[e]
      }
    )),
      t.headers = Sq.concat(a, o);
    const i = [];
    let s = !0;
    this.interceptors.request.forEach((function(e) {
        "function" == typeof e.runWhen && !1 === e.runWhen(t) || (s = s && e.synchronous,
          i.unshift(e.fulfilled, e.rejected))
      }
    ));
    const l = [];
    let u;
    this.interceptors.response.forEach((function(e) {
        l.push(e.fulfilled, e.rejected)
      }
    ));
    let c, d = 0;
    if (!s) {
      const e = [Iq.bind(this), void 0];
      for (e.unshift.apply(e, i),
             e.push.apply(e, l),
             c = e.length,
             u = Promise.resolve(t); d < c; )
        u = u.then(e[d++], e[d++]);
      return u
    }
    c = i.length;
    let f = t;
    for (d = 0; d < c; ) {
      const e = i[d++]
        , t = i[d++];
      try {
        f = e(f)
      } catch (p) {
        t.call(this, p);
        break
      }
    }
    try {
      u = Iq.call(this, f)
    } catch (p) {
      return Promise.reject(p)
    }
    for (d = 0,
           c = l.length; d < c; )
      u = u.then(l[d++], l[d++]);
    return u
  }
  getUri(e) {
    return lq(Tq((e = Fq(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer)
  }
}
YG.forEach(["delete", "get", "head", "options"], (function(e) {
    Uq.prototype[e] = function(t, n) {
      return this.request(Fq(n || {}, {
        method: e,
        url: t,
        data: (n || {}).data
      }))
    }
  }
)),
  YG.forEach(["post", "put", "patch"], (function(e) {
      function t(t) {
        return function(n, r, o) {
          return this.request(Fq(o || {}, {
            method: e,
            headers: t ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: n,
            data: r
          }))
        }
      }
      Uq.prototype[e] = t(),
        Uq.prototype[e + "Form"] = t(!0)
    }
  ));
const $q = Uq;
class Hq {
  constructor(e) {
    if ("function" != typeof e)
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise((function(e) {
        t = e
      }
    ));
    const n = this;
    this.promise.then((e=>{
        if (!n._listeners)
          return;
        let t = n._listeners.length;
        for (; t-- > 0; )
          n._listeners[t](e);
        n._listeners = null
      }
    )),
      this.promise.then = e=>{
        let t;
        const r = new Promise((e=>{
            n.subscribe(e),
              t = e
          }
        )).then(e);
        return r.cancel = function() {
          n.unsubscribe(t)
        }
          ,
          r
      }
      ,
      e((function(e, r, o) {
          n.reason || (n.reason = new Cq(e,r,o),
            t(n.reason))
        }
      ))
  }
  throwIfRequested() {
    if (this.reason)
      throw this.reason
  }
  subscribe(e) {
    this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e]
  }
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    -1 !== t && this._listeners.splice(t, 1)
  }
  static source() {
    let e;
    return {
      token: new Hq((function(t) {
          e = t
        }
      )),
      cancel: e
    }
  }
}
const zq = Hq;
const Kq = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Kq).forEach((([e,t])=>{
    Kq[t] = e
  }
));
const Wq = Kq;
const Gq = function e(t) {
  const n = new $q(t)
    , r = vG($q.prototype.request, n);
  return YG.extend(r, $q.prototype, n, {
    allOwnKeys: !0
  }),
    YG.extend(r, n, null, {
      allOwnKeys: !0
    }),
    r.create = function(n) {
      return e(Fq(t, n))
    }
    ,
    r
}(vq);
Gq.Axios = $q,
  Gq.CanceledError = Cq,
  Gq.CancelToken = zq,
  Gq.isCancel = Aq,
  Gq.VERSION = Bq,
  Gq.toFormData = rq,
  Gq.AxiosError = XG,
  Gq.Cancel = Gq.CanceledError,
  Gq.all = function(e) {
    return Promise.all(e)
  }
  ,
  Gq.spread = function(e) {
    return function(t) {
      return e.apply(null, t)
    }
  }
  ,
  Gq.isAxiosError = function(e) {
    return YG.isObject(e) && !0 === e.isAxiosError
  }
  ,
  Gq.mergeConfig = Fq,
  Gq.AxiosHeaders = Sq,
  Gq.formToJSON = e=>fq(YG.isHTMLForm(e) ? new FormData(e) : e),
  Gq.HttpStatusCode = Wq,
  Gq.default = Gq;
const qq = Gq
  , Yq = qq.create({
  baseURL: "https://rpd-live.yunbovtb.com/yunbo-dp/",
  timeout: 3e4
})
  , Xq = ["/live/live/save_draft", "/digital/video/create/", "/digital/video/compose", "/digital/audio/parseDouYinVideo", "/digital/audio/subtitleComposeTTS", "/digital/video/compose_audio", "/live/live/start"];
Yq.interceptors.request.use((e=>{
    -1 !== ["/digital/customize/upload", "/digital/video/compose_audio", "/digital/video/compose", "/live/material/upload"].indexOf(e.url) && (e.timeout = 36e5),
      e.headers["Content-type"] = e.headers["Content-Type"] || (-1 !== Xq.indexOf(e.url) ? "application/json" : "multipart/form-data");
    let t = window.localStorage.getItem("token");
    return "" != t && "undefined" != t && (e.headers["auth-token"] = t),
      e
  }
), (e=>Promise.reject(e))),
  Yq.interceptors.response.use((e=>{
      if (200 == e.status) {
        if (0 == e.data.code)
          return e.data;
        if ("token.error" == e.data.msg || "token.expire" == e.data.msg) {
          MW({
            message: "登录失效",
            type: "error"
          }),
            window.localStorage.removeItem("token");
          pG().setUserInfo({}),
            Gyt.push("/login")
        } else
          -101 == e.data.code || -100 == e.data.code || MW({
            message: e.data.msg,
            type: "error"
          });
        return Promise.reject(e.data)
      }
      return e
    }
  ), (e=>Promise.reject(e)));
const Qq = Object.freeze(Object.defineProperty({
  __proto__: null,
  adjustPlay: e=>Yq.post("/live/living/adjust_play", e, {
    headers: {
      "Content-Type": "application/json"
    }
  }),
  buyLiveConcurrency: e=>Yq.post("/live/live/buy_live_concurrency", e),
  createLiveRoom: e=>Yq.post("/live/live/create", e, {
    headers: {
      "Content-Type": "application/json"
    }
  }),
  createProduct: e=>Yq.post("/live/product/create", e),
  deleteLiveRoom: e=>Yq.post("/live/live/delete_live_room", e, {
    headers: {
      "Content-Type": "application/json"
    }
  }),
  deleteMaterial: e=>Yq.post("/live/material/delete", e),
  deleteProduct: e=>Yq.post("/live/product/delete", e),
  editProduct: e=>Yq.post("/live/product/edit", e),
  getAuth: e=>Yq.post("/live/live/get_auth", e),
  getCategoryList: e=>Yq.post("/live/category/list", e),
  getDraft: e=>Yq.post("/live/live/get_draft", e),
  getJumpToken: e=>Yq.post("/live/live/get_jump_token", e, {
    headers: {
      "Content-Type": "application/json"
    }
  }),
  getLiveRoomDetail: e=>Yq.post("/live/live/live_room_detail", e),
  getLiveRoomList: e=>Yq.post("/live/live/live_room_list", e),
  getMaterialList: e=>Yq.post("/live/material/list", e),
  getProductList: e=>Yq.post("/live/product/list", e),
  insertCutList: e=>Yq.post("/live/living/insert_cut_list", e, {
    headers: {
      "Content-Type": "application/json"
    }
  }),
  insertPlayList: e=>Yq.post("/live/living/insert_play_list", e, {
    headers: {
      "Content-Type": "application/json"
    }
  }),
  saveDraft: e=>Yq.post("/live/live/save_draft", e),
  startLive: e=>Yq.post("/live/live/start", e),
  stopLive: e=>Yq.post("/live/live/stop", e),
  textMaterialEdit: e=>Yq.post("/live/material/edit", e),
  updateLiveRoom: e=>Yq.post("/live/live/update", e, {
    headers: {
      "Content-Type": "application/json"
    }
  }),
  updateMaterial: e=>Yq.post("/live/living/update_material", e, {
    headers: {
      "Content-Type": "application/json"
    }
  }),
  uploadCover: e=>Yq.post("/live/product/upload_cover", e),
  uploadMaterial: e=>Yq.post("/live/material/upload", e)
}, Symbol.toStringTag, {
  value: "Module"
}))
  , Jq = Object.freeze(Object.defineProperty({
  __proto__: null,
  digitalCustomize: e=>Yq.post("/digital/customize/customize", e),
  getUploadConfig: e=>Yq.post("/digital/customize/upload/config", e)
}, Symbol.toStringTag, {
  value: "Module"
}))
  , Zq = Object.freeze(Object.defineProperty({
  __proto__: null,
  checkQrCodeState: e=>Yq.post("/member/wx_check/", e),
  getLoginQrCode: e=>Yq.post("/member/wx_login/", e),
  getUserInfo: ()=>Yq.post("/member/info"),
  memberLogin: e=>Yq.post("/member/login/", e),
  updatePassword: e=>Yq.post("/member/update_password", e)
}, Symbol.toStringTag, {
  value: "Module"
}))
  , eY = Object.freeze(Object.defineProperty({
  __proto__: null,
  buyLiveConcurrency: e=>Yq.post("/live/live/buy_live_concurrency", e),
  getPayOrderState: e=>Yq.post("/pay/order/order_state", e),
  getQrCode: e=>Yq.post("/pay/order/order", e)
}, Symbol.toStringTag, {
  value: "Module"
}))
  , tY = Object.freeze(Object.defineProperty({
  __proto__: null,
  digitalOrderList: e=>Yq.post("/digital/order/list", e),
  digitalOrderUserinfo: e=>Yq.post("/digital/order/userinfo")
}, Symbol.toStringTag, {
  value: "Module"
}))
  , nY = Object.freeze(Object.defineProperty({
  __proto__: null,
  audioUpload: e=>Yq.post("/digital/audio/upload/", e),
  backgroundListed: e=>Yq.post("/digital/background/listed/", e),
  backgroundUpload: e=>Yq.post("/digital/background/upload/", e),
  composeMinimax: e=>Yq.post("/digital/video/compose_audio", e),
  createSubtitle: e=>Yq.post("/digital/audio/createSubtitle", e),
  createTask: e=>Yq.post("/digital/video/create/", e),
  deleteBackGroundImage: e=>Yq.post("/digital/background/delete", e, {
    headers: {
      "Content-Type": "application/json"
    }
  }),
  deleteDraft: e=>Yq.post("/digital/video/delete_draft", e),
  digitalAudioListed: e=>Yq.post("/digital/audio/listed/", e),
  digitalModelListed: e=>Yq.post("/digital/model/person/", e),
  digitalVideoCompose: e=>Yq.post("/digital/video/compose", e),
  getDraft: e=>Yq.post("/digital/video/get_draft", e),
  getLangList: e=>Yq.post("/digital/audio/get_lang_list", e),
  parseDouYinVideo: e=>Yq.post("/digital/audio/parseDouYinVideo", e),
  saveAudio: e=>Yq.post("/digital/audio/saveAudio", e),
  saveDraft: e=>Yq.post("/digital/video/save_draft", e),
  subtitleComposeTTS: e=>Yq.post("/digital/audio/subtitleComposeTTS", e),
  videoTaskDetail: e=>Yq.post("/digital/video/detail/", e)
}, Symbol.toStringTag, {
  value: "Module"
}))
  , rY = Object.freeze(Object.defineProperty({
  __proto__: null,
  getAudioList: e=>Yq.post("/digital/model/audio/", e),
  getVideoList: e=>Yq.post("/digital/video/listed/", e),
  register: e=>Yq.post("/member/register", e),
  sendVerifyCode: e=>Yq.post("/member/verify_code", e)
}, Symbol.toStringTag, {
  value: "Module"
}))
  , oY = {
  Upload_config: e=>Yq.get("/common/upload/pre_url/", {
    params: e
  }),
  ...function() {
    const e = Object.assign({
      "./modules/createLive.ts": Qq,
      "./modules/custom.ts": Jq,
      "./modules/login.ts": Zq,
      "./modules/pay.ts": eY,
      "./modules/statistic.ts": tY,
      "./modules/video.ts": nY,
      "./modules/worker.ts": rY
    });
    let t = {};
    for (let n in e) {
      let r = n.match(/([^\/|\.])+/g)
        , o = r && r[1];
      o && (t[o] = e[n])
    }
    return t
  }()
};
var aY = {}
  , iY = {}
  , sY = {};
let lY;
const uY = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
sY.getSymbolSize = function(e) {
  if (!e)
    throw new Error('"version" cannot be null or undefined');
  if (e < 1 || e > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return 4 * e + 17
}
  ,
  sY.getSymbolTotalCodewords = function(e) {
    return uY[e]
  }
  ,
  sY.getBCHDigit = function(e) {
    let t = 0;
    for (; 0 !== e; )
      t++,
        e >>>= 1;
    return t
  }
  ,
  sY.setToSJISFunction = function(e) {
    if ("function" != typeof e)
      throw new Error('"toSJISFunc" is not a valid function.');
    lY = e
  }
  ,
  sY.isKanjiModeEnabled = function() {
    return void 0 !== lY
  }
  ,
  sY.toSJIS = function(e) {
    return lY(e)
  }
;
var cY, dY = {};
function fY() {
  this.buffer = [],
    this.length = 0
}
(cY = dY).L = {
  bit: 1
},
  cY.M = {
    bit: 0
  },
  cY.Q = {
    bit: 3
  },
  cY.H = {
    bit: 2
  },
  cY.isValid = function(e) {
    return e && void 0 !== e.bit && e.bit >= 0 && e.bit < 4
  }
  ,
  cY.from = function(e, t) {
    if (cY.isValid(e))
      return e;
    try {
      return function(e) {
        if ("string" != typeof e)
          throw new Error("Param is not a string");
        switch (e.toLowerCase()) {
          case "l":
          case "low":
            return cY.L;
          case "m":
          case "medium":
            return cY.M;
          case "q":
          case "quartile":
            return cY.Q;
          case "h":
          case "high":
            return cY.H;
          default:
            throw new Error("Unknown EC Level: " + e)
        }
      }(e)
    } catch (Y_) {
      return t
    }
  }
  ,
  fY.prototype = {
    get: function(e) {
      const t = Math.floor(e / 8);
      return 1 == (this.buffer[t] >>> 7 - e % 8 & 1)
    },
    put: function(e, t) {
      for (let n = 0; n < t; n++)
        this.putBit(1 == (e >>> t - n - 1 & 1))
    },
    getLengthInBits: function() {
      return this.length
    },
    putBit: function(e) {
      const t = Math.floor(this.length / 8);
      this.buffer.length <= t && this.buffer.push(0),
      e && (this.buffer[t] |= 128 >>> this.length % 8),
        this.length++
    }
  };
var pY = fY;
function hY(e) {
  if (!e || e < 1)
    throw new Error("BitMatrix size must be defined and greater than 0");
  this.size = e,
    this.data = new Uint8Array(e * e),
    this.reservedBit = new Uint8Array(e * e)
}
hY.prototype.set = function(e, t, n, r) {
  const o = e * this.size + t;
  this.data[o] = n,
  r && (this.reservedBit[o] = !0)
}
  ,
  hY.prototype.get = function(e, t) {
    return this.data[e * this.size + t]
  }
  ,
  hY.prototype.xor = function(e, t, n) {
    this.data[e * this.size + t] ^= n
  }
  ,
  hY.prototype.isReserved = function(e, t) {
    return this.reservedBit[e * this.size + t]
  }
;
var vY = hY
  , gY = {};
!function(e) {
  const t = sY.getSymbolSize;
  e.getRowColCoords = function(e) {
    if (1 === e)
      return [];
    const n = Math.floor(e / 7) + 2
      , r = t(e)
      , o = 145 === r ? 26 : 2 * Math.ceil((r - 13) / (2 * n - 2))
      , a = [r - 7];
    for (let t = 1; t < n - 1; t++)
      a[t] = a[t - 1] - o;
    return a.push(6),
      a.reverse()
  }
    ,
    e.getPositions = function(t) {
      const n = []
        , r = e.getRowColCoords(t)
        , o = r.length;
      for (let e = 0; e < o; e++)
        for (let t = 0; t < o; t++)
          0 === e && 0 === t || 0 === e && t === o - 1 || e === o - 1 && 0 === t || n.push([r[e], r[t]]);
      return n
    }
}(gY);
var mY = {};
const yY = sY.getSymbolSize;
mY.getPositions = function(e) {
  const t = yY(e);
  return [[0, 0], [t - 7, 0], [0, t - 7]]
}
;
var bY = {};
!function(e) {
  e.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  const t = 3
    , n = 3
    , r = 40
    , o = 10;
  function a(t, n, r) {
    switch (t) {
      case e.Patterns.PATTERN000:
        return (n + r) % 2 == 0;
      case e.Patterns.PATTERN001:
        return n % 2 == 0;
      case e.Patterns.PATTERN010:
        return r % 3 == 0;
      case e.Patterns.PATTERN011:
        return (n + r) % 3 == 0;
      case e.Patterns.PATTERN100:
        return (Math.floor(n / 2) + Math.floor(r / 3)) % 2 == 0;
      case e.Patterns.PATTERN101:
        return n * r % 2 + n * r % 3 == 0;
      case e.Patterns.PATTERN110:
        return (n * r % 2 + n * r % 3) % 2 == 0;
      case e.Patterns.PATTERN111:
        return (n * r % 3 + (n + r) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + t)
    }
  }
  e.isValid = function(e) {
    return null != e && "" !== e && !isNaN(e) && e >= 0 && e <= 7
  }
    ,
    e.from = function(t) {
      return e.isValid(t) ? parseInt(t, 10) : void 0
    }
    ,
    e.getPenaltyN1 = function(e) {
      const n = e.size;
      let r = 0
        , o = 0
        , a = 0
        , i = null
        , s = null;
      for (let l = 0; l < n; l++) {
        o = a = 0,
          i = s = null;
        for (let u = 0; u < n; u++) {
          let n = e.get(l, u);
          n === i ? o++ : (o >= 5 && (r += t + (o - 5)),
            i = n,
            o = 1),
            n = e.get(u, l),
            n === s ? a++ : (a >= 5 && (r += t + (a - 5)),
              s = n,
              a = 1)
        }
        o >= 5 && (r += t + (o - 5)),
        a >= 5 && (r += t + (a - 5))
      }
      return r
    }
    ,
    e.getPenaltyN2 = function(e) {
      const t = e.size;
      let r = 0;
      for (let n = 0; n < t - 1; n++)
        for (let o = 0; o < t - 1; o++) {
          const t = e.get(n, o) + e.get(n, o + 1) + e.get(n + 1, o) + e.get(n + 1, o + 1);
          4 !== t && 0 !== t || r++
        }
      return r * n
    }
    ,
    e.getPenaltyN3 = function(e) {
      const t = e.size;
      let n = 0
        , o = 0
        , a = 0;
      for (let r = 0; r < t; r++) {
        o = a = 0;
        for (let i = 0; i < t; i++)
          o = o << 1 & 2047 | e.get(r, i),
          i >= 10 && (1488 === o || 93 === o) && n++,
            a = a << 1 & 2047 | e.get(i, r),
          i >= 10 && (1488 === a || 93 === a) && n++
      }
      return n * r
    }
    ,
    e.getPenaltyN4 = function(e) {
      let t = 0;
      const n = e.data.length;
      for (let r = 0; r < n; r++)
        t += e.data[r];
      return Math.abs(Math.ceil(100 * t / n / 5) - 10) * o
    }
    ,
    e.applyMask = function(e, t) {
      const n = t.size;
      for (let r = 0; r < n; r++)
        for (let o = 0; o < n; o++)
          t.isReserved(o, r) || t.xor(o, r, a(e, o, r))
    }
    ,
    e.getBestMask = function(t, n) {
      const r = Object.keys(e.Patterns).length;
      let o = 0
        , a = 1 / 0;
      for (let i = 0; i < r; i++) {
        n(i),
          e.applyMask(i, t);
        const r = e.getPenaltyN1(t) + e.getPenaltyN2(t) + e.getPenaltyN3(t) + e.getPenaltyN4(t);
        e.applyMask(i, t),
        r < a && (a = r,
          o = i)
      }
      return o
    }
}(bY);
var wY = {};
const xY = dY
  , SY = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81]
  , EY = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
wY.getBlocksCount = function(e, t) {
  switch (t) {
    case xY.L:
      return SY[4 * (e - 1) + 0];
    case xY.M:
      return SY[4 * (e - 1) + 1];
    case xY.Q:
      return SY[4 * (e - 1) + 2];
    case xY.H:
      return SY[4 * (e - 1) + 3];
    default:
      return
  }
}
  ,
  wY.getTotalCodewordsCount = function(e, t) {
    switch (t) {
      case xY.L:
        return EY[4 * (e - 1) + 0];
      case xY.M:
        return EY[4 * (e - 1) + 1];
      case xY.Q:
        return EY[4 * (e - 1) + 2];
      case xY.H:
        return EY[4 * (e - 1) + 3];
      default:
        return
    }
  }
;
var AY = {}
  , CY = {};
const kY = new Uint8Array(512)
  , TY = new Uint8Array(256);
!function() {
  let e = 1;
  for (let t = 0; t < 255; t++)
    kY[t] = e,
      TY[e] = t,
      e <<= 1,
    256 & e && (e ^= 285);
  for (let t = 255; t < 512; t++)
    kY[t] = kY[t - 255]
}(),
  CY.log = function(e) {
    if (e < 1)
      throw new Error("log(" + e + ")");
    return TY[e]
  }
  ,
  CY.exp = function(e) {
    return kY[e]
  }
  ,
  CY.mul = function(e, t) {
    return 0 === e || 0 === t ? 0 : kY[TY[e] + TY[t]]
  }
  ,
  function(e) {
    const t = CY;
    e.mul = function(e, n) {
      const r = new Uint8Array(e.length + n.length - 1);
      for (let o = 0; o < e.length; o++)
        for (let a = 0; a < n.length; a++)
          r[o + a] ^= t.mul(e[o], n[a]);
      return r
    }
      ,
      e.mod = function(e, n) {
        let r = new Uint8Array(e);
        for (; r.length - n.length >= 0; ) {
          const e = r[0];
          for (let a = 0; a < n.length; a++)
            r[a] ^= t.mul(n[a], e);
          let o = 0;
          for (; o < r.length && 0 === r[o]; )
            o++;
          r = r.slice(o)
        }
        return r
      }
      ,
      e.generateECPolynomial = function(n) {
        let r = new Uint8Array([1]);
        for (let o = 0; o < n; o++)
          r = e.mul(r, new Uint8Array([1, t.exp(o)]));
        return r
      }
  }(AY);
const DY = AY;
function OY(e) {
  this.genPoly = void 0,
    this.degree = e,
  this.degree && this.initialize(this.degree)
}
OY.prototype.initialize = function(e) {
  this.degree = e,
    this.genPoly = DY.generateECPolynomial(this.degree)
}
  ,
  OY.prototype.encode = function(e) {
    if (!this.genPoly)
      throw new Error("Encoder not initialized");
    const t = new Uint8Array(e.length + this.degree);
    t.set(e);
    const n = DY.mod(t, this.genPoly)
      , r = this.degree - n.length;
    if (r > 0) {
      const e = new Uint8Array(this.degree);
      return e.set(n, r),
        e
    }
    return n
  }
;
var _Y = OY
  , RY = {}
  , LY = {}
  , IY = {
  isValid: function(e) {
    return !isNaN(e) && e >= 1 && e <= 40
  }
}
  , PY = {};
const FY = "[0-9]+";
let BY = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
BY = BY.replace(/u/g, "\\u");
const NY = "(?:(?![A-Z0-9 $%*+\\-./:]|" + BY + ")(?:.|[\r\n]))+";
PY.KANJI = new RegExp(BY,"g"),
  PY.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+","g"),
  PY.BYTE = new RegExp(NY,"g"),
  PY.NUMERIC = new RegExp(FY,"g"),
  PY.ALPHANUMERIC = new RegExp("[A-Z $%*+\\-./:]+","g");
const MY = new RegExp("^" + BY + "$")
  , jY = new RegExp("^" + FY + "$")
  , VY = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
PY.testKanji = function(e) {
  return MY.test(e)
}
  ,
  PY.testNumeric = function(e) {
    return jY.test(e)
  }
  ,
  PY.testAlphanumeric = function(e) {
    return VY.test(e)
  }
  ,
  function(e) {
    const t = IY
      , n = PY;
    e.NUMERIC = {
      id: "Numeric",
      bit: 1,
      ccBits: [10, 12, 14]
    },
      e.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 2,
        ccBits: [9, 11, 13]
      },
      e.BYTE = {
        id: "Byte",
        bit: 4,
        ccBits: [8, 16, 16]
      },
      e.KANJI = {
        id: "Kanji",
        bit: 8,
        ccBits: [8, 10, 12]
      },
      e.MIXED = {
        bit: -1
      },
      e.getCharCountIndicator = function(e, n) {
        if (!e.ccBits)
          throw new Error("Invalid mode: " + e);
        if (!t.isValid(n))
          throw new Error("Invalid version: " + n);
        return n >= 1 && n < 10 ? e.ccBits[0] : n < 27 ? e.ccBits[1] : e.ccBits[2]
      }
      ,
      e.getBestModeForData = function(t) {
        return n.testNumeric(t) ? e.NUMERIC : n.testAlphanumeric(t) ? e.ALPHANUMERIC : n.testKanji(t) ? e.KANJI : e.BYTE
      }
      ,
      e.toString = function(e) {
        if (e && e.id)
          return e.id;
        throw new Error("Invalid mode")
      }
      ,
      e.isValid = function(e) {
        return e && e.bit && e.ccBits
      }
      ,
      e.from = function(t, n) {
        if (e.isValid(t))
          return t;
        try {
          return function(t) {
            if ("string" != typeof t)
              throw new Error("Param is not a string");
            switch (t.toLowerCase()) {
              case "numeric":
                return e.NUMERIC;
              case "alphanumeric":
                return e.ALPHANUMERIC;
              case "kanji":
                return e.KANJI;
              case "byte":
                return e.BYTE;
              default:
                throw new Error("Unknown mode: " + t)
            }
          }(t)
        } catch (Y_) {
          return n
        }
      }
  }(LY),
  function(e) {
    const t = sY
      , n = wY
      , r = dY
      , o = LY
      , a = IY
      , i = t.getBCHDigit(7973);
    function s(e, t) {
      return o.getCharCountIndicator(e, t) + 4
    }
    function l(e, t) {
      let n = 0;
      return e.forEach((function(e) {
          const r = s(e.mode, t);
          n += r + e.getBitsLength()
        }
      )),
        n
    }
    e.from = function(e, t) {
      return a.isValid(e) ? parseInt(e, 10) : t
    }
      ,
      e.getCapacity = function(e, r, i) {
        if (!a.isValid(e))
          throw new Error("Invalid QR Code version");
        void 0 === i && (i = o.BYTE);
        const l = 8 * (t.getSymbolTotalCodewords(e) - n.getTotalCodewordsCount(e, r));
        if (i === o.MIXED)
          return l;
        const u = l - s(i, e);
        switch (i) {
          case o.NUMERIC:
            return Math.floor(u / 10 * 3);
          case o.ALPHANUMERIC:
            return Math.floor(u / 11 * 2);
          case o.KANJI:
            return Math.floor(u / 13);
          case o.BYTE:
          default:
            return Math.floor(u / 8)
        }
      }
      ,
      e.getBestVersionForData = function(t, n) {
        let a;
        const i = r.from(n, r.M);
        if (Array.isArray(t)) {
          if (t.length > 1)
            return function(t, n) {
              for (let r = 1; r <= 40; r++)
                if (l(t, r) <= e.getCapacity(r, n, o.MIXED))
                  return r
            }(t, i);
          if (0 === t.length)
            return 1;
          a = t[0]
        } else
          a = t;
        return function(t, n, r) {
          for (let o = 1; o <= 40; o++)
            if (n <= e.getCapacity(o, r, t))
              return o
        }(a.mode, a.getLength(), i)
      }
      ,
      e.getEncodedBits = function(e) {
        if (!a.isValid(e) || e < 7)
          throw new Error("Invalid QR Code version");
        let n = e << 12;
        for (; t.getBCHDigit(n) - i >= 0; )
          n ^= 7973 << t.getBCHDigit(n) - i;
        return e << 12 | n
      }
  }(RY);
var UY = {};
const $Y = sY
  , HY = $Y.getBCHDigit(1335);
UY.getEncodedBits = function(e, t) {
  const n = e.bit << 3 | t;
  let r = n << 10;
  for (; $Y.getBCHDigit(r) - HY >= 0; )
    r ^= 1335 << $Y.getBCHDigit(r) - HY;
  return 21522 ^ (n << 10 | r)
}
;
var zY = {};
const KY = LY;
function WY(e) {
  this.mode = KY.NUMERIC,
    this.data = e.toString()
}
WY.getBitsLength = function(e) {
  return 10 * Math.floor(e / 3) + (e % 3 ? e % 3 * 3 + 1 : 0)
}
  ,
  WY.prototype.getLength = function() {
    return this.data.length
  }
  ,
  WY.prototype.getBitsLength = function() {
    return WY.getBitsLength(this.data.length)
  }
  ,
  WY.prototype.write = function(e) {
    let t, n, r;
    for (t = 0; t + 3 <= this.data.length; t += 3)
      n = this.data.substr(t, 3),
        r = parseInt(n, 10),
        e.put(r, 10);
    const o = this.data.length - t;
    o > 0 && (n = this.data.substr(t),
      r = parseInt(n, 10),
      e.put(r, 3 * o + 1))
  }
;
var GY = WY;
const qY = LY
  , YY = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function XY(e) {
  this.mode = qY.ALPHANUMERIC,
    this.data = e
}
XY.getBitsLength = function(e) {
  return 11 * Math.floor(e / 2) + e % 2 * 6
}
  ,
  XY.prototype.getLength = function() {
    return this.data.length
  }
  ,
  XY.prototype.getBitsLength = function() {
    return XY.getBitsLength(this.data.length)
  }
  ,
  XY.prototype.write = function(e) {
    let t;
    for (t = 0; t + 2 <= this.data.length; t += 2) {
      let n = 45 * YY.indexOf(this.data[t]);
      n += YY.indexOf(this.data[t + 1]),
        e.put(n, 11)
    }
    this.data.length % 2 && e.put(YY.indexOf(this.data[t]), 6)
  }
;
var QY = XY;
const JY = function(e) {
  for (var t = [], n = e.length, r = 0; r < n; r++) {
    var o = e.charCodeAt(r);
    if (o >= 55296 && o <= 56319 && n > r + 1) {
      var a = e.charCodeAt(r + 1);
      a >= 56320 && a <= 57343 && (o = 1024 * (o - 55296) + a - 56320 + 65536,
        r += 1)
    }
    o < 128 ? t.push(o) : o < 2048 ? (t.push(o >> 6 | 192),
      t.push(63 & o | 128)) : o < 55296 || o >= 57344 && o < 65536 ? (t.push(o >> 12 | 224),
      t.push(o >> 6 & 63 | 128),
      t.push(63 & o | 128)) : o >= 65536 && o <= 1114111 ? (t.push(o >> 18 | 240),
      t.push(o >> 12 & 63 | 128),
      t.push(o >> 6 & 63 | 128),
      t.push(63 & o | 128)) : t.push(239, 191, 189)
  }
  return new Uint8Array(t).buffer
}
  , ZY = LY;
function eX(e) {
  this.mode = ZY.BYTE,
  "string" == typeof e && (e = JY(e)),
    this.data = new Uint8Array(e)
}
eX.getBitsLength = function(e) {
  return 8 * e
}
  ,
  eX.prototype.getLength = function() {
    return this.data.length
  }
  ,
  eX.prototype.getBitsLength = function() {
    return eX.getBitsLength(this.data.length)
  }
  ,
  eX.prototype.write = function(e) {
    for (let t = 0, n = this.data.length; t < n; t++)
      e.put(this.data[t], 8)
  }
;
var tX = eX;
const nX = LY
  , rX = sY;
function oX(e) {
  this.mode = nX.KANJI,
    this.data = e
}
oX.getBitsLength = function(e) {
  return 13 * e
}
  ,
  oX.prototype.getLength = function() {
    return this.data.length
  }
  ,
  oX.prototype.getBitsLength = function() {
    return oX.getBitsLength(this.data.length)
  }
  ,
  oX.prototype.write = function(e) {
    let t;
    for (t = 0; t < this.data.length; t++) {
      let n = rX.toSJIS(this.data[t]);
      if (n >= 33088 && n <= 40956)
        n -= 33088;
      else {
        if (!(n >= 57408 && n <= 60351))
          throw new Error("Invalid SJIS character: " + this.data[t] + "\nMake sure your charset is UTF-8");
        n -= 49472
      }
      n = 192 * (n >>> 8 & 255) + (255 & n),
        e.put(n, 13)
    }
  }
;
var aX, iX = oX, sX = {
  exports: {}
};
aX = {
  single_source_shortest_paths: function(e, t, n) {
    var r = {}
      , o = {};
    o[t] = 0;
    var a, i, s, l, u, c, d, f = aX.PriorityQueue.make();
    for (f.push(t, 0); !f.empty(); )
      for (s in i = (a = f.pop()).value,
        l = a.cost,
        u = e[i] || {})
        u.hasOwnProperty(s) && (c = l + u[s],
          d = o[s],
        (void 0 === o[s] || d > c) && (o[s] = c,
          f.push(s, c),
          r[s] = i));
    if (void 0 !== n && void 0 === o[n]) {
      var p = ["Could not find a path from ", t, " to ", n, "."].join("");
      throw new Error(p)
    }
    return r
  },
  extract_shortest_path_from_predecessor_list: function(e, t) {
    for (var n = [], r = t; r; )
      n.push(r),
        e[r],
        r = e[r];
    return n.reverse(),
      n
  },
  find_path: function(e, t, n) {
    var r = aX.single_source_shortest_paths(e, t, n);
    return aX.extract_shortest_path_from_predecessor_list(r, n)
  },
  PriorityQueue: {
    make: function(e) {
      var t, n = aX.PriorityQueue, r = {};
      for (t in e = e || {},
        n)
        n.hasOwnProperty(t) && (r[t] = n[t]);
      return r.queue = [],
        r.sorter = e.sorter || n.default_sorter,
        r
    },
    default_sorter: function(e, t) {
      return e.cost - t.cost
    },
    push: function(e, t) {
      var n = {
        value: e,
        cost: t
      };
      this.queue.push(n),
        this.queue.sort(this.sorter)
    },
    pop: function() {
      return this.queue.shift()
    },
    empty: function() {
      return 0 === this.queue.length
    }
  }
};
var lX = sX.exports = aX;
!function(e) {
  const t = LY
    , n = GY
    , r = QY
    , o = tX
    , a = iX
    , i = PY
    , s = sY
    , l = lX;
  function u(e) {
    return unescape(encodeURIComponent(e)).length
  }
  function c(e, t, n) {
    const r = [];
    let o;
    for (; null !== (o = e.exec(n)); )
      r.push({
        data: o[0],
        index: o.index,
        mode: t,
        length: o[0].length
      });
    return r
  }
  function d(e) {
    const n = c(i.NUMERIC, t.NUMERIC, e)
      , r = c(i.ALPHANUMERIC, t.ALPHANUMERIC, e);
    let o, a;
    s.isKanjiModeEnabled() ? (o = c(i.BYTE, t.BYTE, e),
      a = c(i.KANJI, t.KANJI, e)) : (o = c(i.BYTE_KANJI, t.BYTE, e),
      a = []);
    return n.concat(r, o, a).sort((function(e, t) {
        return e.index - t.index
      }
    )).map((function(e) {
        return {
          data: e.data,
          mode: e.mode,
          length: e.length
        }
      }
    ))
  }
  function f(e, i) {
    switch (i) {
      case t.NUMERIC:
        return n.getBitsLength(e);
      case t.ALPHANUMERIC:
        return r.getBitsLength(e);
      case t.KANJI:
        return a.getBitsLength(e);
      case t.BYTE:
        return o.getBitsLength(e)
    }
  }
  function p(e, i) {
    let l;
    const u = t.getBestModeForData(e);
    if (l = t.from(i, u),
    l !== t.BYTE && l.bit < u.bit)
      throw new Error('"' + e + '" cannot be encoded with mode ' + t.toString(l) + ".\n Suggested mode is: " + t.toString(u));
    switch (l !== t.KANJI || s.isKanjiModeEnabled() || (l = t.BYTE),
      l) {
      case t.NUMERIC:
        return new n(e);
      case t.ALPHANUMERIC:
        return new r(e);
      case t.KANJI:
        return new a(e);
      case t.BYTE:
        return new o(e)
    }
  }
  e.fromArray = function(e) {
    return e.reduce((function(e, t) {
        return "string" == typeof t ? e.push(p(t, null)) : t.data && e.push(p(t.data, t.mode)),
          e
      }
    ), [])
  }
    ,
    e.fromString = function(n, r) {
      const o = function(e) {
        const n = [];
        for (let r = 0; r < e.length; r++) {
          const o = e[r];
          switch (o.mode) {
            case t.NUMERIC:
              n.push([o, {
                data: o.data,
                mode: t.ALPHANUMERIC,
                length: o.length
              }, {
                data: o.data,
                mode: t.BYTE,
                length: o.length
              }]);
              break;
            case t.ALPHANUMERIC:
              n.push([o, {
                data: o.data,
                mode: t.BYTE,
                length: o.length
              }]);
              break;
            case t.KANJI:
              n.push([o, {
                data: o.data,
                mode: t.BYTE,
                length: u(o.data)
              }]);
              break;
            case t.BYTE:
              n.push([{
                data: o.data,
                mode: t.BYTE,
                length: u(o.data)
              }])
          }
        }
        return n
      }(d(n, s.isKanjiModeEnabled()))
        , a = function(e, n) {
        const r = {}
          , o = {
          start: {}
        };
        let a = ["start"];
        for (let i = 0; i < e.length; i++) {
          const s = e[i]
            , l = [];
          for (let e = 0; e < s.length; e++) {
            const u = s[e]
              , c = "" + i + e;
            l.push(c),
              r[c] = {
                node: u,
                lastCount: 0
              },
              o[c] = {};
            for (let e = 0; e < a.length; e++) {
              const i = a[e];
              r[i] && r[i].node.mode === u.mode ? (o[i][c] = f(r[i].lastCount + u.length, u.mode) - f(r[i].lastCount, u.mode),
                r[i].lastCount += u.length) : (r[i] && (r[i].lastCount = u.length),
                o[i][c] = f(u.length, u.mode) + 4 + t.getCharCountIndicator(u.mode, n))
            }
          }
          a = l
        }
        for (let t = 0; t < a.length; t++)
          o[a[t]].end = 0;
        return {
          map: o,
          table: r
        }
      }(o, r)
        , i = l.find_path(a.map, "start", "end")
        , c = [];
      for (let e = 1; e < i.length - 1; e++)
        c.push(a.table[i[e]].node);
      return e.fromArray(function(e) {
        return e.reduce((function(e, t) {
            const n = e.length - 1 >= 0 ? e[e.length - 1] : null;
            return n && n.mode === t.mode ? (e[e.length - 1].data += t.data,
              e) : (e.push(t),
              e)
          }
        ), [])
      }(c))
    }
    ,
    e.rawSplit = function(t) {
      return e.fromArray(d(t, s.isKanjiModeEnabled()))
    }
}(zY);
const uX = sY
  , cX = dY
  , dX = pY
  , fX = vY
  , pX = gY
  , hX = mY
  , vX = bY
  , gX = wY
  , mX = _Y
  , yX = RY
  , bX = UY
  , wX = LY
  , xX = zY;
function SX(e, t, n) {
  const r = e.size
    , o = bX.getEncodedBits(t, n);
  let a, i;
  for (a = 0; a < 15; a++)
    i = 1 == (o >> a & 1),
      a < 6 ? e.set(a, 8, i, !0) : a < 8 ? e.set(a + 1, 8, i, !0) : e.set(r - 15 + a, 8, i, !0),
      a < 8 ? e.set(8, r - a - 1, i, !0) : a < 9 ? e.set(8, 15 - a - 1 + 1, i, !0) : e.set(8, 15 - a - 1, i, !0);
  e.set(r - 8, 8, 1, !0)
}
function EX(e, t, n) {
  const r = new dX;
  n.forEach((function(t) {
      r.put(t.mode.bit, 4),
        r.put(t.getLength(), wX.getCharCountIndicator(t.mode, e)),
        t.write(r)
    }
  ));
  const o = 8 * (uX.getSymbolTotalCodewords(e) - gX.getTotalCodewordsCount(e, t));
  for (r.getLengthInBits() + 4 <= o && r.put(0, 4); r.getLengthInBits() % 8 != 0; )
    r.putBit(0);
  const a = (o - r.getLengthInBits()) / 8;
  for (let i = 0; i < a; i++)
    r.put(i % 2 ? 17 : 236, 8);
  return function(e, t, n) {
    const r = uX.getSymbolTotalCodewords(t)
      , o = gX.getTotalCodewordsCount(t, n)
      , a = r - o
      , i = gX.getBlocksCount(t, n)
      , s = r % i
      , l = i - s
      , u = Math.floor(r / i)
      , c = Math.floor(a / i)
      , d = c + 1
      , f = u - c
      , p = new mX(f);
    let h = 0;
    const v = new Array(i)
      , g = new Array(i);
    let m = 0;
    const y = new Uint8Array(e.buffer);
    for (let E = 0; E < i; E++) {
      const e = E < l ? c : d;
      v[E] = y.slice(h, h + e),
        g[E] = p.encode(v[E]),
        h += e,
        m = Math.max(m, e)
    }
    const b = new Uint8Array(r);
    let w, x, S = 0;
    for (w = 0; w < m; w++)
      for (x = 0; x < i; x++)
        w < v[x].length && (b[S++] = v[x][w]);
    for (w = 0; w < f; w++)
      for (x = 0; x < i; x++)
        b[S++] = g[x][w];
    return b
  }(r, e, t)
}
function AX(e, t, n, r) {
  let o;
  if (Array.isArray(e))
    o = xX.fromArray(e);
  else {
    if ("string" != typeof e)
      throw new Error("Invalid data");
    {
      let r = t;
      if (!r) {
        const t = xX.rawSplit(e);
        r = yX.getBestVersionForData(t, n)
      }
      o = xX.fromString(e, r || 40)
    }
  }
  const a = yX.getBestVersionForData(o, n);
  if (!a)
    throw new Error("The amount of data is too big to be stored in a QR Code");
  if (t) {
    if (t < a)
      throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + a + ".\n")
  } else
    t = a;
  const i = EX(t, n, o)
    , s = uX.getSymbolSize(t)
    , l = new fX(s);
  return function(e, t) {
    const n = e.size
      , r = hX.getPositions(t);
    for (let o = 0; o < r.length; o++) {
      const t = r[o][0]
        , a = r[o][1];
      for (let r = -1; r <= 7; r++)
        if (!(t + r <= -1 || n <= t + r))
          for (let o = -1; o <= 7; o++)
            a + o <= -1 || n <= a + o || (r >= 0 && r <= 6 && (0 === o || 6 === o) || o >= 0 && o <= 6 && (0 === r || 6 === r) || r >= 2 && r <= 4 && o >= 2 && o <= 4 ? e.set(t + r, a + o, !0, !0) : e.set(t + r, a + o, !1, !0))
    }
  }(l, t),
    function(e) {
      const t = e.size;
      for (let n = 8; n < t - 8; n++) {
        const t = n % 2 == 0;
        e.set(n, 6, t, !0),
          e.set(6, n, t, !0)
      }
    }(l),
    function(e, t) {
      const n = pX.getPositions(t);
      for (let r = 0; r < n.length; r++) {
        const t = n[r][0]
          , o = n[r][1];
        for (let n = -2; n <= 2; n++)
          for (let r = -2; r <= 2; r++)
            -2 === n || 2 === n || -2 === r || 2 === r || 0 === n && 0 === r ? e.set(t + n, o + r, !0, !0) : e.set(t + n, o + r, !1, !0)
      }
    }(l, t),
    SX(l, n, 0),
  t >= 7 && function(e, t) {
    const n = e.size
      , r = yX.getEncodedBits(t);
    let o, a, i;
    for (let s = 0; s < 18; s++)
      o = Math.floor(s / 3),
        a = s % 3 + n - 8 - 3,
        i = 1 == (r >> s & 1),
        e.set(o, a, i, !0),
        e.set(a, o, i, !0)
  }(l, t),
    function(e, t) {
      const n = e.size;
      let r = -1
        , o = n - 1
        , a = 7
        , i = 0;
      for (let s = n - 1; s > 0; s -= 2)
        for (6 === s && s--; ; ) {
          for (let n = 0; n < 2; n++)
            if (!e.isReserved(o, s - n)) {
              let r = !1;
              i < t.length && (r = 1 == (t[i] >>> a & 1)),
                e.set(o, s - n, r),
                a--,
              -1 === a && (i++,
                a = 7)
            }
          if (o += r,
          o < 0 || n <= o) {
            o -= r,
              r = -r;
            break
          }
        }
    }(l, i),
  isNaN(r) && (r = vX.getBestMask(l, SX.bind(null, l, n))),
    vX.applyMask(r, l),
    SX(l, n, r),
    {
      modules: l,
      version: t,
      errorCorrectionLevel: n,
      maskPattern: r,
      segments: o
    }
}
iY.create = function(e, t) {
  if (void 0 === e || "" === e)
    throw new Error("No input text");
  let n, r, o = cX.M;
  return void 0 !== t && (o = cX.from(t.errorCorrectionLevel, cX.M),
    n = yX.from(t.version),
    r = vX.from(t.maskPattern),
  t.toSJISFunc && uX.setToSJISFunction(t.toSJISFunc)),
    AX(e, n, o, r)
}
;
var CX = {}
  , kX = {};
!function(e) {
  function t(e) {
    if ("number" == typeof e && (e = e.toString()),
    "string" != typeof e)
      throw new Error("Color should be defined as hex string");
    let t = e.slice().replace("#", "").split("");
    if (t.length < 3 || 5 === t.length || t.length > 8)
      throw new Error("Invalid hex color: " + e);
    3 !== t.length && 4 !== t.length || (t = Array.prototype.concat.apply([], t.map((function(e) {
        return [e, e]
      }
    )))),
    6 === t.length && t.push("F", "F");
    const n = parseInt(t.join(""), 16);
    return {
      r: n >> 24 & 255,
      g: n >> 16 & 255,
      b: n >> 8 & 255,
      a: 255 & n,
      hex: "#" + t.slice(0, 6).join("")
    }
  }
  e.getOptions = function(e) {
    e || (e = {}),
    e.color || (e.color = {});
    const n = void 0 === e.margin || null === e.margin || e.margin < 0 ? 4 : e.margin
      , r = e.width && e.width >= 21 ? e.width : void 0
      , o = e.scale || 4;
    return {
      width: r,
      scale: r ? 4 : o,
      margin: n,
      color: {
        dark: t(e.color.dark || "#000000ff"),
        light: t(e.color.light || "#ffffffff")
      },
      type: e.type,
      rendererOpts: e.rendererOpts || {}
    }
  }
    ,
    e.getScale = function(e, t) {
      return t.width && t.width >= e + 2 * t.margin ? t.width / (e + 2 * t.margin) : t.scale
    }
    ,
    e.getImageWidth = function(t, n) {
      const r = e.getScale(t, n);
      return Math.floor((t + 2 * n.margin) * r)
    }
    ,
    e.qrToImageData = function(t, n, r) {
      const o = n.modules.size
        , a = n.modules.data
        , i = e.getScale(o, r)
        , s = Math.floor((o + 2 * r.margin) * i)
        , l = r.margin * i
        , u = [r.color.light, r.color.dark];
      for (let e = 0; e < s; e++)
        for (let n = 0; n < s; n++) {
          let c = 4 * (e * s + n)
            , d = r.color.light;
          if (e >= l && n >= l && e < s - l && n < s - l) {
            d = u[a[Math.floor((e - l) / i) * o + Math.floor((n - l) / i)] ? 1 : 0]
          }
          t[c++] = d.r,
            t[c++] = d.g,
            t[c++] = d.b,
            t[c] = d.a
        }
    }
}(kX),
  function(e) {
    const t = kX;
    e.render = function(e, n, r) {
      let o = r
        , a = n;
      void 0 !== o || n && n.getContext || (o = n,
        n = void 0),
      n || (a = function() {
        try {
          return document.createElement("canvas")
        } catch (Y_) {
          throw new Error("You need to specify a canvas element")
        }
      }()),
        o = t.getOptions(o);
      const i = t.getImageWidth(e.modules.size, o)
        , s = a.getContext("2d")
        , l = s.createImageData(i, i);
      return t.qrToImageData(l.data, e, o),
        function(e, t, n) {
          e.clearRect(0, 0, t.width, t.height),
          t.style || (t.style = {}),
            t.height = n,
            t.width = n,
            t.style.height = n + "px",
            t.style.width = n + "px"
        }(s, a, i),
        s.putImageData(l, 0, 0),
        a
    }
      ,
      e.renderToDataURL = function(t, n, r) {
        let o = r;
        void 0 !== o || n && n.getContext || (o = n,
          n = void 0),
        o || (o = {});
        const a = e.render(t, n, o)
          , i = o.type || "image/png"
          , s = o.rendererOpts || {};
        return a.toDataURL(i, s.quality)
      }
  }(CX);
var TX = {};
const DX = kX;
function OX(e, t) {
  const n = e.a / 255
    , r = t + '="' + e.hex + '"';
  return n < 1 ? r + " " + t + '-opacity="' + n.toFixed(2).slice(1) + '"' : r
}
function _X(e, t, n) {
  let r = e + t;
  return void 0 !== n && (r += " " + n),
    r
}
TX.render = function(e, t, n) {
  const r = DX.getOptions(t)
    , o = e.modules.size
    , a = e.modules.data
    , i = o + 2 * r.margin
    , s = r.color.light.a ? "<path " + OX(r.color.light, "fill") + ' d="M0 0h' + i + "v" + i + 'H0z"/>' : ""
    , l = "<path " + OX(r.color.dark, "stroke") + ' d="' + function(e, t, n) {
    let r = ""
      , o = 0
      , a = !1
      , i = 0;
    for (let s = 0; s < e.length; s++) {
      const l = Math.floor(s % t)
        , u = Math.floor(s / t);
      l || a || (a = !0),
        e[s] ? (i++,
        s > 0 && l > 0 && e[s - 1] || (r += a ? _X("M", l + n, .5 + u + n) : _X("m", o, 0),
          o = 0,
          a = !1),
        l + 1 < t && e[s + 1] || (r += _X("h", i),
          i = 0)) : o++
    }
    return r
  }(a, o, r.margin) + '"/>'
    , u = 'viewBox="0 0 ' + i + " " + i + '"'
    , c = '<svg xmlns="http://www.w3.org/2000/svg" ' + (r.width ? 'width="' + r.width + '" height="' + r.width + '" ' : "") + u + ' shape-rendering="crispEdges">' + s + l + "</svg>\n";
  return "function" == typeof n && n(null, c),
    c
}
;
const RX = function() {
  return "function" == typeof Promise && Promise.prototype && Promise.prototype.then
}
  , LX = iY
  , IX = CX
  , PX = TX;
function FX(e, t, n, r, o) {
  const a = [].slice.call(arguments, 1)
    , i = a.length
    , s = "function" == typeof a[i - 1];
  if (!s && !RX())
    throw new Error("Callback required as last argument");
  if (!s) {
    if (i < 1)
      throw new Error("Too few arguments provided");
    return 1 === i ? (n = t,
      t = r = void 0) : 2 !== i || t.getContext || (r = n,
      n = t,
      t = void 0),
      new Promise((function(o, a) {
          try {
            const a = LX.create(n, r);
            o(e(a, t, r))
          } catch (Y_) {
            a(Y_)
          }
        }
      ))
  }
  if (i < 2)
    throw new Error("Too few arguments provided");
  2 === i ? (o = n,
    n = t,
    t = r = void 0) : 3 === i && (t.getContext && void 0 === o ? (o = r,
    r = void 0) : (o = r,
    r = n,
    n = t,
    t = void 0));
  try {
    const a = LX.create(n, r);
    o(null, e(a, t, r))
  } catch (Y_) {
    o(Y_)
  }
}
aY.create = LX.create,
  aY.toCanvas = FX.bind(null, IX.render),
  aY.toDataURL = FX.bind(null, IX.renderToDataURL),
  aY.toString = FX.bind(null, (function(e, t, n) {
      return PX.render(e, n)
    }
  ));
const BX = "/page-webui/loading-62f6bad6.svg"
  , NX = ml("globalData", (()=>({
  globalData: Ft({
    unit_price: 1.5,
    liveAppDownloadUrl: "https://cdn-tx.yunbovtb.com/assets/dp/%E5%B0%8FK%E6%95%B0%E5%AD%97%E4%BA%BA%E5%BC%80%E6%92%AD%E7%9B%92%E5%AD%90.zip",
    live_concurrency_unit_price_month: 29e3,
    live_concurrency_unit_price_year: 3e5
  })
})))
  , MX = e=>(Ln("data-v-29988bf7"),
  e = e(),
  In(),
  e)
  , jX = {
  style: {
    margin: "-34px -25px -30px"
  }
}
  , VX = {
  class: "tab-box"
}
  , UX = {
  class: "recharge",
  id: "payAlert"
}
  , $X = {
  class: "payCont"
}
  , HX = {
  class: "amount",
  style: {
    gap: "34px"
  }
}
  , zX = MX((()=>Ma("div", {
  class: "damon1"
}, [Ma("img", {
  width: "116",
  src: "/page-webui/1-dbffac99.png"
})], -1)))
  , KX = MX((()=>Ma("div", {
  class: "damon-count"
}, [Ma("p", null, "10000 蓝钻"), Ma("span")], -1)))
  , WX = MX((()=>Ma("div", {
  class: "damon2"
}, [Ma("img", {
  width: "122",
  src: "/page-webui/2-fe64c019.png"
})], -1)))
  , GX = MX((()=>Ma("div", {
  class: "damon-count"
}, [Ma("p", null, "30000 蓝钻"), Ma("span", null, "+额外送1500蓝钻")], -1)))
  , qX = MX((()=>Ma("div", {
  class: "damon3"
}, [Ma("img", {
  width: "133",
  src: "/page-webui/3-cdc1a914.png"
})], -1)))
  , YX = MX((()=>Ma("div", {
  class: "damon-count"
}, [Ma("p", null, "60000 蓝钻"), Ma("span", null, "+额外送6000蓝钻")], -1)))
  , XX = MX((()=>Ma("div", {
  class: "title",
  style: {
    "font-size": "16px",
    "margin-top": "19px"
  }
}, " 请选择付款方式： ", -1)))
  , QX = {
  class: "method"
}
  , JX = [MX((()=>Ma("img", {
  style: {
    "margin-right": "20px"
  },
  width: "40",
  src: "/page-webui/weixin-60f7cd92.svg"
}, null, -1))), MX((()=>Ma("span", null, "微信支付", -1)))]
  , ZX = [MX((()=>Ma("img", {
  style: {
    width: "40px",
    "margin-right": "20px"
  },
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAACiZJREFUeF7tnHuMVNUdxz+/mQWtQisoe++AgPVRa/3HaGva2AQhxVQtivH1hxFmRilWLYqKNjVEpG1SRQQtSiu6s5CYttTWrY21xqq1FZuKNjappTYSWR7OzFJdjICy7NxfPTNgl53HPfcxw0L2JvzD/J7f/Z17zu9xrjD8REJAInEPMzMMYMQgGAZwGMCICERkH47AwwrARdrGCT2TKZXG0CajURld9k/0Q/r1Q5LJXja1d7NI+iP6HRv7wYvARZpg0rtnQNs0RM8BvgicBIzw8W4vsBH4NyrroP8FNo9/g0XixYZKAEGtBVBV6CxMQWQWKjNBxwSwtQGp9CLaheoa0u5LiGg8cv2ltAbAh3pGcVTpOyA3ApP8zYpEsRl0BbuTK7mhfWckSRbMzQWwDJzeCjoPGGthT5wk74M8yG5Z2kwgmwdgR/4yEollqB4fJyqBZYlsxfPmk009EZjXgiF+AFcVHZLkED3fQn/rSFSeoUSGOU4xTqXxAthRmIbwOODGaWSMsgooV5F1X4hLZnwA5oq3gC4BEnEZ1yQ5HsgCMs79cciPDmD5aNJzD+iCOAxqnQxZQrr9jqhHnmgAlsErrgKuaZ3jsWp6jLQzJwqI0QDszC9B5bZYXWq1MNH7SKdCr57wAFbeeUtb7W9z9MmtYd+J4QCs7LbPHQIbhi3eHsr0MLtzcADNOa9N3xjCRxVb0AbTFeiXM4KeE4MDmMs/A/LNsFZa8K0jIdfjyUcH0Ip3PsoDFvzhScxhO+tcEERAMABNeibyqyAKAtOqLiabuquKL5e/HGRtYHlBGVQvD5L22QNoCgNH64am57YHG0CTO++S02wLEPYA5op3gS4K+gcNTH+wASwbLIvIOHfb2G4HYLks5XW3pCQ1JADkfXYnJttEoR2AnfnbUbnH5i8SmWZoAAjo7WRSJrdv+PgDWEnXNoWuJGvAHduTjVzb/naV1Y9tH0+y9GU/h6p+V34bmKfCsJm0c4JfmucPYC5/LsiLIY2AjOuvI7RwC8ZcIUJ/RKeSSf2pkRZ/5zoLHSgZC1Nrk6gEzTNfIeu8UiXs0Z6TSXphirQPhrZdyJF2s+EBNK3HyT3/ja97ZuHKkHkHlnfjXrrbj2vUMm0cgR3bzkSSr1u4HR/JkALQ7CWls8hO+Hs9B30ALN6GlKvMrXuGHICygKxzXzgAc4UngZmxoCfchCev+cvq30J2wpYquo78OITT/flN1Mg8hEusaP2Jusi4dWU1jsBcYcO+kQt/NX4UKtPJOn/0I4vl91z+LZAvxCLLjJBk3NOCR6AZ9Jlc3G0xq2Jnp/Aaqu/ZEVtQiWwn7V5dI1K/hMibFhJsSfbS7RxVb6CpfgR2Fk9CtfpAa6u22XSiK0mnrq9S01m4E+WHsaoXOZm0Ywaaqp76AObyXwF5NVZD4hQm3hTS4/9cA8D1KMEzloa26dlkUuuDAVgp2z8fp8+xyTIlp9ntk6rSrI5tE5Hk5tj07BeU0GnMTtXMxupHYEfhYoSuiMZ4iL6Clt9JG0C2gJcEGQE6EuQY0IkgJ6KcinCqVZ9FWUjWrV6mucKPgO9HtLnWOr2YtPtUsAjsLFxE+ETcTEYtp39vjjnHb7V26LHto0mWzsbja4hMh/LgZXIQ/4dwxCQyY3Yc8P+53mNgjym5fdZany2hMpOsW7MoUT8CV+en4kmIGRJ9lra2DFePy9vaV5fu0S1jSYy8ANFLAdOHORJkCRnn9iqeXHEh6OLIOmsKkPPIOKYL2fRNpItu59Kq3PHx7jH0jfwcfbqTfGpHqBlnU9T9jDcDSbxIpr1wgCeVgq8puR3bFABVzqlZ4DDZcl2FQY8xygZG7T2LKyZWummr352EJhaizACcA/QIO/HYQoLXP/n9dUTWs6n9b6GANYJz+QUg9zYFPCM0yYnMct8JFoFBD9Ki3yKderqsJFf43icJlemsHRnAKXPI7oLEE/SNe565YobJ7Z6O/GyQuQhfbRgUdtIGU5Xodo4MfpCuAGGXyglvk3ZPKWvuLMyLoX+7HfSnkHy4ark2AsFUrRP9MxG5BGVKTFnUO2TcE+up9cuF7YoJKveSde6gMrVgCgF+VxVsY6EP9JeU+m/m2onv2zJVVkF5V74AyrcBzAZUuXMS+NFfk0ldFg7ADstyluiVpFNracbAkfIIWXduYL8HMqx9cyQ7j5uKcFH5X5C5bVNRD13Osi2oCt8g7T5P/ONuXRztXMYVUooE4GDmsl+JiyAxA/TMhrIb7MCGr/ESti3pm85b1nmWjuJcxLy7YnhEX0Y/nk7m8x9XScsVliGcDPJj0s66SNpWbT2e5AhzUpiB6DTgiAHyttPtuOFL+pVNwb+pJHoj6dRD+96BJhsYaERw/4Sfsyvx7ZqN7Vx+McjCAULXoZjD9VN+LUhfQ9YUjkblPFRnoFyI8HS0ppLRaJORKE+RdS/etwtHKSftQWU+WWdlTWc7i7eiWqe8Lm8hej/60ZqaUeuL3iACs/pSvaOZO/aDRqz+bU2bxrrQjyRPZ/a4/2DoVxeXoswPZLMpuOJdR3p87SZWrjAHeMRC5nZUV9ImDzHL7bGgj0TiD2B5GVuMdpjZukz7hZ8uo478FCSxGPTrDSospU8KBs9B4mdknNqVH/MHyRV/gHBnQE/3AI9TYhnXuv8MyGtNbgegqZIkSibX9Lvv9gAZ9+YDtK/eeizeiCmgE0DHlUtZKu8h3r8Y2fdXrprcW9faXI8L3qPAhdYe1SZ8joQuY5b7h8jvyUHy7QA0TNbjbdLJbvmuzWRTXVDWapLdxTQqS+Jt6stbwHL6SmuYO970eyI/9gAGG7DcCHI3fe2/CJTTmkiX0pUIJpc2l6+b9EgvyiroX1GzhRpAqz2ARmjwEd9tCE/i6Usk9VW8PT2f7pAmynrzYxghpyNyBjB1X80v2hEogPOYzc/jNyAP1CtX+YkLBmAZxOLvI97E3IWgKKP8jGvp7+VTgNwc9GAeHMDD95rDNpKcGfToExzAchQedhdt9qJybphlHA7Ayq58GF31Yj4Zd3mYV0Z4ACsH7EP/sqHqUrKp0BcmowF46F93XU7GDZZyhj5I14vvcu5buPeQu/aqPEjWvSnMsh3IEy0CB0o6dK7870X1FrKpFVHBM/zxAfj/3Xlof3TCS1zONe0vxwFe/AAaiUP1syfwO7zkdVwz7t24wGsOgPutq6R95mgwIU6DQ8jqRphXbzgohLwDWOJdwoOtObiffnoP5Cf0lZbEVXmpBXZzAdyvsVzJKV2Pyg2hr4zZh8pGRJexR3PNBG6/Oa0BcL82c+RZUzgXlavj/fwd20C6EH2STc6LrfyWYGsBHBhFYT/AaEpQZpAJfQNJ/APx/sIsd33clWbbgD94ANaycP8nQNUbW/78Z4JR5cIX3g4SyQ+gtIMPdhWZd4rpdwyJZ2gBOCQgCWbEMIDB8KqiHgZwGMCICERkH47AYQAjIhCR/X84249+4fnZFQAAAABJRU5ErkJggg=="
}, null, -1))), MX((()=>Ma("span", null, "支付宝支付", -1)))]
  , eQ = {
  class: "pay"
}
  , tQ = ["src"]
  , nQ = ["src"]
  , rQ = {
  style: {
    "text-align": "center",
    "margin-top": "6px"
  }
}
  , oQ = {
  style: {
    color: "#00a6ff"
  }
}
  , aQ = {
  class: "tab-box live"
}
  , iQ = {
  class: "payCont"
}
  , sQ = {
  class: "amount",
  style: {
    "justify-content": "center",
    gap: "93px"
  }
}
  , lQ = ["onClick"]
  , uQ = {
  key: 0,
  class: "discount-tag"
}
  , cQ = MX((()=>Ma("div", {
  class: "liveConcurrency"
}, [Ma("img", {
  width: "76",
  src: "/page-webui/liveConcurrency-da38562f.png"
})], -1)))
  , dQ = {
  class: "damon-count",
  style: {
    height: "40px"
  }
}
  , fQ = {
  style: {
    "font-size": "14px",
    color: "rgba(255,255,255,0.85)"
  }
}
  , pQ = MX((()=>Ma("span", null, null, -1)))
  , hQ = {
  style: {
    height: "65px"
  }
}
  , vQ = MX((()=>Ma("img", {
  style: {
    "margin-left": "3px",
    position: "relative",
    top: "-1px"
  },
  width: "16",
  src: cG,
  alt: ""
}, null, -1)))
  , gQ = {
  key: 0,
  class: "averagePrice"
}
  , mQ = MX((()=>Ma("img", {
  style: {
    "margin-left": "3px",
    position: "relative",
    top: "2px",
    display: "inline-block"
  },
  width: "16",
  src: cG,
  alt: ""
}, null, -1)))
  , yQ = {
  class: "live-buy-box"
}
  , bQ = {
  class: "current-num"
}
  , wQ = MX((()=>Ma("img", {
  class: "img-tips",
  src: hG,
  alt: ""
}, null, -1)))
  , xQ = MX((()=>Ma("div", null, "可同时开启直播间数量", -1)))
  , SQ = {
  class: ""
}
  , EQ = vr({
  __name: "PayQR",
  props: ["show"],
  emits: ["finishPay", "close"],
  setup(e, {emit: t}) {
    const n = e
      , r = Ft({
      live_concurrency_num: 0
    })
      , o = Ft(1)
      , a = Ft("diamond")
      , {globalData: i} = NX()
      , s = pG()
      , l = Ft("")
      , u = Ft("");
    let c;
    const d = ()=>{
        oY.pay.getQrCode({
          platform: l.value,
          goods_code: h.value
        }).then((e=>{
            aY.toDataURL(e.data.qr_code).then((e=>{
                u.value = e
              }
            )).catch((e=>{
                console.error(e)
              }
            )),
              clearInterval(c),
              c = setInterval((()=>{
                  oY.pay.getPayOrderState({
                    out_trade_no: e.data.out_trade_no
                  }).then((e=>{
                      e.data.finish_time > 0 && (oY.login.getUserInfo().then((e=>{
                          s.setUserInfo(e.data)
                        }
                      )),
                        clearInterval(c),
                        t("finishPay"))
                    }
                  ))
                }
              ), 3e3)
          }
        ))
      }
      , f = ()=>{
        u.value = "",
          l.value = "weixin",
          d()
      }
      , p = ()=>{
        u.value = "",
          l.value = "alipay",
          d()
      }
      , h = Ft(0)
      , v = Ft(["1000", "3000", "6000"])
      , g = e=>{
        h.value = e,
        l.value && d()
      }
      , m = yi({
        get: ()=>(n.show && oY.statistic.digitalOrderUserinfo().then((e=>{
            r.value = e.data || {}
          }
        )),
          n.show),
        set(e) {
          e || (t("close"),
            setTimeout((()=>{
                clearInterval(c)
              }
            ), 16e3))
        }
      })
      , y = Ft([{
        price: i.live_concurrency_unit_price_month,
        desc: "单月直播线路（30天）",
        type: 1,
        averagePrice: !1,
        discount: 0
      }, {
        price: i.live_concurrency_unit_price_year,
        desc: "包年直播线路（365天）",
        type: 3,
        averagePrice: !0,
        discount: 8.6
      }])
      , b = Ft(!1)
      , w = ()=>{
        b.value = !0;
        let e = {
          live_concurrency_num: 1,
          duration: 1,
          type: o.value
        };
        oY.pay.buyLiveConcurrency(e).then((e=>{
            b.value = !1,
              0 == e.code ? (oY.login.getUserInfo().then((e=>{
                  s.setUserInfo(e.data)
                }
              )),
                MW({
                  type: "success",
                  message: "购买成功"
                }),
                m.value = !1) : MW({
                type: "error",
                message: "购买失败，请稍后再试1"
              })
          }
        )).catch((e=>{
            b.value = !1
          }
        ))
      }
    ;
    return (e,t)=>{
      const n = WC
        , i = sS
        , s = zP
        , c = C$
        , d = qB
        , x = A$
        , S = YL;
      return Ca(),
        Ra(S, {
          modelValue: m.value,
          "onUpdate:modelValue": t[10] || (t[10] = e=>m.value = e),
          class: "dialogbox buy-damon",
          style: {
            width: "700px",
            padding: "0",
            "box-shadow": "0px 0px 3px 0px rgba(0,0,0,0.5)",
            "border-radius": "12px"
          },
          center: ""
        }, {
          default: Fn((()=>[Ma("div", jX, [ja(x, {
            modelValue: a.value,
            "onUpdate:modelValue": t[9] || (t[9] = e=>a.value = e)
          }, {
            default: Fn((()=>[ja(c, {
              label: "购买蓝钻",
              name: "diamond"
            }, {
              default: Fn((()=>[Ma("div", VX, [Ma("div", UX, [Ma("div", $X, [Ma("div", HX, [Ma("div", {
                class: Y(["amount-item", {
                  act: 0 == h.value
                }]),
                onClick: t[0] || (t[0] = e=>g(0)),
                onMousedown: t[1] || (t[1] = js((()=>{}
                ), ["prevent"]))
              }, [zX, KX, ja(n, {
                type: "primary"
              }, {
                default: Fn((()=>[$a("￥1000.0")])),
                _: 1
              })], 34), Ma("div", {
                class: Y(["amount-item", {
                  act: 1 == h.value
                }]),
                onClick: t[2] || (t[2] = e=>g(1)),
                onMousedown: t[3] || (t[3] = js((()=>{}
                ), ["prevent"]))
              }, [WX, GX, ja(n, {
                type: "primary"
              }, {
                default: Fn((()=>[$a("￥3000.0")])),
                _: 1
              })], 34), Ma("div", {
                class: Y(["amount-item", {
                  act: 2 == h.value
                }]),
                onClick: t[4] || (t[4] = e=>g(2)),
                onMousedown: t[5] || (t[5] = js((()=>{}
                ), ["prevent"]))
              }, [qX, YX, ja(n, {
                type: "primary"
              }, {
                default: Fn((()=>[$a("￥6000.0")])),
                _: 1
              })], 34)])]), rr(Ma("div", null, [XX, Ma("div", QX, [Ma("div", {
                class: Y(["cli", {
                  act: "weixin" == l.value
                }]),
                onClick: f
              }, JX, 2), Ma("div", {
                class: Y(["cli", {
                  act: "alipay" == l.value
                }]),
                onClick: p
              }, ZX, 2)])], 512), [[$s, !l.value]]), rr(Ma("div", eQ, [Ma("div", {
                class: "re-select",
                onClick: t[6] || (t[6] = e=>l.value = "")
              }, [ja(i, {
                style: {
                  "margin-right": "5px"
                },
                size: "16"
              }, {
                default: Fn((()=>[ja(Vt(vm))])),
                _: 1
              }), $a(" 返回重选 ")]), ja(s, {
                class: "qr",
                src: u.value,
                fit: "contain"
              }, {
                placeholder: Fn((()=>[Ma("img", {
                  style: {
                    width: "100%",
                    height: "100%",
                    "object-fit": "contain"
                  },
                  src: Vt(BX)
                }, null, 8, tQ)])),
                error: Fn((()=>[Ma("img", {
                  style: {
                    width: "100%",
                    height: "100%",
                    "object-fit": "contain"
                  },
                  src: Vt(BX)
                }, null, 8, nQ)])),
                _: 1
              }, 8, ["src"]), Ma("p", rQ, [$a(te("weixin" == l.value ? "微信支付" : "支付宝支付") + " ", 1), Ma("span", oQ, te(v.value[h.value] + "元"), 1)])], 512), [[$s, l.value]])])])])),
              _: 1
            }), ja(c, {
              label: "购买直播并发数",
              name: "liveConcurrency"
            }, {
              default: Fn((()=>[Ma("div", aQ, [Ma("div", iQ, [Ma("div", sQ, [(Ca(!0),
                _a(ba, null, Yr(y.value, (e=>(Ca(),
                  _a("div", {
                    class: Y(["amount-item", {
                      act: o.value == e.type
                    }]),
                    onClick: t=>o.value = e.type,
                    onMousedown: t[7] || (t[7] = js((()=>{}
                    ), ["prevent"]))
                  }, [0 !== e.discount ? (Ca(),
                    _a("div", uQ, te(e.discount) + "折", 1)) : za("", !0), cQ, Ma("div", dQ, [Ma("p", fQ, te(e.desc), 1), pQ]), Ma("div", hQ, [ja(n, {
                    type: "primary"
                  }, {
                    default: Fn((()=>[$a(te(e.price), 1), vQ])),
                    _: 2
                  }, 1024), e.averagePrice ? (Ca(),
                    _a("div", gQ, [$a(" 合25000"), mQ, $a("/月 ")])) : za("", !0)])], 42, lQ)))), 256))])]), Ma("div", yQ, [Ma("div", bQ, [$a(" 当前并发数：" + te(r.value.live_concurrency_num) + " ", 1), ja(d, {
                trigger: "hover",
                width: "160px",
                placement: "top"
              }, {
                reference: Fn((()=>[wQ])),
                default: Fn((()=>[xQ])),
                _: 1
              })]), Ma("div", SQ, [ja(n, {
                type: "info",
                class: "live-button live-cancel",
                onClick: t[8] || (t[8] = e=>m.value = !1)
              }, {
                default: Fn((()=>[$a("取 消")])),
                _: 1
              }), ja(n, {
                type: "primary",
                class: "live-button live-buy",
                loading: b.value,
                onClick: w
              }, {
                default: Fn((()=>[$a("购 买")])),
                _: 1
              }, 8, ["loading"])])])])])),
              _: 1
            })])),
            _: 1
          }, 8, ["modelValue"])])])),
          _: 1
        }, 8, ["modelValue"])
    }
  }
})
  , AQ = (e,t)=>{
  const n = e.__vccOpts || e;
  for (const [r,o] of t)
    n[r] = o;
  return n
}
  , CQ = AQ(EQ, [["__scopeId", "data-v-29988bf7"]])
  , kQ = e=>(Ln("data-v-231edb90"),
  e = e(),
  In(),
  e)
  , TQ = {
  class: "headerSlots"
}
  , DQ = {
  class: "user"
}
  , OQ = {
  class: "item-class"
}
  , _Q = kQ((()=>Ma("img", {
  width: "26",
  src: cG,
  alt: ""
}, null, -1)))
  , RQ = {
  style: {
    "font-weight": "800",
    color: "#FFC828"
  }
}
  , LQ = [kQ((()=>Ma("img", {
  width: "22",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAAXNSR0IArs4c6QAABTxJREFUWEfVmWtsVFUQx39nt69FTOQDSDCKwVS2GkkwaLcloBJRopREHk1EosZEEJAiSIX6+KQRgVoebTG2vr6gPKRoVdTQRGwLXWKJ8dMWmqhVUxokFMR2t91ujzl7d/dut3f33tstNj3J7pc7M+d/5878Z84cQRpLSgRn8vKBx5FyBoJpEPtJ4ALQiaQTIX4FviHfd0YI1LMRLTESLdmS9zBCrgCWAFNt2ugC6pHiiCjwNdjUxRZg6c3zwOBOEPPsbmQsL5vA8Yrw+LxW7VkCLH/KnUHIuQtYatWwTbk6nKFScV+7CpuUyxRw5PMfBiaZGUvzeTdSFJuFSUrAssW9AcFuwJkmGKvqISSbREFbZTKFpIClN28PyI1WdxpdObFXeHwvGdk0BBzx7L7RBWHTmqTEyNPDAEdi9jujMHi5up+z7aHYzksKnWwuzrKMREp4dnuAjos6Dd+b66RivaGNEFIsSozpIYAjbNCaLMHOnguxuCyA2litzAxorpzA9KmmuRuWrz8VYnV5YMgLfv1ODnNmJk2RbpyhOfHsMRSw133UjLrW7e6jrnEgtuniQicflOaYejk4APM3+PmtazAm+8S8DN7bnG2mWyc8bcuiQjHAWlGQLWbanZcGKVzvJ9CvS9Zvd3G/25FS9ePjQcpqdaWcLDhV5eKWyan1NKOiIFpc4gDPbLRawXYdDPLuIX3z2bkOju9wIZJERk9Akv9CL5eu6u+0aUUmW1dajX/ZJDzn5oehq79Iop0w8270ub9PUrjOz4XLevJUb8pm2fwMQxPlh4KUH9RfcOokwen9LibkWIv9sFEpFqoE1AB73TXA81YBK7nPfxzgxT19MRX1aU9Xu8jOHGrl7ysSz1o/ysvRtW9DNsULjF8uBYZa4WlbLbQW0d1pt+tSTPHYVj8/t+tJVPZUFhuXD0W8raafT74NxnDMusPB97uSh08KwF3kt00TVpPNyFCrorltOk1NdAla9ruYfJP2qRUjKGZQDBFdX77tIj/PSqIZ7SgKFOA3Qb5uJxziZddW9HGsSUe0amEm5eu0ZFKcq7g3uormOqndYk6BybGIt4RscR9AsHKkgBNpzumApioXPX54ZIs/VmRUbDdXTeDWKTYSLRGU5FMhve4fgAdHCljp7fwsSMVhnQWWP5DBlR5JQ6vu3ZJlmby6yiqNJUVzUgE+B9yZDuDegGTuep3mHA4Y1HORKYrGql2oGE9znVeArwETrRo60BCkoTUOTUTR1xHi9y7js+VtNwvuvn14v/DQbCdPP2qL3v5VgP8BbrQK+LXafj48rtOUVT0juWcWZbBjjWkvEa96zXZIjDHgcEjYSrovmgdo+mV4SETdcLQxGGuMVCw/uSCh9MX5q/AeR9JynuTLnUyb1hINz3qul4vdWiyrfvnPIzekEzVDdTVas1c4fB2D/BF3YkhEU7K3j6s9GmDFyR9tS14oFCffNd1O1VOFw2IfHAU2tjGsSrPN5mcMAWvNj/Kc9LrfV6XfSrBV1gU5FndEStQ5/5dkIKTzcapPXjQ3A9XIW1w1wtO2ZkQNfKoNrlvSxTfwmpetH5H+f8CiWXh84QGk7UOo2ee7Ph42OIRGYtn0mD8GgI2P+WHA2lg16SDFDKx6PsoeTj1ICYPWpuuGoyorgJe+EeDytUilc8CJCpcVNSMZ81FVVGtcDQNjoMfTuDXB0+NjoK2DDsf0+LgyiIEeT5cy8ek7+tdeohkoHfVrr0TOiVBfMVBkd8QFqIvFr5DisNmNkRHXpXXuNrm6Vfupmd2oXt3+B2RxPVSgZ3I8AAAAAElFTkSuQmCC",
  alt: ""
}, null, -1))), kQ((()=>Ma("span", null, "充值", -1)))]
  , IQ = {
  class: "user-pop"
}
  , PQ = kQ((()=>Ma("img", {
  width: "30",
  src: dG,
  alt: ""
}, null, -1)))
  , FQ = {
  class: "user-box"
}
  , BQ = {
  class: "user-header"
}
  , NQ = ["src"]
  , MQ = {
  class: "user_id"
}
  , jQ = {
  class: "user-info"
}
  , VQ = {
  class: "flex-box"
}
  , UQ = kQ((()=>Ma("img", {
  width: "16",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAAXNSR0IArs4c6QAAAPBQTFRFAAAA//8A//8A/79A/8wz/9Uq/78g/9Eu/8Uj/8co/8Uk/8gn/8km/8go/8gp/8ko/8Yo/8co/8gn/8cp/8kp/8cn/8co/8cn/8gp/8kp/8co/8co/8go/8go/8cn/8cn/8gn/8gp/8co/8cn/8gp/8ko/8gp/8go/8co/8go/8go/8gp/8go/8co/8gn/8gp/8go/8gn/8gp/8go/8go/8go/8gp/8go/8go/8gp/8go/8go/8go/8go/8co/8gn/8go/8go/8go/8go/8go/8go/8go/8go/8go/8go/8go/8go/8go/8go/8go/8goDWZ3tgAAAE90Uk5TAAECBAUGCAsWICMuLzM4OTpAQURLTlJWXV5lcnN5e3yCg4WJio2dnqWmp6qtrq+wsbW2vb7Bw8TIydDR0tXh4uTl5+zt8PL09fb5+vv9/mfGuskAAAD9SURBVBgZXcGHQkFhAIbh7yCbFFFGCUUdtKyUUcnmvf+7yWj953mUnbE1OpHDG3tNOUwZ2rb9wdiSac69pDIEZerzLCkNZzJ1GEgKrGnLVGNhSXqCsAxXEJFUhJIMccjLdw2cy+D55FV1WBXcMlUglIKGnBLw6OpBRk4tOI6uWMbkEIOu9xLeY5L7ohTWrypUrFtYZlQA2qdBSzv+PuQOboHGip1x80Rb4QnrnOtyxUaxsWZjpJ3kGireaA+upUC6/AHaS06ge+RK1X3askHfwn3gIaQ9G/TDX2XjJR+xJNmgP4ctthaDzt0Q9F/i5pNvM5k88atapz+fvmW/AIkCO/oPoRN2AAAAAElFTkSuQmCC",
  alt: ""
}, null, -1)))
  , $Q = kQ((()=>Ma("img", {
  width: "16",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAcCAMAAABMOI/cAAAAAXNSR0IArs4c6QAAADlQTFRFAAAA//8A/8gk/8sn/8cq/8go/8kn/8go/8cn/8kn/8gp/8gn/8go/8gn/8go/8go/8go/8go/8goTT2rJAAAABJ0Uk5TAAEOJzdGVYeJm6rC4+/w8ff+M/GJnAAAAGJJREFUKM/NzbkWQEAQRNHCWMY2vP//WIkE1QGRF94+p1q6VjeypYXeegEG77u5pAK53bivpQK5UrtDY7zKsNTeS/qzr+9cwY4Ek3XBaF0wjxOsdxeAc0X+oS7ofP4sPkRTB107DkQA+xvOAAAAAElFTkSuQmCC",
  alt: ""
}, null, -1)))
  , HQ = kQ((()=>Ma("img", {
  width: "16",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAcBAMAAACNPbLgAAAAAXNSR0IArs4c6QAAADBQTFRFAAAA//8A//8A/8Mt/8gk/8Yo/8kq/8kn/8cn/8go/8kn/8gp/8go/8go/8go/8goqESmoAAAAA90Uk5TAAECERwtPVVWdIiquN30p0OBxgAAAGdJREFUGNNjYGAQK4eBRAYGhvn/YeAnkLcfzvsN4n2HKqwH8z4wQAA/Jg8OsPEMkHmsF5B5dcimaP1H4jGf/w+23QHMi4W6qgALD1UlqikMDH0fcNuO6jJ8fsDnd7RQQglB1NBFCnkAqXh+rxNF0jQAAAAASUVORK5CYII=",
  alt: ""
}, null, -1)))
  , zQ = {
  class: "dialog-footer"
}
  , KQ = {
  class: "buy-box"
}
  , WQ = kQ((()=>Ma("li", {
  class: "flex-center"
}, [Ma("div", {
  class: "flex-center count-iconbox"
}, [Ma("img", {
  width: "36",
  src: fG,
  alt: ""
})])], -1)))
  , GQ = {
  class: "flex-center price"
}
  , qQ = kQ((()=>Ma("img", {
  width: "18",
  src: cG,
  alt: ""
}, null, -1)))
  , YQ = kQ((()=>Ma("li", {
  class: "flex-center"
}, [Ma("div", null, [Ma("p", {
  class: "text-desc"
}, " 可同时开启直播间数量 +1 "), Ma("p", {
  class: "text-desc"
}, " 有效时间：30天 ")])], -1)))
  , XQ = {
  class: "live_concurrency_num"
}
  , QQ = {
  class: "buyDialog-footer"
}
  , JQ = AQ(vr({
  __name: "HeaderSlot",
  setup(e) {
    const {globalData: t} = NX()
      , n = Ft(!1)
      , r = Ju()
      , o = ()=>{
        r.push("/home/worker")
      }
      , a = ()=>{
        XW.alert("恭喜您充值成功", "提示", {
          showCancelButton: !1,
          confirmButtonText: "知道了"
        }).then((()=>{
            p.value = !1
          }
        ))
      }
      , i = pG()
      , s = Ft()
      , l = ()=>{
        i.setUserInfo({}),
          window.localStorage.removeItem("token"),
          location.href = "/login"
      }
      , u = Ft(!1)
      , c = Ft(!1)
      , d = bt({
        oldpwd: "",
        newpwd: "",
        newpwd2: ""
      })
      , f = bt({
        oldpwd: [{
          validator(e, t, n) {
            if (!t)
              return n(new Error("请输入原密码"));
            n()
          },
          trigger: "blur"
        }],
        newpwd: [{
          validator: (e,t,n)=>t ? d.newpwd !== d.newpwd2 ? n(new Error("新密码填写不一致")) : void n() : n(new Error("请输入新密码")),
          trigger: "blur"
        }],
        newpwd2: [{
          validator: (e,t,n)=>t ? d.newpwd !== d.newpwd2 ? n(new Error("新密码填写不一致")) : void n() : n(new Error("请输入确认新密码")),
          trigger: "blur"
        }]
      })
      , p = Ft(!1)
      , h = Ft({
        live_concurrency_num: 0
      })
      , v = ()=>{
        oY.statistic.digitalOrderUserinfo().then((e=>{
            h.value = e.data || {}
          }
        ))
      }
    ;
    v();
    return (e,r)=>{
      const g = qB
        , m = yE
        , y = sE
        , b = iE
        , w = WC
        , x = YL;
      return Ca(),
        _a(ba, null, [Ma("div", TQ, [Ma("div", {
          class: "comp-logo"
        }, [Ma("img", {
          width: "113",
          class: "logo",
          src: "/page-webui/logo-56bb3fd7.png",
          alt: "",
          onClick: o
        })]), Ma("div", DQ, [Ma("div", OQ, [_Q, Ma("span", null, [$a("蓝钻："), Ma("span", RQ, te(Vt(i).userInfo.diamond), 1)])]), Ma("div", {
          onClick: r[0] || (r[0] = e=>p.value = !0),
          class: "item-class",
          style: {
            cursor: "pointer",
            "font-weight": "bold"
          }
        }, LQ), Ma("span", IQ, [ja(g, {
          placement: "top-start",
          width: 200,
          trigger: "hover",
          "show-arrow": !1
        }, {
          reference: Fn((()=>[PQ])),
          default: Fn((()=>[Ma("div", FQ, [Ma("div", BQ, [Ma("img", {
            class: "headimg",
            width: "60",
            src: Vt(i).userInfo.headimgurl || Vt(dG),
            alt: ""
          }, null, 8, NQ), Ma("div", MQ, te(Vt(i).userInfo.username), 1)]), Ma("div", jQ, [Ma("div", VQ, [UQ, $a(" " + te(Vt(i).userInfo.phone), 1)]), Ma("div", {
            class: "cursor flex-box",
            onClick: r[1] || (r[1] = e=>u.value = !0)
          }, [$Q, $a(" 修改密码 ")])]), Ma("div", {
            class: "logout"
          }, [Ma("div", {
            class: "cursor flex-box exit",
            onClick: l
          }, [HQ, $a(" 退出登录 ")])])])])),
          _: 1
        })])])]), ja(x, {
          modelValue: u.value,
          "onUpdate:modelValue": r[7] || (r[7] = e=>u.value = e),
          title: "修改密码",
          width: "460px",
          class: "dialogbox"
        }, {
          footer: Fn((()=>[Ma("span", zQ, [ja(w, {
            onClick: r[5] || (r[5] = e=>u.value = !1)
          }, {
            default: Fn((()=>[$a("取消")])),
            _: 1
          }), ja(w, {
            type: "primary",
            onClick: r[6] || (r[6] = e=>{
                var t;
                (t = s.value) && t.validate((e=>{
                    if (!e)
                      return !1;
                    oY.login.updatePassword({
                      old_password: d.oldpwd,
                      new_password: d.newpwd,
                      confirm_password: d.newpwd2
                    }).then((e=>{
                        u.value = !1,
                          XW.alert("密码修改成功", "提示", {
                            showCancelButton: !1,
                            confirmButtonText: "知道了"
                          }).then((()=>{}
                          ))
                      }
                    ))
                  }
                ))
              }
            )
          }, {
            default: Fn((()=>[$a("确定")])),
            _: 1
          })])])),
          default: Fn((()=>[Ma("div", null, [ja(b, {
            "label-position": "right",
            "label-width": "100px",
            model: d,
            style: {
              "max-width": "460px"
            },
            "require-asterisk-position": "left",
            ref_key: "ruleFormRef",
            ref: s,
            rules: f
          }, {
            default: Fn((()=>[ja(y, {
              label: "原密码",
              prop: "oldpwd",
              required: ""
            }, {
              default: Fn((()=>[ja(m, {
                "show-password": "",
                modelValue: d.oldpwd,
                "onUpdate:modelValue": r[2] || (r[2] = e=>d.oldpwd = e),
                type: "password"
              }, null, 8, ["modelValue"])])),
              _: 1
            }), ja(y, {
              label: "新密码",
              prop: "newpwd",
              required: ""
            }, {
              default: Fn((()=>[ja(m, {
                "show-password": "",
                modelValue: d.newpwd,
                "onUpdate:modelValue": r[3] || (r[3] = e=>d.newpwd = e),
                type: "password"
              }, null, 8, ["modelValue"])])),
              _: 1
            }), ja(y, {
              label: "确认新密码",
              prop: "newpwd2",
              required: ""
            }, {
              default: Fn((()=>[ja(m, {
                "show-password": "",
                modelValue: d.newpwd2,
                "onUpdate:modelValue": r[4] || (r[4] = e=>d.newpwd2 = e),
                type: "password"
              }, null, 8, ["modelValue"])])),
              _: 1
            })])),
            _: 1
          }, 8, ["model", "rules"])])])),
          _: 1
        }, 8, ["modelValue"]), ja(x, {
          modelValue: c.value,
          "onUpdate:modelValue": r[10] || (r[10] = e=>c.value = e),
          title: "购买并发数",
          width: "254px",
          class: "dialogbox"
        }, {
          footer: Fn((()=>[Ma("div", QQ, [ja(w, {
            onClick: r[8] || (r[8] = e=>c.value = !1)
          }, {
            default: Fn((()=>[$a("取消")])),
            _: 1
          }), ja(w, {
            type: "primary",
            loading: n.value,
            onClick: r[9] || (r[9] = e=>(n.value = !0,
              void oY.createLive.buyLiveConcurrency({
                live_concurrency_num: 1,
                duration: 1
              }).then((e=>{
                  n.value = !1,
                    c.value = !1,
                    MW({
                      type: "success",
                      message: "购买成功"
                    }),
                    v()
                }
              )).catch((e=>{
                  n.value = !1
                }
              ))))
          }, {
            default: Fn((()=>[$a("确定")])),
            _: 1
          }, 8, ["loading"])])])),
          default: Fn((()=>[Ma("div", null, [Ma("ul", KQ, [WQ, Ma("li", GQ, [$a(te(Vt(t).live_concurrency_unit_price_month) + " ", 1), qQ]), YQ]), Ma("div", XQ, " 当前并发数：" + te(h.value.live_concurrency_num), 1)])])),
          _: 1
        }, 8, ["modelValue"]), ja(CQ, {
          show: p.value,
          onFinishPay: a,
          onClose: r[11] || (r[11] = e=>p.value = !1)
        }, null, 8, ["show"])], 64)
    }
  }
}), [["__scopeId", "data-v-231edb90"]])
  , ZQ = {
  class: "common-layout"
}
  , eJ = {
  class: "flex-center"
}
  , tJ = ["src"]
  , nJ = ["src"]
  , rJ = {
  class: "menu-name"
}
  , oJ = ["src"]
  , aJ = ["src"]
  , iJ = {
  class: "menu-name"
}
  , sJ = {
  class: "menu-name"
}
  , lJ = AQ(vr({
  __name: "Home",
  setup(e) {
    var t;
    const n = Zu()
      , r = pG();
    oY.login.getUserInfo().then((e=>{
        r.setUserInfo(e.data)
      }
    ));
    let o = null == (t = Gyt.getRoutes().find((e=>"/home" === e.path))) ? void 0 : t.children;
    const a = yi((()=>n.meta.k));
    return (e,t)=>{
      const r = K_
        , i = yF
        , s = wF
        , l = mF
        , u = H_
        , c = Hr("router-view")
        , d = W_
        , f = $_;
      return Ca(),
        _a("div", ZQ, [ja(f, null, {
          default: Fn((()=>[ja(r, {
            class: "page_header"
          }, {
            default: Fn((()=>[ja(JQ)])),
            _: 1
          }), ja(f, null, {
            default: Fn((()=>[ja(u, {
              width: "200px"
            }, {
              default: Fn((()=>[ja(l, {
                "default-active": a.value,
                class: "el-menu-vertical-demo",
                "active-text-color": "#3AFFF3",
                router: "",
                "default-openeds": [a.value],
                onMousedown: t[0] || (t[0] = js((()=>{}
                ), ["prevent"]))
              }, {
                default: Fn((()=>[(Ca(!0),
                  _a(ba, null, Yr(Vt(o), (e=>{
                      var t, r, o, a;
                      return Ca(),
                        _a(ba, null, [e.children || (null == (t = e.meta) ? void 0 : t.hideInMenu) ? za("", !0) : (Ca(),
                          Ra(i, {
                            key: 0,
                            index: null == (r = e.meta) ? void 0 : r.k,
                            route: e.path
                          }, {
                            default: Fn((()=>{
                                var t, r, o, a, i;
                                return [Ma("div", {
                                  class: Y(["menu-item", {
                                    active: Vt(n).meta.k == (null == (t = e.meta) ? void 0 : t.k)
                                  }])
                                }, [Ma("div", eJ, [Ma("img", {
                                  class: "activeIcon",
                                  style: {
                                    width: "20px",
                                    "margin-right": "11px"
                                  },
                                  src: null == (r = e.meta) ? void 0 : r.activeIcon
                                }, null, 8, tJ), Ma("img", {
                                  class: "icon",
                                  style: {
                                    width: "20px",
                                    "margin-right": "11px"
                                  },
                                  src: null == (o = e.meta) ? void 0 : o.icon
                                }, null, 8, nJ), Ma("span", rJ, te(null == (a = e.meta) ? void 0 : a.title) + te(null == (i = e.meta) ? void 0 : i.hideInMenu), 1)])], 2)]
                              }
                            )),
                            _: 2
                          }, 1032, ["index", "route"])), e.children && !(null == (o = e.meta) ? void 0 : o.hideInMenu) ? (Ca(),
                          Ra(s, {
                            key: 1,
                            index: null == (a = e.meta) ? void 0 : a.k
                          }, {
                            title: Fn((()=>{
                                var t, r, o, a;
                                return [Ma("div", {
                                  class: Y(["flex-center", {
                                    active: Vt(n).meta.k == (null == (t = e.meta) ? void 0 : t.k)
                                  }])
                                }, [Ma("img", {
                                  class: "activeIcon",
                                  style: {
                                    width: "20px",
                                    "margin-right": "11px"
                                  },
                                  src: null == (r = e.meta) ? void 0 : r.activeIcon
                                }, null, 8, oJ), Ma("img", {
                                  class: "icon",
                                  style: {
                                    width: "20px",
                                    "margin-right": "11px"
                                  },
                                  src: null == (o = e.meta) ? void 0 : o.icon
                                }, null, 8, aJ), Ma("span", iJ, te(null == (a = e.meta) ? void 0 : a.title), 1)], 2)]
                              }
                            )),
                            default: Fn((()=>[(Ca(!0),
                              _a(ba, null, Yr(e.children.filter((e=>{
                                  var t;
                                  return !(null == (t = e.meta) ? void 0 : t.hideInMenu)
                                }
                              )), (e=>{
                                  var t;
                                  return Ca(),
                                    Ra(i, {
                                      class: "child-menu-name",
                                      index: null == (t = e.meta) ? void 0 : t.k,
                                      route: e.path
                                    }, {
                                      default: Fn((()=>{
                                          var t;
                                          return [Ma("span", sJ, te(null == (t = e.meta) ? void 0 : t.title), 1)]
                                        }
                                      )),
                                      _: 2
                                    }, 1032, ["index", "route"])
                                }
                              )), 256))])),
                            _: 2
                          }, 1032, ["index"])) : za("", !0)], 64)
                    }
                  )), 256))])),
                _: 1
              }, 8, ["default-active", "default-openeds"])])),
              _: 1
            }), ja(d, null, {
              default: Fn((()=>[ja(c, null, {
                default: Fn((({Component: e})=>[(Ca(),
                  Ra(Kr(e)))])),
                _: 1
              })])),
              _: 1
            })])),
            _: 1
          })])),
          _: 1
        })])
    }
  }
}), [["__scopeId", "data-v-8c030282"]])
  , uJ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAAAXNSR0IArs4c6QAAAzZJREFUWEfNmE2IjVEYx3//hGxYyEdSbCSliIiyGtNImIWs1IyPGCkKQyysZEE+y0TNyNeEDZthQ9gqIkpJysakMLMwGyE97mOeqzN37p373g/TnHq7vfc953l/7/N9jqhymNkkYDowI35d0hfgs/9K+l6NaFWyyMxmAavjWg6MK7H+N/AMeOyXpE9Z35MJKED2AxuATGsSAAPuAeeygI0o3MzGA/uAVmBCwVf2Aq/DTG4qH25CvxYBswvm/wRuAOcl/SqlsZJAZjYV6ACWJIu/Ad3AQ0nvRjKDmc0HmoCWnHamJHNfAnsk9RdbXxTIzOYBnbnLfcbHj/i6TkkDWf3B55nZZKAttDwx1rpPtUl6XyhrGFBo5k4C4+bYLelNJSCFc81sYS4iLyUR6VCbCjU1BCh8xu2cN9NbYKekr7XA5NeamfuXa35B/Ofma019qhDoELAjJrtmNtYLpgDqbqKpy5JO5Z//A4rQfhDR5D6zuVYzldJqmO8W4D7l0bcmnxJSIKdsDiFdkk6XM5OZNQCrYl6fpIvl1iSaOujuEPc9ktw6g0kutPMk7j20G7NEk5kdAHaF0A+S1lYA5NH3KFKCJ88G11IeyHPF0RDWIelCFsG1AIUi9npOincdl9SdB7oOrIgHzeWSXqL2qjUUQJ48e0LeU0lbFVX7RRTKXklePDONWjUUUF6Avcx4QV7qQHMBjy4f9yW1Z6IZ9L2aNBRAZ4D18c4mB/I2wuuTj6uSTowy0BFgW7yzxYGczil9nJR0ZZSBtgOH453t9QT6GEW02PcMSOor9sDMhgHVy2QjKfampGMlgIaZbI73N3Vw6mqBzgLrUqf2Zr0eYV8t0NCwj9C7lgv9lSGxksQ4E5iWIQj6i/XT0VUOTYwBVFXpyAAy4hQzK1k6vFWtuLjWAhStbfHiGlqquP2oEah0+xFArqXRbNBuRzNYvEELqLHTwgaQbwz/Z5PvEdmVuckPKN8gjo1tUN5J/9NGcUuyHc++UUygxs5WOoEqd9jwCvBNZHrY4H6yuO6HDWmOGTPHMYWJLzmwagSWlTmweh7bnPofWJXoY7xLyB/n+Z7dh5vu77FetUd6fwDj0rZwnjdVywAAAABJRU5ErkJggg=="
  , cJ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAAXNSR0IArs4c6QAABBZJREFUWEftmM9LG0EUxycJJq4pGH/G9NCToQfJoeBBQfuTHqXpTfwDrMe2tgpaJVBoa2176MGLR6l4skToreihClJKD4KXpL0mRk1iikk00d3yln3yMpnEbLIpDUQYZg2TN5/5znfevI2J1difqcZ4WR242jtWV7iuMKdA3RK1ZolydkzRs8hyJuDj8zH0xuSBiy5Ab/BisBiL7wsJiGB8D+MLQlcCLAKEzy4Dp4DwjI2CGg5MoVTIeDw+0NDQ4Do/PzdBk2VZKIYsy5mFhYWvPp8vxRiTCTA8I7ShwHmwgUDgmtvt/l3q4UkkElMOh+OjBgyg2ERq54TVa4k8WMaYORgM9nR3d//MZDKfDw4O/KBuNps18wuw2+1XnU7ny0QiMedwOF5poOeMMWhUbQpuGDAAqW1nZ6fH4/H80EDm8XNtJlyksra25h4aGvoWi8Xm29raXmugCCyCztu0chRWPZtKpR5KkvSJMWYtxQorKyt3YNzw8PDG4eHhu46OjjnG2JkGjb3IGmUrjBlA7U9PT2etVutMNptdl2X5D9hAURS10QNns9muW61W9/Ly8l2YeWRkZH1/f/+90+l8qwEDLALzKlekMAU2p9Pp2cbGxhfb29t9/f39QcaYhVjhIr2FQqFxl8v1ZGlp6Z7FYlEAeG9v74PL5eKBAZo/gIYAq75NJpOzTU1N01tbW/0DAwMAjJ7OycPhcPhZV1fXU6qwBgxeR3Wz2vM/BRZdGiwSiUx0dnaOXwIM4ABtODCoCGCWZDI5QxQOkBuOJn1TNBqdbG1tfQ6HDrxNLAEKg2dRXdHBq9gSF6kMgTc3N/sGBwcRGGDxxlIni8ViUy0tLROrq6u3MpmMGbKEwBJVVRg9rCpMgDHZ5wAfHR1NNzc3T/r9/pvpdNryvwKjLUwIfHJysgEpT5Kk20UOHVgEd0lYT+i5OGBsMUtQhfOA0YyKopzt7u4+8ng8X7g8TD1syNV8GTAw0XoA/geFp9ASXq/3F6nIYCymNewNv+nyFI5Go9OpVCqECprN5outhKzQ3t7ulSTpAXjY6/VCvsaFYQ1Bbzq+AKo4S6DKluPj48d2u/1NKXUEjFlcXLwxOjoaJh4FYHolo3/5or7iWkJV2efzXRkbG7uvKIoNSkko2kXwoHI8Ho/09vZ+54p1WqWVVKmpHitVIW0s3mYAjbUD9vSmw7B8fFQPAbGn3oXvGvLGkVOtaRlDWPAUEIJmEXoFi3xrGDDuCs0Y+EwXxG8cffGkauqC1WsJCovPWFvwsNQKhd6S6eESveoL3arHw3SBone7nLKSzCb6/UHXqz0lLxe4EHyxM1zWDyd8QL3AIhvpjcEfqIIHTLR6vZMZFUMXZCWW0JG2qzPUCIWrQ1Ygah242nLXnMJ/AYaNSksvsj6NAAAAAElFTkSuQmCC"
  , dJ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAAXNSR0IArs4c6QAAA6pJREFUWEftmM9rE0EUx2c3NrRpWuqPlkqKPfVQ9ZJLUVHwkGOIePEo/jwKgl76JwgePXnyUtuLYF167LEHKfYYJeApVk3R1lY2ZambkbfMCy+vk+zOZtsSyMKwm83uzGe+831vZtYSPXZYPcYr+sBHPWJ9hfsKMwX6lug1S0QdMRm3Y1Eb6FQ/ryOsTg5rBB9WeZgQ9H285mesA8H4Gf6PDN0NsA4Q7mHRdRbAaKGwkaDjAHNVA8CdnZ3rAwMD533ft6A0Go3mc67r/pyenl5TsA0GjR3gI6EdXVNgLWylUrkwMzPztZN/VlZWLhaLxaoQAoBp4Yp3tIgJsA7WBnXL5fLl2dnZT57nvd/a2lqmCk9OTt7KZDKl1dXVa4VC4bOC9ckZgKnqHZWOA0x9CsCpjY2NS/l8fn13d/fF2NjYSyFE0BEotVrt+cTExDPHcW6USqUvQggKC9f4u523WwYuFnC9Xr8zNDS0GJZCOv2/ubl5b2pq6p0CRmhUuq0tTIED1ba3t6+Ojo4+tW37imVZuf39/WUppQUFWqIBR6FHRkaKvu//8DxvvVKpvMrn8x+FEP+IyjwgD/U5DjAMd1A8z3ubTqdvW5Z1DqyhStu0JqX85rquk81mHxFlARiKLhATBU55nreggMcVLHSEHphbA2GklN8V8GMNMLeFNi93ozAHxkBD//EGwTI1ojAoCpCo8LECgyVQXYx2AKKHLaX8Va/XPwwPD4Ml0AInAnxWpbEg5kihlgDgPxCgmUzmIZn1UOVjVfiMAsZJAIebKpySUu4p4AcMmOZj3STSrMfEw/BSM0OwLAHAeCAszanQDij8VwHfVw9TH/MpO7G1BEJD0GFaO61RWAsM0/fg4GAUhY8NmNqCe3jvJIFh4liEPFytVnGIA1Vs25apVKolrcGCKJfLvSGWwI5h0OmCtauJA14OvEhmutfpdPquyZrCdd2FbDb7RAUdBhvNENRKiQEH4I7jjM/Nzd08ODg4BesHUBFa4Opiq77vy6WlpbX5+fnfZHnJV2yJA7eoTKbk5pJSAR6a6ch9nv4irSNwiE1GlK+FW9JcyH4O26EzYZTdRwufaR6mG09UFKH5BpTXTXfLHJruOnAtklhaw5GhgPxaN3o6YL6L1n0C6EphCkLXvWHqUjuggnS3zK/b2tTUElw5ahGTmIj9USUOsA6sXT14v91HEn4/9GNKXGA6ZN3WEQqZZGMmKTGRZ7tVJxEIk0r6wCZqxXm25xT+D1ZL9TwKQKnDAAAAAElFTkSuQmCC"
  , fJ = ["onMousedown"]
  , pJ = vr({
  __name: "progress",
  props: {
    time: {},
    current: {}
  },
  emits: ["change"],
  setup(e, {emit: t}) {
    const n = e
      , r = Ft()
      , o = Ft()
      , a = Ft();
    let i;
    Lr((()=>{
        i = r.value.clientWidth - o.value.clientWidth - 2
      }
    ));
    const s = ()=>{
        document.onmousemove = function(e) {
          if (0 !== n.time) {
            let t = e.clientX - r.value.getBoundingClientRect().left - 6;
            t < 0 ? t = 0 : t >= i && (t = i),
              u(t)
          }
        }
          ,
          document.onmouseup = function() {
            document.onmousemove = null,
              document.onmouseup = null
          }
      }
      , l = e=>{
        if (0 !== n.time) {
          let t = e.clientX - r.value.getBoundingClientRect().left - 6;
          t < 0 ? t = 0 : t >= i && (t = i),
            u(t)
        }
      }
      , u = e=>{
        let r = Number((e / i).toFixed(2));
        t("change", r * n.time),
          o.value.style.left = e + "px",
          a.value.style.width = e + "px"
      }
    ;
    return Jn((()=>n.current), (e=>{
        e > n.time && (e = n.time);
        let t = Number((e / n.time).toFixed(2)) * i;
        o.value.style.left = t + "px",
          a.value.style.width = t + "px"
      }
    )),
      (e,t)=>(Ca(),
        _a("div", {
          ref_key: "pg",
          ref: r,
          class: "pg",
          onClick: l,
          onMousedown: t[0] || (t[0] = js((()=>{}
          ), ["prevent"]))
        }, [Ma("div", {
          ref_key: "cir",
          ref: o,
          class: "cir",
          onMousedown: js(s, ["prevent"])
        }, null, 40, fJ), Ma("div", {
          ref_key: "hov",
          ref: a,
          class: "hov"
        }, null, 512)], 544))
  }
})
  , hJ = AQ(pJ, [["__scopeId", "data-v-d4d70207"]])
  , vJ = {
  class: "vpersonlist"
}
  , gJ = {
  class: "search"
}
  , mJ = {
  class: "list"
}
  , yJ = ["onClick"]
  , bJ = {
  class: "person-card"
}
  , wJ = ["src"]
  , xJ = {
  class: "person-name text-center"
}
  , SJ = vr({
  __name: "vPersonList",
  props: ["currentTab"],
  emits: ["sendData"],
  setup(e, {emit: t}) {
    const n = e
      , r = yi((()=>n.currentTab))
      , o = Ft("")
      , a = Ft([])
      , i = ()=>{
        a.value = [],
          oY.video.digitalModelListed({
            type: r.value,
            name: o.value,
            model_code: ""
          }).then((e=>{
              a.value = (e.data || []).filter((e=>"SUCCESS" === e.status))
            }
          ))
      }
    ;
    Jn(r, i),
      Jn(o, i),
      i();
    const s = ()=>{
        window.open("#/home/custom", "_blank")
      }
    ;
    return (e,n)=>{
      const r = sS
        , i = yE;
      return Ca(),
        _a("div", vJ, [Ma("div", gJ, [ja(i, {
          modelValue: o.value,
          "onUpdate:modelValue": n[0] || (n[0] = e=>o.value = e),
          placeholder: "搜索数字人"
        }, {
          suffix: Fn((()=>[ja(r, null, {
            default: Fn((()=>[ja(Vt(qm))])),
            _: 1
          })])),
          _: 1
        }, 8, ["modelValue"]), Ma("div", {
          class: "text-center customer"
        }, [$a(" 没有合适的数字人？"), Ma("span", {
          class: "btn-font",
          onClick: s
        }, "去定制")])]), Ma("div", mJ, [Ma("ul", null, [(Ca(!0),
          _a(ba, null, Yr(a.value, (e=>(Ca(),
            _a("li", {
              class: "item",
              onClick: n=>(e=>{
                  t("sendData", {
                    name: "choosePerson",
                    value: e
                  })
                }
              )(e)
            }, [Ma("div", bJ, [Ma("img", {
              src: e.cover,
              alt: "",
              class: "person-img"
            }, null, 8, wJ)]), Ma("div", xJ, te(e.name), 1)], 8, yJ)))), 256))])])])
    }
  }
})
  , EJ = AQ(SJ, [["__scopeId", "data-v-77ac3399"]])
  , AJ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAAoCAYAAACiu5n/AAAAAXNSR0IArs4c6QAAA1tJREFUaEPtmUmMTFEUhr+j360usbAQhMQQwwK9lZCIRAwdNGLYYCXCTkwh0YaFmBKzWCGxQWIhZgkRVsJeDEFLRIyL3kjorvfK4b53q1930ZXSVa+7VdXbVeq++/7vnHPPPedeocoe6XVeVfvNwcA3RLK9/f0+AA7Oga4FXiJmUhUA+x+AkRGoV49Ipjeh+8DD/ldgqANOI9JeA07QAjUPJ2jcaGqt1JBWfy/QBOxAzN0OQxYCVr8ROAjcQsyeJIyfTEhr2wSoe+0Ev0DM5CKBnwNuq8pORNJvyg2dEHBmGshjJ/YrYoYXCfwFGOZifzqSelIDLtECNQ+XaEAXjZUa0treADIVzGVEvsfrtMzAYcORXQ7aipgHpTil5yGtOgyCt8Ag0EtIanVywJkNIKfc/LNLgS4e2FpZRDtl21mAs7a0IN6EBIEvgOQM2owYu1fHT762AiEQA6uOCseJvM+bbAxkH4LWw895SP0zVzHNBu5HY+Ut4o1PEPgSyEo3/y7E7I+/1T4FBtwD24TUzULkXZ7+lOMKu7IIWP25wB03sLFLyKi/83cft8/9dwIxm/sXsH8c2PR3Y4QF0Ivov+wUJP0qB3wMiEDgCGK2xRb0D4TlYWSms4i3vn8BB2dA1zm9BxHTHGsPFoHecNqXIt41BxycAt3whxcj7//PwEtArzngFYh3pVqB/aPAFufhw4jZXiEh3QR68y8h7c8Eci3cHMQ86gRs168Na/scQ8zW/rWGuzjLtqKHYu0/xoKXS1oNSLql87Y0xK5YRFo7XgjXsI6EwGbwgZBtQtJR26d+b25LF0FWOV07EZNzAGjbRKi7BfwAbwEiH/P010X5NjoSLr7w6DJLaIjRELTYo0fgNmJssx89Wu7S0t8N2AMFK3kZ4l3Nl1Ps754Dh2DBfNAZ4J1G5FNywJqGYFNYS2POdqn4iiV140oD7u5j5fbwP0IVGl4DLosxax6u+DMtezAw4KnLqnmdVIFzabVZX8dF7/1s6OjMyhJ2Tk0Z54qnCk8ofNvSLQTdiKTOxxm8EHBmDchJ0NtIKtcOllViMkmrkMSKvXnodsuq1KuWGnCu7Kw+D38G3NWLVxUX4teBxcAX8EaUUhf3JH33QZbWFGTGQeoDIt96IrqUd34B/dWJR6yIWn4AAAAASUVORK5CYII="
  , CJ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAASCAYAAACEnoQPAAAAAXNSR0IArs4c6QAAAShJREFUOE+d0rFLAmEYBvDnOaIhqKF/okKkJbw7+j/a2ioka3AwcLBBpHCspanNsanNraVCcKnBu7MGI4IGhxCEEO9747QDE7u7z2/+fs/H+7wf5SG1ClHL3HbeoHkojY0KRAoQnGPFOGOqNUiaQXlcq4I8GQM6ELVP27tPEjCFR0QAuQL8Iq3XXlTILBze/4DIIW3v9r+AKByaGxjGMTOtz+mQJDiY5AtiFGA512Qw1m9DfwuLrekO4AEt52VUryYOzDeAMky3Og8OAoZQKj0PboJqj2b7SQf3ITjFu3vBHfg6M9chyNJ2O5OVxr3cBSRPy6vN2kMEZg0Lfp5b7a7OD+uAyNJ063Fbn3zZh+ASS4slbj734+C4sMb6EYS7oMrR9JpJUHjnB08fgybFQXnGAAAAAElFTkSuQmCC"
  , kJ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAASCAYAAABSO15qAAAAAXNSR0IArs4c6QAAAHhJREFUOE9j/H9CcxsDw38lBnTwn8GD0fLGA5Dw/+MaCgyMDDsw1DAw3mP8f0LjBgMDgzqGJCODOqP5jVtgA05qqDH8Z7iJaQDDzVEDRsOAgWE0DIZNGBzTMmRg+MeJkdd//jjH6PjgB7g82K/AwcDOYYRZHjB9BwAjybJJUGUjGAAAAABJRU5ErkJggg=="
  , TJ = ml("audioPlay", (()=>{
    const e = Ft("")
      , t = Ft(0)
      , n = Ft(0)
      , r = Ft(!1)
      , o = Ft("");
    return {
      src: e,
      currentTime: t,
      duration: n,
      playState: r,
      audioSoucePage: o,
      setSrc: t=>{
        e.value = t
      }
      ,
      setCurrentTime: e=>{
        t.value = e
      }
      ,
      setDuration: e=>{
        n.value = e
      }
      ,
      setPlayState: e=>{
        r.value = e
      }
      ,
      setAudioSoucePage: e=>{
        o.value = e
      }
    }
  }
))
  , DJ = ["onClick"]
  , OJ = ["color"]
  , _J = {
  class: "content"
}
  , RJ = ["width", "src"]
  , LJ = AQ(vr({
  __name: "AudioPlayButton",
  props: {
    bindMediaSrc: {
      type: String,
      default: ""
    },
    circleRadius: {
      type: Number,
      default: 9
    },
    lineWidth: {
      type: Number,
      default: 2
    },
    circleColor: {
      type: String,
      default: "rgba(255,255,255,0.5)"
    },
    percentColor: {
      type: String,
      default: "#FFC828"
    }
  },
  emits: ["togglePlayState"],
  setup(e, {emit: t}) {
    const n = e
      , r = TJ()
      , o = yi((()=>({
        width: n.circleRadius + "px",
        height: 2 * n.circleRadius + "px"
      })))
      , a = yi((()=>({
        width: 2 * n.circleRadius + "px",
        height: 2 * n.circleRadius + "px",
        border: `${n.lineWidth}px solid ${n.circleColor}`
      })))
      , i = yi((()=>encodeURI(n.bindMediaSrc) === r.src))
      , s = yi((()=>{
          let e = 0;
          return i.value && !isNaN(r.duration) && r.duration && (e = Math.floor(100 * r.currentTime / r.duration)),
            e
        }
      ))
      , l = yi((()=>{
          let e = 225
            , t = e;
          return s.value > 50 && (t = e + 3.6 * (s.value - 50)),
            t = Math.max(t, e),
            {
              transform: `rotate(${t}deg)`,
              borderBottom: `${n.lineWidth}px solid ${n.percentColor}`,
              borderLeft: `${n.lineWidth}px solid ${n.percentColor}`
            }
        }
      ))
      , u = yi((()=>{
          let e = 405;
          return s.value <= 50 && (e = 225 + 3.6 * s.value),
            e = Math.min(e, 405),
            {
              transform: `rotate(${e}deg)`,
              borderTop: `${n.lineWidth}px solid ${n.percentColor}`,
              borderRight: `${n.lineWidth}px solid ${n.percentColor}`
            }
        }
      ))
      , c = ()=>{
        t("togglePlayState")
      }
    ;
    return (e,t)=>(Ca(),
      _a("div", {
        class: "circle-progress",
        onClick: js(c, ["stop"])
      }, [Ma("div", {
        class: "leftbox",
        style: z(o.value)
      }, [Ma("div", {
        class: "leftcircle",
        style: z([a.value, l.value]),
        color: n.circleColor
      }, null, 12, OJ)], 4), Ma("div", {
        class: "rightbox",
        style: z(o.value)
      }, [Ma("div", {
        class: "rightcircle",
        style: z([a.value, u.value])
      }, null, 4)], 4), Ma("div", _J, [Ma("img", {
        width: Math.ceil(n.circleRadius / 2),
        src: i.value && Vt(r).playState ? Vt(kJ) : Vt(CJ),
        alt: ""
      }, null, 8, RJ)])], 8, DJ))
  }
}), [["__scopeId", "data-v-9844e024"]])
  , IJ = ()=>{
  const e = TJ()
    , t = Ft()
    , n = n=>{
      e.setCurrentTime(t.value.currentTime),
        e.setDuration(t.value.duration)
    }
    , r = t=>{
      e.setCurrentTime(0),
        e.setPlayState(!1)
    }
    , o = t=>{
      e.setCurrentTime(0),
        e.setPlayState(!1)
    }
  ;
  return Lr((()=>{
      (()=>{
          let e = document.getElementById("ybAudioPlayer");
          t.value = e,
          e && (e.addEventListener("timeupdate", n),
            e.addEventListener("ended", r),
            e.addEventListener("error", o))
        }
      )()
    }
  )),
    Fr((()=>{
        (()=>{
            let e = t.value;
            e && (e.pause(),
              e.removeEventListener("timeupdate", n),
              e.removeEventListener("ended", r),
              e.removeEventListener("error", o))
          }
        )()
      }
    )),
    {
      togglePlayState: (n,r)=>{
        e.setAudioSoucePage(r);
        let o = t.value.src === encodeURI(n);
        e.playState ? o ? (t.value.pause(),
          e.setPlayState(!1)) : (t.value.currentTime = 0,
          t.value.src = n,
          t.value.play(),
          e.setPlayState(!0),
          setTimeout((()=>{
              e.setSrc(t.value.src)
            }
          ), 0)) : (o || (t.value.currentTime = 0,
          t.value.src = n,
          setTimeout((()=>{
              e.setSrc(t.value.src)
            }
          ), 0)),
          t.value.play(),
          e.setPlayState(!0))
      }
      ,
      stopPlay: n=>{
        n !== e.audioSoucePage && !0 !== n || (t.value.pause(),
          e.setPlayState(!1))
      }
    }
}
  , PJ = e=>(Ln("data-v-1220b6e3"),
  e = e(),
  In(),
  e)
  , FJ = {
  class: "music"
}
  , BJ = {
  class: "h-100 flex-column"
}
  , NJ = {
  class: "flex-hidden flex-column"
}
  , MJ = {
  class: "search"
}
  , jJ = {
  class: "flex-column flex-hidden content-box"
}
  , VJ = PJ((()=>Ma("div", {
  class: "up"
}, "推荐", -1)))
  , UJ = {
  class: "voice-list"
}
  , $J = ["src"]
  , HJ = PJ((()=>Ma("span", {
  class: "icon-play"
}, null, -1)))
  , zJ = ["title"]
  , KJ = ["onClick"]
  , WJ = {
  class: "flex-column flex-hidden content-box"
}
  , GJ = PJ((()=>Ma("span", {
  style: {
    "margin-right": "5px"
  }
}, "上传录音", -1)))
  , qJ = {
  class: "voice-list"
}
  , YJ = {
  class: "head-img"
}
  , XJ = ["src"]
  , QJ = {
  class: "icon-play"
}
  , JJ = {
  class: "name text-ellipsis"
}
  , ZJ = ["onClick"]
  , eZ = AQ(vr({
  __name: "music",
  props: {
    currentTab: {
      type: String,
      default: ""
    },
    chooseParams: {
      type: Object,
      default: ()=>({})
    }
  },
  emits: ["sendData"],
  setup(e, {emit: t}) {
    const n = e
      , r = TJ()
      , {togglePlayState: o, stopPlay: a} = IJ();
    Fr((()=>{
        a("videoMusic")
      }
    ));
    const i = Ft("audio")
      , s = Ft("")
      , l = Ft([])
      , u = Ft([])
      , c = Ft([])
      , d = yi((()=>n.chooseParams.voice))
      , f = yi((()=>n.currentTab))
      , p = ()=>{
        oY.video.digitalAudioListed({
          name: s.value,
          type: ""
        }).then((e=>{
            var t;
            u.value = null == (t = e.data) ? void 0 : t.reverse()
          }
        )).catch((e=>{}
        ))
      }
    ;
    xe((()=>{
        "ai" === i.value ? oY.worker.getAudioList({
          name: s.value
        }).then((e=>{
            l.value = e.data || []
          }
        )) : p()
      }
    ));
    const h = (e,n)=>{
        t("sendData", {
          name: "chooseVoice",
          value: {
            item: e,
            type: n,
            subtitle: []
          }
        })
      }
      , v = e=>{
        let t = (e.name.split(".").pop() || "").toLowerCase()
          , n = ["mp3", "wav", "m4a", "flac"]
          , r = -1 !== n.indexOf(t);
        if (!r) {
          let e = "只能上传" + n.join("、") + "格式的音频文件";
          MW(e)
        }
        return r
      }
      , g = ()=>{
        let e = new FormData;
        e.append("audio_file", c.value[0].raw),
          oY.video.audioUpload(e).then((e=>{
              e.data,
                p()
            }
          )).catch((e=>{}
          ))
      }
    ;
    return (e,t)=>{
      const n = sS
        , a = yE
        , p = WC
        , m = mK;
      return Ca(),
        _a("div", FJ, [rr(Ma("div", BJ, [Ma("div", NJ, [Ma("div", MJ, [ja(a, {
          modelValue: s.value,
          "onUpdate:modelValue": t[0] || (t[0] = e=>s.value = e),
          placeholder: "模糊搜索声音名"
        }, {
          suffix: Fn((()=>[ja(n, null, {
            default: Fn((()=>[ja(Vt(qm))])),
            _: 1
          })])),
          _: 1
        }, 8, ["modelValue"])]), rr(Ma("div", jJ, [VJ, Ma("ul", UJ, [(Ca(!0),
          _a(ba, null, Yr(l.value, (e=>(Ca(),
            _a("li", {
              class: Y(["item", {
                active: "tts" === d.value.type && d.value.data.model_audio_code === e.model_audio_code
              }])
            }, [Ma("img", {
              src: e.cover,
              alt: "",
              class: "head-img"
            }, null, 8, $J), HJ, Ma("span", {
              class: "name text-ellipsis",
              title: e.name
            }, te(e.name), 9, zJ), Ma("span", {
              class: Y(["btn-ok", {
                active: "tts" === d.value.type && d.value.data.model_audio_code === e.model_audio_code
              }]),
              onClick: t=>h(e, "tts")
            }, te("tts" === d.value.type && d.value.data.model_audio_code === e.model_audio_code ? "应用中" : "选择"), 11, KJ)], 2)))), 256))])], 512), [[$s, "ai" === i.value]]), rr(Ma("div", WJ, [ja(m, {
          "file-list": c.value,
          "onUpdate:fileList": t[1] || (t[1] = e=>c.value = e),
          class: "upload-demo",
          "before-upload": v,
          "http-request": g,
          "show-file-list": !1
        }, {
          default: Fn((()=>[ja(p, {
            class: "btn-upload"
          }, {
            default: Fn((()=>[GJ, ja(n, {
              size: "16"
            }, {
              default: Fn((()=>[ja(Vt(ey))])),
              _: 1
            })])),
            _: 1
          })])),
          _: 1
        }, 8, ["file-list"]), Ma("ul", qJ, [(Ca(!0),
          _a(ba, null, Yr(u.value, (e=>(Ca(),
            _a("li", {
              class: Y(["item", {
                active: "tts" !== d.value.type && d.value.data.audio_code === e.audio_code || Vt(r).src === encodeURI(e.assets_url)
              }])
            }, [Ma("span", YJ, [Ma("img", {
              src: e.cover || Vt(AJ)
            }, null, 8, XJ)]), Ma("span", QJ, [ja(LJ, {
              bindMediaSrc: e.assets_url,
              circleRadius: 11,
              onTogglePlayState: t=>{
                return n = e.assets_url,
                  void o(n, "videoMusic");
                var n
              }
            }, null, 8, ["bindMediaSrc", "onTogglePlayState"])]), Ma("span", JJ, te(e.name), 1), Ma("span", {
              class: Y(["btn-ok", {
                active: "tts" !== d.value.type && d.value.data.audio_code === e.audio_code
              }]),
              onClick: t=>h(e, "audio")
            }, te("tts" !== d.value.type && d.value.data.audio_code === e.audio_code ? "应用中" : "选择"), 11, ZJ)], 2)))), 256))])], 512), [[$s, "audio" === i.value]])])], 512), [[$s, "music1" === f.value]]), rr(Ma("div", null, null, 512), [[$s, "music2" === f.value]])])
    }
  }
}), [["__scopeId", "data-v-1220b6e3"]])
  , tZ = e=>(Ln("data-v-c27a7872"),
  e = e(),
  In(),
  e)
  , nZ = {
  class: "backpage"
}
  , rZ = {
  style: {
    padding: "0 15px"
  }
}
  , oZ = {
  class: "btn-group"
}
  , aZ = {
  class: "search"
}
  , iZ = {
  class: "btn-align"
}
  , sZ = {
  class: "content"
}
  , lZ = {
  class: "back"
}
  , uZ = {
  class: "back-head"
}
  , cZ = ["onClick"]
  , dZ = {
  class: "arrow"
}
  , fZ = {
  class: "back-content"
}
  , pZ = {
  class: "img-list"
}
  , hZ = ["onClick", "src"]
  , vZ = {
  class: "area right-content",
  style: {
    "padding-left": "15px",
    "padding-top": "10px"
  }
}
  , gZ = {
  class: "arrow"
}
  , mZ = {
  class: "img-list"
}
  , yZ = ["onClick", "src"]
  , bZ = {
  class: "content"
}
  , wZ = {
  class: "area",
  style: {
    "padding-left": "15px",
    "padding-top": "10px"
  }
}
  , xZ = tZ((()=>Ma("span", {
  style: {
    "margin-right": "5px"
  }
}, "上传背景", -1)))
  , SZ = {
  class: "img-list",
  style: {
    "margin-top": "15px"
  }
}
  , EZ = ["onClick", "src"]
  , AZ = vr({
  __name: "background",
  emits: ["sendData"],
  setup(e, {emit: t}) {
    const n = Ft("")
      , r = Ft([{
        name: "静态",
        value: "static",
        isQuery: !0
      }, {
        name: "上传",
        value: "upload",
        isQuery: !0
      }])
      , o = Ft("static")
      , a = Ft("VERTICAL")
      , i = Ft([])
      , s = e=>{
        a.value = e,
          d.value = "left-area",
          c()
      }
      , l = Ft([])
      , u = Ft([])
      , c = ()=>{
        let e;
        "static" === o.value ? e = l : "upload" === o.value && (e = u),
          oY.video.backgroundListed({
            type: o.value,
            align: a.value,
            name: n.value
          }).then((t=>{
              e.value = t.data || []
            }
          ))
      }
    ;
    c(),
      Jn(n, c);
    const d = Ft("left-area")
      , f = Ft({})
      , p = (e,n,r)=>{
        t("sendData", {
          name: "chooseBackground",
          value: {
            itemObj: e,
            imgObj: n,
            type: r,
            align: a.value
          }
        })
      }
      , h = e=>{
        let t = (e.name.split(".").pop() || "").toLowerCase()
          , n = ["jpg", "png"]
          , r = -1 !== n.indexOf(t);
        if (!r) {
          let e = "只能上传" + n.join("、") + "格式的图片文件";
          MW(e)
        }
        return r
      }
      , v = ()=>{
        let e = new FormData;
        e.append("background_file", i.value[i.value.length - 1].raw),
          oY.video.backgroundUpload(e).then((e=>{
              c()
            }
          )).catch((e=>{}
          ))
      }
    ;
    return (e,t)=>{
      var g;
      const m = WC
        , y = sS
        , b = yE
        , w = mK;
      return Ca(),
        _a("div", nZ, [Ma("div", rZ, [Ma("div", oZ, [(Ca(!0),
          _a(ba, null, Yr(r.value, (e=>(Ca(),
            Ra(m, {
              class: Y(["btn", {
                active: e.value === o.value
              }]),
              type: e.value === o.value ? "primary" : "default",
              onClick: t=>(e=>{
                  o.value = e.value,
                  e.isQuery && c()
                }
              )(e)
            }, {
              default: Fn((()=>[$a(te(e.name), 1)])),
              _: 2
            }, 1032, ["type", "class", "onClick"])))), 256))]), Ma("div", aZ, [ja(b, {
          modelValue: n.value,
          "onUpdate:modelValue": t[0] || (t[0] = e=>n.value = e),
          placeholder: "搜索背景"
        }, {
          suffix: Fn((()=>[ja(y, null, {
            default: Fn((()=>[ja(Vt(qm))])),
            _: 1
          })])),
          _: 1
        }, 8, ["modelValue"])]), rr(Ma("div", iZ, [Ma("span", {
          class: Y(["align-type", {
            active: "VERTICAL" === a.value
          }]),
          onClick: t[1] || (t[1] = e=>s("VERTICAL"))
        }, "竖版", 2), Ma("span", {
          class: Y(["align-type", {
            active: "HORIZONTAL" === a.value
          }]),
          onClick: t[2] || (t[2] = e=>s("HORIZONTAL"))
        }, "横版", 2)], 512), [[$s, "static" === o.value]])]), rr(Ma("div", sZ, [Ma("div", {
          class: Y(["area left-content", {
            showLeftArea: "left-area" === d.value
          }]),
          style: {
            "padding-left": "15px",
            "padding-top": "10px"
          }
        }, [Ma("ul", null, [(Ca(!0),
          _a(ba, null, Yr(l.value, (e=>(Ca(),
            _a("li", lZ, [Ma("div", uZ, [Ma("span", null, te(e.category_name), 1), Ma("span", {
              class: "cursor-pointer",
              style: {
                display: "flex"
              },
              onClick: t=>(e=>{
                  d.value = "left-area" === d.value ? "right-area" : "left-area",
                    f.value = e
                }
              )(e)
            }, [$a(" 查看全部  "), Ma("span", dZ, [ja(y, null, {
              default: Fn((()=>[ja(Vt(gm))])),
              _: 1
            })])], 8, cZ)]), Ma("div", fZ, [Ma("div", pZ, [(Ca(!0),
              _a(ba, null, Yr(e.list, (t=>(Ca(),
                _a("img", {
                  class: "img-item",
                  onClick: n=>p(e, t, "static"),
                  src: t.assets_url,
                  alt: ""
                }, null, 8, hZ)))), 256))])])])))), 256))])], 2), Ma("div", vZ, [Ma("div", {
          class: "area-right-header cursor-pointer",
          onClick: t[3] || (t[3] = e=>d.value = "left-area")
        }, [Ma("span", gZ, [ja(y, null, {
          default: Fn((()=>[ja(Vt(vm))])),
          _: 1
        })]), $a(" " + te(f.value.category_name), 1)]), Ma("div", mZ, [(Ca(!0),
          _a(ba, null, Yr(f.value.list, (e=>(Ca(),
            _a("img", {
              class: "img-item",
              onClick: t=>p(f.value, e, "static"),
              src: e.assets_url,
              alt: ""
            }, null, 8, yZ)))), 256))])])], 512), [[$s, "static" === o.value]]), rr(Ma("div", bZ, [Ma("div", wZ, [ja(w, {
          "file-list": i.value,
          "onUpdate:fileList": t[4] || (t[4] = e=>i.value = e),
          class: "upload-demo",
          "before-upload": h,
          "http-request": v,
          "show-file-list": !1
        }, {
          default: Fn((()=>[ja(m, {
            class: "btn-primary",
            style: {
              width: "100%"
            }
          }, {
            default: Fn((()=>[xZ, ja(y, {
              size: "16"
            }, {
              default: Fn((()=>[ja(Vt(ey))])),
              _: 1
            })])),
            _: 1
          })])),
          _: 1
        }, 8, ["file-list"]), Ma("div", SZ, [(Ca(!0),
          _a(ba, null, Yr(null == (g = u.value[0]) ? void 0 : g.list, (e=>(Ca(),
            _a("img", {
              class: "img-item",
              onClick: t=>p(e, e, "upload"),
              src: e.assets_url,
              alt: ""
            }, null, 8, EZ)))), 256))])])], 512), [[$s, "upload" === o.value]])])
    }
  }
})
  , CZ = AQ(AZ, [["__scopeId", "data-v-c27a7872"]])
  , kZ = e=>(Ln("data-v-85a9c012"),
  e = e(),
  In(),
  e)
  , TZ = {
  class: "fontpage"
}
  , DZ = kZ((()=>Ma("div", {
  class: "title page-padding"
}, "通用", -1)))
  , OZ = {
  class: "page-padding"
}
  , _Z = {
  class: "list"
}
  , RZ = ["onClick"]
  , LZ = AQ(vr({
  __name: "font",
  props: ["currentTab", "chooseParams"],
  emits: ["sendData"],
  setup(e, {emit: t}) {
    const n = e
      , r = yi((()=>n.chooseParams.font))
      , o = Ft([{
      bgColor: "transparent"
    }, {
      bgColor: "#000"
    }, {
      bgColor: "rgba(0, 0, 0, 0.298)"
    }]);
    return (e,n)=>(Ca(),
      _a("div", TZ, [DZ, Ma("div", OZ, [Ma("ul", _Z, [(Ca(!0),
        _a(ba, null, Yr(o.value, (e=>(Ca(),
          _a("li", {
            class: Y(["item", {
              active: r.value.bgColor === e.bgColor
            }]),
            onClick: n=>(e=>{
                t("sendData", {
                  name: "chooseFont",
                  value: e
                })
              }
            )(e)
          }, [Ma("div", {
            style: z({
              background: e.bgColor
            }),
            class: "bgbox"
          }, "字幕样式", 4)], 10, RZ)))), 256))])])]))
  }
}), [["__scopeId", "data-v-85a9c012"]])
  , IZ = {
  class: "drawer _drawer"
}
  , PZ = {
  class: "drawerBody"
}
  , FZ = {
  class: "title"
}
  , BZ = vr({
  __name: "rightTabComponent",
  props: {
    tab: {
      type: Object,
      default: ()=>({
        name: "",
        value: "",
        children: []
      })
    },
    chooseParams: {
      type: Object,
      default: ()=>({})
    }
  },
  emits: ["close", "sendData"],
  setup(e, {emit: t}) {
    const n = e
      , r = Ot({
      vPersonList: EJ,
      music: eZ,
      background: CZ,
      font: LZ
    })
      , o = Ft("")
      , a = yi((()=>n.tab.children && n.tab.children.length > 0 ? n.tab.children : [n.tab]))
      , i = yi({
      get: ()=>"" !== n.tab.name,
      set(e) {
        e || s()
      }
    });
    Jn((()=>n.tab), (()=>{
        i.value && n.tab.children && n.tab.children.length > 0 ? o.value = n.tab.children[0].value : o.value = n.tab.value
      }
    ));
    const s = ()=>{
        t("close", {
          name: "",
          value: ""
        })
      }
      , l = e=>{
        t("sendData", e)
      }
      , u = e=>{
        if (e.target) {
          let t = !(!e.target.closest("._drawer") && !e.target.closest(".rightbar>.tab"));
          i.value = t
        }
      }
    ;
    return Lr((()=>{
        document.body.addEventListener("click", u)
      }
    )),
      Fr((()=>{
          document.body.removeEventListener("click", u)
        }
      )),
      (e,t)=>{
        const s = C$
          , u = A$;
        return Ca(),
          Ra(es, {
            name: "translate"
          }, {
            default: Fn((()=>[rr(Ma("div", IZ, [Ma("div", PZ, [Ma("div", FZ, [ja(u, {
              modelValue: o.value,
              "onUpdate:modelValue": t[0] || (t[0] = e=>o.value = e),
              class: "demo-tabs"
            }, {
              default: Fn((()=>[(Ca(!0),
                _a(ba, null, Yr(a.value, (e=>(Ca(),
                  Ra(s, {
                    label: e.name,
                    name: e.value
                  }, null, 8, ["label", "name"])))), 256))])),
              _: 1
            }, 8, ["modelValue"])]), (Ca(),
              Ra(Kr(Vt(r)[n.tab.value]), {
                class: "body-content",
                chooseParams: n.chooseParams,
                onSendData: l,
                currentTab: o.value
              }, null, 40, ["chooseParams", "currentTab"]))])], 512), [[$s, i.value]])])),
            _: 1
          })
      }
  }
})
  , NZ = AQ(BZ, [["__scopeId", "data-v-e7ae9ba0"]]);
var MZ = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function jZ(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports),
    t.exports
}
var VZ, UZ, $Z = function(e) {
  return e && e.Math == Math && e
}, HZ = $Z("object" == typeof globalThis && globalThis) || $Z("object" == typeof window && window) || $Z("object" == typeof self && self) || $Z("object" == typeof MZ && MZ) || function() {
  return this
}() || Function("return this")(), zZ = Function.prototype, KZ = zZ.apply, WZ = zZ.bind, GZ = zZ.call, qZ = "object" == typeof Reflect && Reflect.apply || (WZ ? GZ.bind(KZ) : function() {
    return GZ.apply(KZ, arguments)
  }
), YZ = Function.prototype, XZ = YZ.bind, QZ = YZ.call, JZ = XZ && XZ.bind(QZ), ZZ = XZ ? function(e) {
    return e && JZ(QZ, e)
  }
  : function(e) {
    return e && function() {
      return QZ.apply(e, arguments)
    }
  }
  , e0 = function(e) {
  return "function" == typeof e
}, t0 = function(e) {
  try {
    return !!e()
  } catch (t) {
    return !0
  }
}, n0 = !t0((function() {
    return 7 != Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1]
  }
)), r0 = Function.prototype.call, o0 = r0.bind ? r0.bind(r0) : function() {
  return r0.apply(r0, arguments)
}
  , a0 = {}.propertyIsEnumerable, i0 = Object.getOwnPropertyDescriptor, s0 = i0 && !a0.call({
  1: 2
}, 1) ? function(e) {
    var t = i0(this, e);
    return !!t && t.enumerable
  }
  : a0, l0 = {
  f: s0
}, u0 = function(e, t) {
  return {
    enumerable: !(1 & e),
    configurable: !(2 & e),
    writable: !(4 & e),
    value: t
  }
}, c0 = ZZ({}.toString), d0 = ZZ("".slice), f0 = function(e) {
  return d0(c0(e), 8, -1)
}, p0 = HZ.Object, h0 = ZZ("".split), v0 = t0((function() {
    return !p0("z").propertyIsEnumerable(0)
  }
)) ? function(e) {
    return "String" == f0(e) ? h0(e, "") : p0(e)
  }
  : p0, g0 = HZ.TypeError, m0 = function(e) {
  if (null == e)
    throw g0("Can't call method on " + e);
  return e
}, y0 = function(e) {
  return v0(m0(e))
}, b0 = function(e) {
  return "object" == typeof e ? null !== e : e0(e)
}, w0 = {}, x0 = function(e) {
  return e0(e) ? e : void 0
}, S0 = function(e, t) {
  return arguments.length < 2 ? x0(w0[e]) || x0(HZ[e]) : w0[e] && w0[e][t] || HZ[e] && HZ[e][t]
}, E0 = ZZ({}.isPrototypeOf), A0 = S0("navigator", "userAgent") || "", C0 = HZ.process, k0 = HZ.Deno, T0 = C0 && C0.versions || k0 && k0.version, D0 = T0 && T0.v8;
D0 && (UZ = (VZ = D0.split("."))[0] > 0 && VZ[0] < 4 ? 1 : +(VZ[0] + VZ[1])),
!UZ && A0 && (!(VZ = A0.match(/Edge\/(\d+)/)) || VZ[1] >= 74) && (VZ = A0.match(/Chrome\/(\d+)/)) && (UZ = +VZ[1]);
var O0, _0 = UZ, R0 = !!Object.getOwnPropertySymbols && !t0((function() {
    var e = Symbol();
    return !String(e) || !(Object(e)instanceof Symbol) || !Symbol.sham && _0 && _0 < 41
  }
)), L0 = R0 && !Symbol.sham && "symbol" == typeof Symbol.iterator, I0 = HZ.Object, P0 = L0 ? function(e) {
    return "symbol" == typeof e
  }
  : function(e) {
    var t = S0("Symbol");
    return e0(t) && E0(t.prototype, I0(e))
  }
  , F0 = HZ.String, B0 = function(e) {
  try {
    return F0(e)
  } catch (t) {
    return "Object"
  }
}, N0 = HZ.TypeError, M0 = function(e) {
  if (e0(e))
    return e;
  throw N0(B0(e) + " is not a function")
}, j0 = function(e, t) {
  var n = e[t];
  return null == n ? void 0 : M0(n)
}, V0 = HZ.TypeError, U0 = Object.defineProperty, $0 = HZ["__core-js_shared__"] || function(e, t) {
  try {
    U0(HZ, e, {
      value: t,
      configurable: !0,
      writable: !0
    })
  } catch (AEe) {
    HZ[e] = t
  }
  return t
}("__core-js_shared__", {}), H0 = jZ((function(e) {
    (e.exports = function(e, t) {
        return $0[e] || ($0[e] = void 0 !== t ? t : {})
      }
    )("versions", []).push({
      version: "3.19.3",
      mode: "pure",
      copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
    })
  }
)), z0 = HZ.Object, K0 = function(e) {
  return z0(m0(e))
}, W0 = ZZ({}.hasOwnProperty), G0 = Object.hasOwn || function(e, t) {
  return W0(K0(e), t)
}
  , q0 = 0, Y0 = Math.random(), X0 = ZZ(1..toString), Q0 = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + X0(++q0 + Y0, 36)
}, J0 = H0("wks"), Z0 = HZ.Symbol, e1 = Z0 && Z0.for, t1 = L0 ? Z0 : Z0 && Z0.withoutSetter || Q0, n1 = function(e) {
  if (!G0(J0, e) || !R0 && "string" != typeof J0[e]) {
    var t = "Symbol." + e;
    R0 && G0(Z0, e) ? J0[e] = Z0[e] : J0[e] = L0 && e1 ? e1(t) : t1(t)
  }
  return J0[e]
}, r1 = HZ.TypeError, o1 = n1("toPrimitive"), a1 = function(e) {
  var t = function(e, t) {
    if (!b0(e) || P0(e))
      return e;
    var n, r = j0(e, o1);
    if (r) {
      if (void 0 === t && (t = "default"),
        n = o0(r, e, t),
      !b0(n) || P0(n))
        return n;
      throw r1("Can't convert object to primitive value")
    }
    return void 0 === t && (t = "number"),
      function(e, t) {
        var n, r;
        if ("string" === t && e0(n = e.toString) && !b0(r = o0(n, e)))
          return r;
        if (e0(n = e.valueOf) && !b0(r = o0(n, e)))
          return r;
        if ("string" !== t && e0(n = e.toString) && !b0(r = o0(n, e)))
          return r;
        throw V0("Can't convert object to primitive value")
      }(e, t)
  }(e, "string");
  return P0(t) ? t : t + ""
}, i1 = HZ.document, s1 = b0(i1) && b0(i1.createElement), l1 = function(e) {
  return s1 ? i1.createElement(e) : {}
}, u1 = !n0 && !t0((function() {
    return 7 != Object.defineProperty(l1("div"), "a", {
      get: function() {
        return 7
      }
    }).a
  }
)), c1 = Object.getOwnPropertyDescriptor, d1 = n0 ? c1 : function(e, t) {
  if (e = y0(e),
    t = a1(t),
    u1)
    try {
      return c1(e, t)
    } catch (n) {}
  if (G0(e, t))
    return u0(!o0(l0.f, e, t), e[t])
}
  , f1 = {
  f: d1
}, p1 = /#|\.prototype\./, h1 = function(e, t) {
  var n = g1[v1(e)];
  return n == y1 || n != m1 && (e0(t) ? t0(t) : !!t)
}, v1 = h1.normalize = function(e) {
  return String(e).replace(p1, ".").toLowerCase()
}
  , g1 = h1.data = {}, m1 = h1.NATIVE = "N", y1 = h1.POLYFILL = "P", b1 = h1, w1 = ZZ(ZZ.bind), x1 = function(e, t) {
  return M0(e),
    void 0 === t ? e : w1 ? w1(e, t) : function() {
      return e.apply(t, arguments)
    }
}, S1 = HZ.String, E1 = HZ.TypeError, A1 = function(e) {
  if (b0(e))
    return e;
  throw E1(S1(e) + " is not an object")
}, C1 = HZ.TypeError, k1 = Object.defineProperty, T1 = n0 ? k1 : function(e, t, n) {
  if (A1(e),
    t = a1(t),
    A1(n),
    u1)
    try {
      return k1(e, t, n)
    } catch (r) {}
  if ("get"in n || "set"in n)
    throw C1("Accessors not supported");
  return "value"in n && (e[t] = n.value),
    e
}
  , D1 = {
  f: T1
}, O1 = n0 ? function(e, t, n) {
    return D1.f(e, t, u0(1, n))
  }
  : function(e, t, n) {
    return e[t] = n,
      e
  }
  , _1 = f1.f, R1 = function(e) {
  var t = function(n, r, o) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new e;
        case 1:
          return new e(n);
        case 2:
          return new e(n,r)
      }
      return new e(n,r,o)
    }
    return qZ(e, this, arguments)
  };
  return t.prototype = e.prototype,
    t
}, L1 = function(e, t) {
  var n, r, o, a, i, s, l, u, c = e.target, d = e.global, f = e.stat, p = e.proto, h = d ? HZ : f ? HZ[c] : (HZ[c] || {}).prototype, v = d ? w0 : w0[c] || O1(w0, c, {})[c], g = v.prototype;
  for (o in t)
    n = !b1(d ? o : c + (f ? "." : "#") + o, e.forced) && h && G0(h, o),
      i = v[o],
    n && (s = e.noTargetGet ? (u = _1(h, o)) && u.value : h[o]),
      a = n && s ? s : t[o],
    n && typeof i == typeof a || (l = e.bind && n ? x1(a, HZ) : e.wrap && n ? R1(a) : p && e0(a) ? ZZ(a) : a,
    (e.sham || a && a.sham || i && i.sham) && O1(l, "sham", !0),
      O1(v, o, l),
    p && (G0(w0, r = c + "Prototype") || O1(w0, r, {}),
      O1(w0[r], o, a),
    e.real && g && !g[o] && O1(g, o, a)))
}, I1 = H0("keys"), P1 = function(e) {
  return I1[e] || (I1[e] = Q0(e))
}, F1 = !t0((function() {
    function e() {}
    return e.prototype.constructor = null,
    Object.getPrototypeOf(new e) !== e.prototype
  }
)), B1 = P1("IE_PROTO"), N1 = HZ.Object, M1 = N1.prototype, j1 = F1 ? N1.getPrototypeOf : function(e) {
  var t = K0(e);
  if (G0(t, B1))
    return t[B1];
  var n = t.constructor;
  return e0(n) && t instanceof n ? n.prototype : t instanceof N1 ? M1 : null
}
  , V1 = HZ.String, U1 = HZ.TypeError, $1 = Object.setPrototypeOf || ("__proto__"in {} ? function() {
  var e, t = !1, n = {};
  try {
    (e = ZZ(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n, []),
      t = n instanceof Array
  } catch (r) {}
  return function(n, r) {
    return A1(n),
      function(e) {
        if ("object" == typeof e || e0(e))
          return e;
        throw U1("Can't set " + V1(e) + " as a prototype")
      }(r),
      t ? e(n, r) : n.__proto__ = r,
      n
  }
}() : void 0), H1 = Math.ceil, z1 = Math.floor, K1 = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : (t > 0 ? z1 : H1)(t)
}, W1 = Math.max, G1 = Math.min, q1 = function(e, t) {
  var n = K1(e);
  return n < 0 ? W1(n + t, 0) : G1(n, t)
}, Y1 = Math.min, X1 = function(e) {
  return (t = e.length) > 0 ? Y1(K1(t), 9007199254740991) : 0;
  var t
}, Q1 = function(e) {
  return function(t, n, r) {
    var o, a = y0(t), i = X1(a), s = q1(r, i);
    if (e && n != n) {
      for (; i > s; )
        if ((o = a[s++]) != o)
          return !0
    } else
      for (; i > s; s++)
        if ((e || s in a) && a[s] === n)
          return e || s || 0;
    return !e && -1
  }
}, J1 = {
  includes: Q1(!0),
  indexOf: Q1(!1)
}, Z1 = {}, e2 = J1.indexOf, t2 = ZZ([].push), n2 = function(e, t) {
  var n, r = y0(e), o = 0, a = [];
  for (n in r)
    !G0(Z1, n) && G0(r, n) && t2(a, n);
  for (; t.length > o; )
    G0(r, n = t[o++]) && (~e2(a, n) || t2(a, n));
  return a
}, r2 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], o2 = r2.concat("length", "prototype"), a2 = Object.getOwnPropertyNames || function(e) {
  return n2(e, o2)
}
  , i2 = {
  f: a2
}, s2 = {
  f: Object.getOwnPropertySymbols
}, l2 = ZZ([].concat), u2 = S0("Reflect", "ownKeys") || function(e) {
  var t = i2.f(A1(e))
    , n = s2.f;
  return n ? l2(t, n(e)) : t
}
  , c2 = Object.keys || function(e) {
  return n2(e, r2)
}
  , d2 = n0 ? Object.defineProperties : function(e, t) {
  A1(e);
  for (var n, r = y0(t), o = c2(t), a = o.length, i = 0; a > i; )
    D1.f(e, n = o[i++], r[n]);
  return e
}
  , f2 = S0("document", "documentElement"), p2 = P1("IE_PROTO"), h2 = function() {}, v2 = function(e) {
  return "<script>" + e + "<\/script>"
}, g2 = function(e) {
  e.write(v2("")),
    e.close();
  var t = e.parentWindow.Object;
  return e = null,
    t
}, m2 = function() {
  try {
    O0 = new ActiveXObject("htmlfile")
  } catch (r) {}
  var e, t;
  m2 = "undefined" != typeof document ? document.domain && O0 ? g2(O0) : ((t = l1("iframe")).style.display = "none",
    f2.appendChild(t),
    t.src = String("javascript:"),
    (e = t.contentWindow.document).open(),
    e.write(v2("document.F=Object")),
    e.close(),
    e.F) : g2(O0);
  for (var n = r2.length; n--; )
    delete m2.prototype[r2[n]];
  return m2()
};
Z1[p2] = !0;
var y2 = Object.create || function(e, t) {
  var n;
  return null !== e ? (h2.prototype = A1(e),
    n = new h2,
    h2.prototype = null,
    n[p2] = e) : n = m2(),
    void 0 === t ? n : d2(n, t)
}
  , b2 = function(e, t, n) {
  var r = a1(t);
  r in e ? D1.f(e, r, u0(0, n)) : e[r] = n
}
  , w2 = HZ.Array
  , x2 = Math.max
  , S2 = function(e, t, n) {
  for (var r = X1(e), o = q1(t, r), a = q1(void 0 === n ? r : n, r), i = w2(x2(a - o, 0)), s = 0; o < a; o++,
    s++)
    b2(i, s, e[o]);
  return i.length = s,
    i
}
  , E2 = ZZ("".replace)
  , A2 = ZZ("".split)
  , C2 = ZZ([].join)
  , k2 = String(Error("zxcasd").stack)
  , T2 = /\n\s*at [^:]*:[^\n]*/
  , D2 = T2.test(k2)
  , O2 = /@[^\n]*\n/.test(k2) && !/zxcasd/.test(k2)
  , _2 = {}
  , R2 = n1("iterator")
  , L2 = Array.prototype
  , I2 = {};
I2[n1("toStringTag")] = "z";
var P2 = "[object z]" === String(I2)
  , F2 = n1("toStringTag")
  , B2 = HZ.Object
  , N2 = "Arguments" == f0(function() {
  return arguments
}())
  , M2 = P2 ? f0 : function(e) {
  var t, n, r;
  return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
    try {
      return e[t]
    } catch (n) {}
  }(t = B2(e), F2)) ? n : N2 ? f0(t) : "Object" == (r = f0(t)) && e0(t.callee) ? "Arguments" : r
}
  , j2 = n1("iterator")
  , V2 = function(e) {
  if (null != e)
    return j0(e, j2) || j0(e, "@@iterator") || _2[M2(e)]
}
  , U2 = HZ.TypeError
  , $2 = function(e, t, n) {
  var r, o;
  A1(e);
  try {
    if (!(r = j0(e, "return"))) {
      if ("throw" === t)
        throw n;
      return n
    }
    r = o0(r, e)
  } catch (a) {
    o = !0,
      r = a
  }
  if ("throw" === t)
    throw n;
  if (o)
    throw r;
  return A1(r),
    n
}
  , H2 = HZ.TypeError
  , z2 = function(e, t) {
  this.stopped = e,
    this.result = t
}
  , K2 = z2.prototype
  , W2 = HZ.String
  , G2 = function(e) {
  if ("Symbol" === M2(e))
    throw TypeError("Cannot convert a Symbol value to a string");
  return W2(e)
}
  , q2 = !t0((function() {
    var e = Error("a");
    return !("stack"in e) || (Object.defineProperty(e, "stack", u0(1, 7)),
    7 !== e.stack)
  }
))
  , Y2 = n1("toStringTag")
  , X2 = HZ.Error
  , Q2 = [].push
  , J2 = function(e, t) {
  var n, r = arguments.length > 2 ? arguments[2] : void 0, o = E0(Z2, this);
  $1 ? n = $1(new X2(void 0), o ? j1(this) : Z2) : (n = o ? this : y2(Z2),
    O1(n, Y2, "Error")),
    O1(n, "message", function(e, t) {
      return void 0 === e ? arguments.length < 2 ? "" : t : G2(e)
    }(t, "")),
  q2 && O1(n, "stack", function(e, t) {
    if ("string" != typeof e)
      return e;
    if (D2)
      for (; t--; )
        e = E2(e, T2, "");
    else if (O2)
      return C2(S2(A2(e, "\n"), t), "\n");
    return e
  }(n.stack, 1)),
    function(e, t) {
      b0(t) && "cause"in t && O1(e, "cause", t.cause)
    }(n, r);
  var a = [];
  return function(e, t, n) {
    var r, o, a, i, s, l, u, c, d = n && n.that, f = !(!n || !n.AS_ENTRIES), p = !(!n || !n.IS_ITERATOR), h = !(!n || !n.INTERRUPTED), v = x1(t, d), g = function(e) {
      return r && $2(r, "normal", e),
        new z2(!0,e)
    }, m = function(e) {
      return f ? (A1(e),
        h ? v(e[0], e[1], g) : v(e[0], e[1])) : h ? v(e, g) : v(e)
    };
    if (p)
      r = e;
    else {
      if (!(o = V2(e)))
        throw H2(B0(e) + " is not iterable");
      if (void 0 !== (c = o) && (_2.Array === c || L2[R2] === c)) {
        for (a = 0,
               i = X1(e); i > a; a++)
          if ((s = m(e[a])) && E0(K2, s))
            return s;
        return new z2(!1)
      }
      r = function(e, t) {
        var n = arguments.length < 2 ? V2(e) : t;
        if (M0(n))
          return A1(o0(n, e));
        throw U2(B0(e) + " is not iterable")
      }(e, o)
    }
    for (l = r.next; !(u = o0(l, r)).done; ) {
      try {
        s = m(u.value)
      } catch (c) {
        $2(r, "throw", c)
      }
      if ("object" == typeof s && s && E0(K2, s))
        return s
    }
    new z2(!1)
  }(e, Q2, {
    that: a
  }),
    O1(n, "errors", a),
    n
};
$1 ? $1(J2, X2) : function(e, t) {
  for (var n = u2(t), r = D1.f, o = f1.f, a = 0; a < n.length; a++) {
    var i = n[a];
    G0(e, i) || r(e, i, o(t, i))
  }
}(J2, X2);
var Z2 = J2.prototype = y2(X2.prototype, {
  constructor: u0(1, J2),
  message: u0(1, ""),
  name: u0(1, "AggregateError")
});
L1({
  global: !0
}, {
  AggregateError: J2
});
var e4 = ZZ(Function.toString);
e0($0.inspectSource) || ($0.inspectSource = function(e) {
    return e4(e)
  }
);
var t4, n4, r4, o4 = $0.inspectSource, a4 = HZ.WeakMap, i4 = e0(a4) && /native code/.test(o4(a4)), s4 = HZ.TypeError, l4 = HZ.WeakMap;
if (i4 || $0.state) {
  var u4 = $0.state || ($0.state = new l4)
    , c4 = ZZ(u4.get)
    , d4 = ZZ(u4.has)
    , f4 = ZZ(u4.set);
  t4 = function(e, t) {
    if (d4(u4, e))
      throw new s4("Object already initialized");
    return t.facade = e,
      f4(u4, e, t),
      t
  }
    ,
    n4 = function(e) {
      return c4(u4, e) || {}
    }
    ,
    r4 = function(e) {
      return d4(u4, e)
    }
} else {
  var p4 = P1("state");
  Z1[p4] = !0,
    t4 = function(e, t) {
      if (G0(e, p4))
        throw new s4("Object already initialized");
      return t.facade = e,
        O1(e, p4, t),
        t
    }
    ,
    n4 = function(e) {
      return G0(e, p4) ? e[p4] : {}
    }
    ,
    r4 = function(e) {
      return G0(e, p4)
    }
}
var h4, v4, g4, m4 = {
  set: t4,
  get: n4,
  has: r4,
  enforce: function(e) {
    return r4(e) ? n4(e) : t4(e, {})
  },
  getterFor: function(e) {
    return function(t) {
      var n;
      if (!b0(t) || (n = n4(t)).type !== e)
        throw s4("Incompatible receiver, " + e + " required");
      return n
    }
  }
}, y4 = Function.prototype, b4 = n0 && Object.getOwnPropertyDescriptor, w4 = G0(y4, "name"), x4 = {
  EXISTS: w4,
  PROPER: w4 && "something" === function() {}
    .name,
  CONFIGURABLE: w4 && (!n0 || n0 && b4(y4, "name").configurable)
}, S4 = function(e, t, n, r) {
  r && r.enumerable ? e[t] = n : O1(e, t, n)
}, E4 = n1("iterator"), A4 = !1;
[].keys && ("next"in (g4 = [].keys()) ? (v4 = j1(j1(g4))) !== Object.prototype && (h4 = v4) : A4 = !0);
var C4 = null == h4 || t0((function() {
    var e = {};
    return h4[E4].call(e) !== e
  }
));
h4 = C4 ? {} : y2(h4),
e0(h4[E4]) || S4(h4, E4, (function() {
    return this
  }
));
var k4 = {
  IteratorPrototype: h4,
  BUGGY_SAFARI_ITERATORS: A4
}
  , T4 = P2 ? {}.toString : function() {
  return "[object " + M2(this) + "]"
}
  , D4 = D1.f
  , O4 = n1("toStringTag")
  , _4 = function(e, t, n, r) {
  if (e) {
    var o = n ? e : e.prototype;
    G0(o, O4) || D4(o, O4, {
      configurable: !0,
      value: t
    }),
    r && !P2 && O1(o, "toString", T4)
  }
}
  , R4 = k4.IteratorPrototype
  , L4 = function() {
  return this
}
  , I4 = x4.PROPER
  , P4 = k4.BUGGY_SAFARI_ITERATORS
  , F4 = n1("iterator")
  , B4 = function() {
  return this
}
  , N4 = function(e, t, n, r, o, a, i) {
  var s, l, u;
  l = r,
    u = t + " Iterator",
    (s = n).prototype = y2(R4, {
      next: u0(1, l)
    }),
    _4(s, u, !1, !0),
    _2[u] = L4;
  var c, d, f, p = function(e) {
    if (e === o && y)
      return y;
    if (!P4 && e in g)
      return g[e];
    switch (e) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n(this,e)
        }
    }
    return function() {
      return new n(this)
    }
  }, h = t + " Iterator", v = !1, g = e.prototype, m = g[F4] || g["@@iterator"] || o && g[o], y = !P4 && m || p(o), b = "Array" == t && g.entries || m;
  if (b && (c = j1(b.call(new e))) !== Object.prototype && c.next && (_4(c, h, !0, !0),
    _2[h] = B4),
  I4 && "values" == o && m && "values" !== m.name && (v = !0,
      y = function() {
        return o0(m, this)
      }
  ),
    o)
    if (d = {
      values: p("values"),
      keys: a ? y : p("keys"),
      entries: p("entries")
    },
      i)
      for (f in d)
        (P4 || v || !(f in g)) && S4(g, f, d[f]);
    else
      L1({
        target: t,
        proto: !0,
        forced: P4 || v
      }, d);
  return i && g[F4] !== y && S4(g, F4, y, {
    name: o
  }),
    _2[t] = y,
    d
}
  , M4 = m4.set
  , j4 = m4.getterFor("Array Iterator");
N4(Array, "Array", (function(e, t) {
    M4(this, {
      type: "Array Iterator",
      target: y0(e),
      index: 0,
      kind: t
    })
  }
), (function() {
    var e = j4(this)
      , t = e.target
      , n = e.kind
      , r = e.index++;
    return !t || r >= t.length ? (e.target = void 0,
      {
        value: void 0,
        done: !0
      }) : "keys" == n ? {
      value: r,
      done: !1
    } : "values" == n ? {
      value: t[r],
      done: !1
    } : {
      value: [r, t[r]],
      done: !1
    }
  }
), "values"),
  _2.Arguments = _2.Array;
var V4 = ZZ("".charAt)
  , U4 = ZZ("".charCodeAt)
  , $4 = ZZ("".slice)
  , H4 = function(e) {
  return function(t, n) {
    var r, o, a = G2(m0(t)), i = K1(n), s = a.length;
    return i < 0 || i >= s ? e ? "" : void 0 : (r = U4(a, i)) < 55296 || r > 56319 || i + 1 === s || (o = U4(a, i + 1)) < 56320 || o > 57343 ? e ? V4(a, i) : r : e ? $4(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536
  }
}
  , z4 = (H4(!1),
  H4(!0))
  , K4 = m4.set
  , W4 = m4.getterFor("String Iterator");
N4(String, "String", (function(e) {
    K4(this, {
      type: "String Iterator",
      string: G2(e),
      index: 0
    })
  }
), (function() {
    var e, t = W4(this), n = t.string, r = t.index;
    return r >= n.length ? {
      value: void 0,
      done: !0
    } : (e = z4(n, r),
      t.index += e.length,
      {
        value: e,
        done: !1
      })
  }
));
var G4 = w0.AggregateError
  , q4 = n1("toStringTag");
for (var Y4 in {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}) {
  var X4 = HZ[Y4]
    , Q4 = X4 && X4.prototype;
  Q4 && M2(Q4) !== q4 && O1(Q4, q4, Y4),
    _2[Y4] = _2.Array
}
var J4, Z4, e3 = G4, t3 = function(e) {
  return e && e.Math == Math && e
}, n3 = t3("object" == typeof globalThis && globalThis) || t3("object" == typeof window && window) || t3("object" == typeof self && self) || t3("object" == typeof MZ && MZ) || function() {
  return this
}() || Function("return this")(), r3 = function(e) {
  try {
    return !!e()
  } catch (t) {
    return !0
  }
}, o3 = !r3((function() {
    return 7 != Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1]
  }
)), a3 = Function.prototype.call, i3 = a3.bind ? a3.bind(a3) : function() {
  return a3.apply(a3, arguments)
}
  , s3 = {}.propertyIsEnumerable, l3 = Object.getOwnPropertyDescriptor, u3 = l3 && !s3.call({
  1: 2
}, 1) ? function(e) {
    var t = l3(this, e);
    return !!t && t.enumerable
  }
  : s3, c3 = {
  f: u3
}, d3 = function(e, t) {
  return {
    enumerable: !(1 & e),
    configurable: !(2 & e),
    writable: !(4 & e),
    value: t
  }
}, f3 = Function.prototype, p3 = f3.bind, h3 = f3.call, v3 = p3 && p3.bind(h3), g3 = p3 ? function(e) {
    return e && v3(h3, e)
  }
  : function(e) {
    return e && function() {
      return h3.apply(e, arguments)
    }
  }
  , m3 = g3({}.toString), y3 = g3("".slice), b3 = function(e) {
  return y3(m3(e), 8, -1)
}, w3 = n3.Object, x3 = g3("".split), S3 = r3((function() {
    return !w3("z").propertyIsEnumerable(0)
  }
)) ? function(e) {
    return "String" == b3(e) ? x3(e, "") : w3(e)
  }
  : w3, E3 = n3.TypeError, A3 = function(e) {
  if (null == e)
    throw E3("Can't call method on " + e);
  return e
}, C3 = function(e) {
  return S3(A3(e))
}, k3 = function(e) {
  return "function" == typeof e
}, T3 = function(e) {
  return "object" == typeof e ? null !== e : k3(e)
}, D3 = function(e, t) {
  return arguments.length < 2 ? function(e) {
    return k3(e) ? e : void 0
  }(n3[e]) : n3[e] && n3[e][t]
}, O3 = g3({}.isPrototypeOf), _3 = D3("navigator", "userAgent") || "", R3 = n3.process, L3 = n3.Deno, I3 = R3 && R3.versions || L3 && L3.version, P3 = I3 && I3.v8;
P3 && (Z4 = (J4 = P3.split("."))[0] > 0 && J4[0] < 4 ? 1 : +(J4[0] + J4[1])),
!Z4 && _3 && (!(J4 = _3.match(/Edge\/(\d+)/)) || J4[1] >= 74) && (J4 = _3.match(/Chrome\/(\d+)/)) && (Z4 = +J4[1]);
var F3 = Z4
  , B3 = !!Object.getOwnPropertySymbols && !r3((function() {
    var e = Symbol();
    return !String(e) || !(Object(e)instanceof Symbol) || !Symbol.sham && F3 && F3 < 41
  }
))
  , N3 = B3 && !Symbol.sham && "symbol" == typeof Symbol.iterator
  , M3 = n3.Object
  , j3 = N3 ? function(e) {
    return "symbol" == typeof e
  }
  : function(e) {
    var t = D3("Symbol");
    return k3(t) && O3(t.prototype, M3(e))
  }
  , V3 = n3.String
  , U3 = function(e) {
  try {
    return V3(e)
  } catch (t) {
    return "Object"
  }
}
  , $3 = n3.TypeError
  , H3 = function(e) {
  if (k3(e))
    return e;
  throw $3(U3(e) + " is not a function")
}
  , z3 = function(e, t) {
  var n = e[t];
  return null == n ? void 0 : H3(n)
}
  , K3 = n3.TypeError
  , W3 = Object.defineProperty
  , G3 = function(e, t) {
  try {
    W3(n3, e, {
      value: t,
      configurable: !0,
      writable: !0
    })
  } catch (AEe) {
    n3[e] = t
  }
  return t
}
  , q3 = n3["__core-js_shared__"] || G3("__core-js_shared__", {})
  , Y3 = jZ((function(e) {
    (e.exports = function(e, t) {
        return q3[e] || (q3[e] = void 0 !== t ? t : {})
      }
    )("versions", []).push({
      version: "3.19.3",
      mode: "global",
      copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
    })
  }
))
  , X3 = n3.Object
  , Q3 = function(e) {
  return X3(A3(e))
}
  , J3 = g3({}.hasOwnProperty)
  , Z3 = Object.hasOwn || function(e, t) {
  return J3(Q3(e), t)
}
  , e8 = 0
  , t8 = Math.random()
  , n8 = g3(1..toString)
  , r8 = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + n8(++e8 + t8, 36)
}
  , o8 = Y3("wks")
  , a8 = n3.Symbol
  , i8 = a8 && a8.for
  , s8 = N3 ? a8 : a8 && a8.withoutSetter || r8
  , l8 = function(e) {
  if (!Z3(o8, e) || !B3 && "string" != typeof o8[e]) {
    var t = "Symbol." + e;
    B3 && Z3(a8, e) ? o8[e] = a8[e] : o8[e] = N3 && i8 ? i8(t) : s8(t)
  }
  return o8[e]
}
  , u8 = n3.TypeError
  , c8 = l8("toPrimitive")
  , d8 = function(e) {
  var t = function(e, t) {
    if (!T3(e) || j3(e))
      return e;
    var n, r = z3(e, c8);
    if (r) {
      if (void 0 === t && (t = "default"),
        n = i3(r, e, t),
      !T3(n) || j3(n))
        return n;
      throw u8("Can't convert object to primitive value")
    }
    return void 0 === t && (t = "number"),
      function(e, t) {
        var n, r;
        if ("string" === t && k3(n = e.toString) && !T3(r = i3(n, e)))
          return r;
        if (k3(n = e.valueOf) && !T3(r = i3(n, e)))
          return r;
        if ("string" !== t && k3(n = e.toString) && !T3(r = i3(n, e)))
          return r;
        throw K3("Can't convert object to primitive value")
      }(e, t)
  }(e, "string");
  return j3(t) ? t : t + ""
}
  , f8 = n3.document
  , p8 = T3(f8) && T3(f8.createElement)
  , h8 = function(e) {
  return p8 ? f8.createElement(e) : {}
}
  , v8 = !o3 && !r3((function() {
    return 7 != Object.defineProperty(h8("div"), "a", {
      get: function() {
        return 7
      }
    }).a
  }
))
  , g8 = Object.getOwnPropertyDescriptor
  , m8 = o3 ? g8 : function(e, t) {
  if (e = C3(e),
    t = d8(t),
    v8)
    try {
      return g8(e, t)
    } catch (n) {}
  if (Z3(e, t))
    return d3(!i3(c3.f, e, t), e[t])
}
  , y8 = {
  f: m8
}
  , b8 = n3.String
  , w8 = n3.TypeError
  , x8 = function(e) {
  if (T3(e))
    return e;
  throw w8(b8(e) + " is not an object")
}
  , S8 = n3.TypeError
  , E8 = Object.defineProperty
  , A8 = o3 ? E8 : function(e, t, n) {
  if (x8(e),
    t = d8(t),
    x8(n),
    v8)
    try {
      return E8(e, t, n)
    } catch (r) {}
  if ("get"in n || "set"in n)
    throw S8("Accessors not supported");
  return "value"in n && (e[t] = n.value),
    e
}
  , C8 = {
  f: A8
}
  , k8 = o3 ? function(e, t, n) {
    return C8.f(e, t, d3(1, n))
  }
  : function(e, t, n) {
    return e[t] = n,
      e
  }
  , T8 = g3(Function.toString);
k3(q3.inspectSource) || (q3.inspectSource = function(e) {
    return T8(e)
  }
);
var D8, O8, _8, R8 = q3.inspectSource, L8 = n3.WeakMap, I8 = k3(L8) && /native code/.test(R8(L8)), P8 = Y3("keys"), F8 = function(e) {
  return P8[e] || (P8[e] = r8(e))
}, B8 = {}, N8 = n3.TypeError, M8 = n3.WeakMap;
if (I8 || q3.state) {
  var j8 = q3.state || (q3.state = new M8)
    , V8 = g3(j8.get)
    , U8 = g3(j8.has)
    , $8 = g3(j8.set);
  D8 = function(e, t) {
    if (U8(j8, e))
      throw new N8("Object already initialized");
    return t.facade = e,
      $8(j8, e, t),
      t
  }
    ,
    O8 = function(e) {
      return V8(j8, e) || {}
    }
    ,
    _8 = function(e) {
      return U8(j8, e)
    }
} else {
  var H8 = F8("state");
  B8[H8] = !0,
    D8 = function(e, t) {
      if (Z3(e, H8))
        throw new N8("Object already initialized");
      return t.facade = e,
        k8(e, H8, t),
        t
    }
    ,
    O8 = function(e) {
      return Z3(e, H8) ? e[H8] : {}
    }
    ,
    _8 = function(e) {
      return Z3(e, H8)
    }
}
var z8 = {
  set: D8,
  get: O8,
  has: _8,
  enforce: function(e) {
    return _8(e) ? O8(e) : D8(e, {})
  },
  getterFor: function(e) {
    return function(t) {
      var n;
      if (!T3(t) || (n = O8(t)).type !== e)
        throw N8("Incompatible receiver, " + e + " required");
      return n
    }
  }
}
  , K8 = Function.prototype
  , W8 = o3 && Object.getOwnPropertyDescriptor
  , G8 = Z3(K8, "name")
  , q8 = {
  EXISTS: G8,
  PROPER: G8 && "something" === function() {}
    .name,
  CONFIGURABLE: G8 && (!o3 || o3 && W8(K8, "name").configurable)
}
  , Y8 = jZ((function(e) {
    var t = q8.CONFIGURABLE
      , n = z8.get
      , r = z8.enforce
      , o = String(String).split("String");
    (e.exports = function(e, n, a, i) {
        var s, l = !!i && !!i.unsafe, u = !!i && !!i.enumerable, c = !!i && !!i.noTargetGet, d = i && void 0 !== i.name ? i.name : n;
        k3(a) && ("Symbol(" === String(d).slice(0, 7) && (d = "[" + String(d).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
        (!Z3(a, "name") || t && a.name !== d) && k8(a, "name", d),
        (s = r(a)).source || (s.source = o.join("string" == typeof d ? d : ""))),
          e !== n3 ? (l ? !c && e[n] && (u = !0) : delete e[n],
            u ? e[n] = a : k8(e, n, a)) : u ? e[n] = a : G3(n, a)
      }
    )(Function.prototype, "toString", (function() {
        return k3(this) && n(this).source || R8(this)
      }
    ))
  }
))
  , X8 = Math.ceil
  , Q8 = Math.floor
  , J8 = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : (t > 0 ? Q8 : X8)(t)
}
  , Z8 = Math.max
  , e6 = Math.min
  , t6 = function(e, t) {
  var n = J8(e);
  return n < 0 ? Z8(n + t, 0) : e6(n, t)
}
  , n6 = Math.min
  , r6 = function(e) {
  return e > 0 ? n6(J8(e), 9007199254740991) : 0
}
  , o6 = function(e) {
  return r6(e.length)
}
  , a6 = function(e) {
  return function(t, n, r) {
    var o, a = C3(t), i = o6(a), s = t6(r, i);
    if (e && n != n) {
      for (; i > s; )
        if ((o = a[s++]) != o)
          return !0
    } else
      for (; i > s; s++)
        if ((e || s in a) && a[s] === n)
          return e || s || 0;
    return !e && -1
  }
}
  , i6 = (a6(!0),
  a6(!1))
  , s6 = g3([].push)
  , l6 = function(e, t) {
  var n, r = C3(e), o = 0, a = [];
  for (n in r)
    !Z3(B8, n) && Z3(r, n) && s6(a, n);
  for (; t.length > o; )
    Z3(r, n = t[o++]) && (~i6(a, n) || s6(a, n));
  return a
}
  , u6 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
  , c6 = u6.concat("length", "prototype")
  , d6 = Object.getOwnPropertyNames || function(e) {
  return l6(e, c6)
}
  , f6 = {
  f: d6
}
  , p6 = {
  f: Object.getOwnPropertySymbols
}
  , h6 = g3([].concat)
  , v6 = D3("Reflect", "ownKeys") || function(e) {
  var t = f6.f(x8(e))
    , n = p6.f;
  return n ? h6(t, n(e)) : t
}
  , g6 = function(e, t) {
  for (var n = v6(t), r = C8.f, o = y8.f, a = 0; a < n.length; a++) {
    var i = n[a];
    Z3(e, i) || r(e, i, o(t, i))
  }
}
  , m6 = /#|\.prototype\./
  , y6 = function(e, t) {
  var n = w6[b6(e)];
  return n == S6 || n != x6 && (k3(t) ? r3(t) : !!t)
}
  , b6 = y6.normalize = function(e) {
  return String(e).replace(m6, ".").toLowerCase()
}
  , w6 = y6.data = {}
  , x6 = y6.NATIVE = "N"
  , S6 = y6.POLYFILL = "P"
  , E6 = y6
  , A6 = y8.f
  , C6 = function(e, t) {
  var n, r, o, a, i, s = e.target, l = e.global, u = e.stat;
  if (n = l ? n3 : u ? n3[s] || G3(s, {}) : (n3[s] || {}).prototype)
    for (r in t) {
      if (a = t[r],
        o = e.noTargetGet ? (i = A6(n, r)) && i.value : n[r],
      !E6(l ? r : s + (u ? "." : "#") + r, e.forced) && void 0 !== o) {
        if (typeof a == typeof o)
          continue;
        g6(a, o)
      }
      (e.sham || o && o.sham) && k8(a, "sham", !0),
        Y8(n, r, a, e)
    }
}
  , k6 = {};
k6[l8("toStringTag")] = "z";
var T6, D6 = "[object z]" === String(k6), O6 = l8("toStringTag"), _6 = n3.Object, R6 = "Arguments" == b3(function() {
  return arguments
}()), L6 = D6 ? b3 : function(e) {
  var t, n, r;
  return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
    try {
      return e[t]
    } catch (n) {}
  }(t = _6(e), O6)) ? n : R6 ? b3(t) : "Object" == (r = b3(t)) && k3(t.callee) ? "Arguments" : r
}
  , I6 = n3.String, P6 = function(e) {
  if ("Symbol" === L6(e))
    throw TypeError("Cannot convert a Symbol value to a string");
  return I6(e)
}, F6 = function() {
  var e = x8(this)
    , t = "";
  return e.global && (t += "g"),
  e.ignoreCase && (t += "i"),
  e.multiline && (t += "m"),
  e.dotAll && (t += "s"),
  e.unicode && (t += "u"),
  e.sticky && (t += "y"),
    t
}, B6 = n3.RegExp, N6 = r3((function() {
    var e = B6("a", "y");
    return e.lastIndex = 2,
    null != e.exec("abcd")
  }
)), M6 = N6 || r3((function() {
    return !B6("a", "y").sticky
  }
)), j6 = N6 || r3((function() {
    var e = B6("^r", "gy");
    return e.lastIndex = 2,
    null != e.exec("str")
  }
)), V6 = {
  BROKEN_CARET: j6,
  MISSED_STICKY: M6,
  UNSUPPORTED_Y: N6
}, U6 = Object.keys || function(e) {
  return l6(e, u6)
}
  , $6 = o3 ? Object.defineProperties : function(e, t) {
  x8(e);
  for (var n, r = C3(t), o = U6(t), a = o.length, i = 0; a > i; )
    C8.f(e, n = o[i++], r[n]);
  return e
}
  , H6 = D3("document", "documentElement"), z6 = F8("IE_PROTO"), K6 = function() {}, W6 = function(e) {
  return "<script>" + e + "<\/script>"
}, G6 = function(e) {
  e.write(W6("")),
    e.close();
  var t = e.parentWindow.Object;
  return e = null,
    t
}, q6 = function() {
  try {
    T6 = new ActiveXObject("htmlfile")
  } catch (r) {}
  var e, t;
  q6 = "undefined" != typeof document ? document.domain && T6 ? G6(T6) : ((t = h8("iframe")).style.display = "none",
    H6.appendChild(t),
    t.src = String("javascript:"),
    (e = t.contentWindow.document).open(),
    e.write(W6("document.F=Object")),
    e.close(),
    e.F) : G6(T6);
  for (var n = u6.length; n--; )
    delete q6.prototype[u6[n]];
  return q6()
};
B8[z6] = !0;
var Y6, X6, Q6 = Object.create || function(e, t) {
  var n;
  return null !== e ? (K6.prototype = x8(e),
    n = new K6,
    K6.prototype = null,
    n[z6] = e) : n = q6(),
    void 0 === t ? n : $6(n, t)
}
  , J6 = n3.RegExp, Z6 = r3((function() {
    var e = J6(".", "s");
    return !(e.dotAll && e.exec("\n") && "s" === e.flags)
  }
)), e5 = n3.RegExp, t5 = r3((function() {
    var e = e5("(?<a>b)", "g");
    return "b" !== e.exec("b").groups.a || "bc" !== "b".replace(e, "$<a>c")
  }
)), n5 = z8.get, r5 = Y3("native-string-replace", String.prototype.replace), o5 = RegExp.prototype.exec, a5 = o5, i5 = g3("".charAt), s5 = g3("".indexOf), l5 = g3("".replace), u5 = g3("".slice), c5 = (X6 = /b*/g,
  i3(o5, Y6 = /a/, "a"),
  i3(o5, X6, "a"),
0 !== Y6.lastIndex || 0 !== X6.lastIndex), d5 = V6.BROKEN_CARET, f5 = void 0 !== /()??/.exec("")[1];
(c5 || f5 || d5 || Z6 || t5) && (a5 = function(e) {
    var t, n, r, o, a, i, s, l = this, u = n5(l), c = P6(e), d = u.raw;
    if (d)
      return d.lastIndex = l.lastIndex,
        t = i3(a5, d, c),
        l.lastIndex = d.lastIndex,
        t;
    var f = u.groups
      , p = d5 && l.sticky
      , h = i3(F6, l)
      , v = l.source
      , g = 0
      , m = c;
    if (p && (h = l5(h, "y", ""),
    -1 === s5(h, "g") && (h += "g"),
      m = u5(c, l.lastIndex),
    l.lastIndex > 0 && (!l.multiline || l.multiline && "\n" !== i5(c, l.lastIndex - 1)) && (v = "(?: " + v + ")",
      m = " " + m,
      g++),
      n = new RegExp("^(?:" + v + ")",h)),
    f5 && (n = new RegExp("^" + v + "$(?!\\s)",h)),
    c5 && (r = l.lastIndex),
      o = i3(o5, p ? n : l, m),
      p ? o ? (o.input = u5(o.input, g),
        o[0] = u5(o[0], g),
        o.index = l.lastIndex,
        l.lastIndex += o[0].length) : l.lastIndex = 0 : c5 && o && (l.lastIndex = l.global ? o.index + o[0].length : r),
    f5 && o && o.length > 1 && i3(r5, o[0], n, (function() {
        for (a = 1; a < arguments.length - 2; a++)
          void 0 === arguments[a] && (o[a] = void 0)
      }
    )),
    o && f)
      for (o.groups = i = Q6(null),
             a = 0; a < f.length; a++)
        i[(s = f[a])[0]] = o[s[1]];
    return o
  }
);
var p5 = a5;
C6({
  target: "RegExp",
  proto: !0,
  forced: /./.exec !== p5
}, {
  exec: p5
});
l8("species");
var h5 = RegExp.prototype
  , v5 = g3("".charAt)
  , g5 = g3("".charCodeAt)
  , m5 = g3("".slice)
  , y5 = function(e) {
  return function(t, n) {
    var r, o, a = P6(A3(t)), i = J8(n), s = a.length;
    return i < 0 || i >= s ? e ? "" : void 0 : (r = g5(a, i)) < 55296 || r > 56319 || i + 1 === s || (o = g5(a, i + 1)) < 56320 || o > 57343 ? e ? v5(a, i) : r : e ? m5(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536
  }
}
  , b5 = {
  codeAt: y5(!1),
  charAt: y5(!0)
}
  , w5 = b5.charAt
  , x5 = function(e, t, n) {
  return t + (n ? w5(e, t).length : 1)
}
  , S5 = n3.TypeError
  , E5 = function(e, t) {
  var n = e.exec;
  if (k3(n)) {
    var r = i3(n, e, t);
    return null !== r && x8(r),
      r
  }
  if ("RegExp" === b3(e))
    return i3(p5, e, t);
  throw S5("RegExp#exec called on incompatible receiver")
};
!function(e, t, n, r) {
  var o = l8(e)
    , a = !r3((function() {
      var t = {};
      return t[o] = function() {
        return 7
      }
        ,
      7 != ""[e](t)
    }
  ))
    , i = a && !r3((function() {
      var e = !1
        , t = /a/;
      return t.exec = function() {
        return e = !0,
          null
      }
        ,
        t[o](""),
        !e
    }
  ));
  if (!a || !i) {
    var s = g3(/./[o])
      , l = function(e, t, n) {
      return [function(t) {
        var n = A3(this)
          , r = null == t ? void 0 : z3(t, e);
        return r ? i3(r, t, n) : new RegExp(t)[e](P6(n))
      }
        , function(e) {
          var r = x8(this)
            , o = P6(e)
            , a = n(t, r, o);
          if (a.done)
            return a.value;
          if (!r.global)
            return E5(r, o);
          var i = r.unicode;
          r.lastIndex = 0;
          for (var s, l = [], u = 0; null !== (s = E5(r, o)); ) {
            var c = P6(s[0]);
            l[u] = c,
            "" === c && (r.lastIndex = x5(o, r6(r.lastIndex), i)),
              u++
          }
          return 0 === u ? null : l
        }
      ]
    }(o, ""[e], (function(e, t, n, r, o) {
        var i = g3(e)
          , l = t.exec;
        return l === p5 || l === h5.exec ? a && !o ? {
          done: !0,
          value: s(t, n, r)
        } : {
          done: !0,
          value: i(n, t, r)
        } : {
          done: !1
        }
      }
    ));
    Y8(String.prototype, e, l[0]),
      Y8(h5, o, l[1])
  }
}("match"),
  C6({
    global: !0
  }, {
    globalThis: n3
  });
var A5 = !r3((function() {
    function e() {}
    return e.prototype.constructor = null,
    Object.getPrototypeOf(new e) !== e.prototype
  }
))
  , C5 = F8("IE_PROTO")
  , k5 = n3.Object
  , T5 = k5.prototype
  , D5 = A5 ? k5.getPrototypeOf : function(e) {
  var t = Q3(e);
  if (Z3(t, C5))
    return t[C5];
  var n = t.constructor;
  return k3(n) && t instanceof n ? n.prototype : t instanceof k5 ? T5 : null
}
  , O5 = n3.String
  , _5 = n3.TypeError
  , R5 = Object.setPrototypeOf || ("__proto__"in {} ? function() {
  var e, t = !1, n = {};
  try {
    (e = g3(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n, []),
      t = n instanceof Array
  } catch (r) {}
  return function(n, r) {
    return x8(n),
      function(e) {
        if ("object" == typeof e || k3(e))
          return e;
        throw _5("Can't set " + O5(e) + " as a prototype")
      }(r),
      t ? e(n, r) : n.__proto__ = r,
      n
  }
}() : void 0)
  , L5 = n3.Array
  , I5 = Math.max
  , P5 = g3("".replace)
  , F5 = g3("".split)
  , B5 = g3([].join)
  , N5 = String(Error("zxcasd").stack)
  , M5 = /\n\s*at [^:]*:[^\n]*/
  , j5 = M5.test(N5)
  , V5 = /@[^\n]*\n/.test(N5) && !/zxcasd/.test(N5)
  , U5 = g3(g3.bind)
  , $5 = function(e, t) {
  return H3(e),
    void 0 === t ? e : U5 ? U5(e, t) : function() {
      return e.apply(t, arguments)
    }
}
  , H5 = {}
  , z5 = l8("iterator")
  , K5 = Array.prototype
  , W5 = l8("iterator")
  , G5 = function(e) {
  if (null != e)
    return z3(e, W5) || z3(e, "@@iterator") || H5[L6(e)]
}
  , q5 = n3.TypeError
  , Y5 = function(e, t, n) {
  var r, o;
  x8(e);
  try {
    if (!(r = z3(e, "return"))) {
      if ("throw" === t)
        throw n;
      return n
    }
    r = i3(r, e)
  } catch (a) {
    o = !0,
      r = a
  }
  if ("throw" === t)
    throw n;
  if (o)
    throw r;
  return x8(r),
    n
}
  , X5 = n3.TypeError
  , Q5 = function(e, t) {
  this.stopped = e,
    this.result = t
}
  , J5 = Q5.prototype
  , Z5 = !r3((function() {
    var e = Error("a");
    return !("stack"in e) || (Object.defineProperty(e, "stack", d3(1, 7)),
    7 !== e.stack)
  }
))
  , e9 = l8("toStringTag")
  , t9 = n3.Error
  , n9 = [].push
  , r9 = function(e, t) {
  var n, r = arguments.length > 2 ? arguments[2] : void 0, o = O3(o9, this);
  R5 ? n = R5(new t9(void 0), o ? D5(this) : o9) : (n = o ? this : Q6(o9),
    k8(n, e9, "Error")),
    k8(n, "message", function(e, t) {
      return void 0 === e ? arguments.length < 2 ? "" : t : P6(e)
    }(t, "")),
  Z5 && k8(n, "stack", function(e, t) {
    if ("string" != typeof e)
      return e;
    if (j5)
      for (; t--; )
        e = P5(e, M5, "");
    else if (V5)
      return B5(function(e, t, n) {
        for (var r, o, a, i, s = o6(e), l = t6(t, s), u = t6(s, s), c = L5(I5(u - l, 0)), d = 0; l < u; l++,
          d++)
          r = c,
            o = d,
            a = e[l],
            (i = d8(o))in r ? C8.f(r, i, d3(0, a)) : r[i] = a;
        return c.length = d,
          c
      }(F5(e, "\n"), t), "\n");
    return e
  }(n.stack, 1)),
    function(e, t) {
      T3(t) && "cause"in t && k8(e, "cause", t.cause)
    }(n, r);
  var a = [];
  return function(e, t, n) {
    var r, o, a, i, s, l, u, c, d = n && n.that, f = !(!n || !n.AS_ENTRIES), p = !(!n || !n.IS_ITERATOR), h = !(!n || !n.INTERRUPTED), v = $5(t, d), g = function(e) {
      return r && Y5(r, "normal", e),
        new Q5(!0,e)
    }, m = function(e) {
      return f ? (x8(e),
        h ? v(e[0], e[1], g) : v(e[0], e[1])) : h ? v(e, g) : v(e)
    };
    if (p)
      r = e;
    else {
      if (!(o = G5(e)))
        throw X5(U3(e) + " is not iterable");
      if (void 0 !== (c = o) && (H5.Array === c || K5[z5] === c)) {
        for (a = 0,
               i = o6(e); i > a; a++)
          if ((s = m(e[a])) && O3(J5, s))
            return s;
        return new Q5(!1)
      }
      r = function(e, t) {
        var n = arguments.length < 2 ? G5(e) : t;
        if (H3(n))
          return x8(i3(n, e));
        throw q5(U3(e) + " is not iterable")
      }(e, o)
    }
    for (l = r.next; !(u = i3(l, r)).done; ) {
      try {
        s = m(u.value)
      } catch (c) {
        Y5(r, "throw", c)
      }
      if ("object" == typeof s && s && O3(J5, s))
        return s
    }
    new Q5(!1)
  }(e, n9, {
    that: a
  }),
    k8(n, "errors", a),
    n
};
R5 ? R5(r9, t9) : g6(r9, t9);
var o9 = r9.prototype = Q6(t9.prototype, {
  constructor: d3(1, r9),
  message: d3(1, ""),
  name: d3(1, "AggregateError")
});
C6({
  global: !0
}, {
  AggregateError: r9
});
var a9 = l8("unscopables")
  , i9 = Array.prototype;
null == i9[a9] && C8.f(i9, a9, {
  configurable: !0,
  value: Q6(null)
});
var s9, l9, u9, c9 = function(e) {
  i9[a9][e] = !0
}, d9 = l8("iterator"), f9 = !1;
[].keys && ("next"in (u9 = [].keys()) ? (l9 = D5(D5(u9))) !== Object.prototype && (s9 = l9) : f9 = !0);
var p9 = null == s9 || r3((function() {
    var e = {};
    return s9[d9].call(e) !== e
  }
));
p9 && (s9 = {}),
k3(s9[d9]) || Y8(s9, d9, (function() {
    return this
  }
));
var h9 = {
  IteratorPrototype: s9,
  BUGGY_SAFARI_ITERATORS: f9
}
  , v9 = C8.f
  , g9 = l8("toStringTag")
  , m9 = function(e, t, n) {
  e && !Z3(e = n ? e : e.prototype, g9) && v9(e, g9, {
    configurable: !0,
    value: t
  })
}
  , y9 = h9.IteratorPrototype
  , b9 = function() {
  return this
}
  , w9 = q8.PROPER
  , x9 = q8.CONFIGURABLE
  , S9 = h9.IteratorPrototype
  , E9 = h9.BUGGY_SAFARI_ITERATORS
  , A9 = l8("iterator")
  , C9 = function() {
  return this
}
  , k9 = function(e, t, n, r, o, a, i) {
  var s, l, u;
  l = r,
    u = t + " Iterator",
    (s = n).prototype = Q6(y9, {
      next: d3(1, l)
    }),
    m9(s, u, !1),
    H5[u] = b9;
  var c, d, f, p = function(e) {
    if (e === o && y)
      return y;
    if (!E9 && e in g)
      return g[e];
    switch (e) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n(this,e)
        }
    }
    return function() {
      return new n(this)
    }
  }, h = t + " Iterator", v = !1, g = e.prototype, m = g[A9] || g["@@iterator"] || o && g[o], y = !E9 && m || p(o), b = "Array" == t && g.entries || m;
  if (b && (c = D5(b.call(new e))) !== Object.prototype && c.next && (D5(c) !== S9 && (R5 ? R5(c, S9) : k3(c[A9]) || Y8(c, A9, C9)),
    m9(c, h, !0)),
  w9 && "values" == o && m && "values" !== m.name && (x9 ? k8(g, "name", "values") : (v = !0,
      y = function() {
        return i3(m, this)
      }
  )),
    o)
    if (d = {
      values: p("values"),
      keys: a ? y : p("keys"),
      entries: p("entries")
    },
      i)
      for (f in d)
        (E9 || v || !(f in g)) && Y8(g, f, d[f]);
    else
      C6({
        target: t,
        proto: !0,
        forced: E9 || v
      }, d);
  return g[A9] !== y && Y8(g, A9, y, {
    name: o
  }),
    H5[t] = y,
    d
}
  , T9 = z8.set
  , D9 = z8.getterFor("Array Iterator")
  , O9 = k9(Array, "Array", (function(e, t) {
    T9(this, {
      type: "Array Iterator",
      target: C3(e),
      index: 0,
      kind: t
    })
  }
), (function() {
    var e = D9(this)
      , t = e.target
      , n = e.kind
      , r = e.index++;
    return !t || r >= t.length ? (e.target = void 0,
      {
        value: void 0,
        done: !0
      }) : "keys" == n ? {
      value: r,
      done: !1
    } : "values" == n ? {
      value: t[r],
      done: !1
    } : {
      value: [r, t[r]],
      done: !1
    }
  }
), "values");
H5.Arguments = H5.Array,
  c9("keys"),
  c9("values"),
  c9("entries");
var _9 = b5.charAt
  , R9 = z8.set
  , L9 = z8.getterFor("String Iterator");
k9(String, "String", (function(e) {
    R9(this, {
      type: "String Iterator",
      string: P6(e),
      index: 0
    })
  }
), (function() {
    var e, t = L9(this), n = t.string, r = t.index;
    return r >= n.length ? {
      value: void 0,
      done: !0
    } : (e = _9(n, r),
      t.index += e.length,
      {
        value: e,
        done: !1
      })
  }
));
var I9, P9 = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}, F9 = h8("span").classList, B9 = F9 && F9.constructor && F9.constructor.prototype, N9 = B9 === Object.prototype ? void 0 : B9, M9 = l8("iterator"), j9 = l8("toStringTag"), V9 = O9.values, U9 = function(e, t) {
  if (e) {
    if (e[M9] !== V9)
      try {
        k8(e, M9, V9)
      } catch (r) {
        e[M9] = V9
      }
    if (e[j9] || k8(e, j9, t),
      P9[t])
      for (var n in O9)
        if (e[n] !== O9[n])
          try {
            k8(e, n, O9[n])
          } catch (r) {
            e[n] = O9[n]
          }
  }
};
for (var $9 in P9)
  U9(n3[$9] && n3[$9].prototype, $9);
function H9() {
  "undefined" == typeof globalThis && (window.globalThis = window)
}
function z9() {
  void 0 === e3 && (window.AggregateError = function(e, t) {
      var n = new Error(t);
      return n.errors = e,
        n
    }
  )
}
U9(N9, "DOMTokenList"),
  "undefined" == typeof global ? ("ActiveXObject"in window && console.error("抱歉，wangEditor V5+ 版本开始，不在支持 IE 浏览器\n Sorry, wangEditor V5+ versions do not support IE browser."),
    H9(),
    z9()) : global && (null === (I9 = global.navigator) || void 0 === I9 ? void 0 : I9.userAgent.match("QQBrowser")) && (H9(),
    z9());
var K9 = Array.isArray || function(e) {
  return "Array" == f0(e)
}
  , W9 = function() {}
  , G9 = []
  , q9 = S0("Reflect", "construct")
  , Y9 = /^\s*(?:class|function)\b/
  , X9 = ZZ(Y9.exec)
  , Q9 = !Y9.exec(W9)
  , J9 = function(e) {
  if (!e0(e))
    return !1;
  try {
    return q9(W9, G9, e),
      !0
  } catch (t) {
    return !1
  }
}
  , Z9 = !q9 || t0((function() {
    var e;
    return J9(J9.call) || !J9(Object) || !J9((function() {
        e = !0
      }
    )) || e
  }
)) ? function(e) {
    if (!e0(e))
      return !1;
    switch (M2(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    return Q9 || !!X9(Y9, o4(e))
  }
  : J9
  , e7 = n1("species")
  , t7 = HZ.Array
  , n7 = function(e, t) {
  return new (K9(n = e) && (r = n.constructor,
  (Z9(r) && (r === t7 || K9(r.prototype)) || b0(r) && null === (r = r[e7])) && (r = void 0)),
    void 0 === r ? t7 : r)(0 === t ? 0 : t);
  var n, r
}
  , r7 = n1("species")
  , o7 = n1("isConcatSpreadable")
  , a7 = HZ.TypeError
  , i7 = _0 >= 51 || !t0((function() {
    var e = [];
    return e[o7] = !1,
    e.concat()[0] !== e
  }
))
  , s7 = ("concat",
_0 >= 51 || !t0((function() {
    var e = [];
    return (e.constructor = {})[r7] = function() {
      return {
        foo: 1
      }
    }
      ,
    1 !== e.concat(Boolean).foo
  }
)))
  , l7 = function(e) {
  if (!b0(e))
    return !1;
  var t = e[o7];
  return void 0 !== t ? !!t : K9(e)
};
L1({
  target: "Array",
  proto: !0,
  forced: !i7 || !s7
}, {
  concat: function(e) {
    var t, n, r, o, a, i = K0(this), s = n7(i, 0), l = 0;
    for (t = -1,
           r = arguments.length; t < r; t++)
      if (l7(a = -1 === t ? i : arguments[t])) {
        if (l + (o = X1(a)) > 9007199254740991)
          throw a7("Maximum allowed index exceeded");
        for (n = 0; n < o; n++,
          l++)
          n in a && b2(s, l, a[n])
      } else {
        if (l >= 9007199254740991)
          throw a7("Maximum allowed index exceeded");
        b2(s, l++, a)
      }
    return s.length = l,
      s
  }
});
var u7 = i2.f
  , c7 = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []
  , d7 = {
  f: function(e) {
    return c7 && "Window" == f0(e) ? function(e) {
      try {
        return u7(e)
      } catch (t) {
        return S2(c7)
      }
    }(e) : u7(y0(e))
  }
}
  , f7 = ZZ([].slice)
  , p7 = {
  f: n1
}
  , h7 = D1.f
  , v7 = function(e) {
  var t = w0.Symbol || (w0.Symbol = {});
  G0(t, e) || h7(t, e, {
    value: p7.f(e)
  })
}
  , g7 = ZZ([].push)
  , m7 = function(e) {
  var t = 1 == e
    , n = 2 == e
    , r = 3 == e
    , o = 4 == e
    , a = 6 == e
    , i = 7 == e
    , s = 5 == e || a;
  return function(l, u, c, d) {
    for (var f, p, h = K0(l), v = v0(h), g = x1(u, c), m = X1(v), y = 0, b = d || n7, w = t ? b(l, m) : n || i ? b(l, 0) : void 0; m > y; y++)
      if ((s || y in v) && (p = g(f = v[y], y, h),
        e))
        if (t)
          w[y] = p;
        else if (p)
          switch (e) {
            case 3:
              return !0;
            case 5:
              return f;
            case 6:
              return y;
            case 2:
              g7(w, f)
          }
        else
          switch (e) {
            case 4:
              return !1;
            case 7:
              g7(w, f)
          }
    return a ? -1 : r || o ? o : w
  }
}
  , y7 = [m7(0), m7(1), m7(2), m7(3), m7(4), m7(5), m7(6), m7(7)][0]
  , b7 = P1("hidden")
  , w7 = n1("toPrimitive")
  , x7 = m4.set
  , S7 = m4.getterFor("Symbol")
  , E7 = Object.prototype
  , A7 = HZ.Symbol
  , C7 = A7 && A7.prototype
  , k7 = HZ.TypeError
  , T7 = HZ.QObject
  , D7 = S0("JSON", "stringify")
  , O7 = f1.f
  , _7 = D1.f
  , R7 = d7.f
  , L7 = l0.f
  , I7 = ZZ([].push)
  , P7 = H0("symbols")
  , F7 = H0("op-symbols")
  , B7 = H0("string-to-symbol-registry")
  , N7 = H0("symbol-to-string-registry")
  , M7 = H0("wks")
  , j7 = !T7 || !T7.prototype || !T7.prototype.findChild
  , V7 = n0 && t0((function() {
    return 7 != y2(_7({}, "a", {
      get: function() {
        return _7(this, "a", {
          value: 7
        }).a
      }
    })).a
  }
)) ? function(e, t, n) {
    var r = O7(E7, t);
    r && delete E7[t],
      _7(e, t, n),
    r && e !== E7 && _7(E7, t, r)
  }
  : _7
  , U7 = function(e, t) {
  var n = P7[e] = y2(C7);
  return x7(n, {
    type: "Symbol",
    tag: e,
    description: t
  }),
  n0 || (n.description = t),
    n
}
  , $7 = function(e, t, n) {
  e === E7 && $7(F7, t, n),
    A1(e);
  var r = a1(t);
  return A1(n),
    G0(P7, r) ? (n.enumerable ? (G0(e, b7) && e[b7][r] && (e[b7][r] = !1),
      n = y2(n, {
        enumerable: u0(0, !1)
      })) : (G0(e, b7) || _7(e, b7, u0(1, {})),
      e[b7][r] = !0),
      V7(e, r, n)) : _7(e, r, n)
}
  , H7 = function(e, t) {
  A1(e);
  var n = y0(t)
    , r = c2(n).concat(G7(n));
  return y7(r, (function(t) {
      n0 && !o0(z7, n, t) || $7(e, t, n[t])
    }
  )),
    e
}
  , z7 = function(e) {
  var t = a1(e)
    , n = o0(L7, this, t);
  return !(this === E7 && G0(P7, t) && !G0(F7, t)) && (!(n || !G0(this, t) || !G0(P7, t) || G0(this, b7) && this[b7][t]) || n)
}
  , K7 = function(e, t) {
  var n = y0(e)
    , r = a1(t);
  if (n !== E7 || !G0(P7, r) || G0(F7, r)) {
    var o = O7(n, r);
    return !o || !G0(P7, r) || G0(n, b7) && n[b7][r] || (o.enumerable = !0),
      o
  }
}
  , W7 = function(e) {
  var t = R7(y0(e))
    , n = [];
  return y7(t, (function(e) {
      G0(P7, e) || G0(Z1, e) || I7(n, e)
    }
  )),
    n
}
  , G7 = function(e) {
  var t = e === E7
    , n = R7(t ? F7 : y0(e))
    , r = [];
  return y7(n, (function(e) {
      !G0(P7, e) || t && !G0(E7, e) || I7(r, P7[e])
    }
  )),
    r
};
if (R0 || (C7 = (A7 = function() {
    if (E0(C7, this))
      throw k7("Symbol is not a constructor");
    var e = arguments.length && void 0 !== arguments[0] ? G2(arguments[0]) : void 0
      , t = Q0(e)
      , n = function(e) {
      this === E7 && o0(n, F7, e),
      G0(this, b7) && G0(this[b7], t) && (this[b7][t] = !1),
        V7(this, t, u0(1, e))
    };
    return n0 && j7 && V7(E7, t, {
      configurable: !0,
      set: n
    }),
      U7(t, e)
  }
).prototype,
  S4(C7, "toString", (function() {
      return S7(this).tag
    }
  )),
  S4(A7, "withoutSetter", (function(e) {
      return U7(Q0(e), e)
    }
  )),
  l0.f = z7,
  D1.f = $7,
  f1.f = K7,
  i2.f = d7.f = W7,
  s2.f = G7,
  p7.f = function(e) {
    return U7(n1(e), e)
  }
  ,
n0 && _7(C7, "description", {
  configurable: !0,
  get: function() {
    return S7(this).description
  }
})),
  L1({
    global: !0,
    wrap: !0,
    forced: !R0,
    sham: !R0
  }, {
    Symbol: A7
  }),
  y7(c2(M7), (function(e) {
      v7(e)
    }
  )),
  L1({
    target: "Symbol",
    stat: !0,
    forced: !R0
  }, {
    for: function(e) {
      var t = G2(e);
      if (G0(B7, t))
        return B7[t];
      var n = A7(t);
      return B7[t] = n,
        N7[n] = t,
        n
    },
    keyFor: function(e) {
      if (!P0(e))
        throw k7(e + " is not a symbol");
      if (G0(N7, e))
        return N7[e]
    },
    useSetter: function() {
      j7 = !0
    },
    useSimple: function() {
      j7 = !1
    }
  }),
  L1({
    target: "Object",
    stat: !0,
    forced: !R0,
    sham: !n0
  }, {
    create: function(e, t) {
      return void 0 === t ? y2(e) : H7(y2(e), t)
    },
    defineProperty: $7,
    defineProperties: H7,
    getOwnPropertyDescriptor: K7
  }),
  L1({
    target: "Object",
    stat: !0,
    forced: !R0
  }, {
    getOwnPropertyNames: W7,
    getOwnPropertySymbols: G7
  }),
  L1({
    target: "Object",
    stat: !0,
    forced: t0((function() {
        s2.f(1)
      }
    ))
  }, {
    getOwnPropertySymbols: function(e) {
      return s2.f(K0(e))
    }
  }),
  D7) {
  var q7 = !R0 || t0((function() {
      var e = A7();
      return "[null]" != D7([e]) || "{}" != D7({
        a: e
      }) || "{}" != D7(Object(e))
    }
  ));
  L1({
    target: "JSON",
    stat: !0,
    forced: q7
  }, {
    stringify: function(e, t, n) {
      var r = f7(arguments)
        , o = t;
      if ((b0(t) || void 0 !== e) && !P0(e))
        return K9(t) || (t = function(e, t) {
            if (e0(o) && (t = o0(o, this, e, t)),
              !P0(t))
              return t
          }
        ),
          r[1] = t,
          qZ(D7, null, r)
    }
  })
}
if (!C7[w7]) {
  var Y7 = C7.valueOf;
  S4(C7, w7, (function(e) {
      return o0(Y7, this)
    }
  ))
}
_4(A7, "Symbol"),
  Z1[b7] = !0,
  v7("asyncIterator"),
  v7("hasInstance"),
  v7("isConcatSpreadable"),
  v7("iterator"),
  v7("match"),
  v7("matchAll"),
  v7("replace"),
  v7("search"),
  v7("species"),
  v7("split"),
  v7("toPrimitive"),
  v7("toStringTag"),
  v7("unscopables"),
  _4(HZ.JSON, "JSON", !0);
var X7 = w0.Symbol;
v7("asyncDispose"),
  v7("dispose"),
  v7("matcher"),
  v7("metadata"),
  v7("observable"),
  v7("patternMatch"),
  v7("replaceAll");
var Q7 = X7
  , J7 = p7.f("iterator")
  , Z7 = jZ((function(e) {
    function t(n) {
      return "function" == typeof Q7 && "symbol" == typeof J7 ? (e.exports = t = function(e) {
        return typeof e
      }
        ,
        e.exports.default = e.exports,
        e.exports.__esModule = !0) : (e.exports = t = function(e) {
        return e && "function" == typeof Q7 && e.constructor === Q7 && e !== Q7.prototype ? "symbol" : typeof e
      }
        ,
        e.exports.default = e.exports,
        e.exports.__esModule = !0),
        t(n)
    }
    e.exports = t,
      e.exports.default = e.exports,
      e.exports.__esModule = !0
  }
))
  , eee = function(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}(Z7)
  , tee = y8.f
  , nee = r3((function() {
    tee(1)
  }
));
if (C6({
  target: "Object",
  stat: !0,
  forced: !o3 || nee,
  sham: !o3
}, {
  getOwnPropertyDescriptor: function(e, t) {
    return tee(C3(e), t)
  }
}),
"object" === ("undefined" == typeof global ? "undefined" : eee(global))) {
  var ree = Object.getOwnPropertyDescriptor(global, "window");
  global.window && !ree.set || (global.window = global,
    global.requestAnimationFrame = function() {}
    ,
    global.navigator = {
      userAgent: ""
    },
    global.location = {
      hostname: "0.0.0.0",
      port: 0,
      protocol: "http:"
    },
    global.btoa = function() {}
    ,
    global.crypto = {
      getRandomValues: function(e) {
        return nodeCrypto.randomFillSync(e)
      }
    }),
  null != global.document && null == global.document.getElementsByTagName && (global.document.getElementsByTagName = function() {
      return []
    }
  )
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function oee(e) {
  return "[object Object]" === Object.prototype.toString.call(e)
}
function aee(e) {
  var t, n;
  return !1 !== oee(e) && (void 0 === (t = e.constructor) || !1 !== oee(n = t.prototype) && !1 !== n.hasOwnProperty("isPrototypeOf"))
}
function iee(e) {
  for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  throw Error("[Immer] minified error nr: " + e + (n.length ? " " + n.map((function(e) {
      return "'" + e + "'"
    }
  )).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf")
}
function see(e) {
  return !!e && !!e[Kee]
}
function lee(e) {
  return !!e && (function(e) {
    if (!e || "object" != typeof e)
      return !1;
    var t = Object.getPrototypeOf(e);
    if (null === t)
      return !0;
    var n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
    return n === Object || "function" == typeof n && Function.toString.call(n) === Wee
  }(e) || Array.isArray(e) || !!e[zee] || !!e.constructor[zee] || pee(e) || hee(e))
}
function uee(e, t, n) {
  void 0 === n && (n = !1),
    0 === cee(e) ? (n ? Object.keys : Gee)(e).forEach((function(r) {
        n && "symbol" == typeof r || t(r, e[r], e)
      }
    )) : e.forEach((function(n, r) {
        return t(r, n, e)
      }
    ))
}
function cee(e) {
  var t = e[Kee];
  return t ? t.i > 3 ? t.i - 4 : t.i : Array.isArray(e) ? 1 : pee(e) ? 2 : hee(e) ? 3 : 0
}
function dee(e, t) {
  return 2 === cee(e) ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t)
}
function fee(e, t, n) {
  var r = cee(e);
  2 === r ? e.set(t, n) : 3 === r ? (e.delete(t),
    e.add(n)) : e[t] = n
}
function pee(e) {
  return Vee && e instanceof Map
}
function hee(e) {
  return Uee && e instanceof Set
}
function vee(e) {
  return e.o || e.t
}
function gee(e) {
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  var t = qee(e);
  delete t[Kee];
  for (var n = Gee(t), r = 0; r < n.length; r++) {
    var o = n[r]
      , a = t[o];
    !1 === a.writable && (a.writable = !0,
      a.configurable = !0),
    (a.get || a.set) && (t[o] = {
      configurable: !0,
      writable: !0,
      enumerable: a.enumerable,
      value: e[o]
    })
  }
  return Object.create(Object.getPrototypeOf(e), t)
}
function mee(e, t) {
  return void 0 === t && (t = !1),
  bee(e) || see(e) || !lee(e) || (cee(e) > 1 && (e.set = e.add = e.clear = e.delete = yee),
    Object.freeze(e),
  t && uee(e, (function(e, t) {
      return mee(t, !0)
    }
  ), !0)),
    e
}
function yee() {
  iee(2)
}
function bee(e) {
  return null == e || "object" != typeof e || Object.isFrozen(e)
}
function wee(e) {
  var t = Yee[e];
  return t || iee(18, e),
    t
}
function xee() {
  return Mee
}
function See(e, t) {
  t && (wee("Patches"),
    e.u = [],
    e.s = [],
    e.v = t)
}
function Eee(e) {
  Aee(e),
    e.p.forEach(kee),
    e.p = null
}
function Aee(e) {
  e === Mee && (Mee = e.l)
}
function Cee(e) {
  return Mee = {
    p: [],
    l: Mee,
    h: e,
    m: !0,
    _: 0
  }
}
function kee(e) {
  var t = e[Kee];
  0 === t.i || 1 === t.i ? t.j() : t.O = !0
}
function Tee(e, t) {
  t._ = t.p.length;
  var n = t.p[0]
    , r = void 0 !== e && e !== n;
  return t.h.g || wee("ES5").S(t, e, r),
    r ? (n[Kee].P && (Eee(t),
      iee(4)),
    lee(e) && (e = Dee(t, e),
    t.l || _ee(t, e)),
    t.u && wee("Patches").M(n[Kee], e, t.u, t.s)) : e = Dee(t, n, []),
    Eee(t),
  t.u && t.v(t.u, t.s),
    e !== Hee ? e : void 0
}
function Dee(e, t, n) {
  if (bee(t))
    return t;
  var r = t[Kee];
  if (!r)
    return uee(t, (function(o, a) {
        return Oee(e, r, t, o, a, n)
      }
    ), !0),
      t;
  if (r.A !== e)
    return t;
  if (!r.P)
    return _ee(e, r.t, !0),
      r.t;
  if (!r.I) {
    r.I = !0,
      r.A._--;
    var o = 4 === r.i || 5 === r.i ? r.o = gee(r.k) : r.o;
    uee(3 === r.i ? new Set(o) : o, (function(t, a) {
        return Oee(e, r, o, t, a, n)
      }
    )),
      _ee(e, o, !1),
    n && e.u && wee("Patches").R(r, n, e.u, e.s)
  }
  return r.o
}
function Oee(e, t, n, r, o, a) {
  if (see(o)) {
    var i = Dee(e, o, a && t && 3 !== t.i && !dee(t.D, r) ? a.concat(r) : void 0);
    if (fee(n, r, i),
      !see(i))
      return;
    e.m = !1
  }
  if (lee(o) && !bee(o)) {
    if (!e.h.F && e._ < 1)
      return;
    Dee(e, o),
    t && t.A.l || _ee(e, o)
  }
}
function _ee(e, t, n) {
  void 0 === n && (n = !1),
  e.h.F && e.m && mee(t, n)
}
function Ree(e, t) {
  var n = e[Kee];
  return (n ? vee(n) : e)[t]
}
function Lee(e, t) {
  if (t in e)
    for (var n = Object.getPrototypeOf(e); n; ) {
      var r = Object.getOwnPropertyDescriptor(n, t);
      if (r)
        return r;
      n = Object.getPrototypeOf(n)
    }
}
function Iee(e) {
  e.P || (e.P = !0,
  e.l && Iee(e.l))
}
function Pee(e) {
  e.o || (e.o = gee(e.t))
}
function Fee(e, t, n) {
  var r = pee(t) ? wee("MapSet").N(t, n) : hee(t) ? wee("MapSet").T(t, n) : e.g ? function(e, t) {
    var n = Array.isArray(e)
      , r = {
      i: n ? 1 : 0,
      A: t ? t.A : xee(),
      P: !1,
      I: !1,
      D: {},
      l: t,
      t: e,
      k: null,
      o: null,
      j: null,
      C: !1
    }
      , o = r
      , a = Xee;
    n && (o = [r],
      a = Qee);
    var i = Proxy.revocable(o, a)
      , s = i.revoke
      , l = i.proxy;
    return r.k = l,
      r.j = s,
      l
  }(t, n) : wee("ES5").J(t, n);
  return (n ? n.A : xee()).p.push(r),
    r
}
function Bee(e, t) {
  switch (t) {
    case 2:
      return new Map(e);
    case 3:
      return Array.from(e)
  }
  return gee(e)
}
var Nee, Mee, jee = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), Vee = "undefined" != typeof Map, Uee = "undefined" != typeof Set, $ee = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, Hee = jee ? Symbol.for("immer-nothing") : ((Nee = {})["immer-nothing"] = !0,
  Nee), zee = jee ? Symbol.for("immer-draftable") : "__$immer_draftable", Kee = jee ? Symbol.for("immer-state") : "__$immer_state", Wee = "" + Object.prototype.constructor, Gee = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
  }
  : Object.getOwnPropertyNames, qee = Object.getOwnPropertyDescriptors || function(e) {
  var t = {};
  return Gee(e).forEach((function(n) {
      t[n] = Object.getOwnPropertyDescriptor(e, n)
    }
  )),
    t
}
  , Yee = {}, Xee = {
  get: function(e, t) {
    if (t === Kee)
      return e;
    var n = vee(e);
    if (!dee(n, t))
      return function(e, t, n) {
        var r, o = Lee(t, n);
        return o ? "value"in o ? o.value : null === (r = o.get) || void 0 === r ? void 0 : r.call(e.k) : void 0
      }(e, n, t);
    var r = n[t];
    return e.I || !lee(r) ? r : r === Ree(e.t, t) ? (Pee(e),
      e.o[t] = Fee(e.A.h, r, e)) : r
  },
  has: function(e, t) {
    return t in vee(e)
  },
  ownKeys: function(e) {
    return Reflect.ownKeys(vee(e))
  },
  set: function(e, t, n) {
    var r, o, a = Lee(vee(e), t);
    if (null == a ? void 0 : a.set)
      return a.set.call(e.k, n),
        !0;
    if (!e.P) {
      var i = Ree(vee(e), t)
        , s = null == i ? void 0 : i[Kee];
      if (s && s.t === n)
        return e.o[t] = n,
          e.D[t] = !1,
          !0;
      if (((r = n) === (o = i) ? 0 !== r || 1 / r == 1 / o : r != r && o != o) && (void 0 !== n || dee(e.t, t)))
        return !0;
      Pee(e),
        Iee(e)
    }
    return e.o[t] === n && "number" != typeof n && (void 0 !== n || t in e.o) || (e.o[t] = n,
      e.D[t] = !0,
      !0)
  },
  deleteProperty: function(e, t) {
    return void 0 !== Ree(e.t, t) || t in e.t ? (e.D[t] = !1,
      Pee(e),
      Iee(e)) : delete e.D[t],
    e.o && delete e.o[t],
      !0
  },
  getOwnPropertyDescriptor: function(e, t) {
    var n = vee(e)
      , r = Reflect.getOwnPropertyDescriptor(n, t);
    return r ? {
      writable: !0,
      configurable: 1 !== e.i || "length" !== t,
      enumerable: r.enumerable,
      value: n[t]
    } : r
  },
  defineProperty: function() {
    iee(11)
  },
  getPrototypeOf: function(e) {
    return Object.getPrototypeOf(e.t)
  },
  setPrototypeOf: function() {
    iee(12)
  }
}, Qee = {};
uee(Xee, (function(e, t) {
    Qee[e] = function() {
      return arguments[0] = arguments[0][0],
        t.apply(this, arguments)
    }
  }
)),
  Qee.deleteProperty = function(e, t) {
    return Xee.deleteProperty.call(this, e[0], t)
  }
  ,
  Qee.set = function(e, t, n) {
    return Xee.set.call(this, e[0], t, n, e[0])
  }
;
var Jee = function() {
  function e(e) {
    var t = this;
    this.g = $ee,
      this.F = !0,
      this.produce = function(e, n, r) {
        if ("function" == typeof e && "function" != typeof n) {
          var o = n;
          n = e;
          var a = t;
          return function(e) {
            var t = this;
            void 0 === e && (e = o);
            for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)
              i[s - 1] = arguments[s];
            return a.produce(e, (function(e) {
                var r;
                return (r = n).call.apply(r, [t, e].concat(i))
              }
            ))
          }
        }
        var i;
        if ("function" != typeof n && iee(6),
        void 0 !== r && "function" != typeof r && iee(7),
          lee(e)) {
          var s = Cee(t)
            , l = Fee(t, e, void 0)
            , u = !0;
          try {
            i = n(l),
              u = !1
          } finally {
            u ? Eee(s) : Aee(s)
          }
          return "undefined" != typeof Promise && i instanceof Promise ? i.then((function(e) {
              return See(s, r),
                Tee(e, s)
            }
          ), (function(e) {
              throw Eee(s),
                e
            }
          )) : (See(s, r),
            Tee(i, s))
        }
        if (!e || "object" != typeof e) {
          if ((i = n(e)) === Hee)
            return;
          return void 0 === i && (i = e),
          t.F && mee(i, !0),
            i
        }
        iee(21, e)
      }
      ,
      this.produceWithPatches = function(e, n) {
        return "function" == typeof e ? function(n) {
            for (var r = arguments.length, o = Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)
              o[a - 1] = arguments[a];
            return t.produceWithPatches(n, (function(t) {
                return e.apply(void 0, [t].concat(o))
              }
            ))
          }
          : [t.produce(e, n, (function(e, t) {
              r = e,
                o = t
            }
          )), r, o];
        var r, o
      }
      ,
    "boolean" == typeof (null == e ? void 0 : e.useProxies) && this.setUseProxies(e.useProxies),
    "boolean" == typeof (null == e ? void 0 : e.autoFreeze) && this.setAutoFreeze(e.autoFreeze)
  }
  var t = e.prototype;
  return t.createDraft = function(e) {
    lee(e) || iee(8),
    see(e) && (e = function(e) {
      return see(e) || iee(22, e),
        function e(t) {
          if (!lee(t))
            return t;
          var n, r = t[Kee], o = cee(t);
          if (r) {
            if (!r.P && (r.i < 4 || !wee("ES5").K(r)))
              return r.t;
            r.I = !0,
              n = Bee(t, o),
              r.I = !1
          } else
            n = Bee(t, o);
          return uee(n, (function(t, o) {
              var a, i;
              r && (i = t,
              (2 === cee(a = r.t) ? a.get(i) : a[i]) === o) || fee(n, t, e(o))
            }
          )),
            3 === o ? new Set(n) : n
        }(e)
    }(e));
    var t = Cee(this)
      , n = Fee(this, e, void 0);
    return n[Kee].C = !0,
      Aee(t),
      n
  }
    ,
    t.finishDraft = function(e, t) {
      var n = (e && e[Kee]).A;
      return See(n, t),
        Tee(void 0, n)
    }
    ,
    t.setAutoFreeze = function(e) {
      this.F = e
    }
    ,
    t.setUseProxies = function(e) {
      e && !$ee && iee(20),
        this.g = e
    }
    ,
    t.applyPatches = function(e, t) {
      var n;
      for (n = t.length - 1; n >= 0; n--) {
        var r = t[n];
        if (0 === r.path.length && "replace" === r.op) {
          e = r.value;
          break
        }
      }
      n > -1 && (t = t.slice(n + 1));
      var o = wee("Patches").$;
      return see(e) ? o(e, t) : this.produce(e, (function(e) {
          return o(e, t)
        }
      ))
    }
    ,
    e
}()
  , Zee = new Jee
  , ete = Zee.produce;
Zee.produceWithPatches.bind(Zee),
  Zee.setAutoFreeze.bind(Zee),
  Zee.setUseProxies.bind(Zee),
  Zee.applyPatches.bind(Zee);
var tte = Zee.createDraft.bind(Zee)
  , nte = Zee.finishDraft.bind(Zee);
function rte(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n,
    e
}
var ote = new WeakMap
  , ate = new WeakMap
  , ite = new WeakMap
  , ste = new WeakMap
  , lte = new WeakMap
  , ute = new WeakMap;
function cte(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
function dte(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {};
    t % 2 ? cte(Object(n), !0).forEach((function(t) {
        rte(e, t, n[t])
      }
    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cte(Object(n)).forEach((function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      }
    ))
  }
  return e
}
var fte = ()=>{
    var e = {
      children: [],
      operations: [],
      selection: null,
      marks: null,
      isInline: ()=>!1,
      isVoid: ()=>!1,
      onChange: ()=>{}
      ,
      apply: t=>{
        for (var n of Yte.pathRefs(e))
          ane.transform(n, t);
        for (var r of Yte.pointRefs(e))
          une.transform(r, t);
        for (var o of Yte.rangeRefs(e))
          pne.transform(o, t);
        var a = new Set
          , i = []
          , s = e=>{
          if (e) {
            var t = e.join(",");
            a.has(t) || (a.add(t),
              i.push(e))
          }
        }
          , l = ote.get(e) || []
          , u = pte(t);
        for (var c of l)
          s(one.transform(c, t));
        for (var d of u)
          s(d);
        ote.set(e, i),
          Nne.transform(e, t),
          e.operations.push(t),
          Yte.normalize(e),
        "set_selection" === t.type && (e.marks = null),
        ate.get(e) || (ate.set(e, !0),
          Promise.resolve().then((()=>{
              ate.set(e, !1),
                e.onChange(),
                e.operations = []
            }
          )))
      }
      ,
      addMark: (t,n)=>{
        var {selection: r} = e;
        if (r)
          if (fne.isExpanded(r))
            Nne.setNodes(e, {
              [t]: n
            }, {
              match: bne.isText,
              split: !0
            });
          else {
            var o = dte(dte({}, Yte.marks(e) || {}), {}, {
              [t]: n
            });
            e.marks = o,
            ate.get(e) || e.onChange()
          }
      }
      ,
      deleteBackward: t=>{
        var {selection: n} = e;
        n && fne.isCollapsed(n) && Nne.delete(e, {
          unit: t,
          reverse: !0
        })
      }
      ,
      deleteForward: t=>{
        var {selection: n} = e;
        n && fne.isCollapsed(n) && Nne.delete(e, {
          unit: t
        })
      }
      ,
      deleteFragment: t=>{
        var {selection: n} = e;
        n && fne.isExpanded(n) && Nne.delete(e, {
          reverse: "backward" === t
        })
      }
      ,
      getFragment: ()=>{
        var {selection: t} = e;
        return t ? ene.fragment(e, t) : []
      }
      ,
      insertBreak: ()=>{
        Nne.splitNodes(e, {
          always: !0
        })
      }
      ,
      insertFragment: t=>{
        Nne.insertFragment(e, t)
      }
      ,
      insertNode: t=>{
        Nne.insertNodes(e, t)
      }
      ,
      insertText: t=>{
        var {selection: n, marks: r} = e;
        if (n) {
          if (r) {
            var o = dte({
              text: t
            }, r);
            Nne.insertNodes(e, o)
          } else
            Nne.insertText(e, t);
          e.marks = null
        }
      }
      ,
      normalizeNode: t=>{
        var [n,r] = t;
        if (!bne.isText(n))
          if (Hte.isElement(n) && 0 === n.children.length)
            Nne.insertNodes(e, {
              text: ""
            }, {
              at: r.concat(0),
              voids: !0
            });
          else
            for (var o = !Yte.isEditor(n) && Hte.isElement(n) && (e.isInline(n) || 0 === n.children.length || bne.isText(n.children[0]) || e.isInline(n.children[0])), a = 0, i = 0; i < n.children.length; i++,
              a++) {
              var s = ene.get(e, r);
              if (!bne.isText(s)) {
                var l = n.children[i]
                  , u = s.children[a - 1]
                  , c = i === n.children.length - 1;
                (bne.isText(l) || Hte.isElement(l) && e.isInline(l)) !== o ? (Nne.removeNodes(e, {
                  at: r.concat(a),
                  voids: !0
                }),
                  a--) : Hte.isElement(l) ? e.isInline(l) && (null != u && bne.isText(u) ? c && (Nne.insertNodes(e, {
                  text: ""
                }, {
                  at: r.concat(a + 1),
                  voids: !0
                }),
                  a++) : (Nne.insertNodes(e, {
                  text: ""
                }, {
                  at: r.concat(a),
                  voids: !0
                }),
                  a++)) : null != u && bne.isText(u) && (bne.equals(l, u, {
                  loose: !0
                }) ? (Nne.mergeNodes(e, {
                  at: r.concat(a),
                  voids: !0
                }),
                  a--) : "" === u.text ? (Nne.removeNodes(e, {
                  at: r.concat(a - 1),
                  voids: !0
                }),
                  a--) : "" === l.text && (Nne.removeNodes(e, {
                  at: r.concat(a),
                  voids: !0
                }),
                  a--))
              }
            }
      }
      ,
      removeMark: t=>{
        var {selection: n} = e;
        if (n)
          if (fne.isExpanded(n))
            Nne.unsetNodes(e, t, {
              match: bne.isText,
              split: !0
            });
          else {
            var r = dte({}, Yte.marks(e) || {});
            delete r[t],
              e.marks = r,
            ate.get(e) || e.onChange()
          }
      }
    };
    return e
  }
  , pte = e=>{
    switch (e.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
        var {path: t} = e;
        return one.levels(t);
      case "insert_node":
        var {node: n, path: r} = e;
        return [...one.levels(r), ...bne.isText(n) ? [] : Array.from(ene.nodes(n), (e=>{
            var [,t] = e;
            return r.concat(t)
          }
        ))];
      case "merge_node":
        var {path: o} = e;
        return [...one.ancestors(o), one.previous(o)];
      case "move_node":
        var {path: a, newPath: i} = e;
        if (one.equals(a, i))
          return [];
        var s = []
          , l = [];
        for (var u of one.ancestors(a)) {
          var c = one.transform(u, e);
          s.push(c)
        }
        for (var d of one.ancestors(i)) {
          var f = one.transform(d, e);
          l.push(f)
        }
        var p = l[l.length - 1]
          , h = i[i.length - 1]
          , v = p.concat(h);
        return [...s, ...l, v];
      case "remove_node":
        var {path: g} = e;
        return [...one.ancestors(g)];
      case "split_node":
        var {path: m} = e;
        return [...one.levels(m), one.next(m)];
      default:
        return []
    }
  }
;
function hte(e, t) {
  if (null == e)
    return {};
  var n, r, o = function(e, t) {
    if (null == e)
      return {};
    var n, r, o = {}, a = Object.keys(e);
    for (r = 0; r < a.length; r++)
      n = a[r],
      t.indexOf(n) >= 0 || (o[n] = e[n]);
    return o
  }(e, t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++)
      n = a[r],
      t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (o[n] = e[n])
  }
  return o
}
var vte, gte = function(e) {
  var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
    , n = !t
    , r = t ? Ste(e) : e
    , o = vte.None
    , a = vte.None
    , i = 0
    , s = null;
  for (var l of r) {
    var u = l.codePointAt(0);
    if (!u)
      break;
    var c = Pte(l, u);
    if ([o,a] = n ? [a, c] : [c, o],
    Fte(o, vte.ZWJ) && Fte(a, vte.ExtPict) && !jte(n ? e.substring(0, i) : e.substring(0, e.length - i)))
      break;
    if (Fte(o, vte.RI) && Fte(a, vte.RI) && !(s = null !== s ? !s : !!n || Ute(e.substring(0, e.length - i))))
      break;
    if (o !== vte.None && a !== vte.None && Nte(o, a))
      break;
    i += l.length
  }
  return i || 1
}, mte = /\s/, yte = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, bte = /['\u2018\u2019]/, wte = (e,t,n)=>{
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)]
  }
  return [e.slice(0, t), e.slice(t)]
}
  , xte = function e(t, n) {
  var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
  if (mte.test(t))
    return !1;
  if (bte.test(t)) {
    var o = gte(n, r)
      , [a,i] = wte(n, o, r);
    if (e(a, i, r))
      return !0
  }
  return !yte.test(t)
}, Ste = function*(e) {
  for (var t = e.length - 1, n = 0; n < e.length; n++) {
    var r = e.charAt(t - n);
    if (Ate(r.charCodeAt(0))) {
      var o = e.charAt(t - n - 1);
      if (Ete(o.charCodeAt(0))) {
        yield o + r,
          n++;
        continue
      }
    }
    yield r
  }
}, Ete = e=>e >= 55296 && e <= 56319, Ate = e=>e >= 56320 && e <= 57343;
!function(e) {
  e[e.None = 0] = "None",
    e[e.Extend = 1] = "Extend",
    e[e.ZWJ = 2] = "ZWJ",
    e[e.RI = 4] = "RI",
    e[e.Prepend = 8] = "Prepend",
    e[e.SpacingMark = 16] = "SpacingMark",
    e[e.L = 32] = "L",
    e[e.V = 64] = "V",
    e[e.T = 128] = "T",
    e[e.LV = 256] = "LV",
    e[e.LVT = 512] = "LVT",
    e[e.ExtPict = 1024] = "ExtPict",
    e[e.Any = 2048] = "Any"
}(vte || (vte = {}));
var Cte = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/
  , kte = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/
  , Tte = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/
  , Dte = /^[\u1100-\u115F\uA960-\uA97C]$/
  , Ote = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/
  , _te = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/
  , Rte = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/
  , Lte = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/
  , Ite = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/
  , Pte = (e,t)=>{
    var n = vte.Any;
    return -1 !== e.search(Cte) && (n |= vte.Extend),
    8205 === t && (n |= vte.ZWJ),
    t >= 127462 && t <= 127487 && (n |= vte.RI),
    -1 !== e.search(kte) && (n |= vte.Prepend),
    -1 !== e.search(Tte) && (n |= vte.SpacingMark),
    -1 !== e.search(Dte) && (n |= vte.L),
    -1 !== e.search(Ote) && (n |= vte.V),
    -1 !== e.search(_te) && (n |= vte.T),
    -1 !== e.search(Rte) && (n |= vte.LV),
    -1 !== e.search(Lte) && (n |= vte.LVT),
    -1 !== e.search(Ite) && (n |= vte.ExtPict),
      n
  }
;
function Fte(e, t) {
  return 0 != (e & t)
}
var Bte = [[vte.L, vte.L | vte.V | vte.LV | vte.LVT], [vte.LV | vte.V, vte.V | vte.T], [vte.LVT | vte.T, vte.T], [vte.Any, vte.Extend | vte.ZWJ], [vte.Any, vte.SpacingMark], [vte.Prepend, vte.Any], [vte.ZWJ, vte.ExtPict], [vte.RI, vte.RI]];
function Nte(e, t) {
  return -1 === Bte.findIndex((n=>Fte(e, n[0]) && Fte(t, n[1])))
}
var Mte = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/
  , jte = e=>-1 !== e.search(Mte)
  , Vte = /(?:\uD83C[\uDDE6-\uDDFF])+$/g
  , Ute = e=>{
  var t = e.match(Vte);
  return null !== t && t[0].length / 2 % 2 == 1
}
  , $te = e=>aee(e) && ene.isNodeList(e.children) && !Yte.isEditor(e)
  , Hte = {
  isAncestor: e=>aee(e) && ene.isNodeList(e.children),
  isElement: $te,
  isElementList: e=>Array.isArray(e) && e.every((e=>Hte.isElement(e))),
  isElementProps: e=>void 0 !== e.children,
  isElementType: function(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "type";
    return $te(e) && e[n] === t
  },
  matches(e, t) {
    for (var n in t)
      if ("children" !== n && e[n] !== t[n])
        return !1;
    return !0
  }
}
  , zte = ["text"]
  , Kte = ["text"];
function Wte(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
function Gte(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {};
    t % 2 ? Wte(Object(n), !0).forEach((function(t) {
        rte(e, t, n[t])
      }
    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Wte(Object(n)).forEach((function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      }
    ))
  }
  return e
}
var qte = new WeakMap
  , Yte = {
  above(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {voids: n=!1, mode: r="lowest", at: o=e.selection, match: a} = t;
    if (o) {
      var i = Yte.path(e, o)
        , s = "lowest" === r;
      for (var [l,u] of Yte.levels(e, {
        at: i,
        voids: n,
        match: a,
        reverse: s
      }))
        if (!bne.isText(l) && !one.equals(i, u))
          return [l, u]
    }
  },
  addMark(e, t, n) {
    e.addMark(t, n)
  },
  after(e, t) {
    var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o = {
      anchor: Yte.point(e, t, {
        edge: "end"
      }),
      focus: Yte.end(e, [])
    }, {distance: a=1} = r, i = 0;
    for (var s of Yte.positions(e, Gte(Gte({}, r), {}, {
      at: o
    }))) {
      if (i > a)
        break;
      0 !== i && (n = s),
        i++
    }
    return n
  },
  before(e, t) {
    var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o = {
      anchor: Yte.start(e, []),
      focus: Yte.point(e, t, {
        edge: "start"
      })
    }, {distance: a=1} = r, i = 0;
    for (var s of Yte.positions(e, Gte(Gte({}, r), {}, {
      at: o,
      reverse: !0
    }))) {
      if (i > a)
        break;
      0 !== i && (n = s),
        i++
    }
    return n
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {unit: n="character"} = t;
    e.deleteBackward(n)
  },
  deleteForward(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {unit: n="character"} = t;
    e.deleteForward(n)
  },
  deleteFragment(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {direction: n="forward"} = t;
    e.deleteFragment(n)
  },
  edges: (e,t)=>[Yte.start(e, t), Yte.end(e, t)],
  end: (e,t)=>Yte.point(e, t, {
    edge: "end"
  }),
  first(e, t) {
    var n = Yte.path(e, t, {
      edge: "start"
    });
    return Yte.node(e, n)
  },
  fragment(e, t) {
    var n = Yte.range(e, t);
    return ene.fragment(e, n)
  },
  hasBlocks: (e,t)=>t.children.some((t=>Yte.isBlock(e, t))),
  hasInlines: (e,t)=>t.children.some((t=>bne.isText(t) || Yte.isInline(e, t))),
  hasTexts: (e,t)=>t.children.every((e=>bne.isText(e))),
  insertBreak(e) {
    e.insertBreak()
  },
  insertFragment(e, t) {
    e.insertFragment(t)
  },
  insertNode(e, t) {
    e.insertNode(t)
  },
  insertText(e, t) {
    e.insertText(t)
  },
  isBlock: (e,t)=>Hte.isElement(t) && !e.isInline(t),
  isEditor(e) {
    if (!aee(e))
      return !1;
    var t = qte.get(e);
    if (void 0 !== t)
      return t;
    var n = "function" == typeof e.addMark && "function" == typeof e.apply && "function" == typeof e.deleteBackward && "function" == typeof e.deleteForward && "function" == typeof e.deleteFragment && "function" == typeof e.insertBreak && "function" == typeof e.insertFragment && "function" == typeof e.insertNode && "function" == typeof e.insertText && "function" == typeof e.isInline && "function" == typeof e.isVoid && "function" == typeof e.normalizeNode && "function" == typeof e.onChange && "function" == typeof e.removeMark && (null === e.marks || aee(e.marks)) && (null === e.selection || fne.isRange(e.selection)) && ene.isNodeList(e.children) && rne.isOperationList(e.operations);
    return qte.set(e, n),
      n
  },
  isEnd(e, t, n) {
    var r = Yte.end(e, n);
    return lne.equals(t, r)
  },
  isEdge: (e,t,n)=>Yte.isStart(e, t, n) || Yte.isEnd(e, t, n),
  isEmpty(e, t) {
    var {children: n} = t
      , [r] = n;
    return 0 === n.length || 1 === n.length && bne.isText(r) && "" === r.text && !e.isVoid(t)
  },
  isInline: (e,t)=>Hte.isElement(t) && e.isInline(t),
  isNormalizing(e) {
    var t = ite.get(e);
    return void 0 === t || t
  },
  isStart(e, t, n) {
    if (0 !== t.offset)
      return !1;
    var r = Yte.start(e, n);
    return lne.equals(t, r)
  },
  isVoid: (e,t)=>Hte.isElement(t) && e.isVoid(t),
  last(e, t) {
    var n = Yte.path(e, t, {
      edge: "end"
    });
    return Yte.node(e, n)
  },
  leaf(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , r = Yte.path(e, t, n);
    return [ene.leaf(e, r), r]
  },
  *levels(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {at: n=e.selection, reverse: r=!1, voids: o=!1} = t
      , {match: a} = t;
    if (null == a && (a = ()=>!0),
      n) {
      var i = []
        , s = Yte.path(e, n);
      for (var [l,u] of ene.levels(e, s))
        if (a(l, u) && (i.push([l, u]),
        !o && Yte.isVoid(e, l)))
          break;
      r && i.reverse(),
        yield*i
    }
  },
  marks(e) {
    var {marks: t, selection: n} = e;
    if (!n)
      return null;
    if (t)
      return t;
    if (fne.isExpanded(n)) {
      var [r] = Yte.nodes(e, {
        match: bne.isText
      });
      if (r) {
        var [o] = r;
        return hte(o, zte)
      }
      return {}
    }
    var {anchor: a} = n
      , {path: i} = a
      , [s] = Yte.leaf(e, i);
    if (0 === a.offset) {
      var l = Yte.previous(e, {
        at: i,
        match: bne.isText
      })
        , u = Yte.above(e, {
        match: t=>Yte.isBlock(e, t)
      });
      if (l && u) {
        var [c,d] = l
          , [,f] = u;
        one.isAncestor(f, d) && (s = c)
      }
    }
    return hte(s, Kte)
  },
  next(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {mode: n="lowest", voids: r=!1} = t
      , {match: o, at: a=e.selection} = t;
    if (a) {
      var i = Yte.after(e, a, {
        voids: r
      });
      if (i) {
        var [,s] = Yte.last(e, [])
          , l = [i.path, s];
        if (one.isPath(a) && 0 === a.length)
          throw new Error("Cannot get the next node from the root node!");
        if (null == o)
          if (one.isPath(a)) {
            var [u] = Yte.parent(e, a);
            o = e=>u.children.includes(e)
          } else
            o = ()=>!0;
        var [c] = Yte.nodes(e, {
          at: l,
          match: o,
          mode: n,
          voids: r
        });
        return c
      }
    }
  },
  node(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , r = Yte.path(e, t, n);
    return [ene.get(e, r), r]
  },
  *nodes(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {at: n=e.selection, mode: r="all", universal: o=!1, reverse: a=!1, voids: i=!1} = t
      , {match: s} = t;
    if (s || (s = ()=>!0),
      n) {
      var l, u;
      if (Xte.isSpan(n))
        l = n[0],
          u = n[1];
      else {
        var c = Yte.path(e, n, {
          edge: "start"
        })
          , d = Yte.path(e, n, {
          edge: "end"
        });
        l = a ? d : c,
          u = a ? c : d
      }
      var f, p = ene.nodes(e, {
        reverse: a,
        from: l,
        to: u,
        pass: t=>{
          var [n] = t;
          return !i && Yte.isVoid(e, n)
        }
      }), h = [];
      for (var [v,g] of p) {
        var m = f && 0 === one.compare(g, f[1]);
        if ("highest" !== r || !m)
          if (s(v, g))
            if ("lowest" === r && m)
              f = [v, g];
            else {
              var y = "lowest" === r ? f : [v, g];
              y && (o ? h.push(y) : yield y),
                f = [v, g]
            }
          else if (o && !m && bne.isText(v))
            return
      }
      "lowest" === r && f && (o ? h.push(f) : yield f),
      o && (yield*h)
    }
  },
  normalize(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {force: n=!1} = t
      , r = e=>ote.get(e) || [];
    if (Yte.isNormalizing(e)) {
      if (n) {
        var o = Array.from(ene.nodes(e), (e=>{
            var [,t] = e;
            return t
          }
        ));
        ote.set(e, o)
      }
      0 !== r(e).length && Yte.withoutNormalizing(e, (()=>{
          for (var t of r(e))
            if (ene.has(e, t)) {
              var n = Yte.node(e, t)
                , [o,a] = n;
              Hte.isElement(o) && 0 === o.children.length && e.normalizeNode(n)
            }
          for (var i = 42 * r(e).length, s = 0; 0 !== r(e).length; ) {
            if (s > i)
              throw new Error("\n            Could not completely normalize the editor after ".concat(i, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          "));
            var l = r(e).pop();
            if (ene.has(e, l)) {
              var u = Yte.node(e, l);
              e.normalizeNode(u)
            }
            s++
          }
        }
      ))
    }
  },
  parent(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , r = Yte.path(e, t, n)
      , o = one.parent(r);
    return Yte.node(e, o)
  },
  path(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , {depth: r, edge: o} = n;
    if (one.isPath(t))
      if ("start" === o) {
        var [,a] = ene.first(e, t);
        t = a
      } else if ("end" === o) {
        var [,i] = ene.last(e, t);
        t = i
      }
    return fne.isRange(t) && (t = "start" === o ? fne.start(t) : "end" === o ? fne.end(t) : one.common(t.anchor.path, t.focus.path)),
    lne.isPoint(t) && (t = t.path),
    null != r && (t = t.slice(0, r)),
      t
  },
  hasPath: (e,t)=>ene.has(e, t),
  pathRef(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , {affinity: r="forward"} = n
      , o = {
      current: t,
      affinity: r,
      unref() {
        var {current: t} = o;
        return Yte.pathRefs(e).delete(o),
          o.current = null,
          t
      }
    };
    return Yte.pathRefs(e).add(o),
      o
  },
  pathRefs(e) {
    var t = ste.get(e);
    return t || (t = new Set,
      ste.set(e, t)),
      t
  },
  point(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , {edge: r="start"} = n;
    if (one.isPath(t)) {
      var o;
      if ("end" === r) {
        var [,a] = ene.last(e, t);
        o = a
      } else {
        var [,i] = ene.first(e, t);
        o = i
      }
      var s = ene.get(e, o);
      if (!bne.isText(s))
        throw new Error("Cannot get the ".concat(r, " point in the node at path [").concat(t, "] because it has no ").concat(r, " text node."));
      return {
        path: o,
        offset: "end" === r ? s.text.length : 0
      }
    }
    if (fne.isRange(t)) {
      var [l,u] = fne.edges(t);
      return "start" === r ? l : u
    }
    return t
  },
  pointRef(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , {affinity: r="forward"} = n
      , o = {
      current: t,
      affinity: r,
      unref() {
        var {current: t} = o;
        return Yte.pointRefs(e).delete(o),
          o.current = null,
          t
      }
    };
    return Yte.pointRefs(e).add(o),
      o
  },
  pointRefs(e) {
    var t = lte.get(e);
    return t || (t = new Set,
      lte.set(e, t)),
      t
  },
  *positions(e) {
    var t, n, r, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, {at: a=e.selection, unit: i="offset", reverse: s=!1, voids: l=!1} = o;
    if (a) {
      var u = Yte.range(e, a)
        , [c,d] = fne.edges(u)
        , f = s ? d : c
        , p = !1
        , h = ""
        , v = 0
        , g = 0
        , m = 0;
      for (var [y,b] of Yte.nodes(e, {
        at: a,
        reverse: s,
        voids: l
      })) {
        if (Hte.isElement(y)) {
          if (!l && e.isVoid(y)) {
            yield Yte.start(e, b);
            continue
          }
          if (e.isInline(y))
            continue;
          if (Yte.hasInlines(e, y)) {
            var w = one.isAncestor(b, d.path) ? d : Yte.end(e, b)
              , x = one.isAncestor(b, c.path) ? c : Yte.start(e, b);
            h = Yte.string(e, {
              anchor: x,
              focus: w
            }, {
              voids: l
            }),
              p = !0
          }
        }
        if (bne.isText(y)) {
          var S = one.equals(b, f.path);
          for (S ? (g = s ? f.offset : y.text.length - f.offset,
            m = f.offset) : (g = y.text.length,
            m = s ? g : 0),
               (S || p || "offset" === i) && (yield{
                 path: b,
                 offset: m
               },
                 p = !1); ; ) {
            if (0 === v) {
              if ("" === h)
                break;
              t = h,
                r = s,
                v = "character" === (n = i) ? gte(t, r) : "word" === n ? function(e) {
                  for (var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = 0, r = !1; e.length > 0; ) {
                    var o = gte(e, t)
                      , [a,i] = wte(e, o, t);
                    if (xte(a, i, t))
                      r = !0,
                        n += o;
                    else {
                      if (r)
                        break;
                      n += o
                    }
                    e = i
                  }
                  return n
                }(t, r) : "line" === n || "block" === n ? t.length : 1,
                h = wte(h, v, s)[1]
            }
            if (m = s ? m - v : m + v,
            (g -= v) < 0) {
              v = -g;
              break
            }
            v = 0,
              yield{
                path: b,
                offset: m
              }
          }
        }
      }
    }
  },
  previous(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {mode: n="lowest", voids: r=!1} = t
      , {match: o, at: a=e.selection} = t;
    if (a) {
      var i = Yte.before(e, a, {
        voids: r
      });
      if (i) {
        var [,s] = Yte.first(e, [])
          , l = [i.path, s];
        if (one.isPath(a) && 0 === a.length)
          throw new Error("Cannot get the previous node from the root node!");
        if (null == o)
          if (one.isPath(a)) {
            var [u] = Yte.parent(e, a);
            o = e=>u.children.includes(e)
          } else
            o = ()=>!0;
        var [c] = Yte.nodes(e, {
          reverse: !0,
          at: l,
          match: o,
          mode: n,
          voids: r
        });
        return c
      }
    }
  },
  range: (e,t,n)=>fne.isRange(t) && !n ? t : {
    anchor: Yte.start(e, t),
    focus: Yte.end(e, n || t)
  },
  rangeRef(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , {affinity: r="forward"} = n
      , o = {
      current: t,
      affinity: r,
      unref() {
        var {current: t} = o;
        return Yte.rangeRefs(e).delete(o),
          o.current = null,
          t
      }
    };
    return Yte.rangeRefs(e).add(o),
      o
  },
  rangeRefs(e) {
    var t = ute.get(e);
    return t || (t = new Set,
      ute.set(e, t)),
      t
  },
  removeMark(e, t) {
    e.removeMark(t)
  },
  setNormalizing(e, t) {
    ite.set(e, t)
  },
  start: (e,t)=>Yte.point(e, t, {
    edge: "start"
  }),
  string(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , {voids: r=!1} = n
      , o = Yte.range(e, t)
      , [a,i] = fne.edges(o)
      , s = "";
    for (var [l,u] of Yte.nodes(e, {
      at: o,
      match: bne.isText,
      voids: r
    })) {
      var c = l.text;
      one.equals(u, i.path) && (c = c.slice(0, i.offset)),
      one.equals(u, a.path) && (c = c.slice(a.offset)),
        s += c
    }
    return s
  },
  unhangRange(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , {voids: r=!1} = n
      , [o,a] = fne.edges(t);
    if (0 !== o.offset || 0 !== a.offset || fne.isCollapsed(t))
      return t;
    var i = Yte.above(e, {
      at: a,
      match: t=>Yte.isBlock(e, t)
    })
      , s = i ? i[1] : []
      , l = {
      anchor: Yte.start(e, []),
      focus: a
    }
      , u = !0;
    for (var [c,d] of Yte.nodes(e, {
      at: l,
      match: bne.isText,
      reverse: !0,
      voids: r
    }))
      if (u)
        u = !1;
      else if ("" !== c.text || one.isBefore(d, s)) {
        a = {
          path: d,
          offset: c.text.length
        };
        break
      }
    return {
      anchor: o,
      focus: a
    }
  },
  void(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return Yte.above(e, Gte(Gte({}, t), {}, {
      match: t=>Yte.isVoid(e, t)
    }))
  },
  withoutNormalizing(e, t) {
    var n = Yte.isNormalizing(e);
    Yte.setNormalizing(e, !1);
    try {
      t()
    } finally {
      Yte.setNormalizing(e, n)
    }
    Yte.normalize(e)
  }
}
  , Xte = {
  isSpan: e=>Array.isArray(e) && 2 === e.length && e.every(one.isPath)
}
  , Qte = ["children"]
  , Jte = ["text"]
  , Zte = new WeakMap
  , ene = {
  ancestor(e, t) {
    var n = ene.get(e, t);
    if (bne.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(n));
    return n
  },
  *ancestors(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    for (var r of one.ancestors(t, n)) {
      var o = [ene.ancestor(e, r), r];
      yield o
    }
  },
  child(e, t) {
    if (bne.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(JSON.stringify(e)));
    var n = e.children[t];
    if (null == n)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(JSON.stringify(e)));
    return n
  },
  *children(e, t) {
    for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, {reverse: r=!1} = n, o = ene.ancestor(e, t), {children: a} = o, i = r ? a.length - 1 : 0; r ? i >= 0 : i < a.length; ) {
      var s = ene.child(o, i)
        , l = t.concat(i);
      yield[s, l],
        i = r ? i - 1 : i + 1
    }
  },
  common(e, t, n) {
    var r = one.common(t, n);
    return [ene.get(e, r), r]
  },
  descendant(e, t) {
    var n = ene.get(e, t);
    if (Yte.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(n));
    return n
  },
  *descendants(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    for (var [n,r] of ene.nodes(e, t))
      0 !== r.length && (yield[n, r])
  },
  *elements(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    for (var [n,r] of ene.nodes(e, t))
      Hte.isElement(n) && (yield[n, r])
  },
  extractProps: e=>Hte.isAncestor(e) ? hte(e, Qte) : hte(e, Jte),
  first(e, t) {
    for (var n = t.slice(), r = ene.get(e, n); r && !bne.isText(r) && 0 !== r.children.length; )
      r = r.children[0],
        n.push(0);
    return [r, n]
  },
  fragment(e, t) {
    if (bne.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(JSON.stringify(e)));
    var n = ete({
      children: e.children
    }, (e=>{
        var [n,r] = fne.edges(t)
          , o = ene.nodes(e, {
          reverse: !0,
          pass: e=>{
            var [,n] = e;
            return !fne.includes(t, n)
          }
        });
        for (var [,a] of o) {
          if (!fne.includes(t, a)) {
            var i = ene.parent(e, a)
              , s = a[a.length - 1];
            i.children.splice(s, 1)
          }
          if (one.equals(a, r.path)) {
            var l = ene.leaf(e, a);
            l.text = l.text.slice(0, r.offset)
          }
          if (one.equals(a, n.path)) {
            var u = ene.leaf(e, a);
            u.text = u.text.slice(n.offset)
          }
        }
        Yte.isEditor(e) && (e.selection = null)
      }
    ));
    return n.children
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (bne.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(JSON.stringify(e)));
      n = n.children[o]
    }
    return n
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (bne.isText(n) || !n.children[o])
        return !1;
      n = n.children[o]
    }
    return !0
  },
  isNode: e=>bne.isText(e) || Hte.isElement(e) || Yte.isEditor(e),
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Zte.get(e);
    if (void 0 !== t)
      return t;
    var n = e.every((e=>ene.isNode(e)));
    return Zte.set(e, n),
      n
  },
  last(e, t) {
    for (var n = t.slice(), r = ene.get(e, n); r && !bne.isText(r) && 0 !== r.children.length; ) {
      var o = r.children.length - 1;
      r = r.children[o],
        n.push(o)
    }
    return [r, n]
  },
  leaf(e, t) {
    var n = ene.get(e, t);
    if (!bne.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(n));
    return n
  },
  *levels(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    for (var r of one.levels(t, n)) {
      var o = ene.get(e, r);
      yield[o, r]
    }
  },
  matches: (e,t)=>Hte.isElement(e) && Hte.isElementProps(t) && Hte.matches(e, t) || bne.isText(e) && bne.isTextProps(t) && bne.matches(e, t),
  *nodes(e) {
    for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, {pass: n, reverse: r=!1} = t, {from: o=[], to: a} = t, i = new Set, s = [], l = e; !a || !(r ? one.isBefore(s, a) : one.isAfter(s, a)); )
      if (i.has(l) || (yield[l, s]),
      i.has(l) || bne.isText(l) || 0 === l.children.length || null != n && !1 !== n([l, s])) {
        if (0 === s.length)
          break;
        if (!r) {
          var u = one.next(s);
          if (ene.has(e, u)) {
            s = u,
              l = ene.get(e, s);
            continue
          }
        }
        r && 0 !== s[s.length - 1] ? (s = one.previous(s),
          l = ene.get(e, s)) : (s = one.parent(s),
          l = ene.get(e, s),
          i.add(l))
      } else {
        i.add(l);
        var c = r ? l.children.length - 1 : 0;
        one.isAncestor(s, o) && (c = o[s.length]),
          s = s.concat(c),
          l = ene.get(e, s)
      }
  },
  parent(e, t) {
    var n = one.parent(t)
      , r = ene.get(e, n);
    if (bne.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r
  },
  string: e=>bne.isText(e) ? e.text : e.children.map(ene.string).join(""),
  *texts(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    for (var [n,r] of ene.nodes(e, t))
      bne.isText(n) && (yield[n, r])
  }
};
function tne(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
function nne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {};
    t % 2 ? tne(Object(n), !0).forEach((function(t) {
        rte(e, t, n[t])
      }
    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tne(Object(n)).forEach((function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      }
    ))
  }
  return e
}
var rne = {
  isNodeOperation: e=>rne.isOperation(e) && e.type.endsWith("_node"),
  isOperation(e) {
    if (!aee(e))
      return !1;
    switch (e.type) {
      case "insert_node":
      case "remove_node":
        return one.isPath(e.path) && ene.isNode(e.node);
      case "insert_text":
      case "remove_text":
        return "number" == typeof e.offset && "string" == typeof e.text && one.isPath(e.path);
      case "merge_node":
        return "number" == typeof e.position && one.isPath(e.path) && aee(e.properties);
      case "move_node":
        return one.isPath(e.path) && one.isPath(e.newPath);
      case "set_node":
        return one.isPath(e.path) && aee(e.properties) && aee(e.newProperties);
      case "set_selection":
        return null === e.properties && fne.isRange(e.newProperties) || null === e.newProperties && fne.isRange(e.properties) || aee(e.properties) && aee(e.newProperties);
      case "split_node":
        return one.isPath(e.path) && "number" == typeof e.position && aee(e.properties);
      default:
        return !1
    }
  },
  isOperationList: e=>Array.isArray(e) && e.every((e=>rne.isOperation(e))),
  isSelectionOperation: e=>rne.isOperation(e) && e.type.endsWith("_selection"),
  isTextOperation: e=>rne.isOperation(e) && e.type.endsWith("_text"),
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return nne(nne({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return nne(nne({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return nne(nne({}, e), {}, {
          type: "split_node",
          path: one.previous(e.path)
        });
      case "move_node":
        var {newPath: t, path: n} = e;
        if (one.equals(t, n))
          return e;
        if (one.isSibling(n, t))
          return nne(nne({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = one.transform(n, e)
          , o = one.transform(one.next(n), e);
        return nne(nne({}, e), {}, {
          path: r,
          newPath: o
        });
      case "remove_node":
        return nne(nne({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return nne(nne({}, e), {}, {
          type: "insert_text"
        });
      case "set_node":
        var {properties: a, newProperties: i} = e;
        return nne(nne({}, e), {}, {
          properties: i,
          newProperties: a
        });
      case "set_selection":
        var {properties: s, newProperties: l} = e;
        return nne(nne({}, e), {}, null == s ? {
          properties: l,
          newProperties: null
        } : null == l ? {
          properties: null,
          newProperties: s
        } : {
          properties: l,
          newProperties: s
        });
      case "split_node":
        return nne(nne({}, e), {}, {
          type: "merge_node",
          path: one.next(e.path)
        })
    }
  }
}
  , one = {
  ancestors(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {reverse: n=!1} = t
      , r = one.levels(e, t);
    return n ? r.slice(1) : r.slice(0, -1)
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r];
      if (o !== t[r])
        break;
      n.push(o)
    }
    return n
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r])
        return -1;
      if (e[r] > t[r])
        return 1
    }
    return 0
  },
  endsAfter(e, t) {
    var n = e.length - 1
      , r = e.slice(0, n)
      , o = t.slice(0, n)
      , a = e[n]
      , i = t[n];
    return one.equals(r, o) && a > i
  },
  endsAt(e, t) {
    var n = e.length
      , r = e.slice(0, n)
      , o = t.slice(0, n);
    return one.equals(r, o)
  },
  endsBefore(e, t) {
    var n = e.length - 1
      , r = e.slice(0, n)
      , o = t.slice(0, n)
      , a = e[n]
      , i = t[n];
    return one.equals(r, o) && a < i
  },
  equals: (e,t)=>e.length === t.length && e.every(((e,n)=>e === t[n])),
  hasPrevious: e=>e[e.length - 1] > 0,
  isAfter: (e,t)=>1 === one.compare(e, t),
  isAncestor: (e,t)=>e.length < t.length && 0 === one.compare(e, t),
  isBefore: (e,t)=>-1 === one.compare(e, t),
  isChild: (e,t)=>e.length === t.length + 1 && 0 === one.compare(e, t),
  isCommon: (e,t)=>e.length <= t.length && 0 === one.compare(e, t),
  isDescendant: (e,t)=>e.length > t.length && 0 === one.compare(e, t),
  isParent: (e,t)=>e.length + 1 === t.length && 0 === one.compare(e, t),
  isPath: e=>Array.isArray(e) && (0 === e.length || "number" == typeof e[0]),
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1)
      , r = t.slice(0, -1);
    return e[e.length - 1] !== t[t.length - 1] && one.equals(n, r)
  },
  levels(e) {
    for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, {reverse: n=!1} = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(),
      r
  },
  next(e) {
    if (0 === e.length)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1)
  },
  parent(e) {
    if (0 === e.length)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1)
  },
  previous(e) {
    if (0 === e.length)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1)
  },
  relative(e, t) {
    if (!one.isAncestor(t, e) && !one.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length)
  },
  transform(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return ete(e, (r=>{
        var {affinity: o="forward"} = n;
        if (e && 0 !== (null == e ? void 0 : e.length)) {
          if (null === r)
            return null;
          switch (t.type) {
            case "insert_node":
              var {path: a} = t;
              (one.equals(a, r) || one.endsBefore(a, r) || one.isAncestor(a, r)) && (r[a.length - 1] += 1);
              break;
            case "remove_node":
              var {path: i} = t;
              if (one.equals(i, r) || one.isAncestor(i, r))
                return null;
              one.endsBefore(i, r) && (r[i.length - 1] -= 1);
              break;
            case "merge_node":
              var {path: s, position: l} = t;
              one.equals(s, r) || one.endsBefore(s, r) ? r[s.length - 1] -= 1 : one.isAncestor(s, r) && (r[s.length - 1] -= 1,
                r[s.length] += l);
              break;
            case "split_node":
              var {path: u, position: c} = t;
              if (one.equals(u, r)) {
                if ("forward" === o)
                  r[r.length - 1] += 1;
                else if ("backward" !== o)
                  return null
              } else
                one.endsBefore(u, r) ? r[u.length - 1] += 1 : one.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1,
                  r[u.length] -= c);
              break;
            case "move_node":
              var {path: d, newPath: f} = t;
              if (one.equals(d, f))
                return;
              if (one.isAncestor(d, r) || one.equals(d, r)) {
                var p = f.slice();
                return one.endsBefore(d, f) && d.length < f.length && (p[d.length - 1] -= 1),
                  p.concat(r.slice(d.length))
              }
              one.isSibling(d, f) && (one.isAncestor(f, r) || one.equals(f, r)) ? one.endsBefore(d, r) ? r[d.length - 1] -= 1 : r[d.length - 1] += 1 : one.endsBefore(f, r) || one.equals(f, r) || one.isAncestor(f, r) ? (one.endsBefore(d, r) && (r[d.length - 1] -= 1),
                r[f.length - 1] += 1) : one.endsBefore(d, r) && (one.equals(f, r) && (r[f.length - 1] += 1),
                r[d.length - 1] -= 1)
          }
        }
      }
    ))
  }
}
  , ane = {
  transform(e, t) {
    var {current: n, affinity: r} = e;
    if (null != n) {
      var o = one.transform(n, t, {
        affinity: r
      });
      e.current = o,
      null == o && e.unref()
    }
  }
};
function ine(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
function sne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {};
    t % 2 ? ine(Object(n), !0).forEach((function(t) {
        rte(e, t, n[t])
      }
    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ine(Object(n)).forEach((function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      }
    ))
  }
  return e
}
var lne = {
  compare(e, t) {
    var n = one.compare(e.path, t.path);
    return 0 === n ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n
  },
  isAfter: (e,t)=>1 === lne.compare(e, t),
  isBefore: (e,t)=>-1 === lne.compare(e, t),
  equals: (e,t)=>e.offset === t.offset && one.equals(e.path, t.path),
  isPoint: e=>aee(e) && "number" == typeof e.offset && one.isPath(e.path),
  transform(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return ete(e, (e=>{
        if (null === e)
          return null;
        var {affinity: r="forward"} = n
          , {path: o, offset: a} = e;
        switch (t.type) {
          case "insert_node":
          case "move_node":
            e.path = one.transform(o, t, n);
            break;
          case "insert_text":
            one.equals(t.path, o) && t.offset <= a && (e.offset += t.text.length);
            break;
          case "merge_node":
            one.equals(t.path, o) && (e.offset += t.position),
              e.path = one.transform(o, t, n);
            break;
          case "remove_text":
            one.equals(t.path, o) && t.offset <= a && (e.offset -= Math.min(a - t.offset, t.text.length));
            break;
          case "remove_node":
            if (one.equals(t.path, o) || one.isAncestor(t.path, o))
              return null;
            e.path = one.transform(o, t, n);
            break;
          case "split_node":
            if (one.equals(t.path, o)) {
              if (t.position === a && null == r)
                return null;
              (t.position < a || t.position === a && "forward" === r) && (e.offset -= t.position,
                e.path = one.transform(o, t, sne(sne({}, n), {}, {
                  affinity: "forward"
                })))
            } else
              e.path = one.transform(o, t, n)
        }
      }
    ))
  }
}
  , une = {
  transform(e, t) {
    var {current: n, affinity: r} = e;
    if (null != n) {
      var o = lne.transform(n, t, {
        affinity: r
      });
      e.current = o,
      null == o && e.unref()
    }
  }
}
  , cne = ["anchor", "focus"];
function dne(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
var fne = {
  edges(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {reverse: n=!1} = t
      , {anchor: r, focus: o} = e;
    return fne.isBackward(e) === n ? [r, o] : [o, r]
  },
  end(e) {
    var [,t] = fne.edges(e);
    return t
  },
  equals: (e,t)=>lne.equals(e.anchor, t.anchor) && lne.equals(e.focus, t.focus),
  includes(e, t) {
    if (fne.isRange(t)) {
      if (fne.includes(e, t.anchor) || fne.includes(e, t.focus))
        return !0;
      var [n,r] = fne.edges(e)
        , [o,a] = fne.edges(t);
      return lne.isBefore(n, o) && lne.isAfter(r, a)
    }
    var [i,s] = fne.edges(e)
      , l = !1
      , u = !1;
    return lne.isPoint(t) ? (l = lne.compare(t, i) >= 0,
      u = lne.compare(t, s) <= 0) : (l = one.compare(t, i.path) >= 0,
      u = one.compare(t, s.path) <= 0),
    l && u
  },
  intersection(e, t) {
    var n = hte(e, cne)
      , [r,o] = fne.edges(e)
      , [a,i] = fne.edges(t)
      , s = lne.isBefore(r, a) ? a : r
      , l = lne.isBefore(o, i) ? o : i;
    return lne.isBefore(l, s) ? null : function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? dne(Object(n), !0).forEach((function(t) {
            rte(e, t, n[t])
          }
        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dne(Object(n)).forEach((function(t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
          }
        ))
      }
      return e
    }({
      anchor: s,
      focus: l
    }, n)
  },
  isBackward(e) {
    var {anchor: t, focus: n} = e;
    return lne.isAfter(t, n)
  },
  isCollapsed(e) {
    var {anchor: t, focus: n} = e;
    return lne.equals(t, n)
  },
  isExpanded: e=>!fne.isCollapsed(e),
  isForward: e=>!fne.isBackward(e),
  isRange: e=>aee(e) && lne.isPoint(e.anchor) && lne.isPoint(e.focus),
  *points(e) {
    yield[e.anchor, "anchor"],
      yield[e.focus, "focus"]
  },
  start(e) {
    var [t] = fne.edges(e);
    return t
  },
  transform(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return ete(e, (e=>{
        if (null === e)
          return null;
        var r, o, {affinity: a="inward"} = n;
        if ("inward" === a) {
          var i = fne.isCollapsed(e);
          fne.isForward(e) ? (r = "forward",
            o = i ? r : "backward") : (r = "backward",
            o = i ? r : "forward")
        } else
          "outward" === a ? fne.isForward(e) ? (r = "backward",
            o = "forward") : (r = "forward",
            o = "backward") : (r = a,
            o = a);
        var s = lne.transform(e.anchor, t, {
          affinity: r
        })
          , l = lne.transform(e.focus, t, {
          affinity: o
        });
        if (!s || !l)
          return null;
        e.anchor = s,
          e.focus = l
      }
    ))
  }
}
  , pne = {
  transform(e, t) {
    var {current: n, affinity: r} = e;
    if (null != n) {
      var o = fne.transform(n, t, {
        affinity: r
      });
      e.current = o,
      null == o && e.unref()
    }
  }
}
  , hne = (e,t)=>{
  for (var n in e) {
    var r = e[n]
      , o = t[n];
    if (aee(r) && aee(o)) {
      if (!hne(r, o))
        return !1
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length)
        return !1;
      for (var a = 0; a < r.length; a++)
        if (r[a] !== o[a])
          return !1
    } else if (r !== o)
      return !1
  }
  for (var i in t)
    if (void 0 === e[i] && void 0 !== t[i])
      return !1;
  return !0
}
  , vne = ["text"]
  , gne = ["anchor", "focus"];
function mne(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
function yne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {};
    t % 2 ? mne(Object(n), !0).forEach((function(t) {
        rte(e, t, n[t])
      }
    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mne(Object(n)).forEach((function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      }
    ))
  }
  return e
}
var bne = {
  equals(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , {loose: r=!1} = n;
    function o(e) {
      return hte(e, vne)
    }
    return hne(r ? o(e) : e, r ? o(t) : t)
  },
  isText: e=>aee(e) && "string" == typeof e.text,
  isTextList: e=>Array.isArray(e) && e.every((e=>bne.isText(e))),
  isTextProps: e=>void 0 !== e.text,
  matches(e, t) {
    for (var n in t)
      if ("text" !== n && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0
  },
  decorations(e, t) {
    var n = [yne({}, e)];
    for (var r of t) {
      var o = hte(r, gne)
        , [a,i] = fne.edges(r)
        , s = []
        , l = 0;
      for (var u of n) {
        var {length: c} = u.text
          , d = l;
        if (l += c,
        a.offset <= d && i.offset >= l)
          Object.assign(u, o),
            s.push(u);
        else if (a.offset !== i.offset && (a.offset === l || i.offset === d) || a.offset > l || i.offset < d || i.offset === d && 0 !== d)
          s.push(u);
        else {
          var f = u
            , p = void 0
            , h = void 0;
          if (i.offset < l) {
            var v = i.offset - d;
            h = yne(yne({}, f), {}, {
              text: f.text.slice(v)
            }),
              f = yne(yne({}, f), {}, {
                text: f.text.slice(0, v)
              })
          }
          if (a.offset > d) {
            var g = a.offset - d;
            p = yne(yne({}, f), {}, {
              text: f.text.slice(0, g)
            }),
              f = yne(yne({}, f), {}, {
                text: f.text.slice(g)
              })
          }
          Object.assign(f, o),
          p && s.push(p),
            s.push(f),
          h && s.push(h)
        }
      }
      n = s
    }
    return n
  }
};
function wne(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
function xne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {};
    t % 2 ? wne(Object(n), !0).forEach((function(t) {
        rte(e, t, n[t])
      }
    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wne(Object(n)).forEach((function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      }
    ))
  }
  return e
}
var Sne = {
  transform(e, t) {
    e.children = tte(e.children);
    var n = e.selection && tte(e.selection);
    try {
      n = ((e,t,n)=>{
          switch (n.type) {
            case "insert_node":
              var {path: r, node: o} = n
                , a = ene.parent(e, r)
                , i = r[r.length - 1];
              if (i > a.children.length)
                throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
              if (a.children.splice(i, 0, o),
                t)
                for (var [s,l] of fne.points(t))
                  t[l] = lne.transform(s, n);
              break;
            case "insert_text":
              var {path: u, offset: c, text: d} = n;
              if (0 === d.length)
                break;
              var f = ene.leaf(e, u)
                , p = f.text.slice(0, c)
                , h = f.text.slice(c);
              if (f.text = p + d + h,
                t)
                for (var [v,g] of fne.points(t))
                  t[g] = lne.transform(v, n);
              break;
            case "merge_node":
              var {path: m} = n
                , y = ene.get(e, m)
                , b = one.previous(m)
                , w = ene.get(e, b)
                , x = ene.parent(e, m)
                , S = m[m.length - 1];
              if (bne.isText(y) && bne.isText(w))
                w.text += y.text;
              else {
                if (bne.isText(y) || bne.isText(w))
                  throw new Error('Cannot apply a "merge_node" operation at path ['.concat(m, "] to nodes of different interfaces: ").concat(y, " ").concat(w));
                w.children.push(...y.children)
              }
              if (x.children.splice(S, 1),
                t)
                for (var [E,A] of fne.points(t))
                  t[A] = lne.transform(E, n);
              break;
            case "move_node":
              var {path: C, newPath: k} = n;
              if (one.isAncestor(C, k))
                throw new Error("Cannot move a path [".concat(C, "] to new path [").concat(k, "] because the destination is inside itself."));
              var T = ene.get(e, C)
                , D = ene.parent(e, C)
                , O = C[C.length - 1];
              D.children.splice(O, 1);
              var _ = one.transform(C, n)
                , R = ene.get(e, one.parent(_))
                , L = _[_.length - 1];
              if (R.children.splice(L, 0, T),
                t)
                for (var [I,P] of fne.points(t))
                  t[P] = lne.transform(I, n);
              break;
            case "remove_node":
              var {path: F} = n
                , B = F[F.length - 1];
              if (ene.parent(e, F).children.splice(B, 1),
                t)
                for (var [N,M] of fne.points(t)) {
                  var j = lne.transform(N, n);
                  if (null != t && null != j)
                    t[M] = j;
                  else {
                    var V = void 0
                      , U = void 0;
                    for (var [$,H] of ene.texts(e)) {
                      if (-1 !== one.compare(H, F)) {
                        U = [$, H];
                        break
                      }
                      V = [$, H]
                    }
                    var z = !1;
                    V && U && (z = one.equals(U[1], F) ? !one.hasPrevious(U[1]) : one.common(V[1], F).length < one.common(U[1], F).length),
                      V && !z ? (N.path = V[1],
                        N.offset = V[0].text.length) : U ? (N.path = U[1],
                        N.offset = 0) : t = null
                  }
                }
              break;
            case "remove_text":
              var {path: K, offset: W, text: G} = n;
              if (0 === G.length)
                break;
              var q = ene.leaf(e, K)
                , Y = q.text.slice(0, W)
                , X = q.text.slice(W + G.length);
              if (q.text = Y + X,
                t)
                for (var [Q,J] of fne.points(t))
                  t[J] = lne.transform(Q, n);
              break;
            case "set_node":
              var {path: Z, properties: ee, newProperties: te} = n;
              if (0 === Z.length)
                throw new Error("Cannot set properties on the root node!");
              var ne = ene.get(e, Z);
              for (var re in te) {
                if ("children" === re || "text" === re)
                  throw new Error('Cannot set the "'.concat(re, '" property of nodes!'));
                var oe = te[re];
                null == oe ? delete ne[re] : ne[re] = oe
              }
              for (var ae in ee)
                te.hasOwnProperty(ae) || delete ne[ae];
              break;
            case "set_selection":
              var {newProperties: ie} = n;
              if (null == ie)
                t = ie;
              else {
                if (null == t) {
                  if (!fne.isRange(ie))
                    throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(JSON.stringify(ie), " when there is no current selection."));
                  t = xne({}, ie)
                }
                for (var se in ie) {
                  var le = ie[se];
                  if (null == le) {
                    if ("anchor" === se || "focus" === se)
                      throw new Error('Cannot remove the "'.concat(se, '" selection property'));
                    delete t[se]
                  } else
                    t[se] = le
                }
              }
              break;
            case "split_node":
              var {path: ue, position: ce, properties: de} = n;
              if (0 === ue.length)
                throw new Error('Cannot apply a "split_node" operation at path ['.concat(ue, "] because the root node cannot be split."));
              var fe, pe = ene.get(e, ue), he = ene.parent(e, ue), ve = ue[ue.length - 1];
              if (bne.isText(pe)) {
                var ge = pe.text.slice(0, ce)
                  , me = pe.text.slice(ce);
                pe.text = ge,
                  fe = xne(xne({}, de), {}, {
                    text: me
                  })
              } else {
                var ye = pe.children.slice(0, ce)
                  , be = pe.children.slice(ce);
                pe.children = ye,
                  fe = xne(xne({}, de), {}, {
                    children: be
                  })
              }
              if (he.children.splice(ve + 1, 0, fe),
                t)
                for (var [we,xe] of fne.points(t))
                  t[xe] = lne.transform(we, n)
          }
          return t
        }
      )(e, n, t)
    } finally {
      e.children = nte(e.children),
        e.selection = n ? see(n) ? nte(n) : n : null
    }
  }
}
  , Ene = ["text"]
  , Ane = ["children"];
function Cne(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
function kne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {};
    t % 2 ? Cne(Object(n), !0).forEach((function(t) {
        rte(e, t, n[t])
      }
    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Cne(Object(n)).forEach((function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      }
    ))
  }
  return e
}
var Tne = {
    insertNodes(e, t) {
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      Yte.withoutNormalizing(e, (()=>{
          var {hanging: r=!1, voids: o=!1, mode: a="lowest"} = n
            , {at: i, match: s, select: l} = n;
          if (ene.isNode(t) && (t = [t]),
          0 !== t.length) {
            var [u] = t;
            if (i || (i = e.selection ? e.selection : e.children.length > 0 ? Yte.end(e, []) : [0],
              l = !0),
            null == l && (l = !1),
              fne.isRange(i))
              if (r || (i = Yte.unhangRange(e, i)),
                fne.isCollapsed(i))
                i = i.anchor;
              else {
                var [,c] = fne.edges(i)
                  , d = Yte.pointRef(e, c);
                Nne.delete(e, {
                  at: i
                }),
                  i = d.unref()
              }
            if (lne.isPoint(i)) {
              null == s && (s = bne.isText(u) ? e=>bne.isText(e) : e.isInline(u) ? t=>bne.isText(t) || Yte.isInline(e, t) : t=>Yte.isBlock(e, t));
              var [f] = Yte.nodes(e, {
                at: i.path,
                match: s,
                mode: a,
                voids: o
              });
              if (!f)
                return;
              var [,p] = f
                , h = Yte.pathRef(e, p)
                , v = Yte.isEnd(e, i, p);
              Nne.splitNodes(e, {
                at: i,
                match: s,
                mode: a,
                voids: o
              });
              var g = h.unref();
              i = v ? one.next(g) : g
            }
            var m = one.parent(i)
              , y = i[i.length - 1];
            if (o || !Yte.void(e, {
              at: m
            })) {
              for (var b of t) {
                var w = m.concat(y);
                y++,
                  e.apply({
                    type: "insert_node",
                    path: w,
                    node: b
                  }),
                  i = one.next(i)
              }
              if (i = one.previous(i),
                l) {
                var x = Yte.end(e, i);
                x && Nne.select(e, x)
              }
            }
          }
        }
      ))
    },
    liftNodes(e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      Yte.withoutNormalizing(e, (()=>{
          var {at: n=e.selection, mode: r="lowest", voids: o=!1} = t
            , {match: a} = t;
          if (null == a && (a = one.isPath(n) ? _ne(e, n) : t=>Yte.isBlock(e, t)),
            n) {
            var i = Yte.nodes(e, {
              at: n,
              match: a,
              mode: r,
              voids: o
            })
              , s = Array.from(i, (t=>{
                var [,n] = t;
                return Yte.pathRef(e, n)
              }
            ));
            for (var l of s) {
              var u = l.unref();
              if (u.length < 2)
                throw new Error("Cannot lift node at a path [".concat(u, "] because it has a depth of less than `2`."));
              var c = Yte.node(e, one.parent(u))
                , [d,f] = c
                , p = u[u.length - 1]
                , {length: h} = d.children;
              if (1 === h) {
                var v = one.next(f);
                Nne.moveNodes(e, {
                  at: u,
                  to: v,
                  voids: o
                }),
                  Nne.removeNodes(e, {
                    at: f,
                    voids: o
                  })
              } else if (0 === p)
                Nne.moveNodes(e, {
                  at: u,
                  to: f,
                  voids: o
                });
              else if (p === h - 1) {
                var g = one.next(f);
                Nne.moveNodes(e, {
                  at: u,
                  to: g,
                  voids: o
                })
              } else {
                var m = one.next(u)
                  , y = one.next(f);
                Nne.splitNodes(e, {
                  at: m,
                  voids: o
                }),
                  Nne.moveNodes(e, {
                    at: u,
                    to: y,
                    voids: o
                  })
              }
            }
          }
        }
      ))
    },
    mergeNodes(e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      Yte.withoutNormalizing(e, (()=>{
          var {match: n, at: r=e.selection} = t
            , {hanging: o=!1, voids: a=!1, mode: i="lowest"} = t;
          if (r) {
            if (null == n)
              if (one.isPath(r)) {
                var [s] = Yte.parent(e, r);
                n = e=>s.children.includes(e)
              } else
                n = t=>Yte.isBlock(e, t);
            if (!o && fne.isRange(r) && (r = Yte.unhangRange(e, r)),
              fne.isRange(r))
              if (fne.isCollapsed(r))
                r = r.anchor;
              else {
                var [,l] = fne.edges(r)
                  , u = Yte.pointRef(e, l);
                Nne.delete(e, {
                  at: r
                }),
                  r = u.unref(),
                null == t.at && Nne.select(e, r)
              }
            var [c] = Yte.nodes(e, {
              at: r,
              match: n,
              voids: a,
              mode: i
            })
              , d = Yte.previous(e, {
              at: r,
              match: n,
              voids: a,
              mode: i
            });
            if (c && d) {
              var [f,p] = c
                , [h,v] = d;
              if (0 !== p.length && 0 !== v.length) {
                var g, m, y = one.next(v), b = one.common(p, v), w = one.isSibling(p, v), x = Array.from(Yte.levels(e, {
                  at: p
                }), (e=>{
                    var [t] = e;
                    return t
                  }
                )).slice(b.length).slice(0, -1), S = Yte.above(e, {
                  at: p,
                  mode: "highest",
                  match: t=>x.includes(t) && Dne(e, t)
                }), E = S && Yte.pathRef(e, S[1]);
                if (bne.isText(f) && bne.isText(h)) {
                  var A = hte(f, Ene);
                  m = h.text.length,
                    g = A
                } else {
                  if (!Hte.isElement(f) || !Hte.isElement(h))
                    throw new Error("Cannot merge the node at path [".concat(p, "] with the previous sibling because it is not the same kind: ").concat(JSON.stringify(f), " ").concat(JSON.stringify(h)));
                  A = hte(f, Ane),
                    m = h.children.length,
                    g = A
                }
                w || Nne.moveNodes(e, {
                  at: p,
                  to: y,
                  voids: a
                }),
                E && Nne.removeNodes(e, {
                  at: E.current,
                  voids: a
                }),
                  Hte.isElement(h) && Yte.isEmpty(e, h) || bne.isText(h) && "" === h.text && 0 !== v[v.length - 1] ? Nne.removeNodes(e, {
                    at: v,
                    voids: a
                  }) : e.apply({
                    type: "merge_node",
                    path: y,
                    position: m,
                    properties: g
                  }),
                E && E.unref()
              }
            }
          }
        }
      ))
    },
    moveNodes(e, t) {
      Yte.withoutNormalizing(e, (()=>{
          var {to: n, at: r=e.selection, mode: o="lowest", voids: a=!1} = t
            , {match: i} = t;
          if (r) {
            null == i && (i = one.isPath(r) ? _ne(e, r) : t=>Yte.isBlock(e, t));
            var s = Yte.pathRef(e, n)
              , l = Yte.nodes(e, {
              at: r,
              match: i,
              mode: o,
              voids: a
            })
              , u = Array.from(l, (t=>{
                var [,n] = t;
                return Yte.pathRef(e, n)
              }
            ));
            for (var c of u) {
              var d = c.unref()
                , f = s.current;
              0 !== d.length && e.apply({
                type: "move_node",
                path: d,
                newPath: f
              }),
              s.current && one.isSibling(f, d) && one.isAfter(f, d) && (s.current = one.next(s.current))
            }
            s.unref()
          }
        }
      ))
    },
    removeNodes(e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      Yte.withoutNormalizing(e, (()=>{
          var {hanging: n=!1, voids: r=!1, mode: o="lowest"} = t
            , {at: a=e.selection, match: i} = t;
          if (a) {
            null == i && (i = one.isPath(a) ? _ne(e, a) : t=>Yte.isBlock(e, t)),
            !n && fne.isRange(a) && (a = Yte.unhangRange(e, a));
            var s = Yte.nodes(e, {
              at: a,
              match: i,
              mode: o,
              voids: r
            })
              , l = Array.from(s, (t=>{
                var [,n] = t;
                return Yte.pathRef(e, n)
              }
            ));
            for (var u of l) {
              var c = u.unref();
              if (c) {
                var [d] = Yte.node(e, c);
                e.apply({
                  type: "remove_node",
                  path: c,
                  node: d
                })
              }
            }
          }
        }
      ))
    },
    setNodes(e, t) {
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      Yte.withoutNormalizing(e, (()=>{
          var {match: r, at: o=e.selection} = n
            , {hanging: a=!1, mode: i="lowest", split: s=!1, voids: l=!1} = n;
          if (o) {
            if (null == r && (r = one.isPath(o) ? _ne(e, o) : t=>Yte.isBlock(e, t)),
            !a && fne.isRange(o) && (o = Yte.unhangRange(e, o)),
            s && fne.isRange(o)) {
              if (fne.isCollapsed(o) && Yte.leaf(e, o.anchor)[0].text.length > 0)
                return;
              var u = Yte.rangeRef(e, o, {
                affinity: "inward"
              })
                , [c,d] = fne.edges(o)
                , f = "lowest" === i ? "lowest" : "highest"
                , p = Yte.isEnd(e, d, d.path);
              Nne.splitNodes(e, {
                at: d,
                match: r,
                mode: f,
                voids: l,
                always: !p
              });
              var h = Yte.isStart(e, c, c.path);
              Nne.splitNodes(e, {
                at: c,
                match: r,
                mode: f,
                voids: l,
                always: !h
              }),
                o = u.unref(),
              null == n.at && Nne.select(e, o)
            }
            for (var [v,g] of Yte.nodes(e, {
              at: o,
              match: r,
              mode: i,
              voids: l
            })) {
              var m = {}
                , y = {};
              if (0 !== g.length) {
                var b = !1;
                for (var w in t)
                  "children" !== w && "text" !== w && t[w] !== v[w] && (b = !0,
                  v.hasOwnProperty(w) && (m[w] = v[w]),
                  null != t[w] && (y[w] = t[w]));
                b && e.apply({
                  type: "set_node",
                  path: g,
                  properties: m,
                  newProperties: y
                })
              }
            }
          }
        }
      ))
    },
    splitNodes(e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      Yte.withoutNormalizing(e, (()=>{
          var {mode: n="lowest", voids: r=!1} = t
            , {match: o, at: a=e.selection, height: i=0, always: s=!1} = t;
          if (null == o && (o = t=>Yte.isBlock(e, t)),
          fne.isRange(a) && (a = One(e, a)),
            one.isPath(a)) {
            var l = a
              , u = Yte.point(e, l)
              , [c] = Yte.parent(e, l);
            o = e=>e === c,
              i = u.path.length - l.length + 1,
              a = u,
              s = !0
          }
          if (a) {
            var d = Yte.pointRef(e, a, {
              affinity: "backward"
            })
              , [f] = Yte.nodes(e, {
              at: a,
              match: o,
              mode: n,
              voids: r
            });
            if (f) {
              var p = Yte.void(e, {
                at: a,
                mode: "highest"
              });
              if (!r && p) {
                var [h,v] = p;
                if (Hte.isElement(h) && e.isInline(h)) {
                  var g = Yte.after(e, v);
                  if (!g) {
                    var m = one.next(v);
                    Nne.insertNodes(e, {
                      text: ""
                    }, {
                      at: m,
                      voids: r
                    }),
                      g = Yte.point(e, m)
                  }
                  a = g,
                    s = !0
                }
                i = a.path.length - v.length + 1,
                  s = !0
              }
              var y = Yte.pointRef(e, a)
                , b = a.path.length - i
                , [,w] = f
                , x = a.path.slice(0, b)
                , S = 0 === i ? a.offset : a.path[b] + 0;
              for (var [E,A] of Yte.levels(e, {
                at: x,
                reverse: !0,
                voids: r
              })) {
                var C = !1;
                if (A.length < w.length || 0 === A.length || !r && Yte.isVoid(e, E))
                  break;
                var k = d.current
                  , T = Yte.isEnd(e, k, A);
                if (s || !d || !Yte.isEdge(e, k, A)) {
                  C = !0;
                  var D = ene.extractProps(E);
                  e.apply({
                    type: "split_node",
                    path: A,
                    position: S,
                    properties: D
                  })
                }
                S = A[A.length - 1] + (C || T ? 1 : 0)
              }
              if (null == t.at) {
                var O = y.current || Yte.end(e, []);
                Nne.select(e, O)
              }
              d.unref(),
                y.unref()
            }
          }
        }
      ))
    },
    unsetNodes(e, t) {
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      Array.isArray(t) || (t = [t]);
      var r = {};
      for (var o of t)
        r[o] = null;
      Nne.setNodes(e, r, n)
    },
    unwrapNodes(e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      Yte.withoutNormalizing(e, (()=>{
          var {mode: n="lowest", split: r=!1, voids: o=!1} = t
            , {at: a=e.selection, match: i} = t;
          if (a) {
            null == i && (i = one.isPath(a) ? _ne(e, a) : t=>Yte.isBlock(e, t)),
            one.isPath(a) && (a = Yte.range(e, a));
            var s = fne.isRange(a) ? Yte.rangeRef(e, a) : null
              , l = Yte.nodes(e, {
              at: a,
              match: i,
              mode: n,
              voids: o
            })
              , u = Array.from(l, (t=>{
                var [,n] = t;
                return Yte.pathRef(e, n)
              }
            )).reverse()
              , c = function(t) {
              var n = t.unref()
                , [a] = Yte.node(e, n)
                , i = Yte.range(e, n);
              r && s && (i = fne.intersection(s.current, i)),
                Nne.liftNodes(e, {
                  at: i,
                  match: e=>Hte.isAncestor(a) && a.children.includes(e),
                  voids: o
                })
            };
            for (var d of u)
              c(d);
            s && s.unref()
          }
        }
      ))
    },
    wrapNodes(e, t) {
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      Yte.withoutNormalizing(e, (()=>{
          var {mode: r="lowest", split: o=!1, voids: a=!1} = n
            , {match: i, at: s=e.selection} = n;
          if (s) {
            if (null == i && (i = one.isPath(s) ? _ne(e, s) : e.isInline(t) ? t=>Yte.isInline(e, t) || bne.isText(t) : t=>Yte.isBlock(e, t)),
            o && fne.isRange(s)) {
              var [l,u] = fne.edges(s)
                , c = Yte.rangeRef(e, s, {
                affinity: "inward"
              });
              Nne.splitNodes(e, {
                at: u,
                match: i,
                voids: a
              }),
                Nne.splitNodes(e, {
                  at: l,
                  match: i,
                  voids: a
                }),
                s = c.unref(),
              null == n.at && Nne.select(e, s)
            }
            var d = Array.from(Yte.nodes(e, {
              at: s,
              match: e.isInline(t) ? t=>Yte.isBlock(e, t) : e=>Yte.isEditor(e),
              mode: "lowest",
              voids: a
            }));
            for (var [,f] of d) {
              var p = fne.isRange(s) ? fne.intersection(s, Yte.range(e, f)) : s;
              if (p) {
                var h = Array.from(Yte.nodes(e, {
                  at: p,
                  match: i,
                  mode: r,
                  voids: a
                }));
                if (h.length > 0)
                  if ("continue" === function() {
                    var [n] = h
                      , r = h[h.length - 1]
                      , [,o] = n
                      , [,i] = r;
                    if (0 === o.length && 0 === i.length)
                      return "continue";
                    var s = one.equals(o, i) ? one.parent(o) : one.common(o, i)
                      , l = Yte.range(e, o, i)
                      , u = Yte.node(e, s)
                      , [c] = u
                      , d = s.length + 1
                      , f = one.next(i.slice(0, d))
                      , p = kne(kne({}, t), {}, {
                      children: []
                    });
                    Nne.insertNodes(e, p, {
                      at: f,
                      voids: a
                    }),
                      Nne.moveNodes(e, {
                        at: l,
                        match: e=>Hte.isAncestor(c) && c.children.includes(e),
                        to: f.concat(0),
                        voids: a
                      })
                  }())
                    continue
              }
            }
          }
        }
      ))
    }
  }
  , Dne = (e,t)=>{
    if (Hte.isElement(t)) {
      var n = t;
      return !!Yte.isVoid(e, t) || 1 === n.children.length && Dne(e, n.children[0])
    }
    return !Yte.isEditor(t)
  }
  , One = (e,t)=>{
    if (fne.isCollapsed(t))
      return t.anchor;
    var [,n] = fne.edges(t)
      , r = Yte.pointRef(e, n);
    return Nne.delete(e, {
      at: t
    }),
      r.unref()
  }
  , _ne = (e,t)=>{
    var [n] = Yte.node(e, t);
    return e=>e === n
  }
;
function Rne(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
function Lne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {};
    t % 2 ? Rne(Object(n), !0).forEach((function(t) {
        rte(e, t, n[t])
      }
    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rne(Object(n)).forEach((function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      }
    ))
  }
  return e
}
var Ine = {
  collapse(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {edge: n="anchor"} = t
      , {selection: r} = e;
    if (r)
      if ("anchor" === n)
        Nne.select(e, r.anchor);
      else if ("focus" === n)
        Nne.select(e, r.focus);
      else if ("start" === n) {
        var [o] = fne.edges(r);
        Nne.select(e, o)
      } else if ("end" === n) {
        var [,a] = fne.edges(r);
        Nne.select(e, a)
      }
  },
  deselect(e) {
    var {selection: t} = e;
    t && e.apply({
      type: "set_selection",
      properties: t,
      newProperties: null
    })
  },
  move(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {selection: n} = e
      , {distance: r=1, unit: o="character", reverse: a=!1} = t
      , {edge: i=null} = t;
    if (n) {
      "start" === i && (i = fne.isBackward(n) ? "focus" : "anchor"),
      "end" === i && (i = fne.isBackward(n) ? "anchor" : "focus");
      var {anchor: s, focus: l} = n
        , u = {
        distance: r,
        unit: o
      }
        , c = {};
      if (null == i || "anchor" === i) {
        var d = a ? Yte.before(e, s, u) : Yte.after(e, s, u);
        d && (c.anchor = d)
      }
      if (null == i || "focus" === i) {
        var f = a ? Yte.before(e, l, u) : Yte.after(e, l, u);
        f && (c.focus = f)
      }
      Nne.setSelection(e, c)
    }
  },
  select(e, t) {
    var {selection: n} = e;
    if (t = Yte.range(e, t),
      n)
      Nne.setSelection(e, t);
    else {
      if (!fne.isRange(t))
        throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(JSON.stringify(t)));
      e.apply({
        type: "set_selection",
        properties: n,
        newProperties: t
      })
    }
  },
  setPoint(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
      , {selection: r} = e
      , {edge: o="both"} = n;
    if (r) {
      "start" === o && (o = fne.isBackward(r) ? "focus" : "anchor"),
      "end" === o && (o = fne.isBackward(r) ? "anchor" : "focus");
      var {anchor: a, focus: i} = r
        , s = "anchor" === o ? a : i;
      Nne.setSelection(e, {
        ["anchor" === o ? "anchor" : "focus"]: Lne(Lne({}, s), t)
      })
    }
  },
  setSelection(e, t) {
    var {selection: n} = e
      , r = {}
      , o = {};
    if (n) {
      for (var a in t)
        ("anchor" === a && null != t.anchor && !lne.equals(t.anchor, n.anchor) || "focus" === a && null != t.focus && !lne.equals(t.focus, n.focus) || "anchor" !== a && "focus" !== a && t[a] !== n[a]) && (r[a] = n[a],
          o[a] = t[a]);
      Object.keys(r).length > 0 && e.apply({
        type: "set_selection",
        properties: r,
        newProperties: o
      })
    }
  }
}
  , Pne = {
  delete(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    Yte.withoutNormalizing(e, (()=>{
        var {reverse: n=!1, unit: r="character", distance: o=1, voids: a=!1} = t
          , {at: i=e.selection, hanging: s=!1} = t;
        if (i) {
          if (fne.isRange(i) && fne.isCollapsed(i) && (i = i.anchor),
            lne.isPoint(i)) {
            var l = Yte.void(e, {
              at: i,
              mode: "highest"
            });
            if (!a && l) {
              var [,u] = l;
              i = u
            } else {
              var c = {
                unit: r,
                distance: o
              };
              i = {
                anchor: i,
                focus: n ? Yte.before(e, i, c) || Yte.start(e, []) : Yte.after(e, i, c) || Yte.end(e, [])
              },
                s = !0
            }
          }
          if (one.isPath(i))
            Nne.removeNodes(e, {
              at: i,
              voids: a
            });
          else if (!fne.isCollapsed(i)) {
            if (!s) {
              var [,d] = fne.edges(i)
                , f = Yte.end(e, []);
              lne.equals(d, f) || (i = Yte.unhangRange(e, i, {
                voids: a
              }))
            }
            var [p,h] = fne.edges(i)
              , v = Yte.above(e, {
              match: t=>Yte.isBlock(e, t),
              at: p,
              voids: a
            })
              , g = Yte.above(e, {
              match: t=>Yte.isBlock(e, t),
              at: h,
              voids: a
            })
              , m = v && g && !one.equals(v[1], g[1])
              , y = one.equals(p.path, h.path)
              , b = a ? null : Yte.void(e, {
              at: p,
              mode: "highest"
            })
              , w = a ? null : Yte.void(e, {
              at: h,
              mode: "highest"
            });
            if (b) {
              var x = Yte.before(e, p);
              x && v && one.isAncestor(v[1], x.path) && (p = x)
            }
            if (w) {
              var S = Yte.after(e, h);
              S && g && one.isAncestor(g[1], S.path) && (h = S)
            }
            var E, A = [];
            for (var C of Yte.nodes(e, {
              at: i,
              voids: a
            })) {
              var [k,T] = C;
              E && 0 === one.compare(T, E) || (!a && Yte.isVoid(e, k) || !one.isCommon(T, p.path) && !one.isCommon(T, h.path)) && (A.push(C),
                E = T)
            }
            var D = Array.from(A, (t=>{
                var [,n] = t;
                return Yte.pathRef(e, n)
              }
            ))
              , O = Yte.pointRef(e, p)
              , _ = Yte.pointRef(e, h);
            if (!y && !b) {
              var R = O.current
                , [L] = Yte.leaf(e, R)
                , {path: I} = R
                , {offset: P} = p
                , F = L.text.slice(P);
              F.length > 0 && e.apply({
                type: "remove_text",
                path: I,
                offset: P,
                text: F
              })
            }
            for (var B of D) {
              var N = B.unref();
              Nne.removeNodes(e, {
                at: N,
                voids: a
              })
            }
            if (!w) {
              var M = _.current
                , [j] = Yte.leaf(e, M)
                , {path: V} = M
                , U = y ? p.offset : 0
                , $ = j.text.slice(U, h.offset);
              $.length > 0 && e.apply({
                type: "remove_text",
                path: V,
                offset: U,
                text: $
              })
            }
            !y && m && _.current && O.current && Nne.mergeNodes(e, {
              at: _.current,
              hanging: !0,
              voids: a
            });
            var H = n ? O.unref() || _.unref() : _.unref() || O.unref();
            null == t.at && H && Nne.select(e, H)
          }
        }
      }
    ))
  },
  insertFragment(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    Yte.withoutNormalizing(e, (()=>{
        var {hanging: r=!1, voids: o=!1} = n
          , {at: a=e.selection} = n;
        if (t.length && a) {
          if (fne.isRange(a))
            if (r || (a = Yte.unhangRange(e, a)),
              fne.isCollapsed(a))
              a = a.anchor;
            else {
              var [,i] = fne.edges(a);
              if (!o && Yte.void(e, {
                at: i
              }))
                return;
              var s = Yte.pointRef(e, i);
              Nne.delete(e, {
                at: a
              }),
                a = s.unref()
            }
          else
            one.isPath(a) && (a = Yte.start(e, a));
          if (o || !Yte.void(e, {
            at: a
          })) {
            var l = Yte.above(e, {
              at: a,
              match: t=>Yte.isInline(e, t),
              mode: "highest",
              voids: o
            });
            if (l) {
              var [,u] = l;
              Yte.isEnd(e, a, u) ? a = Yte.after(e, u) : Yte.isStart(e, a, u) && (a = Yte.before(e, u))
            }
            var c = Yte.above(e, {
                match: t=>Yte.isBlock(e, t),
                at: a,
                voids: o
              })
              , [,d] = c
              , f = Yte.isStart(e, a, d)
              , p = Yte.isEnd(e, a, d)
              , h = f && p
              , v = !f || f && p
              , g = !p
              , [,m] = ene.first({
                children: t
              }, [])
              , [,y] = ene.last({
                children: t
              }, [])
              , b = []
              , w = t=>{
                var [n,r] = t;
                return !(0 === r.length || !h && (v && one.isAncestor(r, m) && Hte.isElement(n) && !e.isVoid(n) && !e.isInline(n) || g && one.isAncestor(r, y) && Hte.isElement(n) && !e.isVoid(n) && !e.isInline(n)))
              }
            ;
            for (var x of ene.nodes({
              children: t
            }, {
              pass: w
            }))
              w(x) && b.push(x);
            var S = []
              , E = []
              , A = []
              , C = !0
              , k = !1;
            for (var [T] of b)
              Hte.isElement(T) && !e.isInline(T) ? (C = !1,
                k = !0,
                E.push(T)) : C ? S.push(T) : A.push(T);
            var [D] = Yte.nodes(e, {
              at: a,
              match: t=>bne.isText(t) || Yte.isInline(e, t),
              mode: "highest",
              voids: o
            })
              , [,O] = D
              , _ = Yte.isStart(e, a, O)
              , R = Yte.isEnd(e, a, O)
              , L = Yte.pathRef(e, p ? one.next(d) : d)
              , I = Yte.pathRef(e, R ? one.next(O) : O)
              , P = Yte.pathRef(e, d);
            Nne.splitNodes(e, {
              at: a,
              match: t=>k ? Yte.isBlock(e, t) : bne.isText(t) || Yte.isInline(e, t),
              mode: k ? "lowest" : "highest",
              voids: o
            });
            var F = Yte.pathRef(e, !_ || _ && R ? one.next(O) : O);
            if (Nne.insertNodes(e, S, {
              at: F.current,
              match: t=>bne.isText(t) || Yte.isInline(e, t),
              mode: "highest",
              voids: o
            }),
            h && E.length && Nne.delete(e, {
              at: P.unref(),
              voids: o
            }),
              Nne.insertNodes(e, E, {
                at: L.current,
                match: t=>Yte.isBlock(e, t),
                mode: "lowest",
                voids: o
              }),
              Nne.insertNodes(e, A, {
                at: I.current,
                match: t=>bne.isText(t) || Yte.isInline(e, t),
                mode: "highest",
                voids: o
              }),
              !n.at) {
              var B;
              B = A.length > 0 ? one.previous(I.current) : E.length > 0 ? one.previous(L.current) : one.previous(F.current);
              var N = Yte.end(e, B);
              Nne.select(e, N)
            }
            F.unref(),
              L.unref(),
              I.unref()
          }
        }
      }
    ))
  },
  insertText(e, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    Yte.withoutNormalizing(e, (()=>{
        var {voids: r=!1} = n
          , {at: o=e.selection} = n;
        if (o) {
          if (one.isPath(o) && (o = Yte.range(e, o)),
            fne.isRange(o))
            if (fne.isCollapsed(o))
              o = o.anchor;
            else {
              var a = fne.end(o);
              if (!r && Yte.void(e, {
                at: a
              }))
                return;
              var i = Yte.pointRef(e, a);
              Nne.delete(e, {
                at: o,
                voids: r
              }),
                o = i.unref(),
                Nne.setSelection(e, {
                  anchor: o,
                  focus: o
                })
            }
          if (r || !Yte.void(e, {
            at: o
          })) {
            var {path: s, offset: l} = o;
            t.length > 0 && e.apply({
              type: "insert_text",
              path: s,
              offset: l,
              text: t
            })
          }
        }
      }
    ))
  }
};
function Fne(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
function Bne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {};
    t % 2 ? Fne(Object(n), !0).forEach((function(t) {
        rte(e, t, n[t])
      }
    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fne(Object(n)).forEach((function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      }
    ))
  }
  return e
}
var Nne = Bne(Bne(Bne(Bne({}, Sne), Tne), Ine), Pne)
  , Mne = "[object Map]"
  , jne = "[object Set]"
  , Vne = /^\[object .+?Constructor\]$/
  , Une = /^(?:0|[1-9]\d*)$/
  , $ne = "[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]"
  , Hne = "\\ud83c[\\udffb-\\udfff]"
  , zne = "[^\\ud800-\\udfff]"
  , Kne = "(?:\\ud83c[\\udde6-\\uddff]){2}"
  , Wne = "[\\ud800-\\udbff][\\udc00-\\udfff]"
  , Gne = "(?:" + $ne + "|" + Hne + ")?"
  , qne = "[\\ufe0e\\ufe0f]?" + Gne + "(?:\\u200d(?:" + [zne, Kne, Wne].join("|") + ")[\\ufe0e\\ufe0f]?" + Gne + ")*"
  , Yne = "(?:" + [zne + $ne + "?", $ne, Kne, Wne, "[\\ud800-\\udfff]"].join("|") + ")"
  , Xne = RegExp(Hne + "(?=" + Hne + ")|" + Yne + qne, "g")
  , Qne = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]")
  , Jne = "object" == typeof MZ && MZ && MZ.Object === Object && MZ
  , Zne = "object" == typeof self && self && self.Object === Object && self
  , ere = Jne || Zne || Function("return this")();
function tre(e) {
  var t = -1
    , n = Array(e.size);
  return e.forEach((function(e, r) {
      n[++t] = [r, e]
    }
  )),
    n
}
function nre(e) {
  var t = -1
    , n = Array(e.size);
  return e.forEach((function(e) {
      n[++t] = e
    }
  )),
    n
}
var rre, ore, are = Function.prototype, ire = Object.prototype, sre = ere["__core-js_shared__"], lre = function() {
  var e = /[^.]+$/.exec(sre && sre.keys && sre.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : ""
}(), ure = are.toString, cre = ire.hasOwnProperty, dre = ire.toString, fre = RegExp("^" + ure.call(cre).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), pre = ere.Symbol, hre = pre ? pre.iterator : void 0, vre = ire.propertyIsEnumerable, gre = (rre = Object.keys,
    ore = Object,
    function(e) {
      return rre(ore(e))
    }
), mre = Tre(ere, "DataView"), yre = Tre(ere, "Map"), bre = Tre(ere, "Promise"), wre = Tre(ere, "Set"), xre = Tre(ere, "WeakMap"), Sre = _re(mre), Ere = _re(yre), Are = _re(bre), Cre = _re(wre), kre = _re(xre);
function Tre(e, t) {
  var n, r, o = (r = t,
    null == (n = e) ? void 0 : n[r]);
  return function(e) {
    if (!Pre(e) || (t = e,
    lre && lre in t))
      return !1;
    var t, n = Ire(e) || function(e) {
      var t = !1;
      if (null != e && "function" != typeof e.toString)
        try {
          t = !!(e + "")
        } catch (n) {}
      return t
    }(e) ? fre : Vne;
    return n.test(_re(e))
  }(o) ? o : void 0
}
var Dre = function(e) {
  return dre.call(e)
};
function Ore(e, t) {
  return !!(t = null == t ? 9007199254740991 : t) && ("number" == typeof e || Une.test(e)) && e > -1 && e % 1 == 0 && e < t
}
function _re(e) {
  if (null != e) {
    try {
      return ure.call(e)
    } catch (t) {}
    try {
      return e + ""
    } catch (t) {}
  }
  return ""
}
(mre && "[object DataView]" != Dre(new mre(new ArrayBuffer(1))) || yre && Dre(new yre) != Mne || bre && "[object Promise]" != Dre(bre.resolve()) || wre && Dre(new wre) != jne || xre && "[object WeakMap]" != Dre(new xre)) && (Dre = function(e) {
    var t = dre.call(e)
      , n = "[object Object]" == t ? e.constructor : void 0
      , r = n ? _re(n) : void 0;
    if (r)
      switch (r) {
        case Sre:
          return "[object DataView]";
        case Ere:
          return Mne;
        case Are:
          return "[object Promise]";
        case Cre:
          return jne;
        case kre:
          return "[object WeakMap]"
      }
    return t
  }
);
var Rre = Array.isArray;
function Lre(e) {
  return null != e && ("number" == typeof (t = e.length) && t > -1 && t % 1 == 0 && t <= 9007199254740991) && !Ire(e);
  var t
}
function Ire(e) {
  var t = Pre(e) ? dre.call(e) : "";
  return "[object Function]" == t || "[object GeneratorFunction]" == t
}
function Pre(e) {
  var t = typeof e;
  return !!e && ("object" == t || "function" == t)
}
function Fre(e) {
  return !!e && "object" == typeof e
}
function Bre(e) {
  return e ? function(e, t) {
    return function(e, t) {
      for (var n = -1, r = e ? e.length : 0, o = Array(r); ++n < r; )
        o[n] = t(e[n]);
      return o
    }(t, (function(t) {
        return e[t]
      }
    ))
  }(e, Lre(t = e) ? function(e, t) {
    var n, r, o = Rre(e) || Fre(r = n = e) && Lre(r) && cre.call(n, "callee") && (!vre.call(n, "callee") || "[object Arguments]" == dre.call(n)) ? function(e, t) {
      for (var n = -1, r = Array(e); ++n < e; )
        r[n] = t(n);
      return r
    }(e.length, String) : [], a = o.length, i = !!a;
    for (var s in e)
      !t && !cre.call(e, s) || i && ("length" == s || Ore(s, a)) || o.push(s);
    return o
  }(t) : function(e) {
    if (n = (t = e) && t.constructor,
    t !== ("function" == typeof n && n.prototype || ire))
      return gre(e);
    var t, n, r = [];
    for (var o in Object(e))
      cre.call(e, o) && "constructor" != o && r.push(o);
    return r
  }(t)) : [];
  var t
}
var Nre = function(e) {
  if (!e)
    return [];
  if (Lre(e))
    return "string" == typeof (t = e) || !Rre(t) && Fre(t) && "[object String]" == dre.call(t) ? function(e) {
      return t = e,
        Qne.test(t) ? function(e) {
          return e.match(Xne) || []
        }(e) : function(e) {
          return e.split("")
        }(e);
      var t
    }(e) : function(e, t) {
      var n = -1
        , r = e.length;
      for (t || (t = Array(r)); ++n < r; )
        t[n] = e[n];
      return t
    }(e);
  var t;
  if (hre && e[hre])
    return function(e) {
      for (var t, n = []; !(t = e.next()).done; )
        n.push(t.value);
      return n
    }(e[hre]());
  var n = Dre(e);
  return (n == Mne ? tre : n == jne ? nre : Bre)(e)
};
function Mre(e) {
  return null !== e && "object" == typeof e && "constructor"in e && e.constructor === Object
}
function jre(e, t) {
  void 0 === e && (e = {}),
  void 0 === t && (t = {}),
    Object.keys(t).forEach((function(n) {
        void 0 === e[n] ? e[n] = t[n] : Mre(t[n]) && Mre(e[n]) && Object.keys(t[n]).length > 0 && jre(e[n], t[n])
      }
    ))
}
var Vre = {
  body: {},
  addEventListener: function() {},
  removeEventListener: function() {},
  activeElement: {
    blur: function() {},
    nodeName: ""
  },
  querySelector: function() {
    return null
  },
  querySelectorAll: function() {
    return []
  },
  getElementById: function() {
    return null
  },
  createEvent: function() {
    return {
      initEvent: function() {}
    }
  },
  createElement: function() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute: function() {},
      getElementsByTagName: function() {
        return []
      }
    }
  },
  createElementNS: function() {
    return {}
  },
  importNode: function() {
    return null
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function Ure() {
  var e = "undefined" != typeof document ? document : {};
  return jre(e, Vre),
    e
}
var $re = {
  document: Vre,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState: function() {},
    pushState: function() {},
    go: function() {},
    back: function() {}
  },
  CustomEvent: function() {
    return this
  },
  addEventListener: function() {},
  removeEventListener: function() {},
  getComputedStyle: function() {
    return {
      getPropertyValue: function() {
        return ""
      }
    }
  },
  Image: function() {},
  Date: function() {},
  screen: {},
  setTimeout: function() {},
  clearTimeout: function() {},
  matchMedia: function() {
    return {}
  },
  requestAnimationFrame: function(e) {
    return "undefined" == typeof setTimeout ? (e(),
      null) : setTimeout(e, 0)
  },
  cancelAnimationFrame: function(e) {
    "undefined" != typeof setTimeout && clearTimeout(e)
  }
};
function Hre() {
  var e = "undefined" != typeof window ? window : {};
  return jre(e, $re),
    e
}
function zre(e) {
  return (zre = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
      return e.__proto__ || Object.getPrototypeOf(e)
    }
  )(e)
}
function Kre(e, t) {
  return (Kre = Object.setPrototypeOf || function(e, t) {
      return e.__proto__ = t,
        e
    }
  )(e, t)
}
function Wre(e, t, n) {
  return Wre = function() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return !1;
    if (Reflect.construct.sham)
      return !1;
    if ("function" == typeof Proxy)
      return !0;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
      ))),
        !0
    } catch (e) {
      return !1
    }
  }() ? Reflect.construct : function(e, t, n) {
    var r = [null];
    r.push.apply(r, t);
    var o = new (Function.bind.apply(e, r));
    return n && Kre(o, n.prototype),
      o
  }
    ,
    Wre.apply(null, arguments)
}
function Gre(e) {
  var t = "function" == typeof Map ? new Map : void 0;
  return Gre = function(e) {
    if (null === e || (n = e,
    -1 === Function.toString.call(n).indexOf("[native code]")))
      return e;
    var n;
    if ("function" != typeof e)
      throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== t) {
      if (t.has(e))
        return t.get(e);
      t.set(e, r)
    }
    function r() {
      return Wre(e, arguments, zre(this).constructor)
    }
    return r.prototype = Object.create(e.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }),
      Kre(r, e)
  }
    ,
    Gre(e)
}
var qre = function(e) {
  var t, n;
  function r(t) {
    var n, r, o;
    return r = function(e) {
      if (void 0 === e)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e
    }(n = e.call.apply(e, [this].concat(t)) || this),
      o = r.__proto__,
      Object.defineProperty(r, "__proto__", {
        get: function() {
          return o
        },
        set: function(e) {
          o.__proto__ = e
        }
      }),
      n
  }
  return n = e,
    (t = r).prototype = Object.create(n.prototype),
    t.prototype.constructor = t,
    t.__proto__ = n,
    r
}(Gre(Array));
function Yre(e) {
  void 0 === e && (e = []);
  var t = [];
  return e.forEach((function(e) {
      Array.isArray(e) ? t.push.apply(t, Yre(e)) : t.push(e)
    }
  )),
    t
}
function Xre(e, t) {
  return Array.prototype.filter.call(e, t)
}
function Qre(e, t) {
  var n = Hre()
    , r = Ure()
    , o = [];
  if (!t && e instanceof qre)
    return e;
  if (!e)
    return new qre(o);
  if ("string" == typeof e) {
    var a = e.trim();
    if (a.indexOf("<") >= 0 && a.indexOf(">") >= 0) {
      var i = "div";
      0 === a.indexOf("<li") && (i = "ul"),
      0 === a.indexOf("<tr") && (i = "tbody"),
      0 !== a.indexOf("<td") && 0 !== a.indexOf("<th") || (i = "tr"),
      0 === a.indexOf("<tbody") && (i = "table"),
      0 === a.indexOf("<option") && (i = "select");
      var s = r.createElement(i);
      s.innerHTML = a;
      for (var l = 0; l < s.childNodes.length; l += 1)
        o.push(s.childNodes[l])
    } else
      o = function(e, t) {
        if ("string" != typeof e)
          return [e];
        for (var n = [], r = t.querySelectorAll(e), o = 0; o < r.length; o += 1)
          n.push(r[o]);
        return n
      }(e.trim(), t || r)
  } else if (e.nodeType || e === n || e === r)
    o.push(e);
  else if (Array.isArray(e)) {
    if (e instanceof qre)
      return e;
    o = e
  }
  return new qre(function(e) {
    for (var t = [], n = 0; n < e.length; n += 1)
      -1 === t.indexOf(e[n]) && t.push(e[n]);
    return t
  }(o))
}
function Jre() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var r = Yre(t.map((function(e) {
      return e.split(" ")
    }
  )));
  return this.forEach((function(e) {
      var t;
      (t = e.classList).add.apply(t, r)
    }
  )),
    this
}
function Zre() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var r = Yre(t.map((function(e) {
      return e.split(" ")
    }
  )));
  return this.forEach((function(e) {
      var t;
      (t = e.classList).remove.apply(t, r)
    }
  )),
    this
}
function eoe() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var r = Yre(t.map((function(e) {
      return e.split(" ")
    }
  )));
  return Xre(this, (function(e) {
      return r.filter((function(t) {
          return e.classList.contains(t)
        }
      )).length > 0
    }
  )).length > 0
}
function toe(e, t) {
  if (1 === arguments.length && "string" == typeof e)
    return this[0] ? this[0].getAttribute(e) : void 0;
  for (var n = 0; n < this.length; n += 1)
    if (2 === arguments.length)
      this[n].setAttribute(e, t);
    else
      for (var r in e)
        this[n][r] = e[r],
          this[n].setAttribute(r, e[r]);
  return this
}
function noe(e) {
  for (var t = 0; t < this.length; t += 1)
    this[t].removeAttribute(e);
  return this
}
function roe() {
  var e = this[0];
  if (e) {
    var t, n = {};
    if (e.dataset)
      for (var r in e.dataset)
        n[r] = e.dataset[r];
    else
      for (var o = 0; o < e.attributes.length; o += 1) {
        var a = e.attributes[o];
        a.name.indexOf("data-") >= 0 && (n[(t = a.name.split("data-")[1],
          t.toLowerCase().replace(/-(.)/g, (function(e, t) {
              return t.toUpperCase()
            }
          )))] = a.value)
      }
    for (var i in n)
      "false" === n[i] ? n[i] = !1 : "true" === n[i] ? n[i] = !0 : parseFloat(n[i]) === 1 * n[i] && (n[i] *= 1);
    return n
  }
}
function ooe(e) {
  if (void 0 === e) {
    var t = this[0];
    if (!t)
      return;
    if (t.multiple && "select" === t.nodeName.toLowerCase()) {
      for (var n = [], r = 0; r < t.selectedOptions.length; r += 1)
        n.push(t.selectedOptions[r].value);
      return n
    }
    return t.value
  }
  for (var o = 0; o < this.length; o += 1) {
    var a = this[o];
    if (Array.isArray(e) && a.multiple && "select" === a.nodeName.toLowerCase())
      for (var i = 0; i < a.options.length; i += 1)
        a.options[i].selected = e.indexOf(a.options[i].value) >= 0;
    else
      a.value = e
  }
  return this
}
function aoe() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var r = t[0]
    , o = t[1]
    , a = t[2]
    , i = t[3];
  function s(e) {
    var t = e.target;
    if (t) {
      var n = e.target.dom7EventData || [];
      if (n.indexOf(e) < 0 && n.unshift(e),
        Qre(t).is(o))
        a.apply(t, n);
      else
        for (var r = Qre(t).parents(), i = 0; i < r.length; i += 1)
          Qre(r[i]).is(o) && a.apply(r[i], n)
    }
  }
  function l(e) {
    var t = e && e.target && e.target.dom7EventData || [];
    t.indexOf(e) < 0 && t.unshift(e),
      a.apply(this, t)
  }
  "function" == typeof t[1] && (r = t[0],
    a = t[1],
    i = t[2],
    o = void 0),
  i || (i = !1);
  for (var u, c = r.split(" "), d = 0; d < this.length; d += 1) {
    var f = this[d];
    if (o)
      for (u = 0; u < c.length; u += 1) {
        var p = c[u];
        f.dom7LiveListeners || (f.dom7LiveListeners = {}),
        f.dom7LiveListeners[p] || (f.dom7LiveListeners[p] = []),
          f.dom7LiveListeners[p].push({
            listener: a,
            proxyListener: s
          }),
          f.addEventListener(p, s, i)
      }
    else
      for (u = 0; u < c.length; u += 1) {
        var h = c[u];
        f.dom7Listeners || (f.dom7Listeners = {}),
        f.dom7Listeners[h] || (f.dom7Listeners[h] = []),
          f.dom7Listeners[h].push({
            listener: a,
            proxyListener: l
          }),
          f.addEventListener(h, l, i)
      }
  }
  return this
}
function ioe() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var r = t[0]
    , o = t[1]
    , a = t[2]
    , i = t[3];
  "function" == typeof t[1] && (r = t[0],
    a = t[1],
    i = t[2],
    o = void 0),
  i || (i = !1);
  for (var s = r.split(" "), l = 0; l < s.length; l += 1)
    for (var u = s[l], c = 0; c < this.length; c += 1) {
      var d = this[c]
        , f = void 0;
      if (!o && d.dom7Listeners ? f = d.dom7Listeners[u] : o && d.dom7LiveListeners && (f = d.dom7LiveListeners[u]),
      f && f.length)
        for (var p = f.length - 1; p >= 0; p -= 1) {
          var h = f[p];
          a && h.listener === a || a && h.listener && h.listener.dom7proxy && h.listener.dom7proxy === a ? (d.removeEventListener(u, h.proxyListener, i),
            f.splice(p, 1)) : a || (d.removeEventListener(u, h.proxyListener, i),
            f.splice(p, 1))
        }
    }
  return this
}
function soe() {
  var e = Hre();
  return this[0] === e ? e.innerWidth : this.length > 0 ? parseFloat(this.css("width")) : null
}
function loe() {
  var e = Hre();
  return this[0] === e ? e.innerHeight : this.length > 0 ? parseFloat(this.css("height")) : null
}
function uoe() {
  if (this.length > 0) {
    var e = Hre()
      , t = Ure()
      , n = this[0]
      , r = n.getBoundingClientRect()
      , o = t.body
      , a = n.clientTop || o.clientTop || 0
      , i = n.clientLeft || o.clientLeft || 0
      , s = n === e ? e.scrollY : n.scrollTop
      , l = n === e ? e.scrollX : n.scrollLeft;
    return {
      top: r.top + s - a,
      left: r.left + l - i
    }
  }
  return null
}
function coe() {
  for (var e = 0; e < this.length; e += 1)
    this[e].style.display = "none";
  return this
}
function doe() {
  for (var e = Hre(), t = 0; t < this.length; t += 1) {
    var n = this[t];
    "none" === n.style.display && (n.style.display = ""),
    "none" === e.getComputedStyle(n, null).getPropertyValue("display") && (n.style.display = "block")
  }
  return this
}
function foe(e, t) {
  var n, r = Hre();
  if (1 === arguments.length) {
    if ("string" != typeof e) {
      for (n = 0; n < this.length; n += 1)
        for (var o in e)
          this[n].style[o] = e[o];
      return this
    }
    if (this[0])
      return r.getComputedStyle(this[0], null).getPropertyValue(e)
  }
  if (2 === arguments.length && "string" == typeof e) {
    for (n = 0; n < this.length; n += 1)
      this[n].style[e] = t;
    return this
  }
  return this
}
function poe(e) {
  return e ? (this.forEach((function(t, n) {
      e.apply(t, [t, n])
    }
  )),
    this) : this
}
function hoe(e) {
  return Qre(Xre(this, e))
}
function voe(e) {
  if (void 0 === e)
    return this[0] ? this[0].innerHTML : null;
  for (var t = 0; t < this.length; t += 1)
    this[t].innerHTML = e;
  return this
}
function goe(e) {
  if (void 0 === e)
    return this[0] ? this[0].textContent.trim() : null;
  for (var t = 0; t < this.length; t += 1)
    this[t].textContent = e;
  return this
}
function moe(e) {
  var t, n, r = Hre(), o = Ure(), a = this[0];
  if (!a || void 0 === e)
    return !1;
  if ("string" == typeof e) {
    if (a.matches)
      return a.matches(e);
    if (a.webkitMatchesSelector)
      return a.webkitMatchesSelector(e);
    if (a.msMatchesSelector)
      return a.msMatchesSelector(e);
    for (t = Qre(e),
           n = 0; n < t.length; n += 1)
      if (t[n] === a)
        return !0;
    return !1
  }
  if (e === o)
    return a === o;
  if (e === r)
    return a === r;
  if (e.nodeType || e instanceof qre) {
    for (t = e.nodeType ? [e] : e,
           n = 0; n < t.length; n += 1)
      if (t[n] === a)
        return !0;
    return !1
  }
  return !1
}
function yoe() {
  for (var e, t = Ure(), n = 0; n < arguments.length; n += 1) {
    e = n < 0 || arguments.length <= n ? void 0 : arguments[n];
    for (var r = 0; r < this.length; r += 1)
      if ("string" == typeof e) {
        var o = t.createElement("div");
        for (o.innerHTML = e; o.firstChild; )
          this[r].appendChild(o.firstChild)
      } else if (e instanceof qre)
        for (var a = 0; a < e.length; a += 1)
          this[r].appendChild(e[a]);
      else
        this[r].appendChild(e)
  }
  return this
}
function boe(e) {
  var t, n, r = Ure();
  for (t = 0; t < this.length; t += 1)
    if ("string" == typeof e) {
      var o = r.createElement("div");
      for (o.innerHTML = e,
             n = o.childNodes.length - 1; n >= 0; n -= 1)
        this[t].insertBefore(o.childNodes[n], this[t].childNodes[0])
    } else if (e instanceof qre)
      for (n = 0; n < e.length; n += 1)
        this[t].insertBefore(e[n], this[t].childNodes[0]);
    else
      this[t].insertBefore(e, this[t].childNodes[0]);
  return this
}
function woe(e) {
  for (var t = [], n = 0; n < this.length; n += 1)
    null !== this[n].parentNode && (e ? Qre(this[n].parentNode).is(e) && t.push(this[n].parentNode) : t.push(this[n].parentNode));
  return Qre(t)
}
function xoe(e) {
  for (var t = [], n = 0; n < this.length; n += 1)
    for (var r = this[n].parentNode; r; )
      e ? Qre(r).is(e) && t.push(r) : t.push(r),
        r = r.parentNode;
  return Qre(t)
}
function Soe(e) {
  for (var t = [], n = 0; n < this.length; n += 1)
    for (var r = this[n].querySelectorAll(e), o = 0; o < r.length; o += 1)
      t.push(r[o]);
  return Qre(t)
}
function Eoe(e) {
  for (var t = [], n = 0; n < this.length; n += 1)
    for (var r = this[n].children, o = 0; o < r.length; o += 1)
      e && !Qre(r[o]).is(e) || t.push(r[o]);
  return Qre(t)
}
function Aoe() {
  for (var e = 0; e < this.length; e += 1)
    this[e].parentNode && this[e].parentNode.removeChild(this[e]);
  return this
}
function Coe() {
  for (var e = 0; e < this.length; e += 1) {
    var t = this[e];
    if (1 === t.nodeType) {
      for (var n = 0; n < t.childNodes.length; n += 1)
        t.childNodes[n].parentNode && t.childNodes[n].parentNode.removeChild(t.childNodes[n]);
      t.textContent = ""
    }
  }
  return this
}
Qre.fn = qre.prototype;
var koe = "resize scroll".split(" ");
function Toe(e) {
  return function() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    if (void 0 === n[0]) {
      for (var o = 0; o < this.length; o += 1)
        koe.indexOf(e) < 0 && (e in this[o] ? this[o][e]() : Qre(this[o]).trigger(e));
      return this
    }
    return this.on.apply(this, [e].concat(n))
  }
}
var Doe = Toe("click")
  , Ooe = Toe("focus")
  , _oe = "[object GeneratorFunction]"
  , Roe = /^(?:0|[1-9]\d*)$/;
function Loe(e, t) {
  for (var n = -1, r = e ? e.length : 0; ++n < r && !1 !== t(e[n], n, e); )
    ;
  return e
}
var Ioe = Object.prototype
  , Poe = Ioe.hasOwnProperty
  , Foe = Ioe.toString
  , Boe = Ioe.propertyIsEnumerable
  , Noe = function(e, t) {
  return function(n) {
    return e(t(n))
  }
}(Object.keys, Object);
var Moe, joe = (Moe = function(e, t) {
    return e && Voe(e, t, zoe)
  }
    ,
    function(e, t) {
      if (null == e)
        return e;
      if (!Hoe(e))
        return Moe(e, t);
      for (var n = e.length, r = -1, o = Object(e); ++r < n && !1 !== t(o[r], r, o); )
        ;
      return e
    }
), Voe = function(e, t, n) {
  for (var r = -1, o = Object(e), a = n(e), i = a.length; i--; ) {
    var s = a[++r];
    if (!1 === t(o[s], s, o))
      break
  }
  return e
};
function Uoe(e, t) {
  return !!(t = null == t ? 9007199254740991 : t) && ("number" == typeof e || Roe.test(e)) && e > -1 && e % 1 == 0 && e < t
}
var $oe = Array.isArray;
function Hoe(e) {
  return null != e && ("number" == typeof (t = e.length) && t > -1 && t % 1 == 0 && t <= 9007199254740991) && !function(e) {
    var t, n, r = (n = typeof (t = e),
      !t || "object" != n && "function" != n ? "" : Foe.call(e));
    return "[object Function]" == r || r == _oe
  }(e);
  var t
}
function zoe(e) {
  return Hoe(e) ? function(e, t) {
    var n, r, o, a = $oe(e) || (o = r = n = e) && "object" == typeof o && Hoe(r) && Poe.call(n, "callee") && (!Boe.call(n, "callee") || "[object Arguments]" == Foe.call(n)) ? function(e, t) {
      for (var n = -1, r = Array(e); ++n < e; )
        r[n] = t(n);
      return r
    }(e.length, String) : [], i = a.length, s = !!i;
    for (var l in e)
      !t && !Poe.call(e, l) || s && ("length" == l || Uoe(l, i)) || a.push(l);
    return a
  }(e) : function(e) {
    if (n = (t = e) && t.constructor,
    t !== ("function" == typeof n && n.prototype || Ioe))
      return Noe(e);
    var t, n, r = [];
    for (var o in Object(e))
      Poe.call(e, o) && "constructor" != o && r.push(o);
    return r
  }(e)
}
function Koe(e) {
  return e
}
var Woe = function(e, t) {
  return ($oe(e) ? Loe : joe)(e, "function" == typeof t ? t : Koe)
};
let Goe = (e=21)=>{
    let t = ""
      , n = crypto.getRandomValues(new Uint8Array(e));
    for (; e--; ) {
      let r = 63 & n[e];
      t += r < 36 ? r.toString(36) : r < 62 ? (r - 26).toString(36).toUpperCase() : r < 63 ? "_" : "-"
    }
    return t
  }
;
var qoe = /^\s+|\s+$/g
  , Yoe = /^[-+]0x[0-9a-f]+$/i
  , Xoe = /^0b[01]+$/i
  , Qoe = /^0o[0-7]+$/i
  , Joe = parseInt
  , Zoe = "object" == typeof MZ && MZ && MZ.Object === Object && MZ
  , eae = "object" == typeof self && self && self.Object === Object && self
  , tae = Zoe || eae || Function("return this")()
  , nae = Object.prototype.toString
  , rae = Math.max
  , oae = Math.min
  , aae = function() {
  return tae.Date.now()
};
function iae(e, t, n) {
  var r, o, a, i, s, l, u = 0, c = !1, d = !1, f = !0;
  if ("function" != typeof e)
    throw new TypeError("Expected a function");
  function p(t) {
    var n = r
      , a = o;
    return r = o = void 0,
      u = t,
      i = e.apply(a, n)
  }
  function h(e) {
    var n = e - l;
    return void 0 === l || n >= t || n < 0 || d && e - u >= a
  }
  function v() {
    var e, n, r = aae();
    if (h(r))
      return g(r);
    s = setTimeout(v, (n = t - ((e = r) - l),
      d ? oae(n, a - (e - u)) : n))
  }
  function g(e) {
    return s = void 0,
      f && r ? p(e) : (r = o = void 0,
        i)
  }
  function m() {
    var e = aae()
      , n = h(e);
    if (r = arguments,
      o = this,
      l = e,
      n) {
      if (void 0 === s)
        return function(e) {
          return u = e,
            s = setTimeout(v, t),
            c ? p(e) : i
        }(l);
      if (d)
        return s = setTimeout(v, t),
          p(l)
    }
    return void 0 === s && (s = setTimeout(v, t)),
      i
  }
  return t = lae(t) || 0,
  sae(n) && (c = !!n.leading,
    a = (d = "maxWait"in n) ? rae(lae(n.maxWait) || 0, t) : a,
    f = "trailing"in n ? !!n.trailing : f),
    m.cancel = function() {
      void 0 !== s && clearTimeout(s),
        u = 0,
        r = l = o = s = void 0
    }
    ,
    m.flush = function() {
      return void 0 === s ? i : g(aae())
    }
    ,
    m
}
function sae(e) {
  var t = typeof e;
  return !!e && ("object" == t || "function" == t)
}
function lae(e) {
  if ("number" == typeof e)
    return e;
  if ("symbol" == typeof (t = e) || (n = t) && "object" == typeof n && "[object Symbol]" == nae.call(t))
    return NaN;
  var t, n;
  if (sae(e)) {
    var r = "function" == typeof e.valueOf ? e.valueOf() : e;
    e = sae(r) ? r + "" : r
  }
  if ("string" != typeof e)
    return 0 === e ? e : +e;
  e = e.replace(qoe, "");
  var o = Xoe.test(e);
  return o || Qoe.test(e) ? Joe(e.slice(2), o ? 2 : 8) : Yoe.test(e) ? NaN : +e
}
var uae = function(e, t, n) {
  var r = !0
    , o = !0;
  if ("function" != typeof e)
    throw new TypeError("Expected a function");
  return sae(n) && (r = "leading"in n ? !!n.leading : r,
    o = "trailing"in n ? !!n.trailing : o),
    iae(e, t, {
      leading: r,
      maxWait: t,
      trailing: o
    })
};
const cae = {
  createElement: function(e, t) {
    return document.createElement(e, t)
  },
  createElementNS: function(e, t, n) {
    return document.createElementNS(e, t, n)
  },
  createTextNode: function(e) {
    return document.createTextNode(e)
  },
  createComment: function(e) {
    return document.createComment(e)
  },
  insertBefore: function(e, t, n) {
    e.insertBefore(t, n)
  },
  removeChild: function(e, t) {
    e.removeChild(t)
  },
  appendChild: function(e, t) {
    e.appendChild(t)
  },
  parentNode: function(e) {
    return e.parentNode
  },
  nextSibling: function(e) {
    return e.nextSibling
  },
  tagName: function(e) {
    return e.tagName
  },
  setTextContent: function(e, t) {
    e.textContent = t
  },
  getTextContent: function(e) {
    return e.textContent
  },
  isElement: function(e) {
    return 1 === e.nodeType
  },
  isText: function(e) {
    return 3 === e.nodeType
  },
  isComment: function(e) {
    return 8 === e.nodeType
  }
};
function dae(e, t, n, r, o) {
  return {
    sel: e,
    data: t,
    children: n,
    text: r,
    elm: o,
    key: void 0 === t ? void 0 : t.key
  }
}
const fae = Array.isArray;
function pae(e) {
  return "string" == typeof e || "number" == typeof e || e instanceof String || e instanceof Number
}
function hae(e) {
  return void 0 === e
}
function vae(e) {
  return void 0 !== e
}
const gae = dae("", {}, [], void 0, void 0);
function mae(e, t) {
  var n, r;
  const o = e.key === t.key
    , a = (null === (n = e.data) || void 0 === n ? void 0 : n.is) === (null === (r = t.data) || void 0 === r ? void 0 : r.is);
  return e.sel === t.sel && o && a
}
function yae(e, t, n) {
  var r;
  const o = {};
  for (let a = t; a <= n; ++a) {
    const t = null === (r = e[a]) || void 0 === r ? void 0 : r.key;
    void 0 !== t && (o[t] = a)
  }
  return o
}
const bae = ["create", "update", "remove", "destroy", "pre", "post"];
function wae(e, t) {
  const n = {
    create: [],
    update: [],
    remove: [],
    destroy: [],
    pre: [],
    post: []
  }
    , r = void 0 !== t ? t : cae;
  for (const c of bae)
    for (const t of e) {
      const e = t[c];
      void 0 !== e && n[c].push(e)
    }
  function o(e, t) {
    return function() {
      if (0 == --t) {
        const t = r.parentNode(e);
        r.removeChild(t, e)
      }
    }
  }
  function a(e, t) {
    var o, i;
    let s, l = e.data;
    if (void 0 !== l) {
      const t = null === (o = l.hook) || void 0 === o ? void 0 : o.init;
      vae(t) && (t(e),
        l = e.data)
    }
    const u = e.children
      , c = e.sel;
    if ("!" === c)
      hae(e.text) && (e.text = ""),
        e.elm = r.createComment(e.text);
    else if (void 0 !== c) {
      const o = c.indexOf("#")
        , d = c.indexOf(".", o)
        , f = o > 0 ? o : c.length
        , p = d > 0 ? d : c.length
        , h = -1 !== o || -1 !== d ? c.slice(0, Math.min(f, p)) : c
        , v = e.elm = vae(l) && vae(s = l.ns) ? r.createElementNS(s, h, l) : r.createElement(h, l);
      for (f < p && v.setAttribute("id", c.slice(f + 1, p)),
           d > 0 && v.setAttribute("class", c.slice(p + 1).replace(/\./g, " ")),
             s = 0; s < n.create.length; ++s)
        n.create[s](gae, e);
      if (fae(u))
        for (s = 0; s < u.length; ++s) {
          const e = u[s];
          null != e && r.appendChild(v, a(e, t))
        }
      else
        pae(e.text) && r.appendChild(v, r.createTextNode(e.text));
      const g = e.data.hook;
      vae(g) && (null === (i = g.create) || void 0 === i || i.call(g, gae, e),
      g.insert && t.push(e))
    } else
      e.elm = r.createTextNode(e.text);
    return e.elm
  }
  function i(e, t, n, o, i, s) {
    for (; o <= i; ++o) {
      const i = n[o];
      null != i && r.insertBefore(e, a(i, s), t)
    }
  }
  function s(e) {
    var t, r;
    const o = e.data;
    if (void 0 !== o) {
      null === (r = null === (t = null == o ? void 0 : o.hook) || void 0 === t ? void 0 : t.destroy) || void 0 === r || r.call(t, e);
      for (let t = 0; t < n.destroy.length; ++t)
        n.destroy[t](e);
      if (void 0 !== e.children)
        for (let t = 0; t < e.children.length; ++t) {
          const n = e.children[t];
          null != n && "string" != typeof n && s(n)
        }
    }
  }
  function l(e, t, a, i) {
    for (var l, u; a <= i; ++a) {
      let i, c;
      const d = t[a];
      if (null != d)
        if (vae(d.sel)) {
          s(d),
            i = n.remove.length + 1,
            c = o(d.elm, i);
          for (let t = 0; t < n.remove.length; ++t)
            n.remove[t](d, c);
          const e = null === (u = null === (l = null == d ? void 0 : d.data) || void 0 === l ? void 0 : l.hook) || void 0 === u ? void 0 : u.remove;
          vae(e) ? e(d, c) : c()
        } else
          r.removeChild(e, d.elm)
    }
  }
  function u(e, t, o) {
    var s, c, d, f, p;
    const h = null === (s = t.data) || void 0 === s ? void 0 : s.hook;
    null === (c = null == h ? void 0 : h.prepatch) || void 0 === c || c.call(h, e, t);
    const v = t.elm = e.elm
      , g = e.children
      , m = t.children;
    if (e !== t) {
      if (void 0 !== t.data) {
        for (let r = 0; r < n.update.length; ++r)
          n.update[r](e, t);
        null === (f = null === (d = t.data.hook) || void 0 === d ? void 0 : d.update) || void 0 === f || f.call(d, e, t)
      }
      hae(t.text) ? vae(g) && vae(m) ? g !== m && function(e, t, n, o) {
        let s, c, d, f, p = 0, h = 0, v = t.length - 1, g = t[0], m = t[v], y = n.length - 1, b = n[0], w = n[y];
        for (; p <= v && h <= y; )
          null == g ? g = t[++p] : null == m ? m = t[--v] : null == b ? b = n[++h] : null == w ? w = n[--y] : mae(g, b) ? (u(g, b, o),
            g = t[++p],
            b = n[++h]) : mae(m, w) ? (u(m, w, o),
            m = t[--v],
            w = n[--y]) : mae(g, w) ? (u(g, w, o),
            r.insertBefore(e, g.elm, r.nextSibling(m.elm)),
            g = t[++p],
            w = n[--y]) : mae(m, b) ? (u(m, b, o),
            r.insertBefore(e, m.elm, g.elm),
            m = t[--v],
            b = n[++h]) : (void 0 === s && (s = yae(t, p, v)),
            c = s[b.key],
            hae(c) ? r.insertBefore(e, a(b, o), g.elm) : (d = t[c],
              d.sel !== b.sel ? r.insertBefore(e, a(b, o), g.elm) : (u(d, b, o),
                t[c] = void 0,
                r.insertBefore(e, d.elm, g.elm))),
            b = n[++h]);
        (p <= v || h <= y) && (p > v ? (f = null == n[y + 1] ? null : n[y + 1].elm,
          i(e, f, n, h, y, o)) : l(e, t, p, v))
      }(v, g, m, o) : vae(m) ? (vae(e.text) && r.setTextContent(v, ""),
        i(v, null, m, 0, m.length - 1, o)) : vae(g) ? l(v, g, 0, g.length - 1) : vae(e.text) && r.setTextContent(v, "") : e.text !== t.text && (vae(g) && l(v, g, 0, g.length - 1),
        r.setTextContent(v, t.text)),
      null === (p = null == h ? void 0 : h.postpatch) || void 0 === p || p.call(h, e, t)
    }
  }
  return function(e, t) {
    let o, i, s;
    const c = [];
    for (o = 0; o < n.pre.length; ++o)
      n.pre[o]();
    for (void 0 !== e.sel || (e = function(e) {
      const t = e.id ? "#" + e.id : ""
        , n = e.getAttribute("class")
        , o = n ? "." + n.split(" ").join(".") : "";
      return dae(r.tagName(e).toLowerCase() + t + o, {}, [], void 0, e)
    }(e)),
           mae(e, t) ? u(e, t, c) : (i = e.elm,
             s = r.parentNode(i),
             a(t, c),
           null !== s && (r.insertBefore(s, t.elm, r.nextSibling(i)),
             l(s, [e], 0, 0))),
           o = 0; o < c.length; ++o)
      c[o].data.hook.insert(c[o]);
    for (o = 0; o < n.post.length; ++o)
      n.post[o]();
    return t
  }
}
function xae(e, t, n) {
  if (e.ns = "http://www.w3.org/2000/svg",
  "foreignObject" !== n && void 0 !== t)
    for (let r = 0; r < t.length; ++r) {
      const e = t[r].data;
      void 0 !== e && xae(e, t[r].children, t[r].sel)
    }
}
function Sae(e, t, n) {
  let r, o, a, i = {};
  if (void 0 !== n ? (null !== t && (i = t),
    fae(n) ? r = n : pae(n) ? o = n.toString() : n && n.sel && (r = [n])) : null != t && (fae(t) ? r = t : pae(t) ? o = t.toString() : t && t.sel ? r = [t] : i = t),
  void 0 !== r)
    for (a = 0; a < r.length; ++a)
      pae(r[a]) && (r[a] = dae(void 0, void 0, void 0, r[a], void 0));
  return "s" !== e[0] || "v" !== e[1] || "g" !== e[2] || 3 !== e.length && "." !== e[3] && "#" !== e[3] || xae(i, r, e),
    dae(e, i, r, o, void 0)
}
function Eae(e, t) {
  let n;
  const r = t.elm;
  let o = e.data.attrs
    , a = t.data.attrs;
  if ((o || a) && o !== a) {
    for (n in o = o || {},
      a = a || {},
      a) {
      const e = a[n];
      o[n] !== e && (!0 === e ? r.setAttribute(n, "") : !1 === e ? r.removeAttribute(n) : 120 !== n.charCodeAt(0) ? r.setAttribute(n, e) : 58 === n.charCodeAt(3) ? r.setAttributeNS("http://www.w3.org/XML/1998/namespace", n, e) : 58 === n.charCodeAt(5) ? r.setAttributeNS("http://www.w3.org/1999/xlink", n, e) : r.setAttribute(n, e))
    }
    for (n in o)
      n in a || r.removeAttribute(n)
  }
}
const Aae = {
  create: Eae,
  update: Eae
};
function Cae(e, t) {
  let n, r;
  const o = t.elm;
  let a = e.data.class
    , i = t.data.class;
  if ((a || i) && a !== i) {
    for (r in a = a || {},
      i = i || {},
      a)
      a[r] && !Object.prototype.hasOwnProperty.call(i, r) && o.classList.remove(r);
    for (r in i)
      n = i[r],
      n !== a[r] && o.classList[n ? "add" : "remove"](r)
  }
}
const kae = {
  create: Cae,
  update: Cae
}
  , Tae = /[A-Z]/g;
function Dae(e, t) {
  const n = t.elm;
  let r, o = e.data.dataset, a = t.data.dataset;
  if (!o && !a)
    return;
  if (o === a)
    return;
  o = o || {},
    a = a || {};
  const i = n.dataset;
  for (r in o)
    a[r] || (i ? r in i && delete i[r] : n.removeAttribute("data-" + r.replace(Tae, "-$&").toLowerCase()));
  for (r in a)
    o[r] !== a[r] && (i ? i[r] = a[r] : n.setAttribute("data-" + r.replace(Tae, "-$&").toLowerCase(), a[r]))
}
const Oae = {
  create: Dae,
  update: Dae
};
function _ae(e, t, n) {
  if ("function" == typeof e)
    e.call(t, n, t);
  else if ("object" == typeof e)
    for (let r = 0; r < e.length; r++)
      _ae(e[r], t, n)
}
function Rae(e, t) {
  const n = e.type
    , r = t.data.on;
  r && r[n] && _ae(r[n], t, e)
}
function Lae(e, t) {
  const n = e.data.on
    , r = e.listener
    , o = e.elm
    , a = t && t.data.on
    , i = t && t.elm;
  let s;
  if (n !== a) {
    if (n && r)
      if (a)
        for (s in n)
          a[s] || o.removeEventListener(s, r, !1);
      else
        for (s in n)
          o.removeEventListener(s, r, !1);
    if (a) {
      const r = t.listener = e.listener || function e(t) {
          Rae(t, e.vnode)
        }
      ;
      if (r.vnode = t,
        n)
        for (s in a)
          n[s] || i.addEventListener(s, r, !1);
      else
        for (s in a)
          i.addEventListener(s, r, !1)
    }
  }
}
const Iae = {
  create: Lae,
  update: Lae,
  destroy: Lae
};
function Pae(e, t) {
  let n, r, o;
  const a = t.elm;
  let i = e.data.props
    , s = t.data.props;
  if ((i || s) && i !== s)
    for (n in i = i || {},
      s = s || {},
      s)
      r = s[n],
        o = i[n],
      o === r || "value" === n && a[n] === r || (a[n] = r)
}
const Fae = {
  create: Pae,
  update: Pae
}
  , Bae = "undefined" != typeof window && window.requestAnimationFrame.bind(window) || setTimeout;
let Nae = !1;
function Mae(e, t, n) {
  var r;
  r = function() {
    e[t] = n
  }
    ,
    Bae((function() {
        Bae(r)
      }
    ))
}
function jae(e, t) {
  let n, r;
  const o = t.elm;
  let a = e.data.style
    , i = t.data.style;
  if (!a && !i)
    return;
  if (a === i)
    return;
  a = a || {},
    i = i || {};
  const s = "delayed"in a;
  for (r in a)
    i[r] || ("-" === r[0] && "-" === r[1] ? o.style.removeProperty(r) : o.style[r] = "");
  for (r in i)
    if (n = i[r],
    "delayed" === r && i.delayed)
      for (const e in i.delayed)
        n = i.delayed[e],
        s && n === a.delayed[e] || Mae(o.style, e, n);
    else
      "remove" !== r && n !== a[r] && ("-" === r[0] && "-" === r[1] ? o.style.setProperty(r, n) : o.style[r] = n)
}
const Vae = {
  pre: function() {
    Nae = !1
  },
  create: jae,
  update: jae,
  destroy: function(e) {
    let t, n;
    const r = e.elm
      , o = e.data.style;
    if (o && (t = o.destroy))
      for (n in t)
        r.style[n] = t[n]
  },
  remove: function(e, t) {
    const n = e.data.style;
    if (!n || !n.remove)
      return void t();
    let r;
    Nae || (e.elm.offsetLeft,
      Nae = !0);
    const o = e.elm;
    let a = 0;
    const i = n.remove;
    let s = 0;
    const l = [];
    for (r in i)
      l.push(r),
        o.style[r] = i[r];
    const u = getComputedStyle(o)["transition-property"].split(", ");
    for (; a < u.length; ++a)
      -1 !== l.indexOf(u[a]) && s++;
    o.addEventListener("transitionend", (function(e) {
        e.target === o && --s,
        0 === s && t()
      }
    ))
  }
};
function Uae(e, t) {
  for (const n of e)
    null != n && !1 !== n && "" !== n && (Array.isArray(n) ? Uae(n, t) : "string" == typeof n || "number" == typeof n || "boolean" == typeof n ? t.push(dae(void 0, void 0, void 0, String(n), void 0)) : t.push(n));
  return t
}
function $ae(e, t, ...n) {
  const r = Uae(n, []);
  return "function" == typeof e ? e(t, r) : 1 === r.length && !r[0].sel && r[0].text ? Sae(e, t, r[0].text) : Sae(e, t, r)
}
$ae || ($ae = {});
var Hae, zae = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Kae = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Wae = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Gae = "[" + Wae + "]", qae = "[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]", Yae = "\\d+", Xae = "[a-z\\xdf-\\xf6\\xf8-\\xff]", Qae = "[^\\ud800-\\udfff" + Wae + Yae + "\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]", Jae = "\\ud83c[\\udffb-\\udfff]", Zae = "[^\\ud800-\\udfff]", eie = "(?:\\ud83c[\\udde6-\\uddff]){2}", tie = "[\\ud800-\\udbff][\\udc00-\\udfff]", nie = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", rie = "(?:" + Xae + "|" + Qae + ")", oie = "(?:" + nie + "|" + Qae + ")", aie = "(?:" + qae + "|" + Jae + ")?", iie = "[\\ufe0e\\ufe0f]?" + aie + "(?:\\u200d(?:" + [Zae, eie, tie].join("|") + ")[\\ufe0e\\ufe0f]?" + aie + ")*", sie = "(?:" + ["[\\u2700-\\u27bf]", eie, tie].join("|") + ")" + iie, lie = "(?:" + [Zae + qae + "?", qae, eie, tie, "[\\ud800-\\udfff]"].join("|") + ")", uie = RegExp("['’]", "g"), cie = RegExp(qae, "g"), die = RegExp(Jae + "(?=" + Jae + ")|" + lie + iie, "g"), fie = RegExp([nie + "?" + Xae + "+(?:['’](?:d|ll|m|re|s|t|ve))?(?=" + [Gae, nie, "$"].join("|") + ")", oie + "+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=" + [Gae, nie + rie, "$"].join("|") + ")", nie + "?" + rie + "+(?:['’](?:d|ll|m|re|s|t|ve))?", nie + "+(?:['’](?:D|LL|M|RE|S|T|VE))?", Yae, sie].join("|"), "g"), pie = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]"), hie = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, vie = "object" == typeof MZ && MZ && MZ.Object === Object && MZ, gie = "object" == typeof self && self && self.Object === Object && self, mie = vie || gie || Function("return this")(), yie = (Hae = {
    "À": "A",
    "Á": "A",
    "Â": "A",
    "Ã": "A",
    "Ä": "A",
    "Å": "A",
    "à": "a",
    "á": "a",
    "â": "a",
    "ã": "a",
    "ä": "a",
    "å": "a",
    "Ç": "C",
    "ç": "c",
    "Ð": "D",
    "ð": "d",
    "È": "E",
    "É": "E",
    "Ê": "E",
    "Ë": "E",
    "è": "e",
    "é": "e",
    "ê": "e",
    "ë": "e",
    "Ì": "I",
    "Í": "I",
    "Î": "I",
    "Ï": "I",
    "ì": "i",
    "í": "i",
    "î": "i",
    "ï": "i",
    "Ñ": "N",
    "ñ": "n",
    "Ò": "O",
    "Ó": "O",
    "Ô": "O",
    "Õ": "O",
    "Ö": "O",
    "Ø": "O",
    "ò": "o",
    "ó": "o",
    "ô": "o",
    "õ": "o",
    "ö": "o",
    "ø": "o",
    "Ù": "U",
    "Ú": "U",
    "Û": "U",
    "Ü": "U",
    "ù": "u",
    "ú": "u",
    "û": "u",
    "ü": "u",
    "Ý": "Y",
    "ý": "y",
    "ÿ": "y",
    "Æ": "Ae",
    "æ": "ae",
    "Þ": "Th",
    "þ": "th",
    "ß": "ss",
    "Ā": "A",
    "Ă": "A",
    "Ą": "A",
    "ā": "a",
    "ă": "a",
    "ą": "a",
    "Ć": "C",
    "Ĉ": "C",
    "Ċ": "C",
    "Č": "C",
    "ć": "c",
    "ĉ": "c",
    "ċ": "c",
    "č": "c",
    "Ď": "D",
    "Đ": "D",
    "ď": "d",
    "đ": "d",
    "Ē": "E",
    "Ĕ": "E",
    "Ė": "E",
    "Ę": "E",
    "Ě": "E",
    "ē": "e",
    "ĕ": "e",
    "ė": "e",
    "ę": "e",
    "ě": "e",
    "Ĝ": "G",
    "Ğ": "G",
    "Ġ": "G",
    "Ģ": "G",
    "ĝ": "g",
    "ğ": "g",
    "ġ": "g",
    "ģ": "g",
    "Ĥ": "H",
    "Ħ": "H",
    "ĥ": "h",
    "ħ": "h",
    "Ĩ": "I",
    "Ī": "I",
    "Ĭ": "I",
    "Į": "I",
    "İ": "I",
    "ĩ": "i",
    "ī": "i",
    "ĭ": "i",
    "į": "i",
    "ı": "i",
    "Ĵ": "J",
    "ĵ": "j",
    "Ķ": "K",
    "ķ": "k",
    "ĸ": "k",
    "Ĺ": "L",
    "Ļ": "L",
    "Ľ": "L",
    "Ŀ": "L",
    "Ł": "L",
    "ĺ": "l",
    "ļ": "l",
    "ľ": "l",
    "ŀ": "l",
    "ł": "l",
    "Ń": "N",
    "Ņ": "N",
    "Ň": "N",
    "Ŋ": "N",
    "ń": "n",
    "ņ": "n",
    "ň": "n",
    "ŋ": "n",
    "Ō": "O",
    "Ŏ": "O",
    "Ő": "O",
    "ō": "o",
    "ŏ": "o",
    "ő": "o",
    "Ŕ": "R",
    "Ŗ": "R",
    "Ř": "R",
    "ŕ": "r",
    "ŗ": "r",
    "ř": "r",
    "Ś": "S",
    "Ŝ": "S",
    "Ş": "S",
    "Š": "S",
    "ś": "s",
    "ŝ": "s",
    "ş": "s",
    "š": "s",
    "Ţ": "T",
    "Ť": "T",
    "Ŧ": "T",
    "ţ": "t",
    "ť": "t",
    "ŧ": "t",
    "Ũ": "U",
    "Ū": "U",
    "Ŭ": "U",
    "Ů": "U",
    "Ű": "U",
    "Ų": "U",
    "ũ": "u",
    "ū": "u",
    "ŭ": "u",
    "ů": "u",
    "ű": "u",
    "ų": "u",
    "Ŵ": "W",
    "ŵ": "w",
    "Ŷ": "Y",
    "ŷ": "y",
    "Ÿ": "Y",
    "Ź": "Z",
    "Ż": "Z",
    "Ž": "Z",
    "ź": "z",
    "ż": "z",
    "ž": "z",
    "Ĳ": "IJ",
    "ĳ": "ij",
    "Œ": "Oe",
    "œ": "oe",
    "ŉ": "'n",
    "ſ": "ss"
  },
    function(e) {
      return null == Hae ? void 0 : Hae[e]
    }
);
function bie(e) {
  return pie.test(e)
}
var wie = Object.prototype.toString
  , xie = mie.Symbol
  , Sie = xie ? xie.prototype : void 0
  , Eie = Sie ? Sie.toString : void 0;
function Aie(e) {
  return null == e ? "" : function(e) {
    if ("string" == typeof e)
      return e;
    if ("symbol" == typeof (t = e) || (n = t) && "object" == typeof n && "[object Symbol]" == wie.call(t))
      return Eie ? Eie.call(e) : "";
    var t, n, r = e + "";
    return "0" == r && 1 / e == -1 / 0 ? "-0" : r
  }(e)
}
for (var Cie, kie = (Cie = function(e, t, n) {
    return t = t.toLowerCase(),
    e + (n ? Tie(Aie(t).toLowerCase()) : t)
  }
    ,
    function(e) {
      return function(e, t, n, r) {
        for (var o = -1, a = e ? e.length : 0; ++o < a; )
          n = t(n, e[o], o, e);
        return n
      }(function(e, t, n) {
        return e = Aie(e),
          void 0 === t ? (r = e,
            hie.test(r) ? function(e) {
              return e.match(fie) || []
            }(e) : function(e) {
              return e.match(zae) || []
            }(e)) : e.match(t) || [];
        var r
      }((t = e,
      (t = Aie(t)) && t.replace(Kae, yie).replace(cie, "")).replace(uie, "")), Cie, "");
      var t
    }
), Tie = ("toUpperCase",
    function(e) {
      var t = bie(e = Aie(e)) ? function(e) {
        return bie(e) ? e.match(die) || [] : (t = e,
          t.split(""));
        var t
      }(e) : void 0
        , n = t ? t[0] : e.charAt(0)
        , r = t ? function(e, t, n) {
        var r = e.length;
        return n = void 0 === n ? r : n,
          !t && n >= r ? e : function(e, t, n) {
            var r = -1
              , o = e.length;
            t < 0 && (t = -t > o ? 0 : o + t),
            (n = n > o ? o : n) < 0 && (n += o),
              o = t > n ? 0 : n - t >>> 0,
              t >>>= 0;
            for (var a = Array(o); ++r < o; )
              a[r] = e[r + t];
            return a
          }(e, t, n)
      }(t, 1).join("") : e.slice(1);
      return n.toUpperCase() + r
    }
), Die = kie, Oie = "undefined" != typeof window && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), _ie = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Rie = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Oie ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Lie = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
}, Iie = 1; Iie < 20; Iie++)
  Lie["f" + Iie] = 111 + Iie;
function Pie(e, t, n) {
  t && !("byKey"in t) && (n = t,
    t = null),
  Array.isArray(e) || (e = [e]);
  var r = e.map((function(e) {
      return function(e, t) {
        var n = t && t.byKey
          , r = {}
          , o = (e = e.replace("++", "+add")).split("+")
          , a = o.length;
        for (var i in _ie)
          r[_ie[i]] = !1;
        var s = !0
          , l = !1
          , u = void 0;
        try {
          for (var c, d = o[Symbol.iterator](); !(s = (c = d.next()).done); s = !0) {
            var f = c.value
              , p = f.endsWith("?") && f.length > 1;
            p && (f = f.slice(0, -1));
            var h = Bie(f)
              , v = _ie[h];
            if (f.length > 1 && !v && !Rie[f] && !Lie[h])
              throw new TypeError('Unknown modifier: "' + f + '"');
            1 !== a && v || (n ? r.key = h : r.which = Fie(f)),
            v && (r[v] = !p || null)
          }
        } catch (g) {
          l = !0,
            u = g
        } finally {
          try {
            !s && d.return && d.return()
          } finally {
            if (l)
              throw u
          }
        }
        return r
      }(e, t)
    }
  ))
    , o = function(e) {
    return r.some((function(t) {
        return function(e, t) {
          for (var n in e) {
            var r = e[n]
              , o = void 0;
            if (null != r && (null != (o = "key" === n && null != t.key ? t.key.toLowerCase() : "which" === n ? 91 === r && 93 === t.which ? 91 : t.which : t[n]) || !1 !== r) && o !== r)
              return !1
          }
          return !0
        }(t, e)
      }
    ))
  };
  return null == n ? o : o(n)
}
function Fie(e) {
  return e = Bie(e),
  Lie[e] || e.toUpperCase().charCodeAt(0)
}
function Bie(e) {
  return e = e.toLowerCase(),
  Rie[e] || e
}
var Nie = Pie
  , Mie = function(e, t) {
  return Pie(e, {
    byKey: !0
  }, t)
}
  , jie = /^\s+|\s+$/g
  , Vie = /^[-+]0x[0-9a-f]+$/i
  , Uie = /^0b[01]+$/i
  , $ie = /^0o[0-7]+$/i
  , Hie = parseInt
  , zie = "object" == typeof MZ && MZ && MZ.Object === Object && MZ
  , Kie = "object" == typeof self && self && self.Object === Object && self
  , Wie = zie || Kie || Function("return this")()
  , Gie = Object.prototype.toString
  , qie = Math.max
  , Yie = Math.min
  , Xie = function() {
  return Wie.Date.now()
};
function Qie(e) {
  var t = typeof e;
  return !!e && ("object" == t || "function" == t)
}
function Jie(e) {
  if ("number" == typeof e)
    return e;
  if ("symbol" == typeof (t = e) || (n = t) && "object" == typeof n && "[object Symbol]" == Gie.call(t))
    return NaN;
  var t, n;
  if (Qie(e)) {
    var r = "function" == typeof e.valueOf ? e.valueOf() : e;
    e = Qie(r) ? r + "" : r
  }
  if ("string" != typeof e)
    return 0 === e ? e : +e;
  e = e.replace(jie, "");
  var o = Uie.test(e);
  return o || $ie.test(e) ? Hie(e.slice(2), o ? 2 : 8) : Vie.test(e) ? NaN : +e
}
var Zie, ese = function(e, t, n) {
  var r, o, a, i, s, l, u = 0, c = !1, d = !1, f = !0;
  if ("function" != typeof e)
    throw new TypeError("Expected a function");
  function p(t) {
    var n = r
      , a = o;
    return r = o = void 0,
      u = t,
      i = e.apply(a, n)
  }
  function h(e) {
    var n = e - l;
    return void 0 === l || n >= t || n < 0 || d && e - u >= a
  }
  function v() {
    var e, n, r = Xie();
    if (h(r))
      return g(r);
    s = setTimeout(v, (n = t - ((e = r) - l),
      d ? Yie(n, a - (e - u)) : n))
  }
  function g(e) {
    return s = void 0,
      f && r ? p(e) : (r = o = void 0,
        i)
  }
  function m() {
    var e = Xie()
      , n = h(e);
    if (r = arguments,
      o = this,
      l = e,
      n) {
      if (void 0 === s)
        return function(e) {
          return u = e,
            s = setTimeout(v, t),
            c ? p(e) : i
        }(l);
      if (d)
        return s = setTimeout(v, t),
          p(l)
    }
    return void 0 === s && (s = setTimeout(v, t)),
      i
  }
  return t = Jie(t) || 0,
  Qie(n) && (c = !!n.leading,
    a = (d = "maxWait"in n) ? qie(Jie(n.maxWait) || 0, t) : a,
    f = "trailing"in n ? !!n.trailing : f),
    m.cancel = function() {
      void 0 !== s && clearTimeout(s),
        u = 0,
        r = l = o = s = void 0
    }
    ,
    m.flush = function() {
      return void 0 === s ? i : g(Xie())
    }
    ,
    m
}, tse = jZ((function(e, t) {
    var n = "__lodash_hash_undefined__"
      , r = 9007199254740991
      , o = "[object Arguments]"
      , a = "[object Boolean]"
      , i = "[object Date]"
      , s = "[object Function]"
      , l = "[object GeneratorFunction]"
      , u = "[object Map]"
      , c = "[object Number]"
      , d = "[object Object]"
      , f = "[object Promise]"
      , p = "[object RegExp]"
      , h = "[object Set]"
      , v = "[object String]"
      , g = "[object Symbol]"
      , m = "[object WeakMap]"
      , y = "[object ArrayBuffer]"
      , b = "[object DataView]"
      , w = "[object Float32Array]"
      , x = "[object Float64Array]"
      , S = "[object Int8Array]"
      , E = "[object Int16Array]"
      , A = "[object Int32Array]"
      , C = "[object Uint8Array]"
      , k = "[object Uint8ClampedArray]"
      , T = "[object Uint16Array]"
      , D = "[object Uint32Array]"
      , O = /\w*$/
      , _ = /^\[object .+?Constructor\]$/
      , R = /^(?:0|[1-9]\d*)$/
      , L = {};
    L[o] = L["[object Array]"] = L[y] = L[b] = L[a] = L[i] = L[w] = L[x] = L[S] = L[E] = L[A] = L[u] = L[c] = L[d] = L[p] = L[h] = L[v] = L[g] = L[C] = L[k] = L[T] = L[D] = !0,
      L["[object Error]"] = L[s] = L[m] = !1;
    var I = "object" == typeof MZ && MZ && MZ.Object === Object && MZ
      , P = "object" == typeof self && self && self.Object === Object && self
      , F = I || P || Function("return this")()
      , B = t && !t.nodeType && t
      , N = B && e && !e.nodeType && e
      , M = N && N.exports === B;
    function j(e, t) {
      return e.set(t[0], t[1]),
        e
    }
    function V(e, t) {
      return e.add(t),
        e
    }
    function U(e, t, n, r) {
      var o = -1
        , a = e ? e.length : 0;
      for (r && a && (n = e[++o]); ++o < a; )
        n = t(n, e[o], o, e);
      return n
    }
    function $(e) {
      var t = !1;
      if (null != e && "function" != typeof e.toString)
        try {
          t = !!(e + "")
        } catch (n) {}
      return t
    }
    function H(e) {
      var t = -1
        , n = Array(e.size);
      return e.forEach((function(e, r) {
          n[++t] = [r, e]
        }
      )),
        n
    }
    function z(e, t) {
      return function(n) {
        return e(t(n))
      }
    }
    function K(e) {
      var t = -1
        , n = Array(e.size);
      return e.forEach((function(e) {
          n[++t] = e
        }
      )),
        n
    }
    var W = Array.prototype
      , G = Function.prototype
      , q = Object.prototype
      , Y = F["__core-js_shared__"]
      , X = function() {
      var e = /[^.]+$/.exec(Y && Y.keys && Y.keys.IE_PROTO || "");
      return e ? "Symbol(src)_1." + e : ""
    }()
      , Q = G.toString
      , J = q.hasOwnProperty
      , Z = q.toString
      , ee = RegExp("^" + Q.call(J).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$")
      , te = M ? F.Buffer : void 0
      , ne = F.Symbol
      , re = F.Uint8Array
      , oe = z(Object.getPrototypeOf, Object)
      , ae = Object.create
      , ie = q.propertyIsEnumerable
      , se = W.splice
      , le = Object.getOwnPropertySymbols
      , ue = te ? te.isBuffer : void 0
      , ce = z(Object.keys, Object)
      , de = Pe(F, "DataView")
      , fe = Pe(F, "Map")
      , pe = Pe(F, "Promise")
      , he = Pe(F, "Set")
      , ve = Pe(F, "WeakMap")
      , ge = Pe(Object, "create")
      , me = je(de)
      , ye = je(fe)
      , be = je(pe)
      , we = je(he)
      , xe = je(ve)
      , Se = ne ? ne.prototype : void 0
      , Ee = Se ? Se.valueOf : void 0;
    function Ae(e) {
      var t = -1
        , n = e ? e.length : 0;
      for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
      }
    }
    function Ce(e) {
      var t = -1
        , n = e ? e.length : 0;
      for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
      }
    }
    function ke(e) {
      var t = -1
        , n = e ? e.length : 0;
      for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
      }
    }
    function Te(e) {
      this.__data__ = new Ce(e)
    }
    function De(e, t, n) {
      var r = e[t];
      J.call(e, t) && Ve(r, n) && (void 0 !== n || t in e) || (e[t] = n)
    }
    function Oe(e, t) {
      for (var n = e.length; n--; )
        if (Ve(e[n][0], t))
          return n;
      return -1
    }
    function _e(e, t, n, r, f, m, _) {
      var R;
      if (r && (R = m ? r(e, f, m, _) : r(e)),
      void 0 !== R)
        return R;
      if (!Ke(e))
        return e;
      var I, P, F, B = Ue(e);
      if (B) {
        if (P = (I = e).length,
          F = I.constructor(P),
        P && "string" == typeof I[0] && J.call(I, "index") && (F.index = I.index,
          F.input = I.input),
          R = F,
          !t)
          return function(e, t) {
            var n = -1
              , r = e.length;
            for (t || (t = Array(r)); ++n < r; )
              t[n] = e[n];
            return t
          }(e, R)
      } else {
        var N = Be(e)
          , M = N == s || N == l;
        if (He(e))
          return function(e, t) {
            if (t)
              return e.slice();
            var n = new e.constructor(e.length);
            return e.copy(n),
              n
          }(e, t);
        if (N == d || N == o || M && !m) {
          if ($(e))
            return m ? e : {};
          if (R = function(e) {
            return "function" != typeof e.constructor || Me(e) ? {} : Ke(t = oe(e)) ? ae(t) : {};
            var t
          }(M ? {} : e),
            !t)
            return function(e, t) {
              return Le(e, Fe(e), t)
            }(e, function(e, t) {
              return e && Le(t, We(t), e)
            }(R, e))
        } else {
          if (!L[N])
            return m ? e : {};
          R = function(e, t, n, r) {
            var o, s, l = e.constructor;
            switch (t) {
              case y:
                return Re(e);
              case a:
              case i:
                return new l(+e);
              case b:
                return o = e,
                  s = r ? Re(o.buffer) : o.buffer,
                  new o.constructor(s,o.byteOffset,o.byteLength);
              case w:
              case x:
              case S:
              case E:
              case A:
              case C:
              case k:
              case T:
              case D:
                return function(e, t) {
                  var n = t ? Re(e.buffer) : e.buffer;
                  return new e.constructor(n,e.byteOffset,e.length)
                }(e, r);
              case u:
                return function(e, t, n) {
                  return U(t ? n(H(e), !0) : H(e), j, new e.constructor)
                }(e, r, n);
              case c:
              case v:
                return new l(e);
              case p:
                return function(e) {
                  var t = new e.constructor(e.source,O.exec(e));
                  return t.lastIndex = e.lastIndex,
                    t
                }(e);
              case h:
                return function(e, t, n) {
                  return U(t ? n(K(e), !0) : K(e), V, new e.constructor)
                }(e, r, n);
              case g:
                return function(e) {
                  return Ee ? Object(Ee.call(e)) : {}
                }(e)
            }
          }(e, N, _e, t)
        }
      }
      _ || (_ = new Te);
      var z = _.get(e);
      if (z)
        return z;
      if (_.set(e, R),
        !B)
        var W = n ? function(e) {
          return function(e, t, n) {
            var r = t(e);
            return Ue(e) ? r : function(e, t) {
              for (var n = -1, r = t.length, o = e.length; ++n < r; )
                e[o + n] = t[n];
              return e
            }(r, n(e))
          }(e, We, Fe)
        }(e) : We(e);
      return function(o, a) {
        for (var i = -1, s = o ? o.length : 0; ++i < s && !1 !== (l = o[i],
          u = i,
        W && (l = e[u = l]),
          void De(R, u, _e(l, t, n, r, u, e, _))); )
          ;
        var l, u
      }(W || e),
        R
    }
    function Re(e) {
      var t = new e.constructor(e.byteLength);
      return new re(t).set(new re(e)),
        t
    }
    function Le(e, t, n, r) {
      n || (n = {});
      for (var o = -1, a = t.length; ++o < a; ) {
        var i = t[o]
          , s = r ? r(n[i], e[i], i, n, e) : void 0;
        De(n, i, void 0 === s ? e[i] : s)
      }
      return n
    }
    function Ie(e, t) {
      var n, r, o = e.__data__;
      return ("string" == (r = typeof (n = t)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? o["string" == typeof t ? "string" : "hash"] : o.map
    }
    function Pe(e, t) {
      var n, r, o = (r = t,
        null == (n = e) ? void 0 : n[r]);
      return function(e) {
        return !(!Ke(e) || (t = e,
        X && X in t)) && (ze(e) || $(e) ? ee : _).test(je(e));
        var t
      }(o) ? o : void 0
    }
    Ae.prototype.clear = function() {
      this.__data__ = ge ? ge(null) : {}
    }
      ,
      Ae.prototype.delete = function(e) {
        return this.has(e) && delete this.__data__[e]
      }
      ,
      Ae.prototype.get = function(e) {
        var t = this.__data__;
        if (ge) {
          var r = t[e];
          return r === n ? void 0 : r
        }
        return J.call(t, e) ? t[e] : void 0
      }
      ,
      Ae.prototype.has = function(e) {
        var t = this.__data__;
        return ge ? void 0 !== t[e] : J.call(t, e)
      }
      ,
      Ae.prototype.set = function(e, t) {
        return this.__data__[e] = ge && void 0 === t ? n : t,
          this
      }
      ,
      Ce.prototype.clear = function() {
        this.__data__ = []
      }
      ,
      Ce.prototype.delete = function(e) {
        var t = this.__data__
          , n = Oe(t, e);
        return !(n < 0 || (n == t.length - 1 ? t.pop() : se.call(t, n, 1),
          0))
      }
      ,
      Ce.prototype.get = function(e) {
        var t = this.__data__
          , n = Oe(t, e);
        return n < 0 ? void 0 : t[n][1]
      }
      ,
      Ce.prototype.has = function(e) {
        return Oe(this.__data__, e) > -1
      }
      ,
      Ce.prototype.set = function(e, t) {
        var n = this.__data__
          , r = Oe(n, e);
        return r < 0 ? n.push([e, t]) : n[r][1] = t,
          this
      }
      ,
      ke.prototype.clear = function() {
        this.__data__ = {
          hash: new Ae,
          map: new (fe || Ce),
          string: new Ae
        }
      }
      ,
      ke.prototype.delete = function(e) {
        return Ie(this, e).delete(e)
      }
      ,
      ke.prototype.get = function(e) {
        return Ie(this, e).get(e)
      }
      ,
      ke.prototype.has = function(e) {
        return Ie(this, e).has(e)
      }
      ,
      ke.prototype.set = function(e, t) {
        return Ie(this, e).set(e, t),
          this
      }
      ,
      Te.prototype.clear = function() {
        this.__data__ = new Ce
      }
      ,
      Te.prototype.delete = function(e) {
        return this.__data__.delete(e)
      }
      ,
      Te.prototype.get = function(e) {
        return this.__data__.get(e)
      }
      ,
      Te.prototype.has = function(e) {
        return this.__data__.has(e)
      }
      ,
      Te.prototype.set = function(e, t) {
        var n = this.__data__;
        if (n instanceof Ce) {
          var r = n.__data__;
          if (!fe || r.length < 199)
            return r.push([e, t]),
              this;
          n = this.__data__ = new ke(r)
        }
        return n.set(e, t),
          this
      }
    ;
    var Fe = le ? z(le, Object) : function() {
      return []
    }
      , Be = function(e) {
      return Z.call(e)
    };
    function Ne(e, t) {
      return !!(t = null == t ? r : t) && ("number" == typeof e || R.test(e)) && e > -1 && e % 1 == 0 && e < t
    }
    function Me(e) {
      var t = e && e.constructor;
      return e === ("function" == typeof t && t.prototype || q)
    }
    function je(e) {
      if (null != e) {
        try {
          return Q.call(e)
        } catch (t) {}
        try {
          return e + ""
        } catch (t) {}
      }
      return ""
    }
    function Ve(e, t) {
      return e === t || e != e && t != t
    }
    (de && Be(new de(new ArrayBuffer(1))) != b || fe && Be(new fe) != u || pe && Be(pe.resolve()) != f || he && Be(new he) != h || ve && Be(new ve) != m) && (Be = function(e) {
        var t = Z.call(e)
          , n = t == d ? e.constructor : void 0
          , r = n ? je(n) : void 0;
        if (r)
          switch (r) {
            case me:
              return b;
            case ye:
              return u;
            case be:
              return f;
            case we:
              return h;
            case xe:
              return m
          }
        return t
      }
    );
    var Ue = Array.isArray;
    function $e(e) {
      return null != e && ("number" == typeof (t = e.length) && t > -1 && t % 1 == 0 && t <= r) && !ze(e);
      var t
    }
    var He = ue || function() {
        return !1
      }
    ;
    function ze(e) {
      var t = Ke(e) ? Z.call(e) : "";
      return t == s || t == l
    }
    function Ke(e) {
      var t = typeof e;
      return !!e && ("object" == t || "function" == t)
    }
    function We(e) {
      return $e(e) ? function(e, t) {
        var n, r, a, i = Ue(e) || (a = r = n = e) && "object" == typeof a && $e(r) && J.call(n, "callee") && (!ie.call(n, "callee") || Z.call(n) == o) ? function(e, t) {
          for (var n = -1, r = Array(e); ++n < e; )
            r[n] = t(n);
          return r
        }(e.length, String) : [], s = i.length, l = !!s;
        for (var u in e)
          !t && !J.call(e, u) || l && ("length" == u || Ne(u, s)) || i.push(u);
        return i
      }(e) : function(e) {
        if (!Me(e))
          return ce(e);
        var t = [];
        for (var n in Object(e))
          J.call(e, n) && "constructor" != n && t.push(n);
        return t
      }(e)
    }
    e.exports = function(e) {
      return _e(e, !0, !0)
    }
  }
));
function nse(e, t) {
  if (!Object.prototype.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e
}
var rse = 0;
function ose(e, t, n) {
  const r = [];
  return e.forEach((e=>"string" != typeof e ? r.push(e) : t[Symbol.split](e).forEach(((e,t,o)=>{
      "" !== e && r.push(e),
      t < o.length - 1 && r.push(n)
    }
  )))),
    r
  /**
   * Takes a string with placeholder variables like `%{smart_count} file selected`
   * and replaces it with values from options `{smart_count: 5}`
   *
   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
   *
   * @param {string} phrase that needs interpolation, with placeholders
   * @param {object} options with values that will be used to replace placeholders
   * @returns {any[]} interpolated
   */
}
function ase(e, t) {
  const n = /\$/g;
  let r = [e];
  if (null == t)
    return r;
  for (const o of Object.keys(t))
    if ("_" !== o) {
      let e = t[o];
      "string" == typeof e && (e = n[Symbol.replace](e, "$$$$")),
        r = ose(r, new RegExp(`%\\{${o}\\}`,"g"), e)
    }
  return r
}
var ise = (Zie = function(e) {
    return "__private_" + rse++ + "_" + e
  }("apply"),
    class {
      constructor(e) {
        Object.defineProperty(this, Zie, {
          value: sse
        }),
          this.locale = {
            strings: {},
            pluralize: e=>1 === e ? 0 : 1
          },
          Array.isArray(e) ? e.forEach(nse(this, Zie)[Zie], this) : nse(this, Zie)[Zie](e)
      }
      translate(e, t) {
        return this.translateArray(e, t).join("")
      }
      translateArray(e, t) {
        if (n = this.locale.strings,
          r = e,
          !Object.prototype.hasOwnProperty.call(n, r))
          throw new Error(`missing string: ${e}`);
        var n, r;
        const o = this.locale.strings[e];
        if ("object" == typeof o) {
          if (t && void 0 !== t.smart_count)
            return ase(o[this.locale.pluralize(t.smart_count)], t);
          throw new Error("Attempted to use a string with plural forms, but no value was given for %{smart_count}")
        }
        return ase(o, t)
      }
    }
);
function sse(e) {
  if (null == e || !e.strings)
    return;
  const t = this.locale;
  this.locale = {
    ...t,
    strings: {
      ...t.strings,
      ...e.strings
    }
  },
    this.locale.pluralize = e.pluralize || t.pluralize
}
var lse = function() {
  var e = {}
    , t = e._fns = {};
  return e.emit = function(e, n, r, o, a, i, s) {
    var l = function(e) {
      for (var n = t[e] ? t[e] : [], r = e.indexOf(":"), o = -1 === r ? [e] : [e.substring(0, r), e.substring(r + 1)], a = Object.keys(t), i = 0, s = a.length; i < s; i++) {
        var l = a[i];
        if ("*" === l && (n = n.concat(t[l])),
        2 === o.length && o[0] === l) {
          n = n.concat(t[l]);
          break
        }
      }
      return n
    }(e);
    l.length && function(e, t, n) {
      for (var r = 0, o = t.length; r < o && t[r]; r++)
        t[r].event = e,
          t[r].apply(t[r], n)
    }(e, l, [n, r, o, a, i, s])
  }
    ,
    e.on = function(e, n) {
      t[e] || (t[e] = []),
        t[e].push(n)
    }
    ,
    e.once = function(t, n) {
      this.on(t, (function r() {
          n.apply(this, arguments),
            e.off(t, r)
        }
      ))
    }
    ,
    e.off = function(e, t) {
      var n = [];
      if (e && t)
        for (var r = this._fns[e], o = 0, a = r ? r.length : 0; o < a; o++)
          r[o] !== t && n.push(r[o]);
      n.length ? this._fns[e] = n : delete this._fns[e]
    }
    ,
    e
};
let {urlAlphabet: use} = {
    urlAlphabet: "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"
  }
  , cse = e=>crypto.getRandomValues(new Uint8Array(e))
  , dse = (e,t,n)=>{
    let r = (2 << Math.log(e.length - 1) / Math.LN2) - 1
      , o = -~(1.6 * r * t / e.length);
    return ()=>{
      let a = "";
      for (; ; ) {
        let i = n(o)
          , s = o;
        for (; s--; )
          if (a += e[i[s] & r] || "",
          a.length === t)
            return a
      }
    }
  }
;
var fse = {
  nanoid: (e=21)=>{
    let t = ""
      , n = crypto.getRandomValues(new Uint8Array(e));
    for (; e--; ) {
      let r = 63 & n[e];
      t += r < 36 ? r.toString(36) : r < 62 ? (r - 26).toString(36).toUpperCase() : r < 63 ? "_" : "-"
    }
    return t
  }
  ,
  customAlphabet: (e,t)=>dse(e, t, cse),
  customRandom: dse,
  urlAlphabet: use,
  random: cse
}
  , pse = function(e) {
  if ("number" != typeof e || isNaN(e))
    throw new TypeError("Expected a number, got " + typeof e);
  var t = e < 0
    , n = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  if (t && (e = -e),
  e < 1)
    return (t ? "-" : "") + e + " B";
  var r = Math.min(Math.floor(Math.log(e) / Math.log(1024)), n.length - 1);
  e = Number(e / Math.pow(1024, r));
  var o = n[r];
  return e >= 10 || e % 1 == 0 ? (t ? "-" : "") + e.toFixed(0) + " " + o : (t ? "-" : "") + e.toFixed(1) + " " + o
};
function hse(e, t) {
  this.text = e = e || "",
    this.hasWild = ~e.indexOf("*"),
    this.separator = t,
    this.parts = e.split(t)
}
hse.prototype.match = function(e) {
  var t, n, r = !0, o = this.parts, a = o.length;
  if ("string" == typeof e || e instanceof String)
    if (this.hasWild || this.text == e) {
      for (n = (e || "").split(this.separator),
             t = 0; r && t < a; t++)
        "*" !== o[t] && (r = t < n.length && o[t] === n[t]);
      r = r && n
    } else
      r = !1;
  else if ("function" == typeof e.splice)
    for (r = [],
           t = e.length; t--; )
      this.match(e[t]) && (r[r.length] = e[t]);
  else if ("object" == typeof e)
    for (var i in r = {},
      e)
      this.match(i) && (r[i] = e[i]);
  return r
}
;
var vse = /[\/\+\.]/
  , gse = 0;
var mse = function(e) {
  return "__private_" + gse++ + "_" + e
}("publish");
class yse {
  constructor() {
    Object.defineProperty(this, mse, {
      value: bse
    }),
      this.state = {},
      this.callbacks = []
  }
  getState() {
    return this.state
  }
  setState(e) {
    const t = {
      ...this.state
    }
      , n = {
      ...this.state,
      ...e
    };
    this.state = n,
      function(e, t) {
        if (!Object.prototype.hasOwnProperty.call(e, t))
          throw new TypeError("attempted to use private field on non-instance");
        return e
      }(this, mse)[mse](t, n, e)
  }
  subscribe(e) {
    return this.callbacks.push(e),
      ()=>{
        this.callbacks.splice(this.callbacks.indexOf(e), 1)
      }
  }
}
function bse() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  this.callbacks.forEach((e=>{
      e(...t)
    }
  ))
}
yse.VERSION = "2.0.3";
var wse = function(e) {
  const t = e.lastIndexOf(".");
  return -1 === t || t === e.length - 1 ? {
    name: e,
    extension: void 0
  } : {
    name: e.slice(0, t),
    extension: e.slice(t + 1)
  }
}
  , xse = {
  md: "text/markdown",
  markdown: "text/markdown",
  mp4: "video/mp4",
  mp3: "audio/mp3",
  svg: "image/svg+xml",
  jpg: "image/jpeg",
  png: "image/png",
  gif: "image/gif",
  heic: "image/heic",
  heif: "image/heif",
  yaml: "text/yaml",
  yml: "text/yaml",
  csv: "text/csv",
  tsv: "text/tab-separated-values",
  tab: "text/tab-separated-values",
  avi: "video/x-msvideo",
  mks: "video/x-matroska",
  mkv: "video/x-matroska",
  mov: "video/quicktime",
  doc: "application/msword",
  docm: "application/vnd.ms-word.document.macroenabled.12",
  docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  dot: "application/msword",
  dotm: "application/vnd.ms-word.template.macroenabled.12",
  dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
  xla: "application/vnd.ms-excel",
  xlam: "application/vnd.ms-excel.addin.macroenabled.12",
  xlc: "application/vnd.ms-excel",
  xlf: "application/x-xliff+xml",
  xlm: "application/vnd.ms-excel",
  xls: "application/vnd.ms-excel",
  xlsb: "application/vnd.ms-excel.sheet.binary.macroenabled.12",
  xlsm: "application/vnd.ms-excel.sheet.macroenabled.12",
  xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  xlt: "application/vnd.ms-excel",
  xltm: "application/vnd.ms-excel.template.macroenabled.12",
  xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
  xlw: "application/vnd.ms-excel",
  txt: "text/plain",
  text: "text/plain",
  conf: "text/plain",
  log: "text/plain",
  pdf: "application/pdf",
  zip: "application/zip",
  "7z": "application/x-7z-compressed",
  rar: "application/x-rar-compressed",
  tar: "application/x-tar",
  gz: "application/gzip",
  dmg: "application/x-apple-diskimage"
};
function Sse(e) {
  let t = "";
  return e.replace(/[^A-Z0-9]/gi, (e=>{
      return t += `-${n = e,
        n.charCodeAt(0).toString(32)}`,
        "/";
      var n
    }
  )) + t
}
var Ese = function(e) {
  if (null == e && (e = "undefined" != typeof navigator ? navigator.userAgent : null),
    !e)
    return !0;
  const t = /Edge\/(\d+\.\d+)/.exec(e);
  if (!t)
    return !0;
  const n = t[1];
  let[r,o] = n.split(".");
  return r = parseInt(r, 10),
    o = parseInt(o, 10),
  r < 15 || 15 === r && o < 15063 || r > 18 || 18 === r && o >= 18218
};
function Ase(e) {
  return e < 10 ? `0${e}` : e.toString()
}
var Cse = function() {
  const e = new Date;
  return `${Ase(e.getHours())}:${Ase(e.getMinutes())}:${Ase(e.getSeconds())}`
}
  , kse = {
  justErrorsLogger: {
    debug: ()=>{}
    ,
    warn: ()=>{}
    ,
    error: function() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      return console.error(`[Uppy] [${Cse()}]`, ...t)
    }
  },
  debugLogger: {
    debug: function() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      return console.debug(`[Uppy] [${Cse()}]`, ...t)
    },
    warn: function() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      return console.warn(`[Uppy] [${Cse()}]`, ...t)
    },
    error: function() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      return console.error(`[Uppy] [${Cse()}]`, ...t)
    }
  }
}
  , Tse = {
  strings: {
    addBulkFilesFailed: {
      0: "Failed to add %{smart_count} file due to an internal error",
      1: "Failed to add %{smart_count} files due to internal errors"
    },
    youCanOnlyUploadX: {
      0: "You can only upload %{smart_count} file",
      1: "You can only upload %{smart_count} files"
    },
    youHaveToAtLeastSelectX: {
      0: "You have to select at least %{smart_count} file",
      1: "You have to select at least %{smart_count} files"
    },
    exceedsSize: "%{file} exceeds maximum allowed size of %{size}",
    missingRequiredMetaField: "Missing required meta fields",
    missingRequiredMetaFieldOnFile: "Missing required meta fields in %{fileName}",
    inferiorSize: "This file is smaller than the allowed size of %{size}",
    youCanOnlyUploadFileTypes: "You can only upload: %{types}",
    noMoreFilesAllowed: "Cannot add more files",
    noDuplicates: "Cannot add the duplicate file '%{fileName}', it already exists",
    companionError: "Connection with Companion failed",
    authAborted: "Authentication aborted",
    companionUnauthorizeHint: "To unauthorize to your %{provider} account, please go to %{url}",
    failedToUpload: "Failed to upload %{file}",
    noInternetConnection: "No Internet connection",
    connectedToInternet: "Connected to the Internet",
    noFilesFound: "You have no files or folders here",
    selectX: {
      0: "Select %{smart_count}",
      1: "Select %{smart_count}"
    },
    allFilesFromFolderNamed: "All files from folder %{name}",
    openFolderNamed: "Open folder %{name}",
    cancel: "Cancel",
    logOut: "Log out",
    filter: "Filter",
    resetFilter: "Reset filter",
    loading: "Loading...",
    authenticateWithTitle: "Please authenticate with %{pluginName} to select files",
    authenticateWith: "Connect to %{pluginName}",
    signInWithGoogle: "Sign in with Google",
    searchImages: "Search for images",
    enterTextToSearch: "Enter text to search for images",
    backToSearch: "Back to Search",
    emptyFolderAdded: "No files were added from empty folder",
    folderAlreadyAdded: 'The folder "%{folder}" was already added',
    folderAdded: {
      0: "Added %{smart_count} file from %{folder}",
      1: "Added %{smart_count} files from %{folder}"
    }
  }
}
  , Dse = fse;
let Ose, _se;
function Rse(e, t) {
  if (!Object.prototype.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e
}
var Lse = 0;
function Ise(e) {
  return "__private_" + Lse++ + "_" + e
}
const {nanoid: Pse} = Dse
  , {justErrorsLogger: Fse, debugLogger: Bse} = kse;
class Nse extends Error {
  constructor() {
    super(...arguments),
      this.isRestriction = !0
  }
}
"undefined" == typeof AggregateError && (globalThis.AggregateError = class extends Error {
    constructor(e, t) {
      super(t),
        this.errors = e
    }
  }
);
class Mse extends AggregateError {
  constructor() {
    super(...arguments),
      this.isRestriction = !0
  }
}
var jse = Ise("plugins")
  , Vse = Ise("storeUnsubscribe")
  , Use = Ise("emitter")
  , $se = Ise("preProcessors")
  , Hse = Ise("uploaders")
  , zse = Ise("postProcessors")
  , Kse = Ise("checkRestrictions")
  , Wse = Ise("checkMinNumberOfFiles")
  , Gse = Ise("checkRequiredMetaFieldsOnFile")
  , qse = Ise("checkRequiredMetaFields")
  , Yse = Ise("showOrLogErrorAndThrow")
  , Xse = Ise("assertNewUploadAllowed")
  , Qse = Ise("checkAndCreateFileStateObject")
  , Jse = Ise("startIfAutoProceed")
  , Zse = Ise("addListeners")
  , ele = Ise("updateOnlineStatus")
  , tle = Ise("createUpload")
  , nle = Ise("getUpload")
  , rle = Ise("removeUpload")
  , ole = Ise("runUpload");
Ose = Symbol.for("uppy test: getPlugins"),
  _se = Symbol.for("uppy test: createUpload");
class ale {
  constructor(e) {
    Object.defineProperty(this, ole, {
      value: yle
    }),
      Object.defineProperty(this, rle, {
        value: mle
      }),
      Object.defineProperty(this, nle, {
        value: gle
      }),
      Object.defineProperty(this, tle, {
        value: vle
      }),
      Object.defineProperty(this, Zse, {
        value: hle
      }),
      Object.defineProperty(this, Jse, {
        value: ple
      }),
      Object.defineProperty(this, Qse, {
        value: fle
      }),
      Object.defineProperty(this, Xse, {
        value: dle
      }),
      Object.defineProperty(this, Yse, {
        value: cle
      }),
      Object.defineProperty(this, qse, {
        value: ule
      }),
      Object.defineProperty(this, Gse, {
        value: lle
      }),
      Object.defineProperty(this, Wse, {
        value: sle
      }),
      Object.defineProperty(this, Kse, {
        value: ile
      }),
      Object.defineProperty(this, jse, {
        writable: !0,
        value: Object.create(null)
      }),
      Object.defineProperty(this, Vse, {
        writable: !0,
        value: void 0
      }),
      Object.defineProperty(this, Use, {
        writable: !0,
        value: lse()
      }),
      Object.defineProperty(this, $se, {
        writable: !0,
        value: new Set
      }),
      Object.defineProperty(this, Hse, {
        writable: !0,
        value: new Set
      }),
      Object.defineProperty(this, zse, {
        writable: !0,
        value: new Set
      }),
      Object.defineProperty(this, ele, {
        writable: !0,
        value: this.updateOnlineStatus.bind(this)
      }),
      this.defaultLocale = Tse;
    const t = {
      id: "uppy",
      autoProceed: !1,
      allowMultipleUploads: !0,
      allowMultipleUploadBatches: !0,
      debug: !1,
      restrictions: {
        maxFileSize: null,
        minFileSize: null,
        maxTotalFileSize: null,
        maxNumberOfFiles: null,
        minNumberOfFiles: null,
        allowedFileTypes: null,
        requiredMetaFields: []
      },
      meta: {},
      onBeforeFileAdded: e=>e,
      onBeforeUpload: e=>e,
      store: new yse,
      logger: Fse,
      infoTimeout: 5e3
    };
    if (this.opts = {
      ...t,
      ...e,
      restrictions: {
        ...t.restrictions,
        ...e && e.restrictions
      }
    },
      e && e.logger && e.debug ? this.log("You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.", "warning") : e && e.debug && (this.opts.logger = Bse),
      this.log(`Using Core v${this.constructor.VERSION}`),
    this.opts.restrictions.allowedFileTypes && null !== this.opts.restrictions.allowedFileTypes && !Array.isArray(this.opts.restrictions.allowedFileTypes))
      throw new TypeError("`restrictions.allowedFileTypes` must be an array");
    this.i18nInit(),
      this.calculateProgress = uae(this.calculateProgress.bind(this), 500, {
        leading: !0,
        trailing: !0
      }),
      this.store = this.opts.store,
      this.setState({
        plugins: {},
        files: {},
        currentUploads: {},
        allowNewUpload: !0,
        capabilities: {
          uploadProgress: Ese(),
          individualCancellation: !0,
          resumableUploads: !1
        },
        totalProgress: 0,
        meta: {
          ...this.opts.meta
        },
        info: [],
        recoveredState: null
      }),
      Rse(this, Vse)[Vse] = this.store.subscribe(((e,t,n)=>{
          this.emit("state-update", e, t, n),
            this.updateAll(t)
        }
      )),
    this.opts.debug && "undefined" != typeof window && (window[this.opts.id] = this),
      Rse(this, Zse)[Zse]()
  }
  emit(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
    Rse(this, Use)[Use].emit(e, ...n)
  }
  on(e, t) {
    return Rse(this, Use)[Use].on(e, t),
      this
  }
  once(e, t) {
    return Rse(this, Use)[Use].once(e, t),
      this
  }
  off(e, t) {
    return Rse(this, Use)[Use].off(e, t),
      this
  }
  updateAll(e) {
    this.iteratePlugins((t=>{
        t.update(e)
      }
    ))
  }
  setState(e) {
    this.store.setState(e)
  }
  getState() {
    return this.store.getState()
  }
  get state() {
    return this.getState()
  }
  setFileState(e, t) {
    if (!this.getState().files[e])
      throw new Error(`Can’t set state for ${e} (the file could have been removed)`);
    this.setState({
      files: {
        ...this.getState().files,
        [e]: {
          ...this.getState().files[e],
          ...t
        }
      }
    })
  }
  i18nInit() {
    const e = new ise([this.defaultLocale, this.opts.locale]);
    this.i18n = e.translate.bind(e),
      this.i18nArray = e.translateArray.bind(e),
      this.locale = e.locale
  }
  setOptions(e) {
    this.opts = {
      ...this.opts,
      ...e,
      restrictions: {
        ...this.opts.restrictions,
        ...e && e.restrictions
      }
    },
    e.meta && this.setMeta(e.meta),
      this.i18nInit(),
    e.locale && this.iteratePlugins((e=>{
        e.setOptions()
      }
    )),
      this.setState()
  }
  resetProgress() {
    const e = {
      percentage: 0,
      bytesUploaded: 0,
      uploadComplete: !1,
      uploadStarted: null
    }
      , t = {
      ...this.getState().files
    }
      , n = {};
    Object.keys(t).forEach((r=>{
        const o = {
          ...t[r]
        };
        o.progress = {
          ...o.progress,
          ...e
        },
          n[r] = o
      }
    )),
      this.setState({
        files: n,
        totalProgress: 0
      }),
      this.emit("reset-progress")
  }
  addPreProcessor(e) {
    Rse(this, $se)[$se].add(e)
  }
  removePreProcessor(e) {
    return Rse(this, $se)[$se].delete(e)
  }
  addPostProcessor(e) {
    Rse(this, zse)[zse].add(e)
  }
  removePostProcessor(e) {
    return Rse(this, zse)[zse].delete(e)
  }
  addUploader(e) {
    Rse(this, Hse)[Hse].add(e)
  }
  removeUploader(e) {
    return Rse(this, Hse)[Hse].delete(e)
  }
  setMeta(e) {
    const t = {
      ...this.getState().meta,
      ...e
    }
      , n = {
      ...this.getState().files
    };
    Object.keys(n).forEach((t=>{
        n[t] = {
          ...n[t],
          meta: {
            ...n[t].meta,
            ...e
          }
        }
      }
    )),
      this.log("Adding metadata:"),
      this.log(e),
      this.setState({
        meta: t,
        files: n
      })
  }
  setFileMeta(e, t) {
    const n = {
      ...this.getState().files
    };
    if (!n[e])
      return void this.log("Was trying to set metadata for a file that has been removed: ", e);
    const r = {
      ...n[e].meta,
      ...t
    };
    n[e] = {
      ...n[e],
      meta: r
    },
      this.setState({
        files: n
      })
  }
  getFile(e) {
    return this.getState().files[e]
  }
  getFiles() {
    const {files: e} = this.getState();
    return Object.values(e)
  }
  getObjectOfFilesPerState() {
    const {files: e, totalProgress: t, error: n} = this.getState()
      , r = Object.values(e)
      , o = r.filter((e=>{
        let {progress: t} = e;
        return !t.uploadComplete && t.uploadStarted
      }
    ))
      , a = r.filter((e=>!e.progress.uploadStarted))
      , i = r.filter((e=>e.progress.uploadStarted || e.progress.preprocess || e.progress.postprocess))
      , s = r.filter((e=>e.progress.uploadStarted))
      , l = r.filter((e=>e.isPaused))
      , u = r.filter((e=>e.progress.uploadComplete))
      , c = r.filter((e=>e.error))
      , d = o.filter((e=>!e.isPaused))
      , f = r.filter((e=>e.progress.preprocess || e.progress.postprocess));
    return {
      newFiles: a,
      startedFiles: i,
      uploadStartedFiles: s,
      pausedFiles: l,
      completeFiles: u,
      erroredFiles: c,
      inProgressFiles: o,
      inProgressNotPausedFiles: d,
      processingFiles: f,
      isUploadStarted: s.length > 0,
      isAllComplete: 100 === t && u.length === r.length && 0 === f.length,
      isAllErrored: !!n && c.length === r.length,
      isAllPaused: 0 !== o.length && l.length === o.length,
      isUploadInProgress: o.length > 0,
      isSomeGhost: r.some((e=>e.isGhost))
    }
  }
  validateRestrictions(e, t) {
    try {
      return Rse(this, Kse)[Kse](e, t),
        {
          result: !0
        }
    } catch (n) {
      return {
        result: !1,
        reason: n.message
      }
    }
  }
  checkIfFileAlreadyExists(e) {
    const {files: t} = this.getState();
    return !(!t[e] || t[e].isGhost)
  }
  addFile(e) {
    Rse(this, Xse)[Xse](e);
    const {files: t} = this.getState();
    let n = Rse(this, Qse)[Qse](t, e);
    return t[n.id] && t[n.id].isGhost && (n = {
      ...t[n.id],
      data: e.data,
      isGhost: !1
    },
      this.log(`Replaced the blob in the restored ghost file: ${n.name}, ${n.id}`)),
      this.setState({
        files: {
          ...t,
          [n.id]: n
        }
      }),
      this.emit("file-added", n),
      this.emit("files-added", [n]),
      this.log(`Added file: ${n.name}, ${n.id}, mime type: ${n.type}`),
      Rse(this, Jse)[Jse](),
      n.id
  }
  addFiles(e) {
    Rse(this, Xse)[Xse]();
    const t = {
      ...this.getState().files
    }
      , n = []
      , r = [];
    for (let a = 0; a < e.length; a++)
      try {
        let r = Rse(this, Qse)[Qse](t, e[a]);
        t[r.id] && t[r.id].isGhost && (r = {
          ...t[r.id],
          data: e[a].data,
          isGhost: !1
        },
          this.log(`Replaced blob in a ghost file: ${r.name}, ${r.id}`)),
          t[r.id] = r,
          n.push(r)
      } catch (o) {
        o.isRestriction || r.push(o)
      }
    if (this.setState({
      files: t
    }),
      n.forEach((e=>{
          this.emit("file-added", e)
        }
      )),
      this.emit("files-added", n),
      n.length > 5 ? this.log(`Added batch of ${n.length} files`) : Object.keys(n).forEach((e=>{
          this.log(`Added file: ${n[e].name}\n id: ${n[e].id}\n type: ${n[e].type}`)
        }
      )),
    n.length > 0 && Rse(this, Jse)[Jse](),
    r.length > 0) {
      let e = "Multiple errors occurred while adding files:\n";
      if (r.forEach((t=>{
          e += `\n * ${t.message}`
        }
      )),
        this.info({
          message: this.i18n("addBulkFilesFailed", {
            smart_count: r.length
          }),
          details: e
        }, "error", this.opts.infoTimeout),
      "function" == typeof AggregateError)
        throw new AggregateError(r,e);
      {
        const t = new Error(e);
        throw t.errors = r,
          t
      }
    }
  }
  removeFiles(e, t) {
    const {files: n, currentUploads: r} = this.getState()
      , o = {
      ...n
    }
      , a = {
      ...r
    }
      , i = Object.create(null);
    function s(e) {
      return void 0 === i[e]
    }
    e.forEach((e=>{
        n[e] && (i[e] = n[e],
          delete o[e])
      }
    )),
      Object.keys(a).forEach((e=>{
          const t = r[e].fileIDs.filter(s);
          0 !== t.length ? a[e] = {
            ...r[e],
            fileIDs: t
          } : delete a[e]
        }
      ));
    const l = {
      currentUploads: a,
      files: o
    };
    0 === Object.keys(o).length && (l.allowNewUpload = !0,
      l.error = null,
      l.recoveredState = null),
      this.setState(l),
      this.calculateTotalProgress();
    const u = Object.keys(i);
    u.forEach((e=>{
        this.emit("file-removed", i[e], t)
      }
    )),
      u.length > 5 ? this.log(`Removed ${u.length} files`) : this.log(`Removed files: ${u.join(", ")}`)
  }
  removeFile(e, t) {
    void 0 === t && (t = null),
      this.removeFiles([e], t)
  }
  pauseResume(e) {
    if (!this.getState().capabilities.resumableUploads || this.getFile(e).uploadComplete)
      return;
    const t = !this.getFile(e).isPaused;
    return this.setFileState(e, {
      isPaused: t
    }),
      this.emit("upload-pause", e, t),
      t
  }
  pauseAll() {
    const e = {
      ...this.getState().files
    };
    Object.keys(e).filter((t=>!e[t].progress.uploadComplete && e[t].progress.uploadStarted)).forEach((t=>{
        const n = {
          ...e[t],
          isPaused: !0
        };
        e[t] = n
      }
    )),
      this.setState({
        files: e
      }),
      this.emit("pause-all")
  }
  resumeAll() {
    const e = {
      ...this.getState().files
    };
    Object.keys(e).filter((t=>!e[t].progress.uploadComplete && e[t].progress.uploadStarted)).forEach((t=>{
        const n = {
          ...e[t],
          isPaused: !1,
          error: null
        };
        e[t] = n
      }
    )),
      this.setState({
        files: e
      }),
      this.emit("resume-all")
  }
  retryAll() {
    const e = {
      ...this.getState().files
    }
      , t = Object.keys(e).filter((t=>e[t].error));
    if (t.forEach((t=>{
        const n = {
          ...e[t],
          isPaused: !1,
          error: null
        };
        e[t] = n
      }
    )),
      this.setState({
        files: e,
        error: null
      }),
      this.emit("retry-all", t),
    0 === t.length)
      return Promise.resolve({
        successful: [],
        failed: []
      });
    const n = Rse(this, tle)[tle](t, {
      forceAllowNewUpload: !0
    });
    return Rse(this, ole)[ole](n)
  }
  cancelAll() {
    this.emit("cancel-all");
    const {files: e} = this.getState()
      , t = Object.keys(e);
    t.length && this.removeFiles(t, "cancel-all"),
      this.setState({
        totalProgress: 0,
        error: null,
        recoveredState: null
      })
  }
  retryUpload(e) {
    this.setFileState(e, {
      error: null,
      isPaused: !1
    }),
      this.emit("upload-retry", e);
    const t = Rse(this, tle)[tle]([e], {
      forceAllowNewUpload: !0
    });
    return Rse(this, ole)[ole](t)
  }
  reset() {
    this.cancelAll()
  }
  logout() {
    this.iteratePlugins((e=>{
        e.provider && e.provider.logout && e.provider.logout()
      }
    ))
  }
  calculateProgress(e, t) {
    if (!this.getFile(e.id))
      return void this.log(`Not setting progress for a file that has been removed: ${e.id}`);
    const n = Number.isFinite(t.bytesTotal) && t.bytesTotal > 0;
    this.setFileState(e.id, {
      progress: {
        ...this.getFile(e.id).progress,
        bytesUploaded: t.bytesUploaded,
        bytesTotal: t.bytesTotal,
        percentage: n ? Math.round(t.bytesUploaded / t.bytesTotal * 100) : 0
      }
    }),
      this.calculateTotalProgress()
  }
  calculateTotalProgress() {
    const e = this.getFiles().filter((e=>e.progress.uploadStarted || e.progress.preprocess || e.progress.postprocess));
    if (0 === e.length)
      return this.emit("progress", 0),
        void this.setState({
          totalProgress: 0
        });
    const t = e.filter((e=>null != e.progress.bytesTotal))
      , n = e.filter((e=>null == e.progress.bytesTotal));
    if (0 === t.length) {
      const t = 100 * e.length
        , r = n.reduce(((e,t)=>e + t.progress.percentage), 0)
        , o = Math.round(r / t * 100);
      return void this.setState({
        totalProgress: o
      })
    }
    let r = t.reduce(((e,t)=>e + t.progress.bytesTotal), 0);
    const o = r / t.length;
    r += o * n.length;
    let a = 0;
    t.forEach((e=>{
        a += e.progress.bytesUploaded
      }
    )),
      n.forEach((e=>{
          a += o * (e.progress.percentage || 0) / 100
        }
      ));
    let i = 0 === r ? 0 : Math.round(a / r * 100);
    i > 100 && (i = 100),
      this.setState({
        totalProgress: i
      }),
      this.emit("progress", i)
  }
  updateOnlineStatus() {
    void 0 === window.navigator.onLine || window.navigator.onLine ? (this.emit("is-online"),
    this.wasOffline && (this.emit("back-online"),
      this.info(this.i18n("connectedToInternet"), "success", 3e3),
      this.wasOffline = !1)) : (this.emit("is-offline"),
      this.info(this.i18n("noInternetConnection"), "error", 0),
      this.wasOffline = !0)
  }
  getID() {
    return this.opts.id
  }
  use(e, t) {
    if ("function" != typeof e)
      throw new TypeError(`Expected a plugin class, but got ${null === e ? "null" : typeof e}. Please verify that the plugin was imported and spelled correctly.`);
    const n = new e(this,t)
      , r = n.id;
    if (!r)
      throw new Error("Your plugin must have an id");
    if (!n.type)
      throw new Error("Your plugin must have a type");
    const o = this.getPlugin(r);
    if (o) {
      const e = `Already found a plugin named '${o.id}'. Tried to use: '${r}'.\nUppy plugins must have unique \`id\` options. See https://uppy.io/docs/plugins/#id.`;
      throw new Error(e)
    }
    return e.VERSION && this.log(`Using ${r} v${e.VERSION}`),
      n.type in Rse(this, jse)[jse] ? Rse(this, jse)[jse][n.type].push(n) : Rse(this, jse)[jse][n.type] = [n],
      n.install(),
      this
  }
  getPlugin(e) {
    for (const t of Object.values(Rse(this, jse)[jse])) {
      const n = t.find((t=>t.id === e));
      if (null != n)
        return n
    }
  }
  [Ose](e) {
    return Rse(this, jse)[jse][e]
  }
  iteratePlugins(e) {
    Object.values(Rse(this, jse)[jse]).flat(1).forEach(e)
  }
  removePlugin(e) {
    this.log(`Removing plugin ${e.id}`),
      this.emit("plugin-remove", e),
    e.uninstall && e.uninstall();
    const t = Rse(this, jse)[jse][e.type]
      , n = t.findIndex((t=>t.id === e.id));
    -1 !== n && t.splice(n, 1);
    const r = {
      plugins: {
        ...this.getState().plugins,
        [e.id]: void 0
      }
    };
    this.setState(r)
  }
  close() {
    this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`),
      this.reset(),
      Rse(this, Vse)[Vse](),
      this.iteratePlugins((e=>{
          this.removePlugin(e)
        }
      )),
    "undefined" != typeof window && window.removeEventListener && (window.removeEventListener("online", Rse(this, ele)[ele]),
      window.removeEventListener("offline", Rse(this, ele)[ele]))
  }
  hideInfo() {
    const {info: e} = this.getState();
    this.setState({
      info: e.slice(1)
    }),
      this.emit("info-hidden")
  }
  info(e, t, n) {
    void 0 === t && (t = "info"),
    void 0 === n && (n = 3e3);
    const r = "object" == typeof e;
    this.setState({
      info: [...this.getState().info, {
        type: t,
        message: r ? e.message : e,
        details: r ? e.details : null
      }]
    }),
      setTimeout((()=>this.hideInfo()), n),
      this.emit("info-visible")
  }
  log(e, t) {
    const {logger: n} = this.opts;
    switch (t) {
      case "error":
        n.error(e);
        break;
      case "warning":
        n.warn(e);
        break;
      default:
        n.debug(e)
    }
  }
  restore(e) {
    return this.log(`Core: attempting to restore upload "${e}"`),
      this.getState().currentUploads[e] ? Rse(this, ole)[ole](e) : (Rse(this, rle)[rle](e),
        Promise.reject(new Error("Nonexistent upload")))
  }
  [_se]() {
    return Rse(this, tle)[tle](...arguments)
  }
  addResultData(e, t) {
    if (!Rse(this, nle)[nle](e))
      return void this.log(`Not setting result for an upload that has been removed: ${e}`);
    const {currentUploads: n} = this.getState()
      , r = {
      ...n[e],
      result: {
        ...n[e].result,
        ...t
      }
    };
    this.setState({
      currentUploads: {
        ...n,
        [e]: r
      }
    })
  }
  upload() {
    var e;
    null != (e = Rse(this, jse)[jse].uploader) && e.length || this.log("No uploader type plugins are used", "warning");
    let {files: t} = this.getState();
    const n = this.opts.onBeforeUpload(t);
    return !1 === n ? Promise.reject(new Error("Not starting the upload because onBeforeUpload returned false")) : (n && "object" == typeof n && (t = n,
      this.setState({
        files: t
      })),
      Promise.resolve().then((()=>{
          Rse(this, Wse)[Wse](t),
            Rse(this, qse)[qse](t)
        }
      )).catch((e=>{
          Rse(this, Yse)[Yse](e)
        }
      )).then((()=>{
          const {currentUploads: e} = this.getState()
            , n = Object.values(e).flatMap((e=>e.fileIDs))
            , r = [];
          Object.keys(t).forEach((e=>{
              const t = this.getFile(e);
              t.progress.uploadStarted || -1 !== n.indexOf(e) || r.push(t.id)
            }
          ));
          const o = Rse(this, tle)[tle](r);
          return Rse(this, ole)[ole](o)
        }
      )).catch((e=>{
          Rse(this, Yse)[Yse](e, {
            showInformer: !1
          })
        }
      )))
  }
}
function ile(e, t) {
  void 0 === t && (t = this.getFiles());
  const {maxFileSize: n, minFileSize: r, maxTotalFileSize: o, maxNumberOfFiles: a, allowedFileTypes: i} = this.opts.restrictions;
  if (a && t.length + 1 > a)
    throw new Nse(`${this.i18n("youCanOnlyUploadX", {
      smart_count: a
    })}`);
  if (i && !i.some((t=>t.indexOf("/") > -1 ? !!e.type && function(e, t) {
    function n(t) {
      var n = function(e, t, n) {
        var r = new hse(e,vse || /[\/\.]/);
        return void 0 !== t ? r.match(t) : r
      }(t, e);
      return n && n.length >= 2
    }
    return t ? n(t.split(";")[0]) : n
  }(e.type.replace(/;.*?$/, ""), t) : !("." !== t[0] || !e.extension) && e.extension.toLowerCase() === t.substr(1).toLowerCase()))) {
    const e = i.join(", ");
    throw new Nse(this.i18n("youCanOnlyUploadFileTypes", {
      types: e
    }))
  }
  if (o && null != e.size) {
    let n = 0;
    if (n += e.size,
      t.forEach((e=>{
          n += e.size
        }
      )),
    n > o)
      throw new Nse(this.i18n("exceedsSize", {
        size: pse(o),
        file: e.name
      }))
  }
  if (n && null != e.size && e.size > n)
    throw new Nse(this.i18n("exceedsSize", {
      size: pse(n),
      file: e.name
    }));
  if (r && null != e.size && e.size < r)
    throw new Nse(this.i18n("inferiorSize", {
      size: pse(r)
    }))
}
function sle(e) {
  const {minNumberOfFiles: t} = this.opts.restrictions;
  if (Object.keys(e).length < t)
    throw new Nse(`${this.i18n("youHaveToAtLeastSelectX", {
      smart_count: t
    })}`)
}
function lle(e) {
  const {requiredMetaFields: t} = this.opts.restrictions
    , {hasOwnProperty: n} = Object.prototype
    , r = []
    , o = [];
  for (let a = 0; a < t.length; a++)
    if (!n.call(e.meta, t[a]) || "" === e.meta[t[a]]) {
      const n = new Nse(`${this.i18n("missingRequiredMetaFieldOnFile", {
        fileName: e.name
      })}`);
      r.push(n),
        o.push(t[a]),
        Rse(this, Yse)[Yse](n, {
          file: e,
          showInformer: !1,
          throwErr: !1
        })
    }
  return this.setFileState(e.id, {
    missingRequiredMetaFields: o
  }),
    r
}
function ule(e) {
  const t = Object.keys(e).flatMap((e=>{
      const t = this.getFile(e);
      return Rse(this, Gse)[Gse](t)
    }
  ));
  if (t.length)
    throw new Mse(t,`${this.i18n("missingRequiredMetaField")}`)
}
function cle(e, t) {
  let {showInformer: n=!0, file: r=null, throwErr: o=!0} = void 0 === t ? {} : t;
  const a = "object" == typeof e ? e.message : e
    , i = "object" == typeof e && e.details ? e.details : "";
  let s = a;
  if (i && (s += ` ${i}`),
    e.isRestriction ? (this.log(s),
      this.emit("restriction-failed", r, e)) : this.log(s, "error"),
  n && this.info({
    message: a,
    details: i
  }, "error", this.opts.infoTimeout),
    o)
    throw "object" == typeof e ? e : new Error(e)
}
function dle(e) {
  const {allowNewUpload: t} = this.getState();
  !1 === t && Rse(this, Yse)[Yse](new Nse(this.i18n("noMoreFilesAllowed")), {
    file: e
  })
}
function fle(e, t) {
  const n = function(e) {
    var t;
    if (e.type)
      return e.type;
    const n = e.name ? null == (t = wse(e.name).extension) ? void 0 : t.toLowerCase() : null;
    return n && n in xse ? xse[n] : "application/octet-stream"
  }(t)
    , r = (s = n,
    (l = t).name ? l.name : "image" === s.split("/")[0] ? `${s.split("/")[0]}.${s.split("/")[1]}` : "noname")
    , o = wse(r).extension
    , a = Boolean(t.isRemote)
    , i = function(e) {
    let t = "uppy";
    return "string" == typeof e.name && (t += `-${Sse(e.name.toLowerCase())}`),
    void 0 !== e.type && (t += `-${e.type}`),
    e.meta && "string" == typeof e.meta.relativePath && (t += `-${Sse(e.meta.relativePath.toLowerCase())}`),
    void 0 !== e.data.size && (t += `-${e.data.size}`),
    void 0 !== e.data.lastModified && (t += `-${e.data.lastModified}`),
      t
  }({
    ...t,
    type: n
  });
  var s, l;
  if (this.checkIfFileAlreadyExists(i)) {
    const e = new Nse(this.i18n("noDuplicates", {
      fileName: r
    }));
    Rse(this, Yse)[Yse](e, {
      file: t
    })
  }
  const u = t.meta || {};
  u.name = r,
    u.type = n;
  const c = Number.isFinite(t.data.size) ? t.data.size : null;
  let d = {
    source: t.source || "",
    id: i,
    name: r,
    extension: o || "",
    meta: {
      ...this.getState().meta,
      ...u
    },
    type: n,
    data: t.data,
    progress: {
      percentage: 0,
      bytesUploaded: 0,
      bytesTotal: c,
      uploadComplete: !1,
      uploadStarted: null
    },
    size: c,
    isRemote: a,
    remote: t.remote || "",
    preview: t.preview
  };
  const f = this.opts.onBeforeFileAdded(d, e);
  !1 === f ? Rse(this, Yse)[Yse](new Nse("Cannot add the file because onBeforeFileAdded returned false."), {
    showInformer: !1,
    fileDescriptor: t
  }) : "object" == typeof f && null !== f && (d = f);
  try {
    const t = Object.keys(e).map((t=>e[t]));
    Rse(this, Kse)[Kse](d, t)
  } catch (s) {
    Rse(this, Yse)[Yse](s, {
      file: d
    })
  }
  return d
}
function ple() {
  this.opts.autoProceed && !this.scheduledAutoProceed && (this.scheduledAutoProceed = setTimeout((()=>{
      this.scheduledAutoProceed = null,
        this.upload().catch((e=>{
            e.isRestriction || this.log(e.stack || e.message || e)
          }
        ))
    }
  ), 4))
}
function hle() {
  const e = (e,t,n)=>{
      let r = e.message || "Unknown error";
      e.details && (r += ` ${e.details}`),
        this.setState({
          error: r
        }),
      null != t && t.id in this.getState().files && this.setFileState(t.id, {
        error: r,
        response: n
      })
    }
  ;
  this.on("error", e),
    this.on("upload-error", ((t,n,r)=>{
        if (e(n, t, r),
        "object" == typeof n && n.message) {
          const e = new Error(n.message);
          e.details = n.message,
          n.details && (e.details += ` ${n.details}`),
            e.message = this.i18n("failedToUpload", {
              file: t.name
            }),
            Rse(this, Yse)[Yse](e, {
              throwErr: !1
            })
        } else
          Rse(this, Yse)[Yse](n, {
            throwErr: !1
          })
      }
    )),
    this.on("upload", (()=>{
        this.setState({
          error: null
        })
      }
    )),
    this.on("upload-started", (e=>{
        this.getFile(e.id) ? this.setFileState(e.id, {
          progress: {
            uploadStarted: Date.now(),
            uploadComplete: !1,
            percentage: 0,
            bytesUploaded: 0,
            bytesTotal: e.size
          }
        }) : this.log(`Not setting progress for a file that has been removed: ${e.id}`)
      }
    )),
    this.on("upload-progress", this.calculateProgress),
    this.on("upload-success", ((e,t)=>{
        if (!this.getFile(e.id))
          return void this.log(`Not setting progress for a file that has been removed: ${e.id}`);
        const n = this.getFile(e.id).progress;
        this.setFileState(e.id, {
          progress: {
            ...n,
            postprocess: Rse(this, zse)[zse].size > 0 ? {
              mode: "indeterminate"
            } : null,
            uploadComplete: !0,
            percentage: 100,
            bytesUploaded: n.bytesTotal
          },
          response: t,
          uploadURL: t.uploadURL,
          isPaused: !1
        }),
        null == e.size && this.setFileState(e.id, {
          size: t.bytesUploaded || n.bytesTotal
        }),
          this.calculateTotalProgress()
      }
    )),
    this.on("preprocess-progress", ((e,t)=>{
        this.getFile(e.id) ? this.setFileState(e.id, {
          progress: {
            ...this.getFile(e.id).progress,
            preprocess: t
          }
        }) : this.log(`Not setting progress for a file that has been removed: ${e.id}`)
      }
    )),
    this.on("preprocess-complete", (e=>{
        if (!this.getFile(e.id))
          return void this.log(`Not setting progress for a file that has been removed: ${e.id}`);
        const t = {
          ...this.getState().files
        };
        t[e.id] = {
          ...t[e.id],
          progress: {
            ...t[e.id].progress
          }
        },
          delete t[e.id].progress.preprocess,
          this.setState({
            files: t
          })
      }
    )),
    this.on("postprocess-progress", ((e,t)=>{
        this.getFile(e.id) ? this.setFileState(e.id, {
          progress: {
            ...this.getState().files[e.id].progress,
            postprocess: t
          }
        }) : this.log(`Not setting progress for a file that has been removed: ${e.id}`)
      }
    )),
    this.on("postprocess-complete", (e=>{
        if (!this.getFile(e.id))
          return void this.log(`Not setting progress for a file that has been removed: ${e.id}`);
        const t = {
          ...this.getState().files
        };
        t[e.id] = {
          ...t[e.id],
          progress: {
            ...t[e.id].progress
          }
        },
          delete t[e.id].progress.postprocess,
          this.setState({
            files: t
          })
      }
    )),
    this.on("restored", (()=>{
        this.calculateTotalProgress()
      }
    )),
    this.on("dashboard:file-edit-complete", (e=>{
        e && Rse(this, Gse)[Gse](e)
      }
    )),
  "undefined" != typeof window && window.addEventListener && (window.addEventListener("online", Rse(this, ele)[ele]),
    window.addEventListener("offline", Rse(this, ele)[ele]),
    setTimeout(Rse(this, ele)[ele], 3e3))
}
function vle(e, t) {
  void 0 === t && (t = {});
  const {forceAllowNewUpload: n=!1} = t
    , {allowNewUpload: r, currentUploads: o} = this.getState();
  if (!r && !n)
    throw new Error("Cannot create a new upload: already uploading.");
  const a = Pse();
  return this.emit("upload", {
    id: a,
    fileIDs: e
  }),
    this.setState({
      allowNewUpload: !1 !== this.opts.allowMultipleUploadBatches && !1 !== this.opts.allowMultipleUploads,
      currentUploads: {
        ...o,
        [a]: {
          fileIDs: e,
          step: 0,
          result: {}
        }
      }
    }),
    a
}
function gle(e) {
  const {currentUploads: t} = this.getState();
  return t[e]
}
function mle(e) {
  const t = {
    ...this.getState().currentUploads
  };
  delete t[e],
    this.setState({
      currentUploads: t
    })
}
async function yle(e) {
  let {currentUploads: t} = this.getState()
    , n = t[e];
  const r = n.step || 0
    , o = [...Rse(this, $se)[$se], ...Rse(this, Hse)[Hse], ...Rse(this, zse)[zse]];
  try {
    for (let a = r; a < o.length && n; a++) {
      const r = o[a]
        , i = {
        ...n,
        step: a
      };
      this.setState({
        currentUploads: {
          ...t,
          [e]: i
        }
      }),
        await r(i.fileIDs, e),
        t = this.getState().currentUploads,
        n = t[e]
    }
  } catch (i) {
    throw this.emit("error", i),
      Rse(this, rle)[rle](e),
      i
  }
  if (n) {
    n.fileIDs.forEach((e=>{
        const t = this.getFile(e);
        t && t.progress.postprocess && this.emit("postprocess-complete", t)
      }
    ));
    const r = n.fileIDs.map((e=>this.getFile(e)))
      , o = r.filter((e=>!e.error))
      , a = r.filter((e=>e.error));
    await this.addResultData(e, {
      successful: o,
      failed: a,
      uploadID: e
    }),
      t = this.getState().currentUploads,
      n = t[e]
  }
  let a;
  return n && (a = n.result,
    this.emit("complete", a),
    Rse(this, rle)[rle](e)),
  null == a && this.log(`Not setting result for an upload that has been removed: ${e}`),
    a
}
ale.VERSION = "2.1.3";
var ble = ale
  , wle = jZ((function(e, t) {
      var n, r, o, a, i, s, l, u, c = {}, d = [], f = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
      function p(e, t) {
        for (var n in t)
          e[n] = t[n];
        return e
      }
      function h(e) {
        var t = e.parentNode;
        t && t.removeChild(e)
      }
      function v(e, t, r) {
        var o, a, i, s = {};
        for (i in t)
          "key" == i ? o = t[i] : "ref" == i ? a = t[i] : s[i] = t[i];
        if (arguments.length > 2 && (s.children = arguments.length > 3 ? n.call(arguments, 2) : r),
        "function" == typeof e && null != e.defaultProps)
          for (i in e.defaultProps)
            void 0 === s[i] && (s[i] = e.defaultProps[i]);
        return g(e, s, o, a, null)
      }
      function g(e, t, n, a, i) {
        var s = {
          type: e,
          props: t,
          key: n,
          ref: a,
          __k: null,
          __: null,
          __b: 0,
          __e: null,
          __d: void 0,
          __c: null,
          __h: null,
          constructor: void 0,
          __v: null == i ? ++o : i
        };
        return null == i && null != r.vnode && r.vnode(s),
          s
      }
      function m(e) {
        return e.children
      }
      function y(e, t) {
        this.props = e,
          this.context = t
      }
      function b(e, t) {
        if (null == t)
          return e.__ ? b(e.__, e.__.__k.indexOf(e) + 1) : null;
        for (var n; t < e.__k.length; t++)
          if (null != (n = e.__k[t]) && null != n.__e)
            return n.__e;
        return "function" == typeof e.type ? b(e) : null
      }
      function w(e) {
        var t, n;
        if (null != (e = e.__) && null != e.__c) {
          for (e.__e = e.__c.base = null,
                 t = 0; t < e.__k.length; t++)
            if (null != (n = e.__k[t]) && null != n.__e) {
              e.__e = e.__c.base = n.__e;
              break
            }
          return w(e)
        }
      }
      function x(e) {
        (!e.__d && (e.__d = !0) && i.push(e) && !S.__r++ || l !== r.debounceRendering) && ((l = r.debounceRendering) || s)(S)
      }
      function S() {
        for (var e; S.__r = i.length; )
          e = i.sort((function(e, t) {
              return e.__v.__b - t.__v.__b
            }
          )),
            i = [],
            e.some((function(e) {
                var t, n, r, o, a, i;
                e.__d && (a = (o = (t = e).__v).__e,
                (i = t.__P) && (n = [],
                  (r = p({}, o)).__v = o.__v + 1,
                  _(i, o, r, t.__n, void 0 !== i.ownerSVGElement, null != o.__h ? [a] : null, n, null == a ? b(o) : a, o.__h),
                  R(n, o),
                o.__e != a && w(o)))
              }
            ))
      }
      function E(e, t, n, r, o, a, i, s, l, u) {
        var f, p, h, v, y, w, x, S = r && r.__k || d, E = S.length;
        for (n.__k = [],
               f = 0; f < t.length; f++)
          if (null != (v = n.__k[f] = null == (v = t[f]) || "boolean" == typeof v ? null : "string" == typeof v || "number" == typeof v || "bigint" == typeof v ? g(null, v, null, null, v) : Array.isArray(v) ? g(m, {
            children: v
          }, null, null, null) : v.__b > 0 ? g(v.type, v.props, v.key, null, v.__v) : v)) {
            if (v.__ = n,
              v.__b = n.__b + 1,
            null === (h = S[f]) || h && v.key == h.key && v.type === h.type)
              S[f] = void 0;
            else
              for (p = 0; p < E; p++) {
                if ((h = S[p]) && v.key == h.key && v.type === h.type) {
                  S[p] = void 0;
                  break
                }
                h = null
              }
            _(e, v, h = h || c, o, a, i, s, l, u),
              y = v.__e,
            (p = v.ref) && h.ref != p && (x || (x = []),
            h.ref && x.push(h.ref, null, v),
              x.push(p, v.__c || y, v)),
              null != y ? (null == w && (w = y),
                "function" == typeof v.type && v.__k === h.__k ? v.__d = l = A(v, l, e) : l = C(e, v, h, S, y, l),
              "function" == typeof n.type && (n.__d = l)) : l && h.__e == l && l.parentNode != e && (l = b(h))
          }
        for (n.__e = w,
               f = E; f--; )
          null != S[f] && ("function" == typeof n.type && null != S[f].__e && S[f].__e == n.__d && (n.__d = b(r, f + 1)),
            I(S[f], S[f]));
        if (x)
          for (f = 0; f < x.length; f++)
            L(x[f], x[++f], x[++f])
      }
      function A(e, t, n) {
        for (var r, o = e.__k, a = 0; o && a < o.length; a++)
          (r = o[a]) && (r.__ = e,
            t = "function" == typeof r.type ? A(r, t, n) : C(n, r, r, o, r.__e, t));
        return t
      }
      function C(e, t, n, r, o, a) {
        var i, s, l;
        if (void 0 !== t.__d)
          i = t.__d,
            t.__d = void 0;
        else if (null == n || o != a || null == o.parentNode)
          e: if (null == a || a.parentNode !== e)
            e.appendChild(o),
              i = null;
          else {
            for (s = a,
                   l = 0; (s = s.nextSibling) && l < r.length; l += 2)
              if (s == o)
                break e;
            e.insertBefore(o, a),
              i = a
          }
        return void 0 !== i ? i : o.nextSibling
      }
      function k(e, t, n) {
        "-" === t[0] ? e.setProperty(t, n) : e[t] = null == n ? "" : "number" != typeof n || f.test(t) ? n : n + "px"
      }
      function T(e, t, n, r, o) {
        var a;
        e: if ("style" === t)
          if ("string" == typeof n)
            e.style.cssText = n;
          else {
            if ("string" == typeof r && (e.style.cssText = r = ""),
              r)
              for (t in r)
                n && t in n || k(e.style, t, "");
            if (n)
              for (t in n)
                r && n[t] === r[t] || k(e.style, t, n[t])
          }
        else if ("o" === t[0] && "n" === t[1])
          a = t !== (t = t.replace(/Capture$/, "")),
            t = t.toLowerCase()in e ? t.toLowerCase().slice(2) : t.slice(2),
          e.l || (e.l = {}),
            e.l[t + a] = n,
            n ? r || e.addEventListener(t, a ? O : D, a) : e.removeEventListener(t, a ? O : D, a);
        else if ("dangerouslySetInnerHTML" !== t) {
          if (o)
            t = t.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
          else if ("href" !== t && "list" !== t && "form" !== t && "tabIndex" !== t && "download" !== t && t in e)
            try {
              e[t] = null == n ? "" : n;
              break e
            } catch (i) {}
          "function" == typeof n || (null != n && (!1 !== n || "a" === t[0] && "r" === t[1]) ? e.setAttribute(t, n) : e.removeAttribute(t))
        }
      }
      function D(e) {
        this.l[e.type + !1](r.event ? r.event(e) : e)
      }
      function O(e) {
        this.l[e.type + !0](r.event ? r.event(e) : e)
      }
      function _(e, t, o, a, i, s, l, u, d) {
        var f, v, g, w, x, S, A, C, k, D, O, _ = t.type;
        if (void 0 !== t.constructor)
          return null;
        null != o.__h && (d = o.__h,
          u = t.__e = o.__e,
          t.__h = null,
          s = [u]),
        (f = r.__b) && f(t);
        try {
          e: if ("function" == typeof _) {
            if (C = t.props,
              k = (f = _.contextType) && a[f.__c],
              D = f ? k ? k.props.value : f.__ : a,
              o.__c ? A = (v = t.__c = o.__c).__ = v.__E : ("prototype"in _ && _.prototype.render ? t.__c = v = new _(C,D) : (t.__c = v = new y(C,D),
                v.constructor = _,
                v.render = P),
              k && k.sub(v),
                v.props = C,
              v.state || (v.state = {}),
                v.context = D,
                v.__n = a,
                g = v.__d = !0,
                v.__h = []),
            null == v.__s && (v.__s = v.state),
            null != _.getDerivedStateFromProps && (v.__s == v.state && (v.__s = p({}, v.__s)),
              p(v.__s, _.getDerivedStateFromProps(C, v.__s))),
              w = v.props,
              x = v.state,
              g)
              null == _.getDerivedStateFromProps && null != v.componentWillMount && v.componentWillMount(),
              null != v.componentDidMount && v.__h.push(v.componentDidMount);
            else {
              if (null == _.getDerivedStateFromProps && C !== w && null != v.componentWillReceiveProps && v.componentWillReceiveProps(C, D),
              !v.__e && null != v.shouldComponentUpdate && !1 === v.shouldComponentUpdate(C, v.__s, D) || t.__v === o.__v) {
                v.props = C,
                  v.state = v.__s,
                t.__v !== o.__v && (v.__d = !1),
                  v.__v = t,
                  t.__e = o.__e,
                  t.__k = o.__k,
                  t.__k.forEach((function(e) {
                      e && (e.__ = t)
                    }
                  )),
                v.__h.length && l.push(v);
                break e
              }
              null != v.componentWillUpdate && v.componentWillUpdate(C, v.__s, D),
              null != v.componentDidUpdate && v.__h.push((function() {
                  v.componentDidUpdate(w, x, S)
                }
              ))
            }
            v.context = D,
              v.props = C,
              v.state = v.__s,
            (f = r.__r) && f(t),
              v.__d = !1,
              v.__v = t,
              v.__P = e,
              f = v.render(v.props, v.state, v.context),
              v.state = v.__s,
            null != v.getChildContext && (a = p(p({}, a), v.getChildContext())),
            g || null == v.getSnapshotBeforeUpdate || (S = v.getSnapshotBeforeUpdate(w, x)),
              O = null != f && f.type === m && null == f.key ? f.props.children : f,
              E(e, Array.isArray(O) ? O : [O], t, o, a, i, s, l, u, d),
              v.base = t.__e,
              t.__h = null,
            v.__h.length && l.push(v),
            A && (v.__E = v.__ = null),
              v.__e = !1
          } else
            null == s && t.__v === o.__v ? (t.__k = o.__k,
              t.__e = o.__e) : t.__e = function(e, t, r, o, a, i, s, l) {
              var u, d, f, p = r.props, v = t.props, g = t.type, m = 0;
              if ("svg" === g && (a = !0),
              null != i)
                for (; m < i.length; m++)
                  if ((u = i[m]) && "setAttribute"in u == !!g && (g ? u.localName === g : 3 === u.nodeType)) {
                    e = u,
                      i[m] = null;
                    break
                  }
              if (null == e) {
                if (null === g)
                  return document.createTextNode(v);
                e = a ? document.createElementNS("http://www.w3.org/2000/svg", g) : document.createElement(g, v.is && v),
                  i = null,
                  l = !1
              }
              if (null === g)
                p === v || l && e.data === v || (e.data = v);
              else {
                if (i = i && n.call(e.childNodes),
                  d = (p = r.props || c).dangerouslySetInnerHTML,
                  f = v.dangerouslySetInnerHTML,
                  !l) {
                  if (null != i)
                    for (p = {},
                           m = 0; m < e.attributes.length; m++)
                      p[e.attributes[m].name] = e.attributes[m].value;
                  (f || d) && (f && (d && f.__html == d.__html || f.__html === e.innerHTML) || (e.innerHTML = f && f.__html || ""))
                }
                if (function(e, t, n, r, o) {
                  var a;
                  for (a in n)
                    "children" === a || "key" === a || a in t || T(e, a, null, n[a], r);
                  for (a in t)
                    o && "function" != typeof t[a] || "children" === a || "key" === a || "value" === a || "checked" === a || n[a] === t[a] || T(e, a, t[a], n[a], r)
                }(e, v, p, a, l),
                  f)
                  t.__k = [];
                else if (m = t.props.children,
                  E(e, Array.isArray(m) ? m : [m], t, r, o, a && "foreignObject" !== g, i, s, i ? i[0] : r.__k && b(r, 0), l),
                null != i)
                  for (m = i.length; m--; )
                    null != i[m] && h(i[m]);
                l || ("value"in v && void 0 !== (m = v.value) && (m !== p.value || m !== e.value || "progress" === g && !m) && T(e, "value", m, p.value, !1),
                "checked"in v && void 0 !== (m = v.checked) && m !== e.checked && T(e, "checked", m, p.checked, !1))
              }
              return e
            }(o.__e, t, o, a, i, s, l, d);
          (f = r.diffed) && f(t)
        } catch (R) {
          t.__v = null,
          (d || null != s) && (t.__e = u,
            t.__h = !!d,
            s[s.indexOf(u)] = null),
            r.__e(R, t, o)
        }
      }
      function R(e, t) {
        r.__c && r.__c(t, e),
          e.some((function(t) {
              try {
                e = t.__h,
                  t.__h = [],
                  e.some((function(e) {
                      e.call(t)
                    }
                  ))
              } catch (n) {
                r.__e(n, t.__v)
              }
            }
          ))
      }
      function L(e, t, n) {
        try {
          "function" == typeof e ? e(t) : e.current = t
        } catch (o) {
          r.__e(o, n)
        }
      }
      function I(e, t, n) {
        var o, a;
        if (r.unmount && r.unmount(e),
        (o = e.ref) && (o.current && o.current !== e.__e || L(o, null, t)),
        null != (o = e.__c)) {
          if (o.componentWillUnmount)
            try {
              o.componentWillUnmount()
            } catch (i) {
              r.__e(i, t)
            }
          o.base = o.__P = null
        }
        if (o = e.__k)
          for (a = 0; a < o.length; a++)
            o[a] && I(o[a], t, "function" != typeof e.type);
        n || null == e.__e || h(e.__e),
          e.__e = e.__d = void 0
      }
      function P(e, t, n) {
        return this.constructor(e, n)
      }
      function F(e, t, o) {
        var a, i, s;
        r.__ && r.__(e, t),
          i = (a = "function" == typeof o) ? null : o && o.__k || t.__k,
          s = [],
          _(t, e = (!a && o || t).__k = v(m, null, [e]), i || c, c, void 0 !== t.ownerSVGElement, !a && o ? [o] : i ? null : t.firstChild ? n.call(t.childNodes) : null, s, !a && o ? o : i ? i.__e : t.firstChild, a),
          R(s, e)
      }
      n = d.slice,
        r = {
          __e: function(e, t) {
            for (var n, r, o; t = t.__; )
              if ((n = t.__c) && !n.__)
                try {
                  if ((r = n.constructor) && null != r.getDerivedStateFromError && (n.setState(r.getDerivedStateFromError(e)),
                    o = n.__d),
                  null != n.componentDidCatch && (n.componentDidCatch(e),
                    o = n.__d),
                    o)
                    return n.__E = n
                } catch (a) {
                  e = a
                }
            throw e
          }
        },
        o = 0,
        a = function(e) {
          return null != e && void 0 === e.constructor
        }
        ,
        y.prototype.setState = function(e, t) {
          var n;
          n = null != this.__s && this.__s !== this.state ? this.__s : this.__s = p({}, this.state),
          "function" == typeof e && (e = e(p({}, n), this.props)),
          e && p(n, e),
          null != e && this.__v && (t && this.__h.push(t),
            x(this))
        }
        ,
        y.prototype.forceUpdate = function(e) {
          this.__v && (this.__e = !0,
          e && this.__h.push(e),
            x(this))
        }
        ,
        y.prototype.render = m,
        i = [],
        s = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout,
        S.__r = 0,
        u = 0,
        t.Component = y,
        t.Fragment = m,
        t.cloneElement = function(e, t, r) {
          var o, a, i, s = p({}, e.props);
          for (i in t)
            "key" == i ? o = t[i] : "ref" == i ? a = t[i] : s[i] = t[i];
          return arguments.length > 2 && (s.children = arguments.length > 3 ? n.call(arguments, 2) : r),
            g(e.type, s, o || e.key, a || e.ref, null)
        }
        ,
        t.createContext = function(e, t) {
          var n = {
            __c: t = "__cC" + u++,
            __: e,
            Consumer: function(e, t) {
              return e.children(t)
            },
            Provider: function(e) {
              var n, r;
              return this.getChildContext || (n = [],
                  (r = {})[t] = this,
                  this.getChildContext = function() {
                    return r
                  }
                  ,
                  this.shouldComponentUpdate = function(e) {
                    this.props.value !== e.value && n.some(x)
                  }
                  ,
                  this.sub = function(e) {
                    n.push(e);
                    var t = e.componentWillUnmount;
                    e.componentWillUnmount = function() {
                      n.splice(n.indexOf(e), 1),
                      t && t.call(e)
                    }
                  }
              ),
                e.children
            }
          };
          return n.Provider.__ = n.Consumer.contextType = n
        }
        ,
        t.createElement = v,
        t.createRef = function() {
          return {
            current: null
          }
        }
        ,
        t.h = v,
        t.hydrate = function e(t, n) {
          F(t, n, e)
        }
        ,
        t.isValidElement = a,
        t.options = r,
        t.render = F,
        t.toChildArray = function e(t, n) {
          return n = n || [],
          null == t || "boolean" == typeof t || (Array.isArray(t) ? t.some((function(t) {
              e(t, n)
            }
          )) : n.push(t)),
            n
        }
    }
  ))
  , xle = class {
    constructor(e, t) {
      void 0 === t && (t = {}),
        this.uppy = e,
        this.opts = t
    }
    getPluginState() {
      const {plugins: e} = this.uppy.getState();
      return e[this.id] || {}
    }
    setPluginState(e) {
      const {plugins: t} = this.uppy.getState();
      this.uppy.setState({
        plugins: {
          ...t,
          [this.id]: {
            ...t[this.id],
            ...e
          }
        }
      })
    }
    setOptions(e) {
      this.opts = {
        ...this.opts,
        ...e
      },
        this.setPluginState(),
        this.i18nInit()
    }
    i18nInit() {
      const e = new ise([this.defaultLocale, this.uppy.locale, this.opts.locale]);
      this.i18n = e.translate.bind(e),
        this.i18nArray = e.translateArray.bind(e),
        this.setPluginState()
    }
    addTarget() {
      throw new Error("Extend the addTarget method to add your plugin to another plugin's target")
    }
    install() {}
    uninstall() {}
    render() {
      throw new Error("Extend the render method to add your plugin to a DOM element")
    }
    update() {}
    afterUpdate() {}
  }
;
function Sle(e, t) {
  if (!Object.prototype.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e
}
var Ele = 0;
const {render: Ale} = wle;
var Cle = function(e) {
  return "__private_" + Ele++ + "_" + e
}("updateUI");
class kle extends xle {
  constructor() {
    super(...arguments),
      Object.defineProperty(this, Cle, {
        writable: !0,
        value: void 0
      })
  }
  mount(e, t) {
    const n = t.id
      , r = function(e, t) {
      return void 0 === t && (t = document),
        "string" == typeof e ? t.querySelector(e) : (null == (n = e) ? void 0 : n.nodeType) === Node.ELEMENT_NODE ? e : null;
      var n
    }(e);
    if (r) {
      this.isTargetDOMEl = !0;
      const t = document.createDocumentFragment();
      return Sle(this, Cle)[Cle] = function(e) {
        let t = null
          , n = null;
        return function() {
          for (var r = arguments.length, o = new Array(r), a = 0; a < r; a++)
            o[a] = arguments[a];
          return n = o,
          t || (t = Promise.resolve().then((()=>(t = null,
            e(...n))))),
            t
        }
      }((e=>{
          this.uppy.getPlugin(this.id) && (Ale(this.render(e), t),
            this.afterUpdate())
        }
      )),
        this.uppy.log(`Installing ${n} to a DOM element '${e}'`),
      this.opts.replaceTargetContent && (r.innerHTML = ""),
        Ale(this.render(this.uppy.getState()), t),
        this.el = t.firstElementChild,
        r.appendChild(t),
        this.onMount(),
        this.el
    }
    let o;
    if ("object" == typeof e && e instanceof kle)
      o = e;
    else if ("function" == typeof e) {
      const t = e;
      this.uppy.iteratePlugins((e=>{
          if (e instanceof t)
            return o = e,
              !1
        }
      ))
    }
    if (o)
      return this.uppy.log(`Installing ${n} to ${o.id}`),
        this.parent = o,
        this.el = o.addTarget(t),
        this.onMount(),
        this.el;
    this.uppy.log(`Not installing ${n}`);
    let a = `Invalid target option given to ${n}.`;
    throw a += "function" == typeof e ? " The given target is not a Plugin class. Please check that you're not specifying a React Component instead of a plugin. If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly." : "If you meant to target an HTML element, please make sure that the element exists. Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. (see https://github.com/transloadit/uppy/issues/1042)\n\nIf you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.",
      new Error(a)
  }
  update(e) {
    var t, n;
    null != this.el && (null == (t = (n = Sle(this, Cle))[Cle]) || t.call(n, e))
  }
  unmount() {
    var e;
    this.isTargetDOMEl && (null == (e = this.el) || e.remove()),
      this.onUnmount()
  }
  onMount() {}
  onUnmount() {}
}
var Tle = kle;
const {debugLogger: Dle} = kse;
var Ole = ble
  , _le = ble
  , Rle = Tle
  , Lle = xle
  , Ile = Dle;
Ole.Uppy = _le,
  Ole.UIPlugin = Rle,
  Ole.BasePlugin = Lle,
  Ole.debugLogger = Ile;
class Ple extends Error {
  constructor(e, t) {
    void 0 === t && (t = null),
      super("This looks like a network error, the endpoint might be blocked by an internet provider or a firewall."),
      this.cause = e,
      this.isNetworkError = !0,
      this.request = t
  }
}
var Fle = Ple
  , Ble = function() {
  return fetch(...arguments).catch((e=>{
      throw "AbortError" === e.name ? e : new Fle(e)
    }
  ))
};
class Nle extends Error {
  constructor() {
    super("Authorization required"),
      this.name = "AuthError",
      this.isAuthError = !0
  }
}
var Mle, jle, Vle, Ule, $le, Hle = Nle;
function zle(e, t) {
  if (!Object.prototype.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e
}
var Kle = 0;
function Wle(e) {
  return "__private_" + Kle++ + "_" + e
}
async function Gle(e) {
  if (401 === e.status)
    throw new Hle;
  const t = e.json();
  if (e.status < 200 || e.status > 300) {
    let n = `Failed request with status: ${e.status}. ${e.statusText}`;
    try {
      const e = await t;
      n = e.message ? `${n} message: ${e.message}` : n,
        n = e.requestId ? `${n} request-Id: ${e.requestId}` : n
    } finally {
      throw new Error(n)
    }
  }
  return t
}
var qle = (jle = Wle("getPostResponseFunc"),
  Vle = Wle("getUrl"),
  Ule = Wle("errorHandler"),
  $le = Mle = class e {
    constructor(e, t) {
      Object.defineProperty(this, Ule, {
        value: Xle
      }),
        Object.defineProperty(this, Vle, {
          value: Yle
        }),
        Object.defineProperty(this, jle, {
          writable: !0,
          value: e=>t=>e ? t : this.onReceiveResponse(t)
        }),
        this.uppy = e,
        this.opts = t,
        this.onReceiveResponse = this.onReceiveResponse.bind(this),
        this.allowedHeaders = ["accept", "content-type", "uppy-auth-token"],
        this.preflightDone = !1
    }
    get hostname() {
      const {companion: e} = this.uppy.getState()
        , t = this.opts.companionUrl;
      return (e && e[t] ? e[t] : t).replace(/\/$/, "")
    }
    headers() {
      const t = this.opts.companionHeaders || {};
      return Promise.resolve({
        ...e.defaultHeaders,
        ...t
      })
    }
    onReceiveResponse(e) {
      const t = this.uppy.getState().companion || {}
        , n = this.opts.companionUrl
        , {headers: r} = e;
      return r.has("i-am") && r.get("i-am") !== t[n] && this.uppy.setState({
        companion: {
          ...t,
          [n]: r.get("i-am")
        }
      }),
        e
    }
    preflight(e) {
      return this.preflightDone ? Promise.resolve(this.allowedHeaders.slice()) : fetch(zle(this, Vle)[Vle](e), {
        method: "OPTIONS"
      }).then((e=>(e.headers.has("access-control-allow-headers") && (this.allowedHeaders = e.headers.get("access-control-allow-headers").split(",").map((e=>e.trim().toLowerCase()))),
        this.preflightDone = !0,
        this.allowedHeaders.slice()))).catch((e=>(this.uppy.log(`[CompanionClient] unable to make preflight request ${e}`, "warning"),
        this.preflightDone = !0,
        this.allowedHeaders.slice())))
    }
    preflightAndHeaders(e) {
      return Promise.all([this.preflight(e), this.headers()]).then((e=>{
          let[t,n] = e;
          return Object.keys(n).forEach((e=>{
              t.includes(e.toLowerCase()) || (this.uppy.log(`[CompanionClient] excluding disallowed header ${e}`),
                delete n[e])
            }
          )),
            n
        }
      ))
    }
    get(e, t) {
      return this.preflightAndHeaders(e).then((t=>Ble(zle(this, Vle)[Vle](e), {
        method: "get",
        headers: t,
        credentials: this.opts.companionCookiesRule || "same-origin"
      }))).then(zle(this, jle)[jle](t)).then(Gle).catch(zle(this, Ule)[Ule]("get", e))
    }
    post(e, t, n) {
      const r = "post";
      return this.preflightAndHeaders(e).then((n=>Ble(zle(this, Vle)[Vle](e), {
        method: r,
        headers: n,
        credentials: this.opts.companionCookiesRule || "same-origin",
        body: JSON.stringify(t)
      }))).then(zle(this, jle)[jle](n)).then(Gle).catch(zle(this, Ule)[Ule](r, e))
    }
    delete(e, t, n) {
      const r = "delete";
      return this.preflightAndHeaders(e).then((n=>Ble(`${this.hostname}/${e}`, {
        method: r,
        headers: n,
        credentials: this.opts.companionCookiesRule || "same-origin",
        body: t ? JSON.stringify(t) : null
      }))).then(zle(this, jle)[jle](n)).then(Gle).catch(zle(this, Ule)[Ule](r, e))
    }
  }
  ,
  Mle.VERSION = "2.0.4",
  Mle.defaultHeaders = {
    Accept: "application/json",
    "Content-Type": "application/json",
    "Uppy-Versions": `@uppy/companion-client=${Mle.VERSION}`
  },
  $le);
function Yle(e) {
  return /^(https?:|)\/\//.test(e) ? e : `${this.hostname}/${e}`
}
function Xle(e, t) {
  return n=>{
    var r;
    if (null == (r = n) || !r.isAuthError) {
      const r = new Error(`Could not ${e} ${zle(this, Vle)[Vle](t)}`);
      r.cause = n,
        n = r
    }
    return Promise.reject(n)
  }
}
var Qle, Jle, Zle, eue, tue, nue = {
  setItem: (e,t)=>new Promise((n=>{
      localStorage.setItem(e, t),
        n()
    }
  )),
  getItem: e=>Promise.resolve(localStorage.getItem(e)),
  removeItem: e=>new Promise((t=>{
      localStorage.removeItem(e),
        t()
    }
  ))
};
let rue, oue;
function aue(e, t) {
  if (!Object.prototype.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e
}
var iue = 0;
function sue(e) {
  return "__private_" + iue++ + "_" + e
}
var lue, uue, cue = (Qle = sue("queued"),
    Jle = sue("emitter"),
    Zle = sue("isOpen"),
    eue = sue("socket"),
    tue = sue("handleMessage"),
    rue = Symbol.for("uppy test: getSocket"),
    oue = Symbol.for("uppy test: getQueued"),
    class {
      constructor(e) {
        Object.defineProperty(this, Qle, {
          writable: !0,
          value: []
        }),
          Object.defineProperty(this, Jle, {
            writable: !0,
            value: lse()
          }),
          Object.defineProperty(this, Zle, {
            writable: !0,
            value: !1
          }),
          Object.defineProperty(this, eue, {
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, tue, {
            writable: !0,
            value: e=>{
              try {
                const t = JSON.parse(e.data);
                this.emit(t.action, t.payload)
              } catch (t) {
                console.log(t)
              }
            }
          }),
          this.opts = e,
        e && !1 === e.autoOpen || this.open()
      }
      get isOpen() {
        return aue(this, Zle)[Zle]
      }
      [rue]() {
        return aue(this, eue)[eue]
      }
      [oue]() {
        return aue(this, Qle)[Qle]
      }
      open() {
        aue(this, eue)[eue] = new WebSocket(this.opts.target),
          aue(this, eue)[eue].onopen = ()=>{
            for (aue(this, Zle)[Zle] = !0; aue(this, Qle)[Qle].length > 0 && aue(this, Zle)[Zle]; ) {
              const e = aue(this, Qle)[Qle].shift();
              this.send(e.action, e.payload)
            }
          }
          ,
          aue(this, eue)[eue].onclose = ()=>{
            aue(this, Zle)[Zle] = !1
          }
          ,
          aue(this, eue)[eue].onmessage = aue(this, tue)[tue]
      }
      close() {
        var e;
        null == (e = aue(this, eue)[eue]) || e.close()
      }
      send(e, t) {
        aue(this, Zle)[Zle] ? aue(this, eue)[eue].send(JSON.stringify({
          action: e,
          payload: t
        })) : aue(this, Qle)[Qle].push({
          action: e,
          payload: t
        })
      }
      on(e, t) {
        aue(this, Jle)[Jle].on(e, t)
      }
      emit(e, t) {
        aue(this, Jle)[Jle].emit(e, t)
      }
      once(e, t) {
        aue(this, Jle)[Jle].once(e, t)
      }
    }
), due = {
  RequestClient: qle,
  Provider: class extends qle {
    constructor(e, t) {
      super(e, t),
        this.provider = t.provider,
        this.id = this.provider,
        this.name = this.opts.name || (e=>this.id.split("-").map((e=>e.charAt(0).toUpperCase() + e.slice(1))).join(" "))(),
        this.pluginId = this.opts.pluginId,
        this.tokenKey = `companion-${this.pluginId}-auth-token`,
        this.companionKeysParams = this.opts.companionKeysParams,
        this.preAuthToken = null
    }
    headers() {
      return Promise.all([super.headers(), this.getAuthToken()]).then((e=>{
          let[t,n] = e;
          const r = {};
          return n && (r["uppy-auth-token"] = n),
          this.companionKeysParams && (r["uppy-credentials-params"] = btoa(JSON.stringify({
            params: this.companionKeysParams
          }))),
            {
              ...t,
              ...r
            }
        }
      ))
    }
    onReceiveResponse(e) {
      e = super.onReceiveResponse(e);
      const t = this.uppy.getPlugin(this.pluginId)
        , n = t.getPluginState().authenticated ? 401 !== e.status : e.status < 400;
      return t.setPluginState({
        authenticated: n
      }),
        e
    }
    setAuthToken(e) {
      return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, e)
    }
    getAuthToken() {
      return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey)
    }
    authUrl(e) {
      return void 0 === e && (e = {}),
      this.preAuthToken && (e.uppyPreAuthToken = this.preAuthToken),
        `${this.hostname}/${this.id}/connect?${new URLSearchParams(e)}`
    }
    fileUrl(e) {
      return `${this.hostname}/${this.id}/get/${e}`
    }
    fetchPreAuthToken() {
      return this.companionKeysParams ? this.post(`${this.id}/preauth/`, {
        params: this.companionKeysParams
      }).then((e=>{
          this.preAuthToken = e.token
        }
      )).catch((e=>{
          this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${e}`, "warning")
        }
      )) : Promise.resolve()
    }
    list(e) {
      return this.get(`${this.id}/list/${e || ""}`)
    }
    logout() {
      return this.get(`${this.id}/logout`).then((e=>Promise.all([e, this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey)]))).then((e=>{
          let[t] = e;
          return t
        }
      ))
    }
    static initPlugin(e, t, n) {
      if (e.type = "acquirer",
        e.files = [],
      n && (e.opts = {
        ...n,
        ...t
      }),
      t.serverUrl || t.serverPattern)
        throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`");
      if (t.companionAllowedHosts) {
        const n = t.companionAllowedHosts;
        if (!("string" == typeof n || Array.isArray(n) || n instanceof RegExp))
          throw new TypeError(`${e.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`);
        e.opts.companionAllowedHosts = n
      } else
        /^(?!https?:\/\/).*$/i.test(t.companionUrl) ? e.opts.companionAllowedHosts = `https://${t.companionUrl.replace(/^\/\//, "")}` : e.opts.companionAllowedHosts = new URL(t.companionUrl).origin;
      e.storage = e.opts.storage || nue
    }
  }
  ,
  SearchProvider: class extends qle {
    constructor(e, t) {
      super(e, t),
        this.provider = t.provider,
        this.id = this.provider,
        this.name = this.opts.name || (e=>this.id.split("-").map((e=>e.charAt(0).toUpperCase() + e.slice(1))).join(" "))(),
        this.pluginId = this.opts.pluginId
    }
    fileUrl(e) {
      return `${this.hostname}/search/${this.id}/get/${e}`
    }
    search(e, t) {
      return t = t ? `&${t}` : "",
        this.get(`search/${this.id}/list?q=${encodeURIComponent(e)}${t}`)
    }
  }
  ,
  Socket: cue
}, fue = uae((function(e, t, n) {
    const {progress: r, bytesUploaded: o, bytesTotal: a} = t;
    r && (e.uppy.log(`Upload progress: ${r}`),
      e.uppy.emit("upload-progress", n, {
        uploader: e,
        bytesUploaded: o,
        bytesTotal: a
      }))
  }
), 300, {
  leading: !0,
  trailing: !0
});
function pue(e, t) {
  if (!Object.prototype.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e
}
var hue = 0;
function vue(e) {
  return "__private_" + hue++ + "_" + e
}
var gue = (lue = vue("emitter"),
    uue = vue("events"),
    class {
      constructor(e) {
        Object.defineProperty(this, lue, {
          writable: !0,
          value: void 0
        }),
          Object.defineProperty(this, uue, {
            writable: !0,
            value: []
          }),
          pue(this, lue)[lue] = e
      }
      on(e, t) {
        return pue(this, uue)[uue].push([e, t]),
          pue(this, lue)[lue].on(e, t)
      }
      remove() {
        for (const [e,t] of pue(this, uue)[uue].splice(0))
          pue(this, lue)[lue].off(e, t)
      }
    }
);
function mue(e, t) {
  if (!Object.prototype.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e
}
var yue = 0;
function bue(e) {
  return "__private_" + yue++ + "_" + e
}
var wue = bue("aliveTimer")
  , xue = bue("isDone")
  , Sue = bue("onTimedOut")
  , Eue = bue("timeout")
  , Aue = class {
    constructor(e, t) {
      Object.defineProperty(this, wue, {
        writable: !0,
        value: void 0
      }),
        Object.defineProperty(this, xue, {
          writable: !0,
          value: !1
        }),
        Object.defineProperty(this, Sue, {
          writable: !0,
          value: void 0
        }),
        Object.defineProperty(this, Eue, {
          writable: !0,
          value: void 0
        }),
        mue(this, Eue)[Eue] = e,
        mue(this, Sue)[Sue] = t
    }
    progress() {
      mue(this, xue)[xue] || mue(this, Eue)[Eue] > 0 && (clearTimeout(mue(this, wue)[wue]),
        mue(this, wue)[wue] = setTimeout(mue(this, Sue)[Sue], mue(this, Eue)[Eue]))
    }
    done() {
      mue(this, xue)[xue] || (clearTimeout(mue(this, wue)[wue]),
        mue(this, wue)[wue] = null,
        mue(this, xue)[xue] = !0)
    }
  }
;
function Cue(e, t) {
  if (!Object.prototype.hasOwnProperty.call(e, t))
    throw new TypeError("attempted to use private field on non-instance");
  return e
}
var kue = 0;
function Tue(e) {
  return "__private_" + kue++ + "_" + e
}
var Due = Tue("activeRequests")
  , Oue = Tue("queuedHandlers")
  , _ue = Tue("call")
  , Rue = Tue("queueNext")
  , Lue = Tue("next")
  , Iue = Tue("queue")
  , Pue = Tue("dequeue");
function Fue(e) {
  Cue(this, Due)[Due] += 1;
  let t, n = !1;
  try {
    t = e()
  } catch (r) {
    throw Cue(this, Due)[Due] -= 1,
      r
  }
  return {
    abort: ()=>{
      n || (n = !0,
        Cue(this, Due)[Due] -= 1,
        t(),
        Cue(this, Rue)[Rue]())
    }
    ,
    done: ()=>{
      n || (n = !0,
        Cue(this, Due)[Due] -= 1,
        Cue(this, Rue)[Rue]())
    }
  }
}
function Bue() {
  queueMicrotask((()=>Cue(this, Lue)[Lue]()))
}
function Nue() {
  if (Cue(this, Due)[Due] >= this.limit)
    return;
  if (0 === Cue(this, Oue)[Oue].length)
    return;
  const e = Cue(this, Oue)[Oue].shift()
    , t = Cue(this, _ue)[_ue](e.fn);
  e.abort = t.abort,
    e.done = t.done
}
function Mue(e, t) {
  void 0 === t && (t = {});
  const n = {
    fn: e,
    priority: t.priority || 0,
    abort: ()=>{
      Cue(this, Pue)[Pue](n)
    }
    ,
    done: ()=>{
      throw new Error("Cannot mark a queued request as done: this indicates a bug")
    }
  }
    , r = Cue(this, Oue)[Oue].findIndex((e=>n.priority > e.priority));
  return -1 === r ? Cue(this, Oue)[Oue].push(n) : Cue(this, Oue)[Oue].splice(r, 0, n),
    n
}
function jue(e) {
  const t = Cue(this, Oue)[Oue].indexOf(e);
  -1 !== t && Cue(this, Oue)[Oue].splice(t, 1)
}
var Vue, Uue, $ue = {
  RateLimitedQueue: class {
    constructor(e) {
      Object.defineProperty(this, Pue, {
        value: jue
      }),
        Object.defineProperty(this, Iue, {
          value: Mue
        }),
        Object.defineProperty(this, Lue, {
          value: Nue
        }),
        Object.defineProperty(this, Rue, {
          value: Bue
        }),
        Object.defineProperty(this, _ue, {
          value: Fue
        }),
        Object.defineProperty(this, Due, {
          writable: !0,
          value: 0
        }),
        Object.defineProperty(this, Oue, {
          writable: !0,
          value: []
        }),
        this.limit = "number" != typeof e || 0 === e ? 1 / 0 : e
    }
    run(e, t) {
      return Cue(this, Due)[Due] < this.limit ? Cue(this, _ue)[_ue](e) : Cue(this, Iue)[Iue](e, t)
    }
    wrapPromiseFunction(e, t) {
      var n = this;
      return function() {
        for (var r = arguments.length, o = new Array(r), a = 0; a < r; a++)
          o[a] = arguments[a];
        let i;
        const s = new Promise(((r,a)=>{
            i = n.run((()=>{
                let t, n;
                try {
                  n = Promise.resolve(e(...o))
                } catch (s) {
                  n = Promise.reject(s)
                }
                return n.then((e=>{
                    t ? a(t) : (i.done(),
                      r(e))
                  }
                ), (e=>{
                    t ? a(t) : (i.done(),
                      a(e))
                  }
                )),
                  ()=>{
                    t = new Error("Cancelled")
                  }
              }
            ), t)
          }
        ));
        return s.abort = ()=>{
          i.abort()
        }
          ,
          s
      }
    }
  }
  ,
  internalRateLimitedQueue: Symbol("__queue")
}, Hue = function(e) {
  return !!e && (0 !== e.readyState && 4 !== e.readyState || 0 === e.status)
}, zue = {
  strings: {
    timedOut: "Upload stalled for %{seconds} seconds, aborting."
  }
};
const {nanoid: Kue} = Dse
  , {Provider: Wue, RequestClient: Gue, Socket: que} = due
  , {RateLimitedQueue: Yue, internalRateLimitedQueue: Xue} = $ue;
function Que(e, t) {
  let n = t;
  return n || (n = new Error("Upload error")),
  "string" == typeof n && (n = new Error(n)),
  n instanceof Error || (n = Object.assign(new Error("Upload error"), {
    data: n
  })),
    Hue(e) ? (n = new Fle(n,e),
      n) : (n.request = e,
      n)
}
function Jue(e) {
  return e.data.slice(0, e.data.size, e.meta.type)
}
var Zue = (Uue = Vue = class extends xle {
  constructor(e, t) {
    super(e, t),
      this.type = "uploader",
      this.id = this.opts.id || "XHRUpload",
      this.title = "XHRUpload",
      this.defaultLocale = zue;
    const n = {
      formData: !0,
      fieldName: t.bundle ? "files[]" : "file",
      method: "post",
      metaFields: null,
      responseUrlFieldName: "url",
      bundle: !1,
      headers: {},
      timeout: 3e4,
      limit: 5,
      withCredentials: !1,
      responseType: "",
      getResponseData(t) {
        let n = {};
        try {
          n = JSON.parse(t)
        } catch (r) {
          e.log(r)
        }
        return n
      },
      getResponseError(e, t) {
        let n = new Error("Upload error");
        return Hue(t) && (n = new Fle(n,t)),
          n
      },
      validateStatus: e=>e >= 200 && e < 300
    };
    if (this.opts = {
      ...n,
      ...t
    },
      this.i18nInit(),
      this.handleUpload = this.handleUpload.bind(this),
      Xue in this.opts ? this.requests = this.opts[Xue] : this.requests = new Yue(this.opts.limit),
    this.opts.bundle && !this.opts.formData)
      throw new Error("`opts.formData` must be true when `opts.bundle` is enabled.");
    this.uploaderEvents = Object.create(null)
  }
  getOptions(e) {
    const t = this.uppy.getState().xhrUpload
      , {headers: n} = this.opts
      , r = {
      ...this.opts,
      ...t || {},
      ...e.xhrUpload || {},
      headers: {}
    };
    return "function" == typeof n ? r.headers = n(e) : Object.assign(r.headers, this.opts.headers),
    t && Object.assign(r.headers, t.headers),
    e.xhrUpload && Object.assign(r.headers, e.xhrUpload.headers),
      r
  }
  addMetadata(e, t, n) {
    (Array.isArray(n.metaFields) ? n.metaFields : Object.keys(t)).forEach((n=>{
        e.append(n, t[n])
      }
    ))
  }
  createFormDataUpload(e, t) {
    const n = new FormData;
    this.addMetadata(n, e.meta, t);
    const r = Jue(e);
    return e.name ? n.append(t.fieldName, r, e.meta.name) : n.append(t.fieldName, r),
      n
  }
  createBundledUpload(e, t) {
    const n = new FormData
      , {meta: r} = this.uppy.getState();
    return this.addMetadata(n, r, t),
      e.forEach((e=>{
          const t = this.getOptions(e)
            , r = Jue(e);
          e.name ? n.append(t.fieldName, r, e.name) : n.append(t.fieldName, r)
        }
      )),
      n
  }
  upload(e, t, n) {
    const r = this.getOptions(e);
    return this.uppy.log(`uploading ${t} of ${n}`),
      new Promise(((t,n)=>{
          this.uppy.emit("upload-started", e);
          const o = r.formData ? this.createFormDataUpload(e, r) : e.data
            , a = new XMLHttpRequest;
          this.uploaderEvents[e.id] = new gue(this.uppy);
          const i = new Aue(r.timeout,(()=>{
              a.abort(),
                l.done();
              const t = new Error(this.i18n("timedOut", {
                seconds: Math.ceil(r.timeout / 1e3)
              }));
              this.uppy.emit("upload-error", e, t),
                n(t)
            }
          ))
            , s = Kue();
          a.upload.addEventListener("loadstart", (()=>{
              this.uppy.log(`[XHRUpload] ${s} started`)
            }
          )),
            a.upload.addEventListener("progress", (t=>{
                this.uppy.log(`[XHRUpload] ${s} progress: ${t.loaded} / ${t.total}`),
                  i.progress(),
                t.lengthComputable && this.uppy.emit("upload-progress", e, {
                  uploader: this,
                  bytesUploaded: t.loaded,
                  bytesTotal: t.total
                })
              }
            )),
            a.addEventListener("load", (o=>{
                if (this.uppy.log(`[XHRUpload] ${s} finished`),
                  i.done(),
                  l.done(),
                this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(),
                  this.uploaderEvents[e.id] = null),
                  r.validateStatus(o.target.status, a.responseText, a)) {
                  const n = r.getResponseData(a.responseText, a)
                    , i = n[r.responseUrlFieldName]
                    , s = {
                    status: o.target.status,
                    body: n,
                    uploadURL: i
                  };
                  return this.uppy.emit("upload-success", e, s),
                  i && this.uppy.log(`Download ${e.name} from ${i}`),
                    t(e)
                }
                const u = r.getResponseData(a.responseText, a)
                  , c = Que(a, r.getResponseError(a.responseText, a))
                  , d = {
                  status: o.target.status,
                  body: u
                };
                return this.uppy.emit("upload-error", e, c, d),
                  n(c)
              }
            )),
            a.addEventListener("error", (()=>{
                this.uppy.log(`[XHRUpload] ${s} errored`),
                  i.done(),
                  l.done(),
                this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(),
                  this.uploaderEvents[e.id] = null);
                const t = Que(a, r.getResponseError(a.responseText, a));
                return this.uppy.emit("upload-error", e, t),
                  n(t)
              }
            )),
            a.open(r.method.toUpperCase(), r.endpoint, !0),
            a.withCredentials = r.withCredentials,
          "" !== r.responseType && (a.responseType = r.responseType);
          const l = this.requests.run((()=>{
              this.uppy.emit("upload-started", e);
              const t = this.getOptions(e);
              return Object.keys(t.headers).forEach((e=>{
                  a.setRequestHeader(e, t.headers[e])
                }
              )),
                a.send(o),
                ()=>{
                  i.done(),
                    a.abort()
                }
            }
          ));
          this.onFileRemove(e.id, (()=>{
              l.abort(),
                n(new Error("File removed"))
            }
          )),
            this.onCancelAll(e.id, (()=>{
                l.abort(),
                  n(new Error("Upload cancelled"))
              }
            ))
        }
      ))
  }
  uploadRemote(e) {
    const t = this.getOptions(e);
    return new Promise(((n,r)=>{
        this.uppy.emit("upload-started", e);
        const o = {};
        (Array.isArray(t.metaFields) ? t.metaFields : Object.keys(e.meta)).forEach((t=>{
            o[t] = e.meta[t]
          }
        )),
          new (e.remote.providerOptions.provider ? Wue : Gue)(this.uppy,e.remote.providerOptions).post(e.remote.url, {
            ...e.remote.body,
            endpoint: t.endpoint,
            size: e.data.size,
            fieldname: t.fieldName,
            metadata: o,
            httpMethod: t.method,
            useFormData: t.formData,
            headers: t.headers
          }).then((o=>{
              const {token: a} = o
                , i = function(e) {
                const t = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i.exec(e)[1];
                return `${/^http:\/\//i.test(e) ? "ws" : "wss"}://${t}`
              }(e.remote.companionUrl)
                , s = new que({
                target: `${i}/api/${a}`,
                autoOpen: !1
              });
              this.uploaderEvents[e.id] = new gue(this.uppy),
                this.onFileRemove(e.id, (()=>{
                    s.send("cancel", {}),
                      l.abort(),
                      n(`upload ${e.id} was removed`)
                  }
                )),
                this.onCancelAll(e.id, (()=>{
                    s.send("cancel", {}),
                      l.abort(),
                      n(`upload ${e.id} was canceled`)
                  }
                )),
                this.onRetry(e.id, (()=>{
                    s.send("pause", {}),
                      s.send("resume", {})
                  }
                )),
                this.onRetryAll(e.id, (()=>{
                    s.send("pause", {}),
                      s.send("resume", {})
                  }
                )),
                s.on("progress", (t=>fue(this, t, e))),
                s.on("success", (r=>{
                    const o = t.getResponseData(r.response.responseText, r.response)
                      , a = o[t.responseUrlFieldName]
                      , i = {
                      status: r.response.status,
                      body: o,
                      uploadURL: a
                    };
                    return this.uppy.emit("upload-success", e, i),
                      l.done(),
                    this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(),
                      this.uploaderEvents[e.id] = null),
                      n()
                  }
                )),
                s.on("error", (n=>{
                    const o = n.response
                      , a = o ? t.getResponseError(o.responseText, o) : Object.assign(new Error(n.error.message), {
                      cause: n.error
                    });
                    this.uppy.emit("upload-error", e, a),
                      l.done(),
                    this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(),
                      this.uploaderEvents[e.id] = null),
                      r(a)
                  }
                ));
              const l = this.requests.run((()=>(s.open(),
              e.isPaused && s.send("pause", {}),
                ()=>s.close())))
            }
          )).catch((t=>{
              this.uppy.emit("upload-error", e, t),
                r(t)
            }
          ))
      }
    ))
  }
  uploadBundle(e) {
    return new Promise(((t,n)=>{
        const {endpoint: r} = this.opts
          , {method: o} = this.opts
          , a = this.uppy.getState().xhrUpload
          , i = this.createBundledUpload(e, {
            ...this.opts,
            ...a || {}
          })
          , s = new XMLHttpRequest
          , l = new Aue(this.opts.timeout,(()=>{
              s.abort();
              const e = new Error(this.i18n("timedOut", {
                seconds: Math.ceil(this.opts.timeout / 1e3)
              }));
              u(e),
                n(e)
            }
          ))
          , u = t=>{
            e.forEach((e=>{
                this.uppy.emit("upload-error", e, t)
              }
            ))
          }
        ;
        s.upload.addEventListener("loadstart", (()=>{
            this.uppy.log("[XHRUpload] started uploading bundle"),
              l.progress()
          }
        )),
          s.upload.addEventListener("progress", (t=>{
              l.progress(),
              t.lengthComputable && e.forEach((e=>{
                  this.uppy.emit("upload-progress", e, {
                    uploader: this,
                    bytesUploaded: t.loaded / t.total * e.size,
                    bytesTotal: e.size
                  })
                }
              ))
            }
          )),
          s.addEventListener("load", (r=>{
              if (l.done(),
                this.opts.validateStatus(r.target.status, s.responseText, s)) {
                const n = this.opts.getResponseData(s.responseText, s)
                  , o = {
                  status: r.target.status,
                  body: n
                };
                return e.forEach((e=>{
                    this.uppy.emit("upload-success", e, o)
                  }
                )),
                  t()
              }
              const o = this.opts.getResponseError(s.responseText, s) || new Error("Upload error");
              return o.request = s,
                u(o),
                n(o)
            }
          )),
          s.addEventListener("error", (()=>{
              l.done();
              const e = this.opts.getResponseError(s.responseText, s) || new Error("Upload error");
              return u(e),
                n(e)
            }
          )),
          this.uppy.on("cancel-all", (()=>{
              l.done(),
                s.abort()
            }
          )),
          s.open(o.toUpperCase(), r, !0),
          s.withCredentials = this.opts.withCredentials,
        "" !== this.opts.responseType && (s.responseType = this.opts.responseType),
          Object.keys(this.opts.headers).forEach((e=>{
              s.setRequestHeader(e, this.opts.headers[e])
            }
          )),
          s.send(i),
          e.forEach((e=>{
              this.uppy.emit("upload-started", e)
            }
          ))
      }
    ))
  }
  uploadFiles(e) {
    const t = e.map(((t,n)=>{
        const r = parseInt(n, 10) + 1
          , o = e.length;
        return t.error ? Promise.reject(new Error(t.error)) : t.isRemote ? this.uploadRemote(t, r, o) : this.upload(t, r, o)
      }
    ));
    return function(e) {
      const t = []
        , n = [];
      function r(e) {
        t.push(e)
      }
      function o(e) {
        n.push(e)
      }
      return Promise.all(e.map((e=>e.then(r, o)))).then((()=>({
        successful: t,
        failed: n
      })))
    }(t)
  }
  onFileRemove(e, t) {
    this.uploaderEvents[e].on("file-removed", (n=>{
        e === n.id && t(n.id)
      }
    ))
  }
  onRetry(e, t) {
    this.uploaderEvents[e].on("upload-retry", (n=>{
        e === n && t()
      }
    ))
  }
  onRetryAll(e, t) {
    this.uploaderEvents[e].on("retry-all", (()=>{
        this.uppy.getFile(e) && t()
      }
    ))
  }
  onCancelAll(e, t) {
    this.uploaderEvents[e].on("cancel-all", (()=>{
        this.uppy.getFile(e) && t()
      }
    ))
  }
  handleUpload(e) {
    if (0 === e.length)
      return this.uppy.log("[XHRUpload] No files to upload!"),
        Promise.resolve();
    0 !== this.opts.limit || this.opts[Xue] || this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0", "warning"),
      this.uppy.log("[XHRUpload] Uploading...");
    const t = e.map((e=>this.uppy.getFile(e)));
    if (this.opts.bundle) {
      if (t.some((e=>e.isRemote)))
        throw new Error("Can’t upload remote files when the `bundle: true` option is set");
      if ("function" == typeof this.opts.headers)
        throw new TypeError("`headers` may not be a function when the `bundle: true` option is set");
      return this.uploadBundle(t)
    }
    return this.uploadFiles(t).then((()=>null))
  }
  install() {
    if (this.opts.bundle) {
      const {capabilities: e} = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...e,
          individualCancellation: !1
        }
      })
    }
    this.uppy.addUploader(this.handleUpload)
  }
  uninstall() {
    if (this.opts.bundle) {
      const {capabilities: e} = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...e,
          individualCancellation: !0
        }
      })
    }
    this.uppy.removeUploader(this.handleUpload)
  }
}
  ,
  Vue.VERSION = "2.0.6",
  Uue)
  , ece = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function tce(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports),
    t.exports
}
var nce, rce, oce = function(e) {
  return e && e.Math == Math && e
}, ace = oce("object" == typeof globalThis && globalThis) || oce("object" == typeof window && window) || oce("object" == typeof self && self) || oce("object" == typeof ece && ece) || function() {
  return this
}() || Function("return this")(), ice = Object.defineProperty, sce = function(e, t) {
  try {
    ice(ace, e, {
      value: t,
      configurable: !0,
      writable: !0
    })
  } catch (AEe) {
    ace[e] = t
  }
  return t
}, lce = ace["__core-js_shared__"] || sce("__core-js_shared__", {}), uce = tce((function(e) {
    (e.exports = function(e, t) {
        return lce[e] || (lce[e] = void 0 !== t ? t : {})
      }
    )("versions", []).push({
      version: "3.19.3",
      mode: "global",
      copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
    })
  }
)), cce = Function.prototype, dce = cce.bind, fce = cce.call, pce = dce && dce.bind(fce), hce = dce ? function(e) {
    return e && pce(fce, e)
  }
  : function(e) {
    return e && function() {
      return fce.apply(e, arguments)
    }
  }
  , vce = ace.TypeError, gce = function(e) {
  if (null == e)
    throw vce("Can't call method on " + e);
  return e
}, mce = ace.Object, yce = function(e) {
  return mce(gce(e))
}, bce = hce({}.hasOwnProperty), wce = Object.hasOwn || function(e, t) {
  return bce(yce(e), t)
}
  , xce = 0, Sce = Math.random(), Ece = hce(1..toString), Ace = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + Ece(++xce + Sce, 36)
}, Cce = function(e) {
  return "function" == typeof e
}, kce = function(e, t) {
  return arguments.length < 2 ? function(e) {
    return Cce(e) ? e : void 0
  }(ace[e]) : ace[e] && ace[e][t]
}, Tce = kce("navigator", "userAgent") || "", Dce = ace.process, Oce = ace.Deno, _ce = Dce && Dce.versions || Oce && Oce.version, Rce = _ce && _ce.v8;
Rce && (rce = (nce = Rce.split("."))[0] > 0 && nce[0] < 4 ? 1 : +(nce[0] + nce[1])),
!rce && Tce && (!(nce = Tce.match(/Edge\/(\d+)/)) || nce[1] >= 74) && (nce = Tce.match(/Chrome\/(\d+)/)) && (rce = +nce[1]);
var Lce = rce
  , Ice = function(e) {
  try {
    return !!e()
  } catch (t) {
    return !0
  }
}
  , Pce = !!Object.getOwnPropertySymbols && !Ice((function() {
    var e = Symbol();
    return !String(e) || !(Object(e)instanceof Symbol) || !Symbol.sham && Lce && Lce < 41
  }
))
  , Fce = Pce && !Symbol.sham && "symbol" == typeof Symbol.iterator
  , Bce = uce("wks")
  , Nce = ace.Symbol
  , Mce = Nce && Nce.for
  , jce = Fce ? Nce : Nce && Nce.withoutSetter || Ace
  , Vce = function(e) {
  if (!wce(Bce, e) || !Pce && "string" != typeof Bce[e]) {
    var t = "Symbol." + e;
    Pce && wce(Nce, e) ? Bce[e] = Nce[e] : Bce[e] = Fce && Mce ? Mce(t) : jce(t)
  }
  return Bce[e]
}
  , Uce = {};
Uce[Vce("toStringTag")] = "z";
var $ce = "[object z]" === String(Uce)
  , Hce = !Ice((function() {
    return 7 != Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1]
  }
))
  , zce = function(e) {
  return "object" == typeof e ? null !== e : Cce(e)
}
  , Kce = ace.document
  , Wce = zce(Kce) && zce(Kce.createElement)
  , Gce = function(e) {
  return Wce ? Kce.createElement(e) : {}
}
  , qce = !Hce && !Ice((function() {
    return 7 != Object.defineProperty(Gce("div"), "a", {
      get: function() {
        return 7
      }
    }).a
  }
))
  , Yce = ace.String
  , Xce = ace.TypeError
  , Qce = function(e) {
  if (zce(e))
    return e;
  throw Xce(Yce(e) + " is not an object")
}
  , Jce = Function.prototype.call
  , Zce = Jce.bind ? Jce.bind(Jce) : function() {
  return Jce.apply(Jce, arguments)
}
  , ede = hce({}.isPrototypeOf)
  , tde = ace.Object
  , nde = Fce ? function(e) {
    return "symbol" == typeof e
  }
  : function(e) {
    var t = kce("Symbol");
    return Cce(t) && ede(t.prototype, tde(e))
  }
  , rde = ace.String
  , ode = function(e) {
  try {
    return rde(e)
  } catch (t) {
    return "Object"
  }
}
  , ade = ace.TypeError
  , ide = function(e) {
  if (Cce(e))
    return e;
  throw ade(ode(e) + " is not a function")
}
  , sde = function(e, t) {
  var n = e[t];
  return null == n ? void 0 : ide(n)
}
  , lde = ace.TypeError
  , ude = ace.TypeError
  , cde = Vce("toPrimitive")
  , dde = function(e) {
  var t = function(e, t) {
    if (!zce(e) || nde(e))
      return e;
    var n, r = sde(e, cde);
    if (r) {
      if (void 0 === t && (t = "default"),
        n = Zce(r, e, t),
      !zce(n) || nde(n))
        return n;
      throw ude("Can't convert object to primitive value")
    }
    return void 0 === t && (t = "number"),
      function(e, t) {
        var n, r;
        if ("string" === t && Cce(n = e.toString) && !zce(r = Zce(n, e)))
          return r;
        if (Cce(n = e.valueOf) && !zce(r = Zce(n, e)))
          return r;
        if ("string" !== t && Cce(n = e.toString) && !zce(r = Zce(n, e)))
          return r;
        throw lde("Can't convert object to primitive value")
      }(e, t)
  }(e, "string");
  return nde(t) ? t : t + ""
}
  , fde = ace.TypeError
  , pde = Object.defineProperty
  , hde = {
  f: Hce ? pde : function(e, t, n) {
    if (Qce(e),
      t = dde(t),
      Qce(n),
      qce)
      try {
        return pde(e, t, n)
      } catch (r) {}
    if ("get"in n || "set"in n)
      throw fde("Accessors not supported");
    return "value"in n && (e[t] = n.value),
      e
  }
}
  , vde = function(e, t) {
  return {
    enumerable: !(1 & e),
    configurable: !(2 & e),
    writable: !(4 & e),
    value: t
  }
}
  , gde = Hce ? function(e, t, n) {
    return hde.f(e, t, vde(1, n))
  }
  : function(e, t, n) {
    return e[t] = n,
      e
  }
  , mde = hce(Function.toString);
Cce(lce.inspectSource) || (lce.inspectSource = function(e) {
    return mde(e)
  }
);
var yde, bde, wde, xde = lce.inspectSource, Sde = ace.WeakMap, Ede = Cce(Sde) && /native code/.test(xde(Sde)), Ade = uce("keys"), Cde = function(e) {
  return Ade[e] || (Ade[e] = Ace(e))
}, kde = {}, Tde = ace.TypeError, Dde = ace.WeakMap;
if (Ede || lce.state) {
  var Ode = lce.state || (lce.state = new Dde)
    , _de = hce(Ode.get)
    , Rde = hce(Ode.has)
    , Lde = hce(Ode.set);
  yde = function(e, t) {
    if (Rde(Ode, e))
      throw new Tde("Object already initialized");
    return t.facade = e,
      Lde(Ode, e, t),
      t
  }
    ,
    bde = function(e) {
      return _de(Ode, e) || {}
    }
    ,
    wde = function(e) {
      return Rde(Ode, e)
    }
} else {
  var Ide = Cde("state");
  kde[Ide] = !0,
    yde = function(e, t) {
      if (wce(e, Ide))
        throw new Tde("Object already initialized");
      return t.facade = e,
        gde(e, Ide, t),
        t
    }
    ,
    bde = function(e) {
      return wce(e, Ide) ? e[Ide] : {}
    }
    ,
    wde = function(e) {
      return wce(e, Ide)
    }
}
var Pde = {
    set: yde,
    get: bde,
    has: wde,
    enforce: function(e) {
      return wde(e) ? bde(e) : yde(e, {})
    },
    getterFor: function(e) {
      return function(t) {
        var n;
        if (!zce(t) || (n = bde(t)).type !== e)
          throw Tde("Incompatible receiver, " + e + " required");
        return n
      }
    }
  }
  , Fde = Function.prototype
  , Bde = Hce && Object.getOwnPropertyDescriptor
  , Nde = wce(Fde, "name")
  , Mde = {
    EXISTS: Nde,
    PROPER: Nde && "something" === function() {}
      .name,
    CONFIGURABLE: Nde && (!Hce || Hce && Bde(Fde, "name").configurable)
  }
  , jde = tce((function(e) {
      var t = Mde.CONFIGURABLE
        , n = Pde.get
        , r = Pde.enforce
        , o = String(String).split("String");
      (e.exports = function(e, n, a, i) {
          var s, l = !!i && !!i.unsafe, u = !!i && !!i.enumerable, c = !!i && !!i.noTargetGet, d = i && void 0 !== i.name ? i.name : n;
          Cce(a) && ("Symbol(" === String(d).slice(0, 7) && (d = "[" + String(d).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
          (!wce(a, "name") || t && a.name !== d) && gde(a, "name", d),
          (s = r(a)).source || (s.source = o.join("string" == typeof d ? d : ""))),
            e !== ace ? (l ? !c && e[n] && (u = !0) : delete e[n],
              u ? e[n] = a : gde(e, n, a)) : u ? e[n] = a : sce(n, a)
        }
      )(Function.prototype, "toString", (function() {
          return Cce(this) && n(this).source || xde(this)
        }
      ))
    }
  ))
  , Vde = hce({}.toString)
  , Ude = hce("".slice)
  , $de = function(e) {
    return Ude(Vde(e), 8, -1)
  }
  , Hde = Vce("toStringTag")
  , zde = ace.Object
  , Kde = "Arguments" == $de(function() {
    return arguments
  }())
  , Wde = $ce ? $de : function(e) {
    var t, n, r;
    return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
      try {
        return e[t]
      } catch (n) {}
    }(t = zde(e), Hde)) ? n : Kde ? $de(t) : "Object" == (r = $de(t)) && Cce(t.callee) ? "Arguments" : r
  }
  , Gde = $ce ? {}.toString : function() {
    return "[object " + Wde(this) + "]"
  }
;
$ce || jde(Object.prototype, "toString", Gde, {
  unsafe: !0
});
var qde = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}
  , Yde = Gce("span").classList
  , Xde = Yde && Yde.constructor && Yde.constructor.prototype
  , Qde = Xde === Object.prototype ? void 0 : Xde
  , Jde = hce(hce.bind)
  , Zde = function(e, t) {
  return ide(e),
    void 0 === t ? e : Jde ? Jde(e, t) : function() {
      return e.apply(t, arguments)
    }
}
  , efe = ace.Object
  , tfe = hce("".split)
  , nfe = Ice((function() {
    return !efe("z").propertyIsEnumerable(0)
  }
)) ? function(e) {
    return "String" == $de(e) ? tfe(e, "") : efe(e)
  }
  : efe
  , rfe = Math.ceil
  , ofe = Math.floor
  , afe = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : (t > 0 ? ofe : rfe)(t)
}
  , ife = Math.min
  , sfe = function(e) {
  return e > 0 ? ife(afe(e), 9007199254740991) : 0
}
  , lfe = function(e) {
  return sfe(e.length)
}
  , ufe = Array.isArray || function(e) {
  return "Array" == $de(e)
}
  , cfe = function() {}
  , dfe = []
  , ffe = kce("Reflect", "construct")
  , pfe = /^\s*(?:class|function)\b/
  , hfe = hce(pfe.exec)
  , vfe = !pfe.exec(cfe)
  , gfe = function(e) {
  if (!Cce(e))
    return !1;
  try {
    return ffe(cfe, dfe, e),
      !0
  } catch (t) {
    return !1
  }
}
  , mfe = !ffe || Ice((function() {
    var e;
    return gfe(gfe.call) || !gfe(Object) || !gfe((function() {
        e = !0
      }
    )) || e
  }
)) ? function(e) {
    if (!Cce(e))
      return !1;
    switch (Wde(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    return vfe || !!hfe(pfe, xde(e))
  }
  : gfe
  , yfe = Vce("species")
  , bfe = ace.Array
  , wfe = function(e, t) {
  return new (ufe(n = e) && (r = n.constructor,
  (mfe(r) && (r === bfe || ufe(r.prototype)) || zce(r) && null === (r = r[yfe])) && (r = void 0)),
    void 0 === r ? bfe : r)(0 === t ? 0 : t);
  var n, r
}
  , xfe = hce([].push)
  , Sfe = function(e) {
  var t = 1 == e
    , n = 2 == e
    , r = 3 == e
    , o = 4 == e
    , a = 6 == e
    , i = 7 == e
    , s = 5 == e || a;
  return function(l, u, c, d) {
    for (var f, p, h = yce(l), v = nfe(h), g = Zde(u, c), m = lfe(v), y = 0, b = d || wfe, w = t ? b(l, m) : n || i ? b(l, 0) : void 0; m > y; y++)
      if ((s || y in v) && (p = g(f = v[y], y, h),
        e))
        if (t)
          w[y] = p;
        else if (p)
          switch (e) {
            case 3:
              return !0;
            case 5:
              return f;
            case 6:
              return y;
            case 2:
              xfe(w, f)
          }
        else
          switch (e) {
            case 4:
              return !1;
            case 7:
              xfe(w, f)
          }
    return a ? -1 : r || o ? o : w
  }
}
  , Efe = {
  forEach: Sfe(0),
  map: Sfe(1),
  filter: Sfe(2),
  some: Sfe(3),
  every: Sfe(4),
  find: Sfe(5),
  findIndex: Sfe(6),
  filterReject: Sfe(7)
}
  , Afe = function(e, t) {
  var n = [][e];
  return !!n && Ice((function() {
      n.call(null, t || function() {
        throw 1
      }
        , 1)
    }
  ))
}
  , Cfe = Efe.forEach
  , kfe = Afe("forEach") ? [].forEach : function(e) {
  return Cfe(this, e, arguments.length > 1 ? arguments[1] : void 0)
}
  , Tfe = function(e) {
  if (e && e.forEach !== kfe)
    try {
      gde(e, "forEach", kfe)
    } catch (X_) {
      e.forEach = kfe
    }
};
for (var Dfe in qde)
  qde[Dfe] && Tfe(ace[Dfe] && ace[Dfe].prototype);
Tfe(Qde);
var Ofe = {}.propertyIsEnumerable
  , _fe = Object.getOwnPropertyDescriptor
  , Rfe = _fe && !Ofe.call({
  1: 2
}, 1) ? function(e) {
    var t = _fe(this, e);
    return !!t && t.enumerable
  }
  : Ofe
  , Lfe = {
  f: Rfe
}
  , Ife = function(e) {
  return nfe(gce(e))
}
  , Pfe = Object.getOwnPropertyDescriptor
  , Ffe = {
  f: Hce ? Pfe : function(e, t) {
    if (e = Ife(e),
      t = dde(t),
      qce)
      try {
        return Pfe(e, t)
      } catch (n) {}
    if (wce(e, t))
      return vde(!Zce(Lfe.f, e, t), e[t])
  }
}
  , Bfe = Math.max
  , Nfe = Math.min
  , Mfe = function(e, t) {
  var n = afe(e);
  return n < 0 ? Bfe(n + t, 0) : Nfe(n, t)
}
  , jfe = function(e) {
  return function(t, n, r) {
    var o, a = Ife(t), i = lfe(a), s = Mfe(r, i);
    if (e && n != n) {
      for (; i > s; )
        if ((o = a[s++]) != o)
          return !0
    } else
      for (; i > s; s++)
        if ((e || s in a) && a[s] === n)
          return e || s || 0;
    return !e && -1
  }
}
  , Vfe = {
  includes: jfe(!0),
  indexOf: jfe(!1)
}
  , Ufe = Vfe.indexOf
  , $fe = hce([].push)
  , Hfe = function(e, t) {
  var n, r = Ife(e), o = 0, a = [];
  for (n in r)
    !wce(kde, n) && wce(r, n) && $fe(a, n);
  for (; t.length > o; )
    wce(r, n = t[o++]) && (~Ufe(a, n) || $fe(a, n));
  return a
}
  , zfe = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
  , Kfe = zfe.concat("length", "prototype")
  , Wfe = {
  f: Object.getOwnPropertyNames || function(e) {
    return Hfe(e, Kfe)
  }
}
  , Gfe = {
  f: Object.getOwnPropertySymbols
}
  , qfe = hce([].concat)
  , Yfe = kce("Reflect", "ownKeys") || function(e) {
  var t = Wfe.f(Qce(e))
    , n = Gfe.f;
  return n ? qfe(t, n(e)) : t
}
  , Xfe = function(e, t) {
  for (var n = Yfe(t), r = hde.f, o = Ffe.f, a = 0; a < n.length; a++) {
    var i = n[a];
    wce(e, i) || r(e, i, o(t, i))
  }
}
  , Qfe = /#|\.prototype\./
  , Jfe = function(e, t) {
  var n = epe[Zfe(e)];
  return n == npe || n != tpe && (Cce(t) ? Ice(t) : !!t)
}
  , Zfe = Jfe.normalize = function(e) {
  return String(e).replace(Qfe, ".").toLowerCase()
}
  , epe = Jfe.data = {}
  , tpe = Jfe.NATIVE = "N"
  , npe = Jfe.POLYFILL = "P"
  , rpe = Jfe
  , ope = Ffe.f
  , ape = function(e, t) {
  var n, r, o, a, i, s = e.target, l = e.global, u = e.stat;
  if (n = l ? ace : u ? ace[s] || sce(s, {}) : (ace[s] || {}).prototype)
    for (r in t) {
      if (a = t[r],
        o = e.noTargetGet ? (i = ope(n, r)) && i.value : n[r],
      !rpe(l ? r : s + (u ? "." : "#") + r, e.forced) && void 0 !== o) {
        if (typeof a == typeof o)
          continue;
        Xfe(a, o)
      }
      (e.sham || o && o.sham) && gde(a, "sham", !0),
        jde(n, r, a, e)
    }
}
  , ipe = Object.keys || function(e) {
  return Hfe(e, zfe)
}
  , spe = Ice((function() {
    ipe(1)
  }
));
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function lpe(e) {
  return "[object Object]" === Object.prototype.toString.call(e)
}
ape({
  target: "Object",
  stat: !0,
  forced: spe
}, {
  keys: function(e) {
    return ipe(yce(e))
  }
});
var upe = {
  isHistory(e) {
    return !1 !== lpe(t = e) && (void 0 === (n = t.constructor) || !1 !== lpe(r = n.prototype) && !1 !== r.hasOwnProperty("isPrototypeOf")) && Array.isArray(e.redos) && Array.isArray(e.undos) && (0 === e.redos.length || rne.isOperationList(e.redos[0])) && (0 === e.undos.length || rne.isOperationList(e.undos[0]));
    var t, n, r
  }
}
  , cpe = new WeakMap
  , dpe = new WeakMap
  , fpe = {
  isHistoryEditor: e=>upe.isHistory(e.history) && Yte.isEditor(e),
  isMerging: e=>dpe.get(e),
  isSaving: e=>cpe.get(e),
  redo(e) {
    e.redo()
  },
  undo(e) {
    e.undo()
  },
  withoutMerging(e, t) {
    var n = fpe.isMerging(e);
    dpe.set(e, !1),
      t(),
      dpe.set(e, n)
  },
  withoutSaving(e, t) {
    var n = fpe.isSaving(e);
    cpe.set(e, !1),
      t(),
      cpe.set(e, n)
  }
}
  , ppe = ace.String
  , hpe = function(e) {
  if ("Symbol" === Wde(e))
    throw TypeError("Cannot convert a Symbol value to a string");
  return ppe(e)
}
  , vpe = function() {
  var e = Qce(this)
    , t = "";
  return e.global && (t += "g"),
  e.ignoreCase && (t += "i"),
  e.multiline && (t += "m"),
  e.dotAll && (t += "s"),
  e.unicode && (t += "u"),
  e.sticky && (t += "y"),
    t
}
  , gpe = Mde.PROPER
  , mpe = RegExp.prototype
  , ype = mpe.toString
  , bpe = hce(vpe)
  , wpe = Ice((function() {
    return "/a/b" != ype.call({
      source: "a",
      flags: "b"
    })
  }
))
  , xpe = gpe && "toString" != ype.name;
(wpe || xpe) && jde(RegExp.prototype, "toString", (function() {
    var e = Qce(this)
      , t = hpe(e.source)
      , n = e.flags;
    return "/" + t + "/" + hpe(void 0 === n && ede(mpe, e) && !("flags"in mpe) ? bpe(e) : n)
  }
), {
  unsafe: !0
});
var Spe, Epe = Hce ? Object.defineProperties : function(e, t) {
  Qce(e);
  for (var n, r = Ife(t), o = ipe(t), a = o.length, i = 0; a > i; )
    hde.f(e, n = o[i++], r[n]);
  return e
}
  , Ape = kce("document", "documentElement"), Cpe = Cde("IE_PROTO"), kpe = function() {}, Tpe = function(e) {
  return "<script>" + e + "<\/script>"
}, Dpe = function(e) {
  e.write(Tpe("")),
    e.close();
  var t = e.parentWindow.Object;
  return e = null,
    t
}, Ope = function() {
  try {
    Spe = new ActiveXObject("htmlfile")
  } catch (r) {}
  var e, t;
  Ope = "undefined" != typeof document ? document.domain && Spe ? Dpe(Spe) : ((t = Gce("iframe")).style.display = "none",
    Ape.appendChild(t),
    t.src = String("javascript:"),
    (e = t.contentWindow.document).open(),
    e.write(Tpe("document.F=Object")),
    e.close(),
    e.F) : Dpe(Spe);
  for (var n = zfe.length; n--; )
    delete Ope.prototype[zfe[n]];
  return Ope()
};
kde[Cpe] = !0;
var _pe = Object.create || function(e, t) {
  var n;
  return null !== e ? (kpe.prototype = Qce(e),
    n = new kpe,
    kpe.prototype = null,
    n[Cpe] = e) : n = Ope(),
    void 0 === t ? n : Epe(n, t)
}
  , Rpe = Vce("unscopables")
  , Lpe = Array.prototype;
null == Lpe[Rpe] && hde.f(Lpe, Rpe, {
  configurable: !0,
  value: _pe(null)
});
var Ipe = function(e) {
  Lpe[Rpe][e] = !0
}
  , Ppe = Vfe.includes;
ape({
  target: "Array",
  proto: !0
}, {
  includes: function(e) {
    return Ppe(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
}),
  Ipe("includes");
var Fpe = Vce("match")
  , Bpe = function(e) {
  var t;
  return zce(e) && (void 0 !== (t = e[Fpe]) ? !!t : "RegExp" == $de(e))
}
  , Npe = ace.TypeError
  , Mpe = function(e) {
  if (Bpe(e))
    throw Npe("The method doesn't accept regular expressions");
  return e
}
  , jpe = Vce("match")
  , Vpe = function(e) {
  var t = /./;
  try {
    "/./"[e](t)
  } catch (AEe) {
    try {
      return t[jpe] = !1,
        "/./"[e](t)
    } catch (n) {}
  }
  return !1
}
  , Upe = hce("".indexOf);
ape({
  target: "String",
  proto: !0,
  forced: !Vpe("includes")
}, {
  includes: function(e) {
    return !!~Upe(hpe(gce(this)), hpe(Mpe(e)), arguments.length > 1 ? arguments[1] : void 0)
  }
});
var $pe = /"/g
  , Hpe = hce("".replace);
ape({
  target: "String",
  proto: !0,
  forced: Ice((function() {
      var e = "".anchor('"');
      return e !== e.toLowerCase() || e.split('"').length > 3
    }
  ))
}, {
  anchor: function(e) {
    return t = e,
      n = hpe(gce(this)),
      r = "<a",
    (r += ' name="' + Hpe(hpe(t), $pe, "&quot;") + '"') + ">" + n + "</a>";
    var t, n, r
  }
});
var zpe = function(e, t, n) {
  var r, o;
  Qce(e);
  try {
    if (!(r = sde(e, "return"))) {
      if ("throw" === t)
        throw n;
      return n
    }
    r = Zce(r, e)
  } catch (a) {
    o = !0,
      r = a
  }
  if ("throw" === t)
    throw n;
  if (o)
    throw r;
  return Qce(r),
    n
}
  , Kpe = function(e, t, n, r) {
  try {
    return r ? t(Qce(n)[0], n[1]) : t(n)
  } catch (o) {
    zpe(e, "throw", o)
  }
}
  , Wpe = {}
  , Gpe = Vce("iterator")
  , qpe = Array.prototype
  , Ype = function(e) {
  return void 0 !== e && (Wpe.Array === e || qpe[Gpe] === e)
}
  , Xpe = function(e, t, n) {
  var r = dde(t);
  r in e ? hde.f(e, r, vde(0, n)) : e[r] = n
}
  , Qpe = Vce("iterator")
  , Jpe = function(e) {
  if (null != e)
    return sde(e, Qpe) || sde(e, "@@iterator") || Wpe[Wde(e)]
}
  , Zpe = ace.TypeError
  , ehe = function(e, t) {
  var n = arguments.length < 2 ? Jpe(e) : t;
  if (ide(n))
    return Qce(Zce(n, e));
  throw Zpe(ode(e) + " is not iterable")
}
  , the = ace.Array
  , nhe = Vce("iterator")
  , rhe = !1;
try {
  var ohe = 0
    , ahe = {
    next: function() {
      return {
        done: !!ohe++
      }
    },
    return: function() {
      rhe = !0
    }
  };
  ahe[nhe] = function() {
    return this
  }
    ,
    Array.from(ahe, (function() {
        throw 2
      }
    ))
} catch (sbt) {}
var ihe = function(e, t) {
  if (!t && !rhe)
    return !1;
  var n = !1;
  try {
    var r = {};
    r[nhe] = function() {
      return {
        next: function() {
          return {
            done: n = !0
          }
        }
      }
    }
      ,
      e(r)
  } catch (o) {}
  return n
}
  , she = !ihe((function(e) {
    Array.from(e)
  }
));
ape({
  target: "Array",
  stat: !0,
  forced: she
}, {
  from: function(e) {
    var t = yce(e)
      , n = mfe(this)
      , r = arguments.length
      , o = r > 1 ? arguments[1] : void 0
      , a = void 0 !== o;
    a && (o = Zde(o, r > 2 ? arguments[2] : void 0));
    var i, s, l, u, c, d, f = Jpe(t), p = 0;
    if (!f || this == the && Ype(f))
      for (i = lfe(t),
             s = n ? new this(i) : the(i); i > p; p++)
        d = a ? o(t[p], p) : t[p],
          Xpe(s, p, d);
    else
      for (c = (u = ehe(t, f)).next,
             s = n ? new this : []; !(l = Zce(c, u)).done; p++)
        d = a ? Kpe(u, o, [l.value, p], !0) : l.value,
          Xpe(s, p, d);
    return s.length = p,
      s
  }
});
var lhe, uhe, che, dhe = hce("".charAt), fhe = hce("".charCodeAt), phe = hce("".slice), hhe = function(e) {
  return function(t, n) {
    var r, o, a = hpe(gce(t)), i = afe(n), s = a.length;
    return i < 0 || i >= s ? e ? "" : void 0 : (r = fhe(a, i)) < 55296 || r > 56319 || i + 1 === s || (o = fhe(a, i + 1)) < 56320 || o > 57343 ? e ? dhe(a, i) : r : e ? phe(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536
  }
}, vhe = {
  codeAt: hhe(!1),
  charAt: hhe(!0)
}, ghe = !Ice((function() {
    function e() {}
    return e.prototype.constructor = null,
    Object.getPrototypeOf(new e) !== e.prototype
  }
)), mhe = Cde("IE_PROTO"), yhe = ace.Object, bhe = yhe.prototype, whe = ghe ? yhe.getPrototypeOf : function(e) {
  var t = yce(e);
  if (wce(t, mhe))
    return t[mhe];
  var n = t.constructor;
  return Cce(n) && t instanceof n ? n.prototype : t instanceof yhe ? bhe : null
}
  , xhe = Vce("iterator"), She = !1;
[].keys && ("next"in (che = [].keys()) ? (uhe = whe(whe(che))) !== Object.prototype && (lhe = uhe) : She = !0);
var Ehe = null == lhe || Ice((function() {
    var e = {};
    return lhe[xhe].call(e) !== e
  }
));
Ehe && (lhe = {}),
Cce(lhe[xhe]) || jde(lhe, xhe, (function() {
    return this
  }
));
var Ahe = {
  IteratorPrototype: lhe,
  BUGGY_SAFARI_ITERATORS: She
}
  , Che = hde.f
  , khe = Vce("toStringTag")
  , The = function(e, t, n) {
  e && !wce(e = n ? e : e.prototype, khe) && Che(e, khe, {
    configurable: !0,
    value: t
  })
}
  , Dhe = Ahe.IteratorPrototype
  , Ohe = function() {
  return this
}
  , _he = ace.String
  , Rhe = ace.TypeError
  , Lhe = Object.setPrototypeOf || ("__proto__"in {} ? function() {
  var e, t = !1, n = {};
  try {
    (e = hce(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n, []),
      t = n instanceof Array
  } catch (r) {}
  return function(n, r) {
    return Qce(n),
      function(e) {
        if ("object" == typeof e || Cce(e))
          return e;
        throw Rhe("Can't set " + _he(e) + " as a prototype")
      }(r),
      t ? e(n, r) : n.__proto__ = r,
      n
  }
}() : void 0)
  , Ihe = Mde.PROPER
  , Phe = Mde.CONFIGURABLE
  , Fhe = Ahe.IteratorPrototype
  , Bhe = Ahe.BUGGY_SAFARI_ITERATORS
  , Nhe = Vce("iterator")
  , Mhe = function() {
  return this
}
  , jhe = function(e, t, n, r, o, a, i) {
  var s, l, u;
  l = r,
    u = t + " Iterator",
    (s = n).prototype = _pe(Dhe, {
      next: vde(1, l)
    }),
    The(s, u, !1),
    Wpe[u] = Ohe;
  var c, d, f, p = function(e) {
    if (e === o && y)
      return y;
    if (!Bhe && e in g)
      return g[e];
    switch (e) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n(this,e)
        }
    }
    return function() {
      return new n(this)
    }
  }, h = t + " Iterator", v = !1, g = e.prototype, m = g[Nhe] || g["@@iterator"] || o && g[o], y = !Bhe && m || p(o), b = "Array" == t && g.entries || m;
  if (b && (c = whe(b.call(new e))) !== Object.prototype && c.next && (whe(c) !== Fhe && (Lhe ? Lhe(c, Fhe) : Cce(c[Nhe]) || jde(c, Nhe, Mhe)),
    The(c, h, !0)),
  Ihe && "values" == o && m && "values" !== m.name && (Phe ? gde(g, "name", "values") : (v = !0,
      y = function() {
        return Zce(m, this)
      }
  )),
    o)
    if (d = {
      values: p("values"),
      keys: a ? y : p("keys"),
      entries: p("entries")
    },
      i)
      for (f in d)
        (Bhe || v || !(f in g)) && jde(g, f, d[f]);
    else
      ape({
        target: t,
        proto: !0,
        forced: Bhe || v
      }, d);
  return g[Nhe] !== y && jde(g, Nhe, y, {
    name: o
  }),
    Wpe[t] = y,
    d
}
  , Vhe = vhe.charAt
  , Uhe = Pde.set
  , $he = Pde.getterFor("String Iterator");
jhe(String, "String", (function(e) {
    Uhe(this, {
      type: "String Iterator",
      string: hpe(e),
      index: 0
    })
  }
), (function() {
    var e, t = $he(this), n = t.string, r = t.index;
    return r >= n.length ? {
      value: void 0,
      done: !0
    } : (e = Vhe(n, r),
      t.index += e.length,
      {
        value: e,
        done: !1
      })
  }
));
var Hhe, zhe = Ffe.f, Khe = hce("".endsWith), Whe = hce("".slice), Ghe = Math.min, qhe = Vpe("endsWith"), Yhe = !(qhe || (Hhe = zhe(String.prototype, "endsWith"),
!Hhe || Hhe.writable));
ape({
  target: "String",
  proto: !0,
  forced: !Yhe && !qhe
}, {
  endsWith: function(e) {
    var t = hpe(gce(this));
    Mpe(e);
    var n = arguments.length > 1 ? arguments[1] : void 0
      , r = t.length
      , o = void 0 === n ? r : Ghe(sfe(n), r)
      , a = hpe(e);
    return Khe ? Khe(t, a, o) : Whe(t, o - a.length, o) === a
  }
});
var Xhe = hce([].join)
  , Qhe = nfe != Object
  , Jhe = Afe("join", ",");
ape({
  target: "Array",
  proto: !0,
  forced: Qhe || !Jhe
}, {
  join: function(e) {
    return Xhe(Ife(this), void 0 === e ? "," : e)
  }
});
var Zhe = Vce("species")
  , eve = function(e) {
  return Lce >= 51 || !Ice((function() {
      var t = [];
      return (t.constructor = {})[Zhe] = function() {
        return {
          foo: 1
        }
      }
        ,
      1 !== t[e](Boolean).foo
    }
  ))
}
  , tve = Efe.map
  , nve = eve("map");
ape({
  target: "Array",
  proto: !0,
  forced: !nve
}, {
  map: function(e) {
    return tve(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var rve = ace.RegExp
  , ove = Ice((function() {
    var e = rve("a", "y");
    return e.lastIndex = 2,
    null != e.exec("abcd")
  }
))
  , ave = ove || Ice((function() {
    return !rve("a", "y").sticky
  }
))
  , ive = {
  BROKEN_CARET: ove || Ice((function() {
      var e = rve("^r", "gy");
      return e.lastIndex = 2,
      null != e.exec("str")
    }
  )),
  MISSED_STICKY: ave,
  UNSUPPORTED_Y: ove
}
  , sve = ace.RegExp
  , lve = Ice((function() {
    var e = sve(".", "s");
    return !(e.dotAll && e.exec("\n") && "s" === e.flags)
  }
))
  , uve = ace.RegExp
  , cve = Ice((function() {
    var e = uve("(?<a>b)", "g");
    return "b" !== e.exec("b").groups.a || "bc" !== "b".replace(e, "$<a>c")
  }
))
  , dve = Pde.get
  , fve = uce("native-string-replace", String.prototype.replace)
  , pve = RegExp.prototype.exec
  , hve = pve
  , vve = hce("".charAt)
  , gve = hce("".indexOf)
  , mve = hce("".replace)
  , yve = hce("".slice)
  , bve = function() {
  var e = /a/
    , t = /b*/g;
  return Zce(pve, e, "a"),
    Zce(pve, t, "a"),
  0 !== e.lastIndex || 0 !== t.lastIndex
}()
  , wve = ive.BROKEN_CARET
  , xve = void 0 !== /()??/.exec("")[1];
(bve || xve || wve || lve || cve) && (hve = function(e) {
    var t, n, r, o, a, i, s, l = this, u = dve(l), c = hpe(e), d = u.raw;
    if (d)
      return d.lastIndex = l.lastIndex,
        t = Zce(hve, d, c),
        l.lastIndex = d.lastIndex,
        t;
    var f = u.groups
      , p = wve && l.sticky
      , h = Zce(vpe, l)
      , v = l.source
      , g = 0
      , m = c;
    if (p && (h = mve(h, "y", ""),
    -1 === gve(h, "g") && (h += "g"),
      m = yve(c, l.lastIndex),
    l.lastIndex > 0 && (!l.multiline || l.multiline && "\n" !== vve(c, l.lastIndex - 1)) && (v = "(?: " + v + ")",
      m = " " + m,
      g++),
      n = new RegExp("^(?:" + v + ")",h)),
    xve && (n = new RegExp("^" + v + "$(?!\\s)",h)),
    bve && (r = l.lastIndex),
      o = Zce(pve, p ? n : l, m),
      p ? o ? (o.input = yve(o.input, g),
        o[0] = yve(o[0], g),
        o.index = l.lastIndex,
        l.lastIndex += o[0].length) : l.lastIndex = 0 : bve && o && (l.lastIndex = l.global ? o.index + o[0].length : r),
    xve && o && o.length > 1 && Zce(fve, o[0], n, (function() {
        for (a = 1; a < arguments.length - 2; a++)
          void 0 === arguments[a] && (o[a] = void 0)
      }
    )),
    o && f)
      for (o.groups = i = _pe(null),
             a = 0; a < f.length; a++)
        i[(s = f[a])[0]] = o[s[1]];
    return o
  }
);
var Sve = hve;
ape({
  target: "RegExp",
  proto: !0,
  forced: /./.exec !== Sve
}, {
  exec: Sve
});
var Eve = Function.prototype
  , Ave = Eve.apply
  , Cve = Eve.bind
  , kve = Eve.call
  , Tve = "object" == typeof Reflect && Reflect.apply || (Cve ? kve.bind(Ave) : function() {
    return kve.apply(Ave, arguments)
  }
)
  , Dve = Vce("species")
  , Ove = RegExp.prototype
  , _ve = function(e, t, n, r) {
  var o = Vce(e)
    , a = !Ice((function() {
      var t = {};
      return t[o] = function() {
        return 7
      }
        ,
      7 != ""[e](t)
    }
  ))
    , i = a && !Ice((function() {
      var t = !1
        , n = /a/;
      return "split" === e && ((n = {}).constructor = {},
        n.constructor[Dve] = function() {
          return n
        }
        ,
        n.flags = "",
        n[o] = /./[o]),
        n.exec = function() {
          return t = !0,
            null
        }
        ,
        n[o](""),
        !t
    }
  ));
  if (!a || !i || n) {
    var s = hce(/./[o])
      , l = t(o, ""[e], (function(e, t, n, r, o) {
        var i = hce(e)
          , l = t.exec;
        return l === Sve || l === Ove.exec ? a && !o ? {
          done: !0,
          value: s(t, n, r)
        } : {
          done: !0,
          value: i(n, t, r)
        } : {
          done: !1
        }
      }
    ));
    jde(String.prototype, e, l[0]),
      jde(Ove, o, l[1])
  }
  r && gde(Ove[o], "sham", !0)
}
  , Rve = vhe.charAt
  , Lve = function(e, t, n) {
  return t + (n ? Rve(e, t).length : 1)
}
  , Ive = Math.floor
  , Pve = hce("".charAt)
  , Fve = hce("".replace)
  , Bve = hce("".slice)
  , Nve = /\$([$&'`]|\d{1,2}|<[^>]*>)/g
  , Mve = /\$([$&'`]|\d{1,2})/g
  , jve = function(e, t, n, r, o, a) {
  var i = n + e.length
    , s = r.length
    , l = Mve;
  return void 0 !== o && (o = yce(o),
    l = Nve),
    Fve(a, l, (function(a, l) {
        var u;
        switch (Pve(l, 0)) {
          case "$":
            return "$";
          case "&":
            return e;
          case "`":
            return Bve(t, 0, n);
          case "'":
            return Bve(t, i);
          case "<":
            u = o[Bve(l, 1, -1)];
            break;
          default:
            var c = +l;
            if (0 === c)
              return a;
            if (c > s) {
              var d = Ive(c / 10);
              return 0 === d ? a : d <= s ? void 0 === r[d - 1] ? Pve(l, 1) : r[d - 1] + Pve(l, 1) : a
            }
            u = r[c - 1]
        }
        return void 0 === u ? "" : u
      }
    ))
}
  , Vve = ace.TypeError
  , Uve = function(e, t) {
  var n = e.exec;
  if (Cce(n)) {
    var r = Zce(n, e, t);
    return null !== r && Qce(r),
      r
  }
  if ("RegExp" === $de(e))
    return Zce(Sve, e, t);
  throw Vve("RegExp#exec called on incompatible receiver")
}
  , $ve = Vce("replace")
  , Hve = Math.max
  , zve = Math.min
  , Kve = hce([].concat)
  , Wve = hce([].push)
  , Gve = hce("".indexOf)
  , qve = hce("".slice)
  , Yve = "$0" === "a".replace(/./, "$0")
  , Xve = !!/./[$ve] && "" === /./[$ve]("a", "$0");
_ve("replace", (function(e, t, n) {
    var r = Xve ? "$" : "$0";
    return [function(e, n) {
      var r = gce(this)
        , o = null == e ? void 0 : sde(e, $ve);
      return o ? Zce(o, e, r, n) : Zce(t, hpe(r), e, n)
    }
      , function(e, o) {
        var a = Qce(this)
          , i = hpe(e);
        if ("string" == typeof o && -1 === Gve(o, r) && -1 === Gve(o, "$<")) {
          var s = n(t, a, i, o);
          if (s.done)
            return s.value
        }
        var l = Cce(o);
        l || (o = hpe(o));
        var u = a.global;
        if (u) {
          var c = a.unicode;
          a.lastIndex = 0
        }
        for (var d = []; ; ) {
          var f = Uve(a, i);
          if (null === f)
            break;
          if (Wve(d, f),
            !u)
            break;
          "" === hpe(f[0]) && (a.lastIndex = Lve(i, sfe(a.lastIndex), c))
        }
        for (var p, h = "", v = 0, g = 0; g < d.length; g++) {
          for (var m = hpe((f = d[g])[0]), y = Hve(zve(afe(f.index), i.length), 0), b = [], w = 1; w < f.length; w++)
            Wve(b, void 0 === (p = f[w]) ? p : String(p));
          var x = f.groups;
          if (l) {
            var S = Kve([m], b, y, i);
            void 0 !== x && Wve(S, x);
            var E = hpe(Tve(o, void 0, S))
          } else
            E = jve(m, i, y, b, x, o);
          y >= v && (h += qve(i, v, y) + E,
            v = y + m.length)
        }
        return h + qve(i, v)
      }
    ]
  }
), !!Ice((function() {
    var e = /./;
    return e.exec = function() {
      var e = [];
      return e.groups = {
        a: "7"
      },
        e
    }
      ,
    "7" !== "".replace(e, "$<a>")
  }
)) || !Yve || Xve);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Qve = function(e, t) {
  return (Qve = Object.setPrototypeOf || {
        __proto__: []
      }instanceof Array && function(e, t) {
        e.__proto__ = t
      }
      || function(e, t) {
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
      }
  )(e, t)
};
function Jve(e, t) {
  if ("function" != typeof t && null !== t)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function n() {
    this.constructor = e
  }
  Qve(e, t),
    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype,
      new n)
}
var Zve = function() {
  return Zve = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++)
      for (var o in t = arguments[n])
        Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    return e
  }
    ,
    Zve.apply(this, arguments)
};
function ege(e) {
  var t = "function" == typeof Symbol && Symbol.iterator
    , n = t && e[t]
    , r = 0;
  if (n)
    return n.call(e);
  if (e && "number" == typeof e.length)
    return {
      next: function() {
        return e && r >= e.length && (e = void 0),
          {
            value: e && e[r++],
            done: !e
          }
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function tge(e, t) {
  var n = "function" == typeof Symbol && e[Symbol.iterator];
  if (!n)
    return e;
  var r, o, a = n.call(e), i = [];
  try {
    for (; (void 0 === t || t-- > 0) && !(r = a.next()).done; )
      i.push(r.value)
  } catch (s) {
    o = {
      error: s
    }
  } finally {
    try {
      r && !r.done && (n = a.return) && n.call(a)
    } finally {
      if (o)
        throw o.error
    }
  }
  return i
}
function nge(e, t) {
  for (var n = 0, r = t.length, o = e.length; n < r; n++,
    o++)
    e[o] = t[n];
  return e
}
var rge = 0
  , oge = function() {
  this.id = "" + rge++
}
  , age = Pde.set
  , ige = Pde.getterFor("Array Iterator")
  , sge = jhe(Array, "Array", (function(e, t) {
    age(this, {
      type: "Array Iterator",
      target: Ife(e),
      index: 0,
      kind: t
    })
  }
), (function() {
    var e = ige(this)
      , t = e.target
      , n = e.kind
      , r = e.index++;
    return !t || r >= t.length ? (e.target = void 0,
      {
        value: void 0,
        done: !0
      }) : "keys" == n ? {
      value: r,
      done: !1
    } : "values" == n ? {
      value: t[r],
      done: !1
    } : {
      value: [r, t[r]],
      done: !1
    }
  }
), "values");
Wpe.Arguments = Wpe.Array,
  Ipe("keys"),
  Ipe("values"),
  Ipe("entries");
var lge = function(e, t, n) {
  for (var r in t)
    jde(e, r, t[r], n);
  return e
}
  , uge = ace.Array
  , cge = Math.max
  , dge = function(e, t, n) {
  for (var r = lfe(e), o = Mfe(t, r), a = Mfe(void 0 === n ? r : n, r), i = uge(cge(a - o, 0)), s = 0; o < a; o++,
    s++)
    Xpe(i, s, e[o]);
  return i.length = s,
    i
}
  , fge = Wfe.f
  , pge = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []
  , hge = {
  f: function(e) {
    return pge && "Window" == $de(e) ? function(e) {
      try {
        return fge(e)
      } catch (t) {
        return dge(pge)
      }
    }(e) : fge(Ife(e))
  }
}
  , vge = Ice((function() {
    if ("function" == typeof ArrayBuffer) {
      var e = new ArrayBuffer(8);
      Object.isExtensible(e) && Object.defineProperty(e, "a", {
        value: 8
      })
    }
  }
))
  , gge = Object.isExtensible
  , mge = Ice((function() {
    gge(1)
  }
)) || vge ? function(e) {
    return !!zce(e) && (!vge || "ArrayBuffer" != $de(e)) && (!gge || gge(e))
  }
  : gge
  , yge = !Ice((function() {
    return Object.isExtensible(Object.preventExtensions({}))
  }
))
  , bge = tce((function(e) {
    var t = hde.f
      , n = !1
      , r = Ace("meta")
      , o = 0
      , a = function(e) {
      t(e, r, {
        value: {
          objectID: "O" + o++,
          weakData: {}
        }
      })
    }
      , i = e.exports = {
      enable: function() {
        i.enable = function() {}
          ,
          n = !0;
        var e = Wfe.f
          , t = hce([].splice)
          , o = {};
        o[r] = 1,
        e(o).length && (Wfe.f = function(n) {
          for (var o = e(n), a = 0, i = o.length; a < i; a++)
            if (o[a] === r) {
              t(o, a, 1);
              break
            }
          return o
        }
          ,
          ape({
            target: "Object",
            stat: !0,
            forced: !0
          }, {
            getOwnPropertyNames: hge.f
          }))
      },
      fastKey: function(e, t) {
        if (!zce(e))
          return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
        if (!wce(e, r)) {
          if (!mge(e))
            return "F";
          if (!t)
            return "E";
          a(e)
        }
        return e[r].objectID
      },
      getWeakData: function(e, t) {
        if (!wce(e, r)) {
          if (!mge(e))
            return !0;
          if (!t)
            return !1;
          a(e)
        }
        return e[r].weakData
      },
      onFreeze: function(e) {
        return yge && n && mge(e) && !wce(e, r) && a(e),
          e
      }
    };
    kde[r] = !0
  }
))
  , wge = ace.TypeError
  , xge = function(e, t) {
  this.stopped = e,
    this.result = t
}
  , Sge = xge.prototype
  , Ege = function(e, t, n) {
  var r, o, a, i, s, l, u, c = n && n.that, d = !(!n || !n.AS_ENTRIES), f = !(!n || !n.IS_ITERATOR), p = !(!n || !n.INTERRUPTED), h = Zde(t, c), v = function(e) {
    return r && zpe(r, "normal", e),
      new xge(!0,e)
  }, g = function(e) {
    return d ? (Qce(e),
      p ? h(e[0], e[1], v) : h(e[0], e[1])) : p ? h(e, v) : h(e)
  };
  if (f)
    r = e;
  else {
    if (!(o = Jpe(e)))
      throw wge(ode(e) + " is not iterable");
    if (Ype(o)) {
      for (a = 0,
             i = lfe(e); i > a; a++)
        if ((s = g(e[a])) && ede(Sge, s))
          return s;
      return new xge(!1)
    }
    r = ehe(e, o)
  }
  for (l = r.next; !(u = Zce(l, r)).done; ) {
    try {
      s = g(u.value)
    } catch (m) {
      zpe(r, "throw", m)
    }
    if ("object" == typeof s && s && ede(Sge, s))
      return s
  }
  return new xge(!1)
}
  , Age = ace.TypeError
  , Cge = function(e, t) {
  if (ede(t, e))
    return e;
  throw Age("Incorrect invocation")
}
  , kge = function(e, t, n) {
  var r, o;
  return Lhe && Cce(r = t.constructor) && r !== n && zce(o = r.prototype) && o !== n.prototype && Lhe(e, o),
    e
}
  , Tge = function(e, t, n) {
  var r = -1 !== e.indexOf("Map")
    , o = -1 !== e.indexOf("Weak")
    , a = r ? "set" : "add"
    , i = ace[e]
    , s = i && i.prototype
    , l = i
    , u = {}
    , c = function(e) {
    var t = hce(s[e]);
    jde(s, e, "add" == e ? function(e) {
          return t(this, 0 === e ? 0 : e),
            this
        }
        : "delete" == e ? function(e) {
            return !(o && !zce(e)) && t(this, 0 === e ? 0 : e)
          }
          : "get" == e ? function(e) {
              return o && !zce(e) ? void 0 : t(this, 0 === e ? 0 : e)
            }
            : "has" == e ? function(e) {
                return !(o && !zce(e)) && t(this, 0 === e ? 0 : e)
              }
              : function(e, n) {
                return t(this, 0 === e ? 0 : e, n),
                  this
              }
    )
  };
  if (rpe(e, !Cce(i) || !(o || s.forEach && !Ice((function() {
      (new i).entries().next()
    }
  )))))
    l = n.getConstructor(t, e, r, a),
      bge.enable();
  else if (rpe(e, !0)) {
    var d = new l
      , f = d[a](o ? {} : -0, 1) != d
      , p = Ice((function() {
        d.has(1)
      }
    ))
      , h = ihe((function(e) {
        new i(e)
      }
    ))
      , v = !o && Ice((function() {
        for (var e = new i, t = 5; t--; )
          e[a](t, t);
        return !e.has(-0)
      }
    ));
    h || ((l = t((function(e, t) {
        Cge(e, s);
        var n = kge(new i, e, l);
        return null != t && Ege(t, n[a], {
          that: n,
          AS_ENTRIES: r
        }),
          n
      }
    ))).prototype = s,
      s.constructor = l),
    (p || v) && (c("delete"),
      c("has"),
    r && c("get")),
    (v || f) && c(a),
    o && s.clear && delete s.clear
  }
  return u[e] = l,
    ape({
      global: !0,
      forced: l != i
    }, u),
    The(l, e),
  o || n.setStrong(l, e, r),
    l
}
  , Dge = bge.getWeakData
  , Oge = Pde.set
  , _ge = Pde.getterFor
  , Rge = Efe.find
  , Lge = Efe.findIndex
  , Ige = hce([].splice)
  , Pge = 0
  , Fge = function(e) {
  return e.frozen || (e.frozen = new Bge)
}
  , Bge = function() {
  this.entries = []
}
  , Nge = function(e, t) {
  return Rge(e.entries, (function(e) {
      return e[0] === t
    }
  ))
};
Bge.prototype = {
  get: function(e) {
    var t = Nge(this, e);
    if (t)
      return t[1]
  },
  has: function(e) {
    return !!Nge(this, e)
  },
  set: function(e, t) {
    var n = Nge(this, e);
    n ? n[1] = t : this.entries.push([e, t])
  },
  delete: function(e) {
    var t = Lge(this.entries, (function(t) {
        return t[0] === e
      }
    ));
    return ~t && Ige(this.entries, t, 1),
      !!~t
  }
};
var Mge, jge = {
  getConstructor: function(e, t, n, r) {
    var o = e((function(e, o) {
        Cge(e, a),
          Oge(e, {
            type: t,
            id: Pge++,
            frozen: void 0
          }),
        null != o && Ege(o, e[r], {
          that: e,
          AS_ENTRIES: n
        })
      }
    ))
      , a = o.prototype
      , i = _ge(t)
      , s = function(e, t, n) {
      var r = i(e)
        , o = Dge(Qce(t), !0);
      return !0 === o ? Fge(r).set(t, n) : o[r.id] = n,
        e
    };
    return lge(a, {
      delete: function(e) {
        var t = i(this);
        if (!zce(e))
          return !1;
        var n = Dge(e);
        return !0 === n ? Fge(t).delete(e) : n && wce(n, t.id) && delete n[t.id]
      },
      has: function(e) {
        var t = i(this);
        if (!zce(e))
          return !1;
        var n = Dge(e);
        return !0 === n ? Fge(t).has(e) : n && wce(n, t.id)
      }
    }),
      lge(a, n ? {
        get: function(e) {
          var t = i(this);
          if (zce(e)) {
            var n = Dge(e);
            return !0 === n ? Fge(t).get(e) : n ? n[t.id] : void 0
          }
        },
        set: function(e, t) {
          return s(this, e, t)
        }
      } : {
        add: function(e) {
          return s(this, e, !0)
        }
      }),
      o
  }
}, Vge = Pde.enforce, Uge = !ace.ActiveXObject && "ActiveXObject"in ace, $ge = function(e) {
  return function() {
    return e(this, arguments.length ? arguments[0] : void 0)
  }
}, Hge = Tge("WeakMap", $ge, jge);
if (Ede && Uge) {
  Mge = jge.getConstructor($ge, "WeakMap", !0),
    bge.enable();
  var zge = Hge.prototype
    , Kge = hce(zge.delete)
    , Wge = hce(zge.has)
    , Gge = hce(zge.get)
    , qge = hce(zge.set);
  lge(zge, {
    delete: function(e) {
      if (zce(e) && !mge(e)) {
        var t = Vge(this);
        return t.frozen || (t.frozen = new Mge),
        Kge(this, e) || t.frozen.delete(e)
      }
      return Kge(this, e)
    },
    has: function(e) {
      if (zce(e) && !mge(e)) {
        var t = Vge(this);
        return t.frozen || (t.frozen = new Mge),
        Wge(this, e) || t.frozen.has(e)
      }
      return Wge(this, e)
    },
    get: function(e) {
      if (zce(e) && !mge(e)) {
        var t = Vge(this);
        return t.frozen || (t.frozen = new Mge),
          Wge(this, e) ? Gge(this, e) : t.frozen.get(e)
      }
      return Gge(this, e)
    },
    set: function(e, t) {
      if (zce(e) && !mge(e)) {
        var n = Vge(this);
        n.frozen || (n.frozen = new Mge),
          Wge(this, e) ? qge(this, e, t) : n.frozen.set(e, t)
      } else
        qge(this, e, t);
      return this
    }
  })
}
var Yge = Vce("iterator")
  , Xge = Vce("toStringTag")
  , Qge = sge.values
  , Jge = function(e, t) {
  if (e) {
    if (e[Yge] !== Qge)
      try {
        gde(e, Yge, Qge)
      } catch (r) {
        e[Yge] = Qge
      }
    if (e[Xge] || gde(e, Xge, t),
      qde[t])
      for (var n in sge)
        if (e[n] !== sge[n])
          try {
            gde(e, n, sge[n])
          } catch (r) {
            e[n] = sge[n]
          }
  }
};
for (var Zge in qde)
  Jge(ace[Zge] && ace[Zge].prototype, Zge);
Jge(Qde, "DOMTokenList");
var eme = new WeakMap
  , tme = new WeakMap
  , nme = new WeakMap
  , rme = new WeakMap
  , ome = new WeakMap
  , ame = new WeakMap
  , ime = new WeakMap
  , sme = new WeakMap
  , lme = new WeakMap
  , ume = new WeakMap
  , cme = new WeakMap
  , dme = new WeakMap
  , fme = new WeakMap
  , pme = new WeakMap
  , hme = new WeakMap
  , vme = new WeakMap
  , gme = new WeakMap
  , mme = new WeakMap
  , yme = new WeakMap
  , bme = new WeakMap
  , wme = new WeakMap
  , xme = new WeakMap
  , Sme = new WeakMap
  , Eme = new WeakMap
  , Ame = new WeakMap
  , Cme = Efe.find
  , kme = !0;
"find"in [] && Array(1).find((function() {
    kme = !1
  }
)),
  ape({
    target: "Array",
    proto: !0,
    forced: kme
  }, {
    find: function(e) {
      return Cme(this, e, arguments.length > 1 ? arguments[1] : void 0)
    }
  }),
  Ipe("find"),
  ape({
    global: !0
  }, {
    globalThis: ace
  });
const Tme = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"];
foe && (Qre.fn.css = foe),
yoe && (Qre.fn.append = yoe),
Jre && (Qre.fn.addClass = Jre),
Zre && (Qre.fn.removeClass = Zre),
eoe && (Qre.fn.hasClass = eoe),
aoe && (Qre.fn.on = aoe),
Ooe && (Qre.fn.focus = Ooe),
toe && (Qre.fn.attr = toe),
noe && (Qre.fn.removeAttr = noe),
coe && (Qre.fn.hide = coe),
doe && (Qre.fn.show = doe),
uoe && (Qre.fn.offset = uoe),
soe && (Qre.fn.width = soe),
loe && (Qre.fn.height = loe),
woe && (Qre.fn.parent = woe),
xoe && (Qre.fn.parents = xoe),
moe && (Qre.fn.is = moe),
roe && (Qre.fn.dataset = roe),
ooe && (Qre.fn.val = ooe),
goe && (Qre.fn.text = goe),
voe && (Qre.fn.html = voe),
Eoe && (Qre.fn.children = Eoe),
Aoe && (Qre.fn.remove = Aoe),
Soe && (Qre.fn.find = Soe),
poe && (Qre.fn.each = poe),
Coe && (Qre.fn.empty = Coe);
var Dme, Ome, _me = function(e) {
  return e && e.ownerDocument && e.ownerDocument.defaultView || null
}, Rme = function(e) {
  return Lme(e) && 1 === e.nodeType
}, Lme = function(e) {
  var t = _me(e);
  return !!t && e instanceof t.Node
}, Ime = function(e) {
  var t = e && e.anchorNode && _me(e.anchorNode);
  return !!t && e instanceof t.Selection
}, Pme = function(e) {
  return Lme(e) && 3 === e.nodeType
}, Fme = function(e) {
  var t, n, r;
  return null !== (t = window.document.getElementById(e)) && void 0 !== t ? t : (null === (r = null === (n = window.document.activeElement) || void 0 === n ? void 0 : n.shadowRoot) || void 0 === r ? void 0 : r.getElementById(e)) || null
}, Bme = function(e, t, n) {
  for (var r, o = e.childNodes, a = o[t], i = t, s = !1, l = !1; (Lme(r = a) && 8 === r.nodeType || Rme(a) && 0 === a.childNodes.length || Rme(a) && "false" === a.getAttribute("contenteditable")) && (!s || !l); )
    i >= o.length ? (s = !0,
      i = t - 1,
      n = "backward") : i < 0 ? (l = !0,
      i = t + 1,
      n = "forward") : (a = o[i],
      t = i,
      i += "forward" === n ? 1 : -1);
  return [a, t]
}, Nme = function(e, t, n) {
  return tge(Bme(e, t, n), 1)[0]
}, Mme = function e(t) {
  var n, r, o = "";
  if (Pme(t) && t.nodeValue)
    return t.nodeValue;
  if (Rme(t)) {
    try {
      for (var a = ege(Array.from(t.childNodes)), i = a.next(); !i.done; i = a.next())
        o += e(i.value)
    } catch (Y_) {
      n = {
        error: Y_
      }
    } finally {
      try {
        i && !i.done && (r = a.return) && r.call(a)
      } finally {
        if (n)
          throw n.error
      }
    }
    var s = getComputedStyle(t).getPropertyValue("display");
    "block" !== s && "list" !== s && "table-row" !== s && "BR" !== t.tagName || (o += "\n")
  }
  return o
};
function jme(e, t) {
  if (!(e instanceof HTMLElement && "true" === e.dataset.slateVoid))
    for (var n = e.childNodes, r = n.length; r--; ) {
      var o = n[r]
        , a = o.nodeType;
      3 == a ? t(o, e) : 1 != a && 9 != a && 11 != a || jme(o, t)
    }
}
function Vme(e) {
  if (0 === e.length)
    return "";
  var t = e[0];
  return t.nodeType !== Dme.ELEMENT_NODE ? "" : t.tagName.toLowerCase()
}
(Ome = Dme || (Dme = {}))[Ome.ELEMENT_NODE = 1] = "ELEMENT_NODE",
  Ome[Ome.TEXT_NODE = 3] = "TEXT_NODE",
  Ome[Ome.CDATA_SECTION_NODE = 4] = "CDATA_SECTION_NODE",
  Ome[Ome.PROCESSING_INSTRUCTION_NODE = 7] = "PROCESSING_INSTRUCTION_NODE",
  Ome[Ome.COMMENT_NODE = 8] = "COMMENT_NODE",
  Ome[Ome.DOCUMENT_NODE = 9] = "DOCUMENT_NODE",
  Ome[Ome.DOCUMENT_TYPE_NODE = 10] = "DOCUMENT_TYPE_NODE",
  Ome[Ome.DOCUMENT_FRAGMENT_NODE = 11] = "DOCUMENT_FRAGMENT_NODE";
var Ume = "undefined" != typeof navigator && /Mac OS X/.test(navigator.userAgent)
  , $me = "undefined" != typeof navigator && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent)
  , Hme = "undefined" != typeof navigator && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent)
  , zme = "undefined" != typeof navigator && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent)
  , Kme = "undefined" != typeof navigator && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent)
  , Wme = "undefined" != typeof navigator && /Chrome/i.test(navigator.userAgent)
  , Gme = !Kme && !zme && "undefined" != typeof globalThis && globalThis.InputEvent && "function" == typeof globalThis.InputEvent.prototype.getTargetRanges
  , qme = {
  getWindow: function(e) {
    var t = wme.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t
  },
  findKey: function(e, t) {
    var n = bme.get(t);
    return n || (n = new oge,
      bme.set(t, n)),
      n
  },
  setNewKey: function(e) {
    var t = new oge;
    bme.set(e, t)
  },
  findPath: function(e, t) {
    for (var n = [], r = t; ; ) {
      var o = hme.get(r);
      if (null == o) {
        if (Yte.isEditor(r))
          return n;
        break
      }
      var a = pme.get(r);
      if (null == a)
        break;
      n.unshift(a),
        r = o
    }
    throw new Error("Unable to find the path for Slate node: " + JSON.stringify(t))
  },
  findDocumentOrShadowRoot: function(e) {
    if (e.isDestroyed)
      return window.document;
    var t = qme.toDOMNode(e, e)
      , n = t.getRootNode();
    return (n instanceof Document || n instanceof ShadowRoot) && null != n.getSelection ? n : t.ownerDocument
  },
  getParentNode: function(e, t) {
    return hme.get(t) || null
  },
  getParentsNodes: function(e, t) {
    for (var n = [], r = t; r !== e && null != r; ) {
      var o = qme.getParentNode(e, r);
      if (null == o)
        break;
      n.push(o),
        r = o
    }
    return n
  },
  getTopNode: function(e, t) {
    var n = [qme.findPath(e, t)[0]];
    return ene.get(e, n)
  },
  toDOMNode: function(e, t) {
    var n;
    if (Yte.isEditor(t))
      n = vme.get(e);
    else {
      var r = qme.findKey(e, t);
      n = mme.get(r)
    }
    if (!n)
      throw new Error("Cannot resolve a DOM node from Slate node: " + JSON.stringify(t));
    return n
  },
  hasDOMNode: function(e, t, n) {
    void 0 === n && (n = {});
    var r, o = n.editable, a = void 0 !== o && o, i = qme.toDOMNode(e, e);
    try {
      r = Rme(t) ? t : t.parentElement
    } catch (s) {
      if (!s.message.includes('Permission denied to access property "nodeType"'))
        throw s
    }
    return !!r && r.closest("[data-slate-editor]") === i && (!a || r.isContentEditable || !!r.getAttribute("data-slate-zero-width"))
  },
  toDOMRange: function(e, t) {
    var n = t.anchor
      , r = t.focus
      , o = fne.isBackward(t)
      , a = qme.toDOMPoint(e, n)
      , i = fne.isCollapsed(t) ? a : qme.toDOMPoint(e, r)
      , s = qme.getWindow(e).document.createRange()
      , l = tge(o ? i : a, 2)
      , u = l[0]
      , c = l[1]
      , d = tge(o ? a : i, 2)
      , f = d[0]
      , p = d[1]
      , h = !!(Rme(u) ? u : u.parentElement).getAttribute("data-slate-zero-width")
      , v = !!(Rme(f) ? f : f.parentElement).getAttribute("data-slate-zero-width");
    return s.setStart(u, h ? 1 : c),
      s.setEnd(f, v ? 1 : p),
      s
  },
  toDOMPoint: function(e, t) {
    var n, r, o, a = tge(Yte.node(e, t.path), 1)[0], i = qme.toDOMNode(e, a);
    Yte.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    var s = Array.from(i.querySelectorAll("[data-slate-string], [data-slate-zero-width]"))
      , l = 0;
    try {
      for (var u = ege(s), c = u.next(); !c.done; c = u.next()) {
        var d = c.value
          , f = d.childNodes[0];
        if (null != f && null != f.textContent) {
          var p = f.textContent.length
            , h = d.getAttribute("data-slate-length")
            , v = l + (null == h ? p : parseInt(h, 10));
          if (t.offset <= v) {
            o = [f, Math.min(p, Math.max(0, t.offset - l))];
            break
          }
          l = v
        }
      }
    } catch (g) {
      n = {
        error: g
      }
    } finally {
      try {
        c && !c.done && (r = u.return) && r.call(u)
      } finally {
        if (n)
          throw n.error
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: " + JSON.stringify(t));
    return o
  },
  toSlateNode: function(e, t) {
    var n = Rme(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? gme.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: " + n);
    return r
  },
  findEventRange: function(e, t) {
    "nativeEvent"in t && (t = t.nativeEvent);
    var n = t.clientX
      , r = t.clientY
      , o = t.target;
    if (null == n || null == r)
      throw new Error("Cannot resolve a Slate range from a DOM event: " + t);
    var a, i = qme.toSlateNode(e, t.target), s = qme.findPath(e, i);
    if (Yte.isVoid(e, i)) {
      var l = o.getBoundingClientRect()
        , u = e.isInline(i) ? n - l.left < l.left + l.width - n : r - l.top < l.top + l.height - r
        , c = Yte.point(e, s, {
        edge: u ? "start" : "end"
      })
        , d = u ? Yte.before(e, c) : Yte.after(e, c);
      if (d)
        return Yte.range(e, d)
    }
    var f = this.getWindow(e).document;
    if (f.caretRangeFromPoint)
      a = f.caretRangeFromPoint(n, r);
    else {
      var p = f.caretPositionFromPoint(n, r);
      p && ((a = f.createRange()).setStart(p.offsetNode, p.offset),
        a.setEnd(p.offsetNode, p.offset))
    }
    if (!a)
      throw new Error("Cannot resolve a Slate range from a DOM event: " + t);
    return qme.toSlateRange(e, a, {
      exactMatch: !1,
      suppressThrow: !1
    })
  },
  toSlateRange: function(e, t, n) {
    var r, o, a, i, s, l = n.exactMatch, u = n.suppressThrow;
    if ((Ime(t) ? t.anchorNode : t.startContainer) && (Ime(t) ? (r = t.anchorNode,
      o = t.anchorOffset,
      a = t.focusNode,
      i = t.focusOffset,
      s = Wme && window.document.activeElement && window.document.activeElement.shadowRoot ? t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : t.isCollapsed) : (r = t.startContainer,
      o = t.startOffset,
      a = t.endContainer,
      i = t.endOffset,
      s = t.collapsed)),
    null == r || null == a || null == o || null == i)
      throw new Error("Cannot resolve a Slate range from DOM range: " + t);
    var c = qme.toSlatePoint(e, [r, o], {
      exactMatch: l,
      suppressThrow: u
    });
    if (!c)
      return null;
    var d = s ? c : qme.toSlatePoint(e, [a, i], {
      exactMatch: l,
      suppressThrow: u
    });
    if (!d)
      return null;
    var f = {
      anchor: c,
      focus: d
    };
    return fne.isExpanded(f) && fne.isForward(f) && Rme(a) && Yte.void(e, {
      at: f.focus,
      mode: "highest"
    }) && (f = Yte.unhangRange(e, f, {
      voids: !0
    })),
      f
  },
  toSlatePoint: function(e, t, n) {
    var r, o = n.exactMatch, a = n.suppressThrow, i = tge(o ? t : function(e) {
      var t, n = tge(e, 2), r = n[0], o = n[1];
      if (Rme(r) && r.childNodes.length) {
        var a = o === r.childNodes.length
          , i = a ? o - 1 : o;
        for (r = (t = tge(Bme(r, i, a ? "backward" : "forward"), 2))[0],
               a = (i = t[1]) < o; Rme(r) && r.childNodes.length; ) {
          var s = a ? r.childNodes.length - 1 : 0;
          r = Nme(r, s, a ? "backward" : "forward")
        }
        o = a && null != r.textContent ? r.textContent.length : 0
      }
      return [r, o]
    }(t), 2), s = i[0], l = i[1], u = s.parentNode, c = null, d = 0;
    if (u) {
      var f = u.closest('[data-slate-void="true"]')
        , p = u.closest("[data-slate-leaf]")
        , h = null;
      if (p) {
        c = p.closest('[data-slate-node="text"]');
        var v = qme.getWindow(e).document.createRange();
        v.setStart(c, 0),
          v.setEnd(s, l);
        var g = v.cloneContents();
        nge(nge([], tge(Nre(g.querySelectorAll("[data-slate-zero-width]")))), tge(Nre(g.querySelectorAll("[contenteditable=false]")))).forEach((function(e) {
            e.parentNode.removeChild(e)
          }
        )),
          d = g.textContent.length,
          h = c
      } else
        f && ((p = f.querySelector("[data-slate-leaf]")) ? (c = p.closest('[data-slate-node="text"]'),
          d = (h = p).textContent.length,
          h.querySelectorAll("[data-slate-zero-width]").forEach((function(e) {
              d -= e.textContent.length
            }
          ))) : d = 1);
      h && d === h.textContent.length && (u.hasAttribute("data-slate-zero-width") || $me && (null === (r = h.textContent) || void 0 === r ? void 0 : r.endsWith("\n"))) && d--
    }
    if (!c) {
      if (a)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: " + t)
    }
    var m = qme.toSlateNode(e, c);
    return {
      path: qme.findPath(e, m),
      offset: d
    }
  },
  hasRange: function(e, t) {
    var n = t.anchor
      , r = t.focus;
    return Yte.hasPath(e, n.path) && Yte.hasPath(e, r.path)
  },
  getNodeType: function(e) {
    return Hte.isElement(e) ? e.type : ""
  },
  checkNodeType: function(e, t) {
    return this.getNodeType(e) === t
  },
  getNodesStr: function(e) {
    return e.map((function(e) {
        return ene.string(e)
      }
    )).join("")
  },
  getSelectedElems: function(e) {
    var t, n, r = [], o = Yte.nodes(e, {
      universal: !0
    });
    try {
      for (var a = ege(o), i = a.next(); !i.done; i = a.next()) {
        var s = tge(i.value, 1)[0];
        Hte.isElement(s) && r.push(s)
      }
    } catch (l) {
      t = {
        error: l
      }
    } finally {
      try {
        i && !i.done && (n = a.return) && n.call(a)
      } finally {
        if (t)
          throw t.error
      }
    }
    return r
  },
  getSelectedNodeByType: function(e, t) {
    var n = this
      , r = tge(Yte.nodes(e, {
      match: function(e) {
        return n.checkNodeType(e, t)
      },
      universal: !0
    }), 1)[0];
    return null == r ? null : r[0]
  },
  getSelectedTextNode: function(e) {
    var t = tge(Yte.nodes(e, {
      match: function(e) {
        return bne.isText(e)
      },
      universal: !0
    }), 1)[0];
    return null == t ? null : t[0]
  },
  isNodeSelected: function(e, t) {
    var n = tge(Yte.nodes(e, {
      match: function(e) {
        return e === t
      },
      universal: !0
    }), 1)[0];
    return null != n && tge(n, 1)[0] === t
  },
  isSelectionAtLineEnd: function(e, t) {
    var n = e.selection;
    return !!n && (Yte.isEnd(e, n.anchor, t) || Yte.isEnd(e, n.focus, t))
  },
  getTextarea: function(e) {
    var t = eme.get(e);
    if (null == t)
      throw new Error("Cannot find textarea instance by editor");
    return t
  },
  getToolbar: function(e) {
    return rme.get(e) || null
  },
  getHoverbar: function(e) {
    return ame.get(e) || null
  },
  normalizeContent: function(e) {
    e.children.forEach((function(t, n) {
        e.normalizeNode([t, [n]])
      }
    ))
  },
  getLeftLengthOfMaxLength: function(e) {
    var t = e.getConfig()
      , n = t.maxLength
      , r = t.onMaxLength;
    if ("number" != typeof n || n <= 0)
      return 1 / 0;
    var o = n - e.getText().replace(/\r|\n|(\r\n)/g, "").length;
    return o <= 0 && r && r(e),
      o
  },
  cleanExposedTexNodeInSelectionBlock: function(e) {
    var t, n, r, o, a = qme.getTextarea(e).$textArea, i = null == a ? void 0 : a[0].childNodes;
    if (i)
      try {
        for (var s = ege(Array.from(i)), l = s.next(); !l.done; l = s.next()) {
          var u = l.value;
          if (3 !== u.nodeType)
            break;
          u.remove()
        }
      } catch (v) {
        t = {
          error: v
        }
      } finally {
        try {
          l && !l.done && (n = s.return) && n.call(s)
        } finally {
          if (t)
            throw t.error
        }
      }
    var c = Yte.nodes(e, {
      match: function(t) {
        return !(!Hte.isElement(t) || e.isInline(t))
      },
      universal: !0
    });
    try {
      for (var d = ege(c), f = d.next(); !f.done; f = d.next()) {
        var p = f.value;
        if (null != p) {
          var h = p[0];
          jme(qme.toDOMNode(e, h), (function(e, t) {
              var n = Qre(t);
              n.attr("data-slate-string") || n.attr("data-slate-zero-width") || n.attr("data-w-e-reserve") || t.removeChild(e)
            }
          ))
        }
      }
    } catch (v) {
      r = {
        error: v
      }
    } finally {
      try {
        f && !f.done && (o = d.return) && o.call(d)
      } finally {
        if (r)
          throw r.error
      }
    }
  },
  isLastNode: function(e, t) {
    var n = e.children || [];
    return n[n.length - 1] === t
  },
  genEmptyParagraph: function() {
    return {
      type: "paragraph",
      children: [{
        text: ""
      }]
    }
  },
  isSelectedVoidNode: function(e) {
    var t, n, r = Yte.nodes(e, {
      match: function(t) {
        return e.isVoid(t)
      }
    }), o = 0;
    try {
      for (var a = ege(r), i = a.next(); !i.done; i = a.next())
        i.value,
          o++
    } catch (s) {
      t = {
        error: s
      }
    } finally {
      try {
        i && !i.done && (n = a.return) && n.call(a)
      } finally {
        if (t)
          throw t.error
      }
    }
    return o > 0
  },
  isSelectedEmptyParagraph: function(e) {
    var t = e.selection;
    if (null == t)
      return !1;
    if (fne.isExpanded(t))
      return !1;
    var n = qme.getSelectedNodeByType(e, "paragraph");
    if (null === n)
      return !1;
    var r = n.children;
    return 1 === r.length && ("" === r[0].text || void 0)
  },
  isEmptyPath: function(e, t) {
    var n = Yte.node(e, t);
    if (null == n)
      return !1;
    var r = tge(n, 1)[0].children;
    return 1 === r.length && "" === r[0].text
  }
}
  , Yme = 1
  , Xme = {}
  , Qme = {}
  , Jme = Efe.filter
  , Zme = eve("filter");
ape({
  target: "Array",
  proto: !0,
  forced: !Zme
}, {
  filter: function(e) {
    return Jme(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var eye = "\t\n\v\f\r                　\u2028\u2029\ufeff"
  , tye = hce("".replace)
  , nye = "[" + eye + "]"
  , rye = RegExp("^" + nye + nye + "*")
  , oye = RegExp(nye + nye + "*$")
  , aye = function(e) {
  return function(t) {
    var n = hpe(gce(t));
    return 1 & e && (n = tye(n, rye, "")),
    2 & e && (n = tye(n, oye, "")),
      n
  }
}
  , iye = {
  start: aye(1),
  end: aye(2),
  trim: aye(3)
}
  , sye = Mde.PROPER
  , lye = iye.trim;
ape({
  target: "String",
  proto: !0,
  forced: function(e) {
    return Ice((function() {
        return !!eye[e]() || "​᠎" !== "​᠎"[e]() || sye && eye[e].name !== e
      }
    ))
  }("trim")
}, {
  trim: function() {
    return lye(this)
  }
});
var uye = []
  , cye = {};
function dye(e, t, n) {
  var r = n.isInline(e) ? "span" : "div";
  return "<" + r + ">" + t + "</" + r + ">"
}
var fye, pye, hye, vye, gye = ace.Promise, mye = Vce("species"), yye = function(e) {
  var t = kce(e)
    , n = hde.f;
  Hce && t && !t[mye] && n(t, mye, {
    configurable: !0,
    get: function() {
      return this
    }
  })
}, bye = ace.TypeError, wye = Vce("species"), xye = function(e, t) {
  var n, r = Qce(e).constructor;
  return void 0 === r || null == (n = Qce(r)[wye]) ? t : function(e) {
    if (mfe(e))
      return e;
    throw bye(ode(e) + " is not a constructor")
  }(n)
}, Sye = hce([].slice), Eye = /(?:ipad|iphone|ipod).*applewebkit/i.test(Tce), Aye = "process" == $de(ace.process), Cye = ace.setImmediate, kye = ace.clearImmediate, Tye = ace.process, Dye = ace.Dispatch, Oye = ace.Function, _ye = ace.MessageChannel, Rye = ace.String, Lye = 0, Iye = {};
try {
  fye = ace.location
} catch (sbt) {}
var Pye = function(e) {
  if (wce(Iye, e)) {
    var t = Iye[e];
    delete Iye[e],
      t()
  }
}
  , Fye = function(e) {
  return function() {
    Pye(e)
  }
}
  , Bye = function(e) {
  Pye(e.data)
}
  , Nye = function(e) {
  ace.postMessage(Rye(e), fye.protocol + "//" + fye.host)
};
Cye && kye || (Cye = function(e) {
    var t = Sye(arguments, 1);
    return Iye[++Lye] = function() {
      Tve(Cce(e) ? e : Oye(e), void 0, t)
    }
      ,
      pye(Lye),
      Lye
  }
    ,
    kye = function(e) {
      delete Iye[e]
    }
    ,
    Aye ? pye = function(e) {
        Tye.nextTick(Fye(e))
      }
      : Dye && Dye.now ? pye = function(e) {
          Dye.now(Fye(e))
        }
        : _ye && !Eye ? (vye = (hye = new _ye).port2,
          hye.port1.onmessage = Bye,
          pye = Zde(vye.postMessage, vye)) : ace.addEventListener && Cce(ace.postMessage) && !ace.importScripts && fye && "file:" !== fye.protocol && !Ice(Nye) ? (pye = Nye,
          ace.addEventListener("message", Bye, !1)) : pye = "onreadystatechange"in Gce("script") ? function(e) {
            Ape.appendChild(Gce("script")).onreadystatechange = function() {
              Ape.removeChild(this),
                Pye(e)
            }
          }
          : function(e) {
            setTimeout(Fye(e), 0)
          }
);
var Mye, jye, Vye, Uye, $ye, Hye, zye, Kye, Wye = {
  set: Cye,
  clear: kye
}, Gye = /ipad|iphone|ipod/i.test(Tce) && void 0 !== ace.Pebble, qye = /web0s(?!.*chrome)/i.test(Tce), Yye = Ffe.f, Xye = Wye.set, Qye = ace.MutationObserver || ace.WebKitMutationObserver, Jye = ace.document, Zye = ace.process, ebe = ace.Promise, tbe = Yye(ace, "queueMicrotask"), nbe = tbe && tbe.value;
nbe || (Mye = function() {
  var e, t;
  for (Aye && (e = Zye.domain) && e.exit(); jye; ) {
    t = jye.fn,
      jye = jye.next;
    try {
      t()
    } catch (n) {
      throw jye ? Uye() : Vye = void 0,
        n
    }
  }
  Vye = void 0,
  e && e.enter()
}
  ,
  Eye || Aye || qye || !Qye || !Jye ? !Gye && ebe && ebe.resolve ? ((zye = ebe.resolve(void 0)).constructor = ebe,
      Kye = Zde(zye.then, zye),
      Uye = function() {
        Kye(Mye)
      }
  ) : Aye ? Uye = function() {
      Zye.nextTick(Mye)
    }
    : (Xye = Zde(Xye, ace),
        Uye = function() {
          Xye(Mye)
        }
    ) : ($ye = !0,
      Hye = Jye.createTextNode(""),
      new Qye(Mye).observe(Hye, {
        characterData: !0
      }),
      Uye = function() {
        Hye.data = $ye = !$ye
      }
  ));
var rbe, obe, abe, ibe, sbe = nbe || function(e) {
  var t = {
    fn: e,
    next: void 0
  };
  Vye && (Vye.next = t),
  jye || (jye = t,
    Uye()),
    Vye = t
}
  , lbe = function(e) {
  var t, n;
  this.promise = new e((function(e, r) {
      if (void 0 !== t || void 0 !== n)
        throw TypeError("Bad Promise constructor");
      t = e,
        n = r
    }
  )),
    this.resolve = ide(t),
    this.reject = ide(n)
}, ube = {
  f: function(e) {
    return new lbe(e)
  }
}, cbe = function(e) {
  try {
    return {
      error: !1,
      value: e()
    }
  } catch (t) {
    return {
      error: !0,
      value: t
    }
  }
}, dbe = "object" == typeof window, fbe = Wye.set, pbe = Vce("species"), hbe = "Promise", vbe = Pde.getterFor(hbe), gbe = Pde.set, mbe = Pde.getterFor(hbe), ybe = gye && gye.prototype, bbe = gye, wbe = ybe, xbe = ace.TypeError, Sbe = ace.document, Ebe = ace.process, Abe = ube.f, Cbe = Abe, kbe = !!(Sbe && Sbe.createEvent && ace.dispatchEvent), Tbe = Cce(ace.PromiseRejectionEvent), Dbe = !1, Obe = rpe(hbe, (function() {
    var e = xde(bbe)
      , t = e !== String(bbe);
    if (!t && 66 === Lce)
      return !0;
    if (Lce >= 51 && /native code/.test(e))
      return !1;
    var n = new bbe((function(e) {
        e(1)
      }
    ))
      , r = function(e) {
      e((function() {}
      ), (function() {}
      ))
    };
    return (n.constructor = {})[pbe] = r,
    !(Dbe = n.then((function() {}
    ))instanceof r) || !t && dbe && !Tbe
  }
)), _be = Obe || !ihe((function(e) {
    bbe.all(e).catch((function() {}
    ))
  }
)), Rbe = function(e) {
  var t;
  return !(!zce(e) || !Cce(t = e.then)) && t
}, Lbe = function(e, t) {
  if (!e.notified) {
    e.notified = !0;
    var n = e.reactions;
    sbe((function() {
        for (var r = e.value, o = 1 == e.state, a = 0; n.length > a; ) {
          var i, s, l, u = n[a++], c = o ? u.ok : u.fail, d = u.resolve, f = u.reject, p = u.domain;
          try {
            c ? (o || (2 === e.rejection && Bbe(e),
              e.rejection = 1),
              !0 === c ? i = r : (p && p.enter(),
                i = c(r),
              p && (p.exit(),
                l = !0)),
              i === u.promise ? f(xbe("Promise-chain cycle")) : (s = Rbe(i)) ? Zce(s, i, d, f) : d(i)) : f(r)
          } catch (h) {
            p && !l && p.exit(),
              f(h)
          }
        }
        e.reactions = [],
          e.notified = !1,
        t && !e.rejection && Pbe(e)
      }
    ))
  }
}, Ibe = function(e, t, n) {
  var r, o;
  kbe ? ((r = Sbe.createEvent("Event")).promise = t,
    r.reason = n,
    r.initEvent(e, !1, !0),
    ace.dispatchEvent(r)) : r = {
    promise: t,
    reason: n
  },
    !Tbe && (o = ace["on" + e]) ? o(r) : "unhandledrejection" === e && function(e, t) {
      var n = ace.console;
      n && n.error && (1 == arguments.length ? n.error(e) : n.error(e, t))
    }("Unhandled promise rejection", n)
}, Pbe = function(e) {
  Zce(fbe, ace, (function() {
      var t, n = e.facade, r = e.value;
      if (Fbe(e) && (t = cbe((function() {
          Aye ? Ebe.emit("unhandledRejection", r, n) : Ibe("unhandledrejection", n, r)
        }
      )),
        e.rejection = Aye || Fbe(e) ? 2 : 1,
        t.error))
        throw t.value
    }
  ))
}, Fbe = function(e) {
  return 1 !== e.rejection && !e.parent
}, Bbe = function(e) {
  Zce(fbe, ace, (function() {
      var t = e.facade;
      Aye ? Ebe.emit("rejectionHandled", t) : Ibe("rejectionhandled", t, e.value)
    }
  ))
}, Nbe = function(e, t, n) {
  return function(r) {
    e(t, r, n)
  }
}, Mbe = function(e, t, n) {
  e.done || (e.done = !0,
  n && (e = n),
    e.value = t,
    e.state = 2,
    Lbe(e, !0))
}, jbe = function(e, t, n) {
  if (!e.done) {
    e.done = !0,
    n && (e = n);
    try {
      if (e.facade === t)
        throw xbe("Promise can't be resolved itself");
      var r = Rbe(t);
      r ? sbe((function() {
          var n = {
            done: !1
          };
          try {
            Zce(r, t, Nbe(jbe, n, e), Nbe(Mbe, n, e))
          } catch (o) {
            Mbe(n, o, e)
          }
        }
      )) : (e.value = t,
        e.state = 1,
        Lbe(e, !1))
    } catch (o) {
      Mbe({
        done: !1
      }, o, e)
    }
  }
};
if (Obe && (wbe = (bbe = function(e) {
    Cge(this, wbe),
      ide(e),
      Zce(rbe, this);
    var t = vbe(this);
    try {
      e(Nbe(jbe, t), Nbe(Mbe, t))
    } catch (n) {
      Mbe(t, n)
    }
  }
).prototype,
  (rbe = function(e) {
      gbe(this, {
        type: hbe,
        done: !1,
        notified: !1,
        parent: !1,
        reactions: [],
        rejection: !1,
        state: 0,
        value: void 0
      })
    }
  ).prototype = lge(wbe, {
    then: function(e, t) {
      var n = mbe(this)
        , r = n.reactions
        , o = Abe(xye(this, bbe));
      return o.ok = !Cce(e) || e,
        o.fail = Cce(t) && t,
        o.domain = Aye ? Ebe.domain : void 0,
        n.parent = !0,
        r[r.length] = o,
      0 != n.state && Lbe(n, !1),
        o.promise
    },
    catch: function(e) {
      return this.then(void 0, e)
    }
  }),
  obe = function() {
    var e = new rbe
      , t = vbe(e);
    this.promise = e,
      this.resolve = Nbe(jbe, t),
      this.reject = Nbe(Mbe, t)
  }
  ,
  ube.f = Abe = function(e) {
    return e === bbe || e === abe ? new obe(e) : Cbe(e)
  }
  ,
Cce(gye) && ybe !== Object.prototype)) {
  ibe = ybe.then,
  Dbe || (jde(ybe, "then", (function(e, t) {
      var n = this;
      return new bbe((function(e, t) {
          Zce(ibe, n, e, t)
        }
      )).then(e, t)
    }
  ), {
    unsafe: !0
  }),
    jde(ybe, "catch", wbe.catch, {
      unsafe: !0
    }));
  try {
    delete ybe.constructor
  } catch (sbt) {}
  Lhe && Lhe(ybe, wbe)
}
ape({
  global: !0,
  wrap: !0,
  forced: Obe
}, {
  Promise: bbe
}),
  The(bbe, hbe, !1),
  yye(hbe),
  abe = kce(hbe),
  ape({
    target: hbe,
    stat: !0,
    forced: Obe
  }, {
    reject: function(e) {
      var t = Abe(this);
      return Zce(t.reject, void 0, e),
        t.promise
    }
  }),
  ape({
    target: hbe,
    stat: !0,
    forced: Obe
  }, {
    resolve: function(e) {
      return function(e, t) {
        if (Qce(e),
        zce(t) && t.constructor === e)
          return t;
        var n = ube.f(e);
        return (0,
          n.resolve)(t),
          n.promise
      }(this, e)
    }
  }),
  ape({
    target: hbe,
    stat: !0,
    forced: _be
  }, {
    all: function(e) {
      var t = this
        , n = Abe(t)
        , r = n.resolve
        , o = n.reject
        , a = cbe((function() {
          var n = ide(t.resolve)
            , a = []
            , i = 0
            , s = 1;
          Ege(e, (function(e) {
              var l = i++
                , u = !1;
              s++,
                Zce(n, t, e).then((function(e) {
                    u || (u = !0,
                      a[l] = e,
                    --s || r(a))
                  }
                ), o)
            }
          )),
          --s || r(a)
        }
      ));
      return a.error && o(a.value),
        n.promise
    },
    race: function(e) {
      var t = this
        , n = Abe(t)
        , r = n.reject
        , o = cbe((function() {
          var o = ide(t.resolve);
          Ege(e, (function(e) {
              Zce(o, t, e).then(n.resolve, r)
            }
          ))
        }
      ));
      return o.error && r(o.value),
        n.promise
    }
  });
var Vbe = ive.UNSUPPORTED_Y
  , Ube = Math.min
  , $be = [].push
  , Hbe = hce(/./.exec)
  , zbe = hce($be)
  , Kbe = hce("".slice);
function Wbe(e) {
  Promise.resolve().then(e)
}
function Gbe(e, t) {
  return Hte.isElement(e) ? function(e, t) {
    var n = e.type
      , r = void 0 === n ? "" : n
      , o = e.children
      , a = void 0 === o ? [] : o
      , i = Yte.isVoid(t, e)
      , s = "";
    i || (s = a.map((function(e) {
        return Gbe(e, t)
      }
    )).join(""));
    var l = (cye[r] || dye)(e, s, t)
      , u = "";
    if (u = "string" == typeof l ? l : l.html || "",
    i || uye.forEach((function(t) {
        return u = t(e, u)
      }
    )),
    "string" == typeof l)
      return u;
    var c = l.prefix
      , d = void 0 === c ? "" : c
      , f = l.suffix
      , p = void 0 === f ? "" : f;
    return d && (u = d + u),
    p && (u += p),
      u
  }(e, t) : function(e, t) {
    var n = e.text;
    if (null == n)
      throw new Error("Current node is not slate Text " + JSON.stringify(e));
    var r = n;
    r = r.replace(/ {2}/g, " &nbsp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/®/g, "&reg;").replace(/©/g, "&copy;").replace(/™/g, "&trade;");
    var o = qme.getParentsNodes(t, e).some((function(e) {
        return "pre" === qme.getNodeType(e)
      }
    ));
    if (o || (r = r.replace(/\r\n|\r|\n/g, "<br>")),
    o && (r = r.replace(/&nbsp;/g, " ")),
    "" === r) {
      var a = qme.getParentNode(null, e);
      if (!a || 0 !== a.children.length)
        return r;
      r = "<br>"
    }
    return uye.forEach((function(t) {
        return r = t(e, r)
      }
    )),
      r
  }(e, t)
}
function qbe(e) {
  return "w-e-element-" + e
}
_ve("split", (function(e, t, n) {
    var r;
    return r = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e, n) {
        var r = hpe(gce(this))
          , o = void 0 === n ? 4294967295 : n >>> 0;
        if (0 === o)
          return [];
        if (void 0 === e)
          return [r];
        if (!Bpe(e))
          return Zce(t, r, e, o);
        for (var a, i, s, l = [], u = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), c = 0, d = new RegExp(e.source,u + "g"); (a = Zce(Sve, d, r)) && !((i = d.lastIndex) > c && (zbe(l, Kbe(r, c, a.index)),
        a.length > 1 && a.index < r.length && Tve($be, l, dge(a, 1)),
          s = a[0].length,
          c = i,
        l.length >= o)); )
          d.lastIndex === a.index && d.lastIndex++;
        return c === r.length ? !s && Hbe(d, "") || zbe(l, "") : zbe(l, Kbe(r, c)),
          l.length > o ? dge(l, 0, o) : l
      }
      : "0".split(void 0, 0).length ? function(e, n) {
          return void 0 === e && 0 === n ? [] : Zce(t, this, e, n)
        }
        : t,
      [function(t, n) {
        var o = gce(this)
          , a = null == t ? void 0 : sde(t, e);
        return a ? Zce(a, t, o, n) : Zce(r, hpe(o), t, n)
      }
        , function(e, o) {
        var a = Qce(this)
          , i = hpe(e)
          , s = n(r, a, i, o, r !== t);
        if (s.done)
          return s.value;
        var l = xye(a, RegExp)
          , u = a.unicode
          , c = (a.ignoreCase ? "i" : "") + (a.multiline ? "m" : "") + (a.unicode ? "u" : "") + (Vbe ? "g" : "y")
          , d = new l(Vbe ? "^(?:" + a.source + ")" : a,c)
          , f = void 0 === o ? 4294967295 : o >>> 0;
        if (0 === f)
          return [];
        if (0 === i.length)
          return null === Uve(d, i) ? [i] : [];
        for (var p = 0, h = 0, v = []; h < i.length; ) {
          d.lastIndex = Vbe ? 0 : h;
          var g, m = Uve(d, Vbe ? Kbe(i, h) : i);
          if (null === m || (g = Ube(sfe(d.lastIndex + (Vbe ? h : 0)), i.length)) === p)
            h = Lve(i, h, u);
          else {
            if (zbe(v, Kbe(i, p, h)),
            v.length === f)
              return v;
            for (var y = 1; y <= m.length - 1; y++)
              if (zbe(v, m[y]),
              v.length === f)
                return v;
            h = p = g
          }
        }
        return zbe(v, Kbe(i, p)),
          v
      }
      ]
  }
), !!Ice((function() {
    var e = /(?:)/
      , t = e.exec;
    e.exec = function() {
      return t.apply(this, arguments)
    }
    ;
    var n = "ab".split(e);
    return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
  }
)), Vbe);
var Ybe = function(e, t) {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n
}
  , Xbe = function(e, t, n) {
  var r = qme.toDOMRange(e, t).getBoundingClientRect()
    , o = qme.toDOMRange(e, n).getBoundingClientRect();
  return Ybe(r, o) && Ybe(o, r)
}
  , Qbe = ["span", "b", "strong", "i", "em", "s", "strike", "u", "font", "sub", "sup"]
  , Jbe = []
  , Zbe = []
  , ewe = {}
  , twe = hde.f
  , nwe = Wfe.f
  , rwe = Pde.enforce
  , owe = Vce("match")
  , awe = ace.RegExp
  , iwe = awe.prototype
  , swe = ace.SyntaxError
  , lwe = hce(vpe)
  , uwe = hce(iwe.exec)
  , cwe = hce("".charAt)
  , dwe = hce("".replace)
  , fwe = hce("".indexOf)
  , pwe = hce("".slice)
  , hwe = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/
  , vwe = /a/g
  , gwe = /a/g
  , mwe = new awe(vwe) !== vwe
  , ywe = ive.MISSED_STICKY
  , bwe = ive.UNSUPPORTED_Y
  , wwe = Hce && (!mwe || ywe || lve || cve || Ice((function() {
    return gwe[owe] = !1,
    awe(vwe) != vwe || awe(gwe) == gwe || "/a/i" != awe(vwe, "i")
  }
)));
if (rpe("RegExp", wwe)) {
  for (var xwe = function(e, t) {
    var n, r, o, a, i, s, l = ede(iwe, this), u = Bpe(e), c = void 0 === t, d = [], f = e;
    if (!l && u && c && e.constructor === xwe)
      return e;
    if ((u || ede(iwe, e)) && (e = e.source,
    c && (t = "flags"in f ? f.flags : lwe(f))),
      e = void 0 === e ? "" : hpe(e),
      t = void 0 === t ? "" : hpe(t),
      f = e,
    lve && "dotAll"in vwe && (r = !!t && fwe(t, "s") > -1) && (t = dwe(t, /s/g, "")),
      n = t,
    ywe && "sticky"in vwe && (o = !!t && fwe(t, "y") > -1) && bwe && (t = dwe(t, /y/g, "")),
    cve && (e = (a = function(e) {
      for (var t, n = e.length, r = 0, o = "", a = [], i = {}, s = !1, l = !1, u = 0, c = ""; r <= n; r++) {
        if ("\\" === (t = cwe(e, r)))
          t += cwe(e, ++r);
        else if ("]" === t)
          s = !1;
        else if (!s)
          switch (!0) {
            case "[" === t:
              s = !0;
              break;
            case "(" === t:
              uwe(hwe, pwe(e, r + 1)) && (r += 2,
                l = !0),
                o += t,
                u++;
              continue;
            case ">" === t && l:
              if ("" === c || wce(i, c))
                throw new swe("Invalid capture group name");
              i[c] = !0,
                a[a.length] = [c, u],
                l = !1,
                c = "";
              continue
          }
        l ? c += t : o += t
      }
      return [o, a]
    }(e))[0],
      d = a[1]),
      i = kge(awe(e, t), l ? this : iwe, xwe),
    (r || o || d.length) && (s = rwe(i),
    r && (s.dotAll = !0,
      s.raw = xwe(function(e) {
        for (var t, n = e.length, r = 0, o = "", a = !1; r <= n; r++)
          "\\" !== (t = cwe(e, r)) ? a || "." !== t ? ("[" === t ? a = !0 : "]" === t && (a = !1),
            o += t) : o += "[\\s\\S]" : o += t + cwe(e, ++r);
        return o
      }(e), n)),
    o && (s.sticky = !0),
    d.length && (s.groups = d)),
    e !== f)
      try {
        gde(i, "source", "" === f ? "(?:)" : f)
      } catch (p) {}
    return i
  }, Swe = function(e) {
    e in xwe || twe(xwe, e, {
      configurable: !0,
      get: function() {
        return awe[e]
      },
      set: function(t) {
        awe[e] = t
      }
    })
  }, Ewe = nwe(awe), Awe = 0; Ewe.length > Awe; )
    Swe(Ewe[Awe++]);
  iwe.constructor = xwe,
    xwe.prototype = iwe,
    jde(ace, "RegExp", xwe)
}
yye("RegExp");
var Cwe = new RegExp(String.fromCharCode(160),"g");
function kwe(e) {
  return e.replace(Cwe, " ")
}
function Twe(e, t) {
  var n = e.length;
  if (n) {
    var r = e[n - 1];
    if (bne.isText(r)) {
      var o = Object.keys(r);
      if (1 === o.length && "text" === o[0])
        return r.text = r.text + t,
          !0
    }
  }
  return !1
}
function Dwe(e, t, n) {
  return {
    type: "paragraph",
    children: [{
      text: Qre(e).text().replace(/\s+/gm, " ")
    }]
  }
}
function Owe(e, t) {
  var n = function(e, t) {
    var n = [];
    if (null != e.attr("data-w-e-is-void"))
      return n;
    var r = e[0].childNodes;
    return 1 === r.length && "BR" === r[0].nodeName ? (n.push({
      text: ""
    }),
      n) : (r.forEach((function(e) {
        if (e.nodeType !== Dme.ELEMENT_NODE)
          if (e.nodeType !== Dme.TEXT_NODE)
            ;
          else {
            var r = e.textContent || "";
            if ("" === r.trim() && r.indexOf("\n") >= 0)
              return;
            r && (r = kwe(r),
            Twe(n, r) || n.push({
              text: r
            }))
          }
        else {
          if ("BR" === e.nodeName)
            return void (Twe(n, "\n") || n.push({
              text: "\n"
            }));
          var o = Rwe(Qre(e), t);
          Array.isArray(o) ? o.forEach((function(e) {
              return n.push(e)
            }
          )) : n.push(o)
        }
      }
    )),
      n)
  }(e, t)
    , r = function(e) {
    for (var t in ewe)
      if (e[0].matches(t))
        return ewe[t];
    return Dwe
  }(e)(e[0], n, t);
  return Array.isArray(r) || (r = [r]),
    r.forEach((function(r) {
        Yte.isVoid(t, r) || (0 === n.length && (r.children = [{
          text: e.text().replace(/\s+/gm, " ")
        }]),
          Zbe.forEach((function(n) {
              r = n(e[0], r, t)
            }
          )))
      }
    )),
    r
}
function _we(e, t) {
  0 === e.parents("pre").length && (e[0].innerHTML = e[0].innerHTML.replace(/\s+/gm, " ").replace(/<br>/g, "\n"));
  var n = e[0].textContent || ""
    , r = {
    text: n = kwe(n = n.replace(/&nbsp;/g, " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&reg;/g, "®").replace(/&copy;/g, "©").replace(/&trade;/g, "™").replace(/&quot;/g, '"'))
  };
  return Zbe.forEach((function(n) {
      r = n(e[0], r, t)
    }
  )),
    r
}
function Rwe(e, t) {
  Jbe.forEach((function(t) {
      var n = t.selector
        , r = t.preParseHtml;
      e[0].matches(n) && (e = Qre(r(e[0])))
    }
  ));
  var n = Vme(e);
  return "span" === n ? e.attr("data-w-e-type") ? Owe(e, t) : _we(e, t) : "code" === n ? "pre" === Vme(e.parent()) ? Owe(e, t) : _we(e, t) : Qbe.includes(n) ? _we(e, t) : Owe(e, t)
}
function Lwe(e, t) {
  void 0 === t && (t = "");
  var n = [];
  "" === t && (t = "<p><br></p>"),
  0 !== t.indexOf("<") && (t = t.split(/\n/).map((function(e) {
      return "<p>" + e + "</p>"
    }
  )).join(""));
  var r = Qre("<div>" + t + "</div>");
  return Array.from(r.children()).forEach((function(t) {
      var r = Rwe(Qre(t), e);
      Array.isArray(r) ? r.forEach((function(e) {
          return n.push(e)
        }
      )) : n.push(r)
    }
  )),
    n
}
var Iwe = hde.f
  , Pwe = bge.fastKey
  , Fwe = Pde.set
  , Bwe = Pde.getterFor
  , Nwe = {
  getConstructor: function(e, t, n, r) {
    var o = e((function(e, o) {
        Cge(e, a),
          Fwe(e, {
            type: t,
            index: _pe(null),
            first: void 0,
            last: void 0,
            size: 0
          }),
        Hce || (e.size = 0),
        null != o && Ege(o, e[r], {
          that: e,
          AS_ENTRIES: n
        })
      }
    ))
      , a = o.prototype
      , i = Bwe(t)
      , s = function(e, t, n) {
      var r, o, a = i(e), s = l(e, t);
      return s ? s.value = n : (a.last = s = {
        index: o = Pwe(t, !0),
        key: t,
        value: n,
        previous: r = a.last,
        next: void 0,
        removed: !1
      },
      a.first || (a.first = s),
      r && (r.next = s),
        Hce ? a.size++ : e.size++,
      "F" !== o && (a.index[o] = s)),
        e
    }
      , l = function(e, t) {
      var n, r = i(e), o = Pwe(t);
      if ("F" !== o)
        return r.index[o];
      for (n = r.first; n; n = n.next)
        if (n.key == t)
          return n
    };
    return lge(a, {
      clear: function() {
        for (var e = i(this), t = e.index, n = e.first; n; )
          n.removed = !0,
          n.previous && (n.previous = n.previous.next = void 0),
            delete t[n.index],
            n = n.next;
        e.first = e.last = void 0,
          Hce ? e.size = 0 : this.size = 0
      },
      delete: function(e) {
        var t = this
          , n = i(t)
          , r = l(t, e);
        if (r) {
          var o = r.next
            , a = r.previous;
          delete n.index[r.index],
            r.removed = !0,
          a && (a.next = o),
          o && (o.previous = a),
          n.first == r && (n.first = o),
          n.last == r && (n.last = a),
            Hce ? n.size-- : t.size--
        }
        return !!r
      },
      forEach: function(e) {
        for (var t, n = i(this), r = Zde(e, arguments.length > 1 ? arguments[1] : void 0); t = t ? t.next : n.first; )
          for (r(t.value, t.key, this); t && t.removed; )
            t = t.previous
      },
      has: function(e) {
        return !!l(this, e)
      }
    }),
      lge(a, n ? {
        get: function(e) {
          var t = l(this, e);
          return t && t.value
        },
        set: function(e, t) {
          return s(this, 0 === e ? 0 : e, t)
        }
      } : {
        add: function(e) {
          return s(this, e = 0 === e ? 0 : e, e)
        }
      }),
    Hce && Iwe(a, "size", {
      get: function() {
        return i(this).size
      }
    }),
      o
  },
  setStrong: function(e, t, n) {
    var r = t + " Iterator"
      , o = Bwe(t)
      , a = Bwe(r);
    jhe(e, t, (function(e, t) {
        Fwe(this, {
          type: r,
          target: e,
          state: o(e),
          kind: t,
          last: void 0
        })
      }
    ), (function() {
        for (var e = a(this), t = e.kind, n = e.last; n && n.removed; )
          n = n.previous;
        return e.target && (e.last = n = n ? n.next : e.state.first) ? "keys" == t ? {
          value: n.key,
          done: !1
        } : "values" == t ? {
          value: n.value,
          done: !1
        } : {
          value: [n.key, n.value],
          done: !1
        } : (e.target = void 0,
          {
            value: void 0,
            done: !0
          })
      }
    ), n ? "entries" : "values", !n, !0),
      yye(t)
  }
};
Tge("Set", (function(e) {
    return function() {
      return e(this, arguments.length ? arguments[0] : void 0)
    }
  }
), Nwe);
var Mwe = new Set(["doctype", "!doctype", "meta", "script", "style", "link", "frame", "iframe", "title", "svg"]);
function jwe(e, t) {
  e.isInline(t) ? (e.insertNode(t),
  "link" === t.type && e.insertFragment([{
    text: ""
  }])) : Nne.insertNodes(e, t, {
    mode: "highest"
  })
}
var Vwe = function(e) {
  var t = e
    , n = t.insertText;
  return t.insertFragment,
    t.setFragmentData = function(e) {
      var n = t.selection;
      if (n) {
        var r = tge(fne.edges(n), 2)
          , o = r[0]
          , a = r[1]
          , i = Yte.void(t, {
          at: o.path
        })
          , s = Yte.void(t, {
          at: a.path
        });
        if (!fne.isCollapsed(n) || i) {
          var l = qme.toDOMRange(t, n)
            , u = l.cloneContents()
            , c = u.childNodes[0];
          if (u.childNodes.forEach((function(e) {
              e.textContent && "" !== e.textContent.trim() && (c = e)
            }
          )),
            s) {
            var d = tge(s, 1)[0]
              , f = l.cloneRange()
              , p = qme.toDOMNode(t, d);
            f.setEndAfter(p),
              u = f.cloneContents()
          }
          if (i && (c = u.querySelector("[data-slate-spacer]")),
            Array.from(u.querySelectorAll("[data-slate-zero-width]")).forEach((function(e) {
                var t = "n" === e.getAttribute("data-slate-zero-width");
                e.textContent = t ? "\n" : ""
              }
            )),
            Pme(c)) {
            var h = c.ownerDocument.createElement("span");
            h.style.whiteSpace = "pre",
              h.appendChild(c),
              u.appendChild(h),
              c = h
          }
          var v = t.getFragment()
            , g = JSON.stringify(v)
            , m = window.btoa(encodeURIComponent(g));
          c.setAttribute("data-slate-fragment", m),
            e.setData("application/x-slate-fragment", m);
          var y = u.ownerDocument.createElement("div");
          return y.appendChild(u),
            y.setAttribute("hidden", "true"),
            u.ownerDocument.body.appendChild(y),
            e.setData("text/html", y.innerHTML),
            e.setData("text/plain", Mme(y)),
            u.ownerDocument.body.removeChild(y),
            e
        }
      }
    }
    ,
    t.insertData = function(e) {
      var r, o, a = e.getData("application/x-slate-fragment");
      if (a) {
        var i = decodeURIComponent(window.atob(a))
          , s = JSON.parse(i);
        t.insertFragment(s)
      } else {
        var l = e.getData("text/plain")
          , u = e.getData("text/html");
        if (u)
          t.dangerouslyInsertHtml(u);
        else if (l) {
          var c = l.split(/\r\n|\r|\n/)
            , d = !1;
          try {
            for (var f = ege(c), p = f.next(); !p.done; p = f.next()) {
              var h = p.value;
              d && Nne.splitNodes(t, {
                always: !0
              }),
                n(h),
                d = !0
            }
          } catch (v) {
            r = {
              error: v
            }
          } finally {
            try {
              p && !p.done && (o = f.return) && o.call(f)
            } finally {
              if (r)
                throw r.error
            }
          }
        }
      }
    }
    ,
    t
}
  , Uwe = function(e) {
  return null != e
}
  , $we = {
  object: !0,
  function: !0,
  undefined: !0
}
  , Hwe = /^\s*class[\s{/}]/
  , zwe = Function.prototype.toString
  , Kwe = function(e) {
  return !!function(e) {
    if ("function" != typeof e)
      return !1;
    if (!hasOwnProperty.call(e, "length"))
      return !1;
    try {
      if ("number" != typeof e.length)
        return !1;
      if ("function" != typeof e.call)
        return !1;
      if ("function" != typeof e.apply)
        return !1
    } catch (t) {
      return !1
    }
    return !function(e) {
      if (!Uwe(t = e) || !hasOwnProperty.call($we, typeof t))
        return !1;
      var t;
      try {
        return !!e.constructor && e.constructor.prototype === e
      } catch (t) {
        return !1
      }
    }(e)
  }(e) && !Hwe.test(zwe.call(e))
}
  , Wwe = function(e) {
  return null != e
}
  , Gwe = Object.keys
  , qwe = function() {
  try {
    return Object.keys("primitive"),
      !0
  } catch (Y_) {
    return !1
  }
}() ? Object.keys : function(e) {
  return Gwe(Wwe(e) ? Object(e) : e)
}
  , Ywe = Math.max
  , Xwe = function() {
  var e, t = Object.assign;
  return "function" == typeof t && (t(e = {
    foo: "raz"
  }, {
    bar: "dwa"
  }, {
    trzy: "trzy"
  }),
  e.foo + e.bar + e.trzy === "razdwatrzy")
}() ? Object.assign : function(e, t) {
  var n, r, o, a = Ywe(arguments.length, 2);
  for (e = Object(function(e) {
    if (!Wwe(e))
      throw new TypeError("Cannot use null or undefined");
    return e
  }(e)),
         o = function(r) {
           try {
             e[r] = t[r]
           } catch (o) {
             n || (n = o)
           }
         }
         ,
         r = 1; r < a; ++r)
    qwe(t = arguments[r]).forEach(o);
  if (void 0 !== n)
    throw n;
  return e
}
  , Qwe = Array.prototype.forEach
  , Jwe = Object.create
  , Zwe = function(e) {
  var t = Jwe(null);
  return Qwe.call(arguments, (function(e) {
      Wwe(e) && function(e, t) {
        var n;
        for (n in e)
          t[n] = e[n]
      }(Object(e), t)
    }
  )),
    t
}
  , exe = "razdwatrzy"
  , txe = String.prototype.indexOf
  , nxe = "function" == typeof exe.contains && !0 === exe.contains("dwa") && !1 === exe.contains("foo") ? String.prototype.contains : function(e) {
  return txe.call(this, e, arguments[1]) > -1
}
  , rxe = tce((function(e) {
    var t = e.exports = function(e, t) {
        var n, r, o, a, i;
        return arguments.length < 2 || "string" != typeof e ? (a = t,
          t = e,
          e = null) : a = arguments[2],
          Uwe(e) ? (n = nxe.call(e, "c"),
            r = nxe.call(e, "e"),
            o = nxe.call(e, "w")) : (n = o = !0,
            r = !1),
          i = {
            value: t,
            configurable: n,
            enumerable: r,
            writable: o
          },
          a ? Xwe(Zwe(a), i) : i
      }
    ;
    t.gs = function(e, t, n) {
      var r, o, a, i;
      return "string" != typeof e ? (a = n,
        n = t,
        t = e,
        e = null) : a = arguments[3],
        Uwe(t) ? Kwe(t) ? Uwe(n) ? Kwe(n) || (a = n,
          n = void 0) : n = void 0 : (a = t,
          t = n = void 0) : t = void 0,
        Uwe(e) ? (r = nxe.call(e, "c"),
          o = nxe.call(e, "e")) : (r = !0,
          o = !1),
        i = {
          get: t,
          set: n,
          configurable: r,
          enumerable: o
        },
        a ? Xwe(Zwe(a), i) : i
    }
  }
))
  , oxe = function(e) {
  if ("function" != typeof e)
    throw new TypeError(e + " is not a function");
  return e
}
  , axe = tce((function(e, t) {
    var n, r, o, a, i, s, l, u = Function.prototype.apply, c = Function.prototype.call, d = Object.create, f = Object.defineProperty, p = Object.defineProperties, h = Object.prototype.hasOwnProperty, v = {
      configurable: !0,
      enumerable: !1,
      writable: !0
    };
    r = function(e, t) {
      var r, a;
      return oxe(t),
        a = this,
        n.call(this, e, r = function() {
            o.call(a, e, r),
              u.call(t, this, arguments)
          }
        ),
        r.__eeOnceListener__ = t,
        this
    }
      ,
      a = function(e) {
        var t, n, r, o, a;
        if (h.call(this, "__ee__") && (o = this.__ee__[e]))
          if ("object" == typeof o) {
            for (n = arguments.length,
                   a = new Array(n - 1),
                   t = 1; t < n; ++t)
              a[t - 1] = arguments[t];
            for (o = o.slice(),
                   t = 0; r = o[t]; ++t)
              u.call(r, this, a)
          } else
            switch (arguments.length) {
              case 1:
                c.call(o, this);
                break;
              case 2:
                c.call(o, this, arguments[1]);
                break;
              case 3:
                c.call(o, this, arguments[1], arguments[2]);
                break;
              default:
                for (n = arguments.length,
                       a = new Array(n - 1),
                       t = 1; t < n; ++t)
                  a[t - 1] = arguments[t];
                u.call(o, this, a)
            }
      }
      ,
      i = {
        on: n = function(e, t) {
          var n;
          return oxe(t),
            h.call(this, "__ee__") ? n = this.__ee__ : (n = v.value = d(null),
              f(this, "__ee__", v),
              v.value = null),
            n[e] ? "object" == typeof n[e] ? n[e].push(t) : n[e] = [n[e], t] : n[e] = t,
            this
        }
        ,
        once: r,
        off: o = function(e, t) {
          var n, r, o, a;
          if (oxe(t),
            !h.call(this, "__ee__"))
            return this;
          if (!(n = this.__ee__)[e])
            return this;
          if ("object" == typeof (r = n[e]))
            for (a = 0; o = r[a]; ++a)
              o !== t && o.__eeOnceListener__ !== t || (2 === r.length ? n[e] = r[a ? 0 : 1] : r.splice(a, 1));
          else
            r !== t && r.__eeOnceListener__ !== t || delete n[e];
          return this
        }
        ,
        emit: a
      },
      s = {
        on: rxe(n),
        once: rxe(r),
        off: rxe(o),
        emit: rxe(a)
      },
      l = p({}, s),
      e.exports = t = function(e) {
        return null == e ? d(l) : p(Object(e), s)
      }
      ,
      t.methods = i
  }
));
function ixe(e) {
  var t = Eme.get(e);
  return null == t && (t = axe(),
    Eme.set(e, t)),
    t
}
var sxe = new WeakMap;
function lxe(e, t) {
  var n = sxe.get(e);
  null == n && (n = new Set,
    sxe.set(e, n)),
    n.add(t)
}
function uxe(e) {
  var t = qme.getTextarea(e).$textAreaContainer
    , n = t.width()
    , r = t.height()
    , o = t.offset();
  return {
    top: o.top,
    left: o.left,
    width: n,
    height: r
  }
}
function cxe(e) {
  var t = {
    top: "0",
    left: "0"
  }
    , n = e.selection;
  if (null == n)
    return t;
  var r = uxe(e);
  if (null == r)
    return t;
  var o = r.top
    , a = r.left
    , i = r.width
    , s = r.height
    , l = qme.toDOMRange(e, n).getClientRects()[0];
  if (null == l)
    return t;
  l.width;
  var u = l.height
    , c = {}
    , d = l.top - o
    , f = l.left - a;
  if (f > i / 2) {
    var p = i - f;
    c.right = p + 5 + "px"
  } else
    c.left = f + 5 + "px";
  if (d > s / 2) {
    var h = s - d;
    c.bottom = h + 5 + "px"
  } else {
    var v = d + u;
    v < 0 && (v = 0),
      c.top = v + 5 + "px"
  }
  return c
}
function dxe(e, t, n) {
  void 0 === n && (n = "modal");
  var r = {
    top: "0",
    left: "0"
  };
  if (null == e.selection)
    return r;
  var o = Hte.isElement(t) && e.isVoid(t)
    , a = Hte.isElement(t) && e.isInline(t)
    , i = yme.get(t);
  if (null == i)
    return r;
  var s = i.getBoundingClientRect()
    , l = s.top
    , u = s.left
    , c = s.height
    , d = s.width;
  if (o) {
    var f = function(e) {
      var t = [];
      t.push(e);
      for (var n = 0; t.length > 0; ) {
        var r = t.pop();
        if (null == r)
          break;
        if (++n > 1e4)
          break;
        var o = r.nodeName;
        if (1 === r.nodeType) {
          var a = o.toLowerCase();
          if (Tme.includes(a) || "iframe" === a || "video" === a)
            return r;
          var i = r.children || []
            , s = i.length;
          if (s)
            for (var l = s - 1; l >= 0; l--)
              t.push(i[l])
        }
      }
      return null
    }(i);
    if (null != f) {
      var p = f.getBoundingClientRect();
      l = p.top,
        c = p.height
    }
  }
  var h = uxe(e);
  if (null == h)
    return r;
  var v, g = h.top, m = h.left, y = h.width, b = h.height, w = {}, x = l - g, S = u - m;
  if ("bar" === n)
    return w.left = S + "px",
      x > 40 ? w.bottom = b - x + 5 + "px" : w.top = x + c + 5 + "px",
      w;
  if ("modal" === n)
    return o ? a ? S > (y - d) / 2 ? w.right = y - S + 5 + "px" : w.left = S + d + 5 + "px" : w.left = "20px" : w.left = S + "px",
      o ? ((v = x) < 0 && (v = 0),
        w.top = v + "px") : x > (b - c) / 2 ? w.bottom = b - x + 5 + "px" : ((v = x + c) < 0 && (v = 0),
        w.top = v + 5 + "px"),
      w;
  throw new Error("type '" + n + "' is invalid")
}
function fxe(e, t) {
  Wbe((function() {
      var n = uxe(e);
      if (null != n) {
        var r, o = n.top, a = n.left, i = n.width, s = n.height, l = t.offset(), u = l.top, c = l.left, d = t.width(), f = t.height(), p = u - o, h = c - a, v = t.attr("style");
        if (v.indexOf("top") >= 0 && (r = p + f - s) > 0) {
          var g = t.css("top")
            , m = parseInt(g.toString()) - r;
          m < 0 && (m = 0),
            t.css("top", m + "px")
        }
        if (v.indexOf("bottom") >= 0 && u < 0) {
          var y = t.css("bottom")
            , b = parseInt(y.toString()) - Math.abs(u);
          t.css("bottom", b + "px")
        }
        if (v.indexOf("left") >= 0 && (r = h + d - i) > 0) {
          var w = t.css("left")
            , x = parseInt(w.toString()) - r;
          x < 0 && (x = 0),
            t.css("left", x + "px")
        }
        if (v.indexOf("right") >= 0 && c < 0) {
          var S = t.css("right")
            , E = parseInt(S.toString()) - Math.abs(c);
          t.css("right", E + "px")
        }
      }
    }
  ))
}
var pxe = eve("slice")
  , hxe = Vce("species")
  , vxe = ace.Array
  , gxe = Math.max;
ape({
  target: "Array",
  proto: !0,
  forced: !pxe
}, {
  slice: function(e, t) {
    var n, r, o, a = Ife(this), i = lfe(a), s = Mfe(e, i), l = Mfe(void 0 === t ? i : t, i);
    if (ufe(a) && (n = a.constructor,
    (mfe(n) && (n === vxe || ufe(n.prototype)) || zce(n) && null === (n = n[hxe])) && (n = void 0),
    n === vxe || void 0 === n))
      return Sye(a, s, l);
    for (r = new (void 0 === n ? vxe : n)(gxe(l - s, 0)),
           o = 0; s < l; s++,
           o++)
      s in a && Xpe(r, o, a[s]);
    return r.length = o,
      r
  }
});
var mxe = Ffe.f
  , yxe = hce("".startsWith)
  , bxe = hce("".slice)
  , wxe = Math.min
  , xxe = Vpe("startsWith")
  , Sxe = !xxe && !!function() {
  var e = mxe(String.prototype, "startsWith");
  return e && !e.writable
}();
ape({
  target: "String",
  proto: !0,
  forced: !Sxe && !xxe
}, {
  startsWith: function(e) {
    var t = hpe(gce(this));
    Mpe(e);
    var n = sfe(wxe(arguments.length > 1 ? arguments[1] : void 0, t.length))
      , r = hpe(e);
    return yxe ? yxe(t, r, n) : bxe(t, n, n + r.length) === r
  }
});
var Exe = Object.assign
  , Axe = Object.defineProperty
  , Cxe = hce([].concat)
  , kxe = !Exe || Ice((function() {
    if (Hce && 1 !== Exe({
      b: 1
    }, Exe(Axe({}, "a", {
      enumerable: !0,
      get: function() {
        Axe(this, "b", {
          value: 3,
          enumerable: !1
        })
      }
    }), {
      b: 2
    })).b)
      return !0;
    var e = {}
      , t = {}
      , n = Symbol()
      , r = "abcdefghijklmnopqrst";
    return e[n] = 7,
      r.split("").forEach((function(e) {
          t[e] = e
        }
      )),
    7 != Exe({}, e)[n] || ipe(Exe({}, t)).join("") != r
  }
)) ? function(e, t) {
    for (var n = yce(e), r = arguments.length, o = 1, a = Gfe.f, i = Lfe.f; r > o; )
      for (var s, l = nfe(arguments[o++]), u = a ? Cxe(ipe(l), a(l)) : ipe(l), c = u.length, d = 0; c > d; )
        s = u[d++],
        Hce && !Zce(i, l, s) || (n[s] = l[s]);
    return n
  }
  : Exe;
ape({
  target: "Object",
  stat: !0,
  forced: Object.assign !== kxe
}, {
  assign: kxe
});
var Txe = ["props", "attrs", "style", "dataset", "on", "hook"];
function Dxe(e) {
  var t = e.data
    , n = void 0 === t ? {} : t
    , r = e.children
    , o = void 0 === r ? [] : r;
  Object.keys(n).forEach((function(t) {
      var r, o, a = n[t];
      if ("key" !== t) {
        if (!Txe.includes(t)) {
          if (t.startsWith("data-")) {
            var i = t.slice(5);
            return i = Die(i),
              function(e, t) {
                null == e.data && (e.data = {});
                var n = e.data;
                null == n.dataset && (n.dataset = {}),
                  Object.assign(n.dataset, t)
              }(e, ((r = {})[i] = a,
                r)),
              void delete n[t]
          }
          !function(e, t) {
            null == e.data && (e.data = {});
            var n = e.data;
            null == n.props && (n.props = {}),
              Object.assign(n.props, t)
          }(e, (o = {},
            o[t] = a,
            o)),
            delete n[t]
        }
      } else
        e.key = a
    }
  )),
  o.length > 0 && o.forEach((function(e) {
      "string" != typeof e && Dxe(e)
    }
  ))
}
var Oxe = []
  , _xe = {};
function Rxe(e, t, n) {
  return $ae(n.isInline(e) ? "span" : "div", null, t)
}
function Lxe(e, t) {
  return void 0 === t && (t = !1),
    $ae("span", {
      "data-slate-string": !0
    }, t ? e + "\n" : e)
}
function Ixe(e, t) {
  return void 0 === e && (e = 0),
  void 0 === t && (t = !1),
    $ae("span", {
      "data-slate-zero-width": t ? "n" : "z",
      "data-slate-length": e
    }, "\ufeff", t ? $ae("br", null) : null)
}
function Pxe(e, t, n, r) {
  return pme.set(e, t),
    hme.set(e, n),
    Hte.isElement(e) ? function(e, t) {
      var n, r = qme.findKey(t, e), o = t.isInline(e), a = Yte.isVoid(t, e), i = qbe(r.id), s = {
        id: i,
        key: r.id,
        "data-slate-node": "element",
        "data-slate-inline": o
      }, l = e.type, u = e.children, c = void 0 === u ? [] : u, d = _xe[l] || Rxe;
      n = a ? null : c.map((function(n, r) {
          return Pxe(n, r, e, t)
        }
      ));
      var f = d(e, n, t);
      if (a) {
        s["data-slate-void"] = !0;
        var p = o ? "span" : "div"
          , h = tge(ene.texts(e), 1)
          , v = tge(h[0], 1)[0]
          , g = $ae(p, {
          "data-slate-spacer": !0,
          style: {
            height: "0",
            color: "transparent",
            outline: "none",
            position: "absolute"
          }
        }, Pxe(v, 0, e, t));
        f = $ae(p, {
          style: {
            position: "relative"
          }
        }, f, g),
          pme.set(v, 0),
          hme.set(v, e)
      }
      return null == f.data && (f.data = {}),
        Object.assign(f.data, s),
      a || o || (f = function(e, t) {
        var n = t;
        return Oxe.forEach((function(r) {
            n = r(e, t)
          }
        )),
          n
      }(e, f)),
        Wbe((function() {
            var t = Fme(i);
            null != t && (mme.set(r, t),
              yme.set(e, t),
              gme.set(t, e))
          }
        )),
        f
    }(e, r) : function(e, t, n) {
      if (null == e.text)
        throw new Error("Current node is not slate Text " + JSON.stringify(e));
      var r = qme.findKey(n, e)
        , o = n.getConfig().decorate;
      if (null == o)
        throw new Error("Can not get config.decorate");
      var a = qme.findPath(n, e)
        , i = o([e, a])
        , s = bne.decorations(e, i)
        , l = s.map((function(r, o) {
          var a, i, l = function(e, t, n, r, o) {
            void 0 === t && (t = !1);
            var a = e.text
              , i = qme.findPath(o, n)
              , s = one.parent(i);
            if (Yte.isEditor(r))
              throw new Error("Text node " + JSON.stringify(n) + " parent is Editor");
            return o.isVoid(r) ? Ixe(ene.string(r).length) : "" !== a || r.children[r.children.length - 1] !== n || o.isInline(r) || "" !== Yte.string(o, s) ? "" === a ? Ixe() : t && "\n" === a.slice(-1) ? Lxe(a, !0) : Lxe(a) : Ixe(0, !0)
          }(r, o === s.length - 1, e, t, n);
          return a = r,
            i = l,
            Oxe.forEach((function(e) {
                i = e(a, i)
              }
            )),
            $ae("span", {
              "data-slate-leaf": !0
            }, l = i)
        }
      ))
        , u = "w-e-text-" + r.id
        , c = $ae("span", {
        "data-slate-node": "text",
        id: u,
        key: r.id
      }, l);
      return Wbe((function() {
          var t = Fme(u);
          null != t && (mme.set(r, t),
            yme.set(e, t),
            gme.set(t, e))
        }
      )),
        c
    }(e, n, r)
}
function Fxe(e, t) {
  var n, r = e.$scroll, o = "w-e-textarea-" + e.id, a = t.getConfig(), i = a.readOnly, s = a.autoFocus, l = function(e, t) {
    return void 0 === t && (t = !1),
      Sae("div#" + e, {
        props: {
          contentEditable: !t
        }
      })
  }(o, i), u = t.children || [];
  l.children = u.map((function(e, n) {
      var r = Pxe(e, n, t, t);
      return Dxe(r),
        r
    }
  ));
  var c = cme.get(e);
  if (null == c && (c = !0),
    c) {
    var d = function(e, t) {
      return Qre('<div\n        id="' + e + '"\n        data-slate-editor\n        data-slate-node="value"\n        suppressContentEditableWarning\n        role="textarea"\n        spellCheck="true"\n        autoCorrect="true"\n        autoCapitalize="true"\n    ></div>')
    }(o);
    r.append(d),
      e.$textArea = d,
      n = d[0],
      (p = wae([kae, Fae, Vae, Oae, Iae, Aae]))(n, l),
      cme.set(e, !1),
      dme.set(e, p)
  } else {
    var f = fme.get(e)
      , p = dme.get(e);
    if (null == f || null == p)
      return;
    n = f.elm,
      p(f, l)
  }
  if (null != n || null != (n = Fme(o))) {
    if ((c ? s : t.isFocused()) && n.focus({
      preventScroll: !0
    }),
      c) {
      var h = _me(n);
      h && wme.set(t, h)
    }
    vme.set(t, n),
      yme.set(t, n),
      gme.set(n, t),
      fme.set(e, l)
  }
}
function Bxe(e) {
  return "object" == typeof e && null != e && 1 === e.nodeType
}
function Nxe(e, t) {
  return (!t || "hidden" !== e) && "visible" !== e && "clip" !== e
}
function Mxe(e, t) {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    var n = getComputedStyle(e, null);
    return Nxe(n.overflowY, t) || Nxe(n.overflowX, t) || !!(o = function(e) {
      if (!e.ownerDocument || !e.ownerDocument.defaultView)
        return null;
      try {
        return e.ownerDocument.defaultView.frameElement
      } catch (t) {
        return null
      }
    }(r = e)) && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth)
  }
  var r, o;
  return !1
}
function jxe(e, t, n, r, o, a, i, s) {
  return a < e && i > t || a > e && i < t ? 0 : a <= e && s <= n || i >= t && s >= n ? a - e - r : i > t && s < n || a < e && s > n ? i - t + o : 0
}
function Vxe(e, t) {
  var n = window
    , r = t.scrollMode
    , o = t.block
    , a = t.inline
    , i = t.boundary
    , s = t.skipOverflowHiddenElements
    , l = "function" == typeof i ? i : function(e) {
      return e !== i
    }
  ;
  if (!Bxe(e))
    throw new TypeError("Invalid target");
  for (var u = document.scrollingElement || document.documentElement, c = [], d = e; Bxe(d) && l(d); ) {
    if ((d = d.parentElement) === u) {
      c.push(d);
      break
    }
    null != d && d === document.body && Mxe(d) && !Mxe(document.documentElement) || null != d && Mxe(d, s) && c.push(d)
  }
  for (var f = n.visualViewport ? n.visualViewport.width : innerWidth, p = n.visualViewport ? n.visualViewport.height : innerHeight, h = window.scrollX || pageXOffset, v = window.scrollY || pageYOffset, g = e.getBoundingClientRect(), m = g.height, y = g.width, b = g.top, w = g.right, x = g.bottom, S = g.left, E = "start" === o || "nearest" === o ? b : "end" === o ? x : b + m / 2, A = "center" === a ? S + y / 2 : "end" === a ? w : S, C = [], k = 0; k < c.length; k++) {
    var T = c[k]
      , D = T.getBoundingClientRect()
      , O = D.height
      , _ = D.width
      , R = D.top
      , L = D.right
      , I = D.bottom
      , P = D.left;
    if ("if-needed" === r && b >= 0 && S >= 0 && x <= p && w <= f && b >= R && x <= I && S >= P && w <= L)
      return C;
    var F = getComputedStyle(T)
      , B = parseInt(F.borderLeftWidth, 10)
      , N = parseInt(F.borderTopWidth, 10)
      , M = parseInt(F.borderRightWidth, 10)
      , j = parseInt(F.borderBottomWidth, 10)
      , V = 0
      , U = 0
      , $ = "offsetWidth"in T ? T.offsetWidth - T.clientWidth - B - M : 0
      , H = "offsetHeight"in T ? T.offsetHeight - T.clientHeight - N - j : 0;
    if (u === T)
      V = "start" === o ? E : "end" === o ? E - p : "nearest" === o ? jxe(v, v + p, p, N, j, v + E, v + E + m, m) : E - p / 2,
        U = "start" === a ? A : "center" === a ? A - f / 2 : "end" === a ? A - f : jxe(h, h + f, f, B, M, h + A, h + A + y, y),
        V = Math.max(0, V + v),
        U = Math.max(0, U + h);
    else {
      V = "start" === o ? E - R - N : "end" === o ? E - I + j + H : "nearest" === o ? jxe(R, I, O, N, j + H, E, E + m, m) : E - (R + O / 2) + H / 2,
        U = "start" === a ? A - P - B : "center" === a ? A - (P + _ / 2) + $ / 2 : "end" === a ? A - L + M + $ : jxe(P, L, _, B, M + $, A, A + y, y);
      var z = T.scrollLeft
        , K = T.scrollTop;
      E += K - (V = Math.max(0, Math.min(K + V, T.scrollHeight - O + H))),
        A += z - (U = Math.max(0, Math.min(z + U, T.scrollWidth - _ + $)))
    }
    C.push({
      el: T,
      top: V,
      left: U
    })
  }
  return C
}
function Uxe(e) {
  return e === Object(e) && 0 !== Object.keys(e).length
}
function $xe(e, t) {
  return Lme(t) && qme.hasDOMNode(e, t, {
    editable: !0
  })
}
function Hxe(e, t) {
  if (e.getConfig().readOnly)
    return !1;
  var n = zxe(e, t) && qme.toSlateNode(e, t);
  return Yte.isVoid(e, n)
}
function zxe(e, t) {
  return Lme(t) && qme.hasDOMNode(e, t)
}
function Kxe(e, t, n) {
  void 0 === n && (n = !1);
  var r = t.selection
    , o = t.getConfig()
    , a = qme.findDocumentOrShadowRoot(t).getSelection();
  if (a && (!e.isComposing || n) && t.isFocused()) {
    var i = "None" !== a.type;
    if (r || i) {
      var s = vme.get(t)
        , l = !1;
      if (s.contains(a.anchorNode) && s.contains(a.focusNode) && (l = !0),
      i && l && r) {
        var u = qme.toSlateRange(t, a, {
          exactMatch: !0,
          suppressThrow: !0
        });
        if (u && fne.equals(u, r)) {
          var c = !0;
          if (fne.isCollapsed(r)) {
            var d = a.anchorNode
              , f = a.anchorOffset;
            if (d === s) {
              var p = s.childNodes
                , h = void 0;
              (h = p[f]) && h.matches("table") && (c = !1),
              (h = p[f - 1]) && h.matches("table") && (c = !1)
            }
          }
          if (c)
            return
        }
      }
      if (!r || qme.hasRange(t, r)) {
        e.isUpdatingSelection = !0;
        var v = r && qme.toDOMRange(t, r);
        if (v) {
          fne.isBackward(r) ? a.setBaseAndExtent(v.endContainer, v.endOffset, v.startContainer, v.startOffset) : a.setBaseAndExtent(v.startContainer, v.startOffset, v.endContainer, v.endOffset);
          var g = v.startContainer.parentElement;
          if (!g.closest("[data-slate-spacer]")) {
            g.getBoundingClientRect = v.getBoundingClientRect.bind(v);
            var m = document.body;
            (function(e, t) {
                var n, r = !e.ownerDocument.documentElement.contains(e);
                if (Uxe(t) && "function" == typeof t.behavior)
                  return t.behavior(r ? [] : Vxe(e, t));
                if (!r) {
                  var o = !1 === (n = t) ? {
                    block: "end",
                    inline: "nearest"
                  } : Uxe(n) ? n : {
                    block: "start",
                    inline: "nearest"
                  };
                  !function(e, t) {
                    void 0 === t && (t = "auto");
                    var n = "scrollBehavior"in document.body.style;
                    e.forEach((function(e) {
                        var r = e.el
                          , o = e.top
                          , a = e.left;
                        r.scroll && n ? r.scroll({
                          top: o,
                          left: a,
                          behavior: t
                        }) : (r.scrollTop = o,
                          r.scrollLeft = a)
                      }
                    ))
                  }(Vxe(e, o), o.behavior)
                }
              }
            )(g, {
              scrollMode: "if-needed",
              boundary: o.scroll ? s.parentElement : m,
              block: "end",
              behavior: "smooth"
            }),
              delete g.getBoundingClientRect
          }
        } else
          a.removeAllRanges();
        setTimeout((function() {
            v && $me && s.focus(),
              e.isUpdatingSelection = !1
          }
        ))
      } else
        t.selection = qme.toSlateRange(t, a, {
          exactMatch: !1,
          suppressThrow: !1
        })
    }
  }
}
var Wxe = new WeakMap
  , Gxe = new WeakMap
  , qxe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  splitBlock: "shift?+enter",
  undo: "mod+z",
  tab: "tab",
  selectAll: "mod+a"
}
  , Yxe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}
  , Xxe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}
  , Qxe = function(e) {
  var t = qxe[e]
    , n = Yxe[e]
    , r = Xxe[e]
    , o = t && Mie(t)
    , a = n && Mie(n)
    , i = r && Mie(r);
  return function(e) {
    return !(!o || !o(e)) || !!(Ume && a && a(e)) || !(Ume || !i || !i(e))
  }
}
  , Jxe = {
  isBold: Qxe("bold"),
  isCompose: Qxe("compose"),
  isMoveBackward: Qxe("moveBackward"),
  isMoveForward: Qxe("moveForward"),
  isDeleteBackward: Qxe("deleteBackward"),
  isDeleteForward: Qxe("deleteForward"),
  isDeleteLineBackward: Qxe("deleteLineBackward"),
  isDeleteLineForward: Qxe("deleteLineForward"),
  isDeleteWordBackward: Qxe("deleteWordBackward"),
  isDeleteWordForward: Qxe("deleteWordForward"),
  isExtendBackward: Qxe("extendBackward"),
  isExtendForward: Qxe("extendForward"),
  isExtendLineBackward: Qxe("extendLineBackward"),
  isExtendLineForward: Qxe("extendLineForward"),
  isItalic: Qxe("italic"),
  isMoveLineBackward: Qxe("moveLineBackward"),
  isMoveLineForward: Qxe("moveLineForward"),
  isMoveWordBackward: Qxe("moveWordBackward"),
  isMoveWordForward: Qxe("moveWordForward"),
  isRedo: Qxe("redo"),
  isSplitBlock: Qxe("splitBlock"),
  isTransposeCharacter: Qxe("transposeCharacter"),
  isUndo: Qxe("undo"),
  isTab: Qxe("tab"),
  isSelectAll: Qxe("selectAll")
};
function Zxe(e) {
  e.preventDefault()
}
var eSe = {
  beforeinput: function(e, t, n) {
    var r = e
      , o = n.getConfig().readOnly;
    if (Gme && !o && $xe(n, r.target)) {
      var a = n.selection
        , i = r.inputType
        , s = r.dataTransfer || r.data || void 0;
      if ("insertCompositionText" !== i && "deleteCompositionText" !== i) {
        if (r.preventDefault(),
        !i.startsWith("delete") || i.startsWith("deleteBy")) {
          var l = tge(r.getTargetRanges(), 1)[0];
          if (l) {
            var u = qme.toSlateRange(n, l, {
              exactMatch: !1,
              suppressThrow: !1
            });
            a && fne.equals(a, u) || Nne.select(n, u)
          }
        }
        if (a && fne.isExpanded(a) && i.startsWith("delete")) {
          var c = i.endsWith("Backward") ? "backward" : "forward";
          Yte.deleteFragment(n, {
            direction: c
          })
        } else
          switch (i) {
            case "deleteByComposition":
            case "deleteByCut":
            case "deleteByDrag":
              Yte.deleteFragment(n);
              break;
            case "deleteContent":
            case "deleteContentForward":
              Yte.deleteForward(n);
              break;
            case "deleteContentBackward":
              Yte.deleteBackward(n);
              break;
            case "deleteEntireSoftLine":
              Yte.deleteBackward(n, {
                unit: "line"
              }),
                Yte.deleteForward(n, {
                  unit: "line"
                });
              break;
            case "deleteHardLineBackward":
              Yte.deleteBackward(n, {
                unit: "block"
              });
              break;
            case "deleteSoftLineBackward":
              Yte.deleteBackward(n, {
                unit: "line"
              });
              break;
            case "deleteHardLineForward":
              Yte.deleteForward(n, {
                unit: "block"
              });
              break;
            case "deleteSoftLineForward":
              Yte.deleteForward(n, {
                unit: "line"
              });
              break;
            case "deleteWordBackward":
              Yte.deleteBackward(n, {
                unit: "word"
              });
              break;
            case "deleteWordForward":
              Yte.deleteForward(n, {
                unit: "word"
              });
              break;
            case "insertLineBreak":
            case "insertParagraph":
              Yte.insertBreak(n);
              break;
            case "insertFromDrop":
            case "insertFromPaste":
            case "insertFromYank":
            case "insertReplacementText":
            case "insertText":
              if ("insertFromPaste" === i && !Ame.get(n))
                break;
              s instanceof DataTransfer ? n.insertData(s) : "string" == typeof s && Yte.insertText(n, s)
          }
      }
    }
  },
  blur: function(e, t, n) {
    var r = e
      , o = t.isUpdatingSelection
      , a = t.latestElement;
    if (!n.getConfig().readOnly && !o && $xe(n, r.target)) {
      var i = qme.findDocumentOrShadowRoot(n);
      if (a !== i.activeElement) {
        var s = r.relatedTarget;
        if (!(s === qme.toDOMNode(n, n) || Rme(s) && s.hasAttribute("data-slate-spacer"))) {
          if (null != s && Lme(s) && qme.hasDOMNode(n, s)) {
            var l = qme.toSlateNode(n, s);
            if (Hte.isElement(l) && !n.isVoid(l))
              return
          }
          if (Hme) {
            var u = i.getSelection();
            null == u || u.removeAllRanges()
          }
          xme.delete(n)
        }
      }
    }
  },
  focus: function(e, t, n) {
    var r = qme.toDOMNode(n, n)
      , o = qme.findDocumentOrShadowRoot(n);
    t.latestElement = o.activeElement,
      $me && e.target !== r ? r.focus() : xme.set(n, !0)
  },
  click: function(e, t, n) {
    if (!n.getConfig().readOnly && zxe(n, e.target) && Lme(e.target)) {
      var r = qme.toSlateNode(n, e.target)
        , o = qme.findPath(n, r);
      if (Yte.hasPath(n, o) && ene.get(n, o) === r) {
        var a = Yte.start(n, o)
          , i = Yte.end(n, o)
          , s = Yte.void(n, {
          at: a
        })
          , l = Yte.void(n, {
          at: i
        });
        if (s && l && one.equals(s[1], l[1])) {
          var u = Yte.range(n, a);
          Nne.select(n, u)
        }
      }
    }
  },
  compositionstart: function(e, t, n) {
    if ($xe(n, e.target)) {
      var r = n.selection;
      if (r && fne.isExpanded(r) && (Yte.deleteFragment(n),
        Promise.resolve().then((function() {
            Kxe(t, n, !0)
          }
        ))),
      r && fne.isCollapsed(r)) {
        var o = qme.toDOMRange(n, r).startContainer
          , a = o.textContent || "";
        Wxe.set(n, a),
          Gxe.set(n, o)
      }
      t.isComposing = !0,
        i = t,
      (s = n).getConfig().placeholder && s.isEmpty() && i.showPlaceholder && (null === (l = i.$placeholder) || void 0 === l || l.hide(),
        i.showPlaceholder = !1)
    }
    var i, s, l
  },
  compositionend: function(e, t, n) {
    var r = e;
    if ($xe(n, r.target)) {
      t.isComposing = !1;
      var o = n.selection;
      if (null != o) {
        (Wme || $me) && qme.cleanExposedTexNodeInSelectionBlock(n);
        for (var a = fne.isBackward(o) ? o.focus : o.anchor, i = tge(Yte.node(n, [a.path[0]]), 1)[0], s = 0; s < a.path.length; s++) {
          var l = tge(Yte.node(n, a.path.slice(0, s + 1)), 1)[0];
          if (Hte.isElement(l) && ((Hme || $me) && "link" === l.type || "code" === l.type)) {
            qme.setNewKey(i);
            break
          }
        }
        var u = r.data;
        if (u) {
          if (n.getConfig().maxLength) {
            var c = qme.getLeftLengthOfMaxLength(n);
            c < u.length ? (qme.toDOMRange(n, o).startContainer.textContent = Wxe.get(n) || "",
            c > 0 && Yte.insertText(n, u.slice(0, c)),
              t.changeViewState()) : Yte.insertText(n, u)
          } else
            Yte.insertText(n, u);
          Hme || setTimeout((function() {
              var e = n.selection;
              if (null != e) {
                var t = Gxe.get(n);
                null != t && qme.toDOMRange(n, e).startContainer !== t && (t.textContent = Wxe.get(n) || "")
              }
            }
          ))
        }
      }
    }
  },
  compositionupdate: function(e, t, n) {
    $xe(n, e.target) && (t.isComposing = !0)
  },
  keydown: function(e, t, n) {
    var r = e
      , o = n.selection;
    if (!n.getConfig().readOnly && !t.isComposing && $xe(n, r.target)) {
      if (function(e, t) {
        var n = rme.get(e)
          , r = n && n.getMenus()
          , o = ame.get(e)
          , a = o && o.getMenus()
          , i = Zve(Zve({}, r), a);
        for (var s in i) {
          var l = i[s]
            , u = l.hotkey;
          if (u && Nie(u, t) && !l.isDisabled(e)) {
            var c = l.getValue(e);
            l.exec(e, c)
          }
        }
      }(n, r),
        Jxe.isTab(r))
        return Zxe(r),
          void n.handleTab();
      if (Jxe.isRedo(r))
        return Zxe(r),
          void ("function" == typeof n.redo && n.redo());
      if (Jxe.isUndo(r))
        return Zxe(r),
          void ("function" == typeof n.undo && n.undo());
      if (Jxe.isMoveLineBackward(r))
        return Zxe(r),
          void Nne.move(n, {
            unit: "line",
            reverse: !0
          });
      if (Jxe.isMoveLineForward(r))
        return Zxe(r),
          void Nne.move(n, {
            unit: "line"
          });
      if (Jxe.isExtendLineBackward(r))
        return Zxe(r),
          void Nne.move(n, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
      if (Jxe.isExtendLineForward(r))
        return Zxe(r),
          void Nne.move(n, {
            unit: "line",
            edge: "focus"
          });
      if (Jxe.isMoveBackward(r))
        return Zxe(r),
          void (o && fne.isCollapsed(o) ? Nne.move(n, {
            reverse: !0
          }) : Nne.collapse(n, {
            edge: "start"
          }));
      if (Jxe.isMoveForward(r))
        return Zxe(r),
          void (o && fne.isCollapsed(o) ? Nne.move(n) : Nne.collapse(n, {
            edge: "end"
          }));
      if (Jxe.isMoveWordBackward(r))
        return Zxe(r),
        o && fne.isExpanded(o) && Nne.collapse(n, {
          edge: "focus"
        }),
          void Nne.move(n, {
            unit: "word",
            reverse: !0
          });
      if (Jxe.isMoveWordForward(r))
        return Zxe(r),
        o && fne.isExpanded(o) && Nne.collapse(n, {
          edge: "focus"
        }),
          void Nne.move(n, {
            unit: "word"
          });
      if (Jxe.isSelectAll(r))
        return Zxe(r),
          void n.selectAll();
      if (Gme) {
        if ((Wme || Hme) && o && (Jxe.isDeleteBackward(r) || Jxe.isDeleteForward(r)) && fne.isCollapsed(o)) {
          var a = ene.parent(n, o.anchor.path);
          if (Hte.isElement(a) && Yte.isVoid(n, a) && Yte.isInline(n, a))
            return r.preventDefault(),
              void Nne.delete(n, {
                unit: "block"
              })
        }
      } else {
        if (Jxe.isBold(r) || Jxe.isItalic(r) || Jxe.isTransposeCharacter(r))
          return void Zxe(r);
        if (Jxe.isSplitBlock(r))
          return Zxe(r),
            void Yte.insertBreak(n);
        if (Jxe.isDeleteBackward(r))
          return Zxe(r),
            void (o && fne.isExpanded(o) ? Yte.deleteFragment(n, {
              direction: "backward"
            }) : Yte.deleteBackward(n));
        if (Jxe.isDeleteForward(r))
          return Zxe(r),
            void (o && fne.isExpanded(o) ? Yte.deleteFragment(n, {
              direction: "forward"
            }) : Yte.deleteForward(n));
        if (Jxe.isDeleteLineBackward(r))
          return Zxe(r),
            void (o && fne.isExpanded(o) ? Yte.deleteFragment(n, {
              direction: "backward"
            }) : Yte.deleteBackward(n, {
              unit: "line"
            }));
        if (Jxe.isDeleteLineForward(r))
          return Zxe(r),
            void (o && fne.isExpanded(o) ? Yte.deleteFragment(n, {
              direction: "forward"
            }) : Yte.deleteForward(n, {
              unit: "line"
            }));
        if (Jxe.isDeleteWordBackward(r))
          return Zxe(r),
            void (o && fne.isExpanded(o) ? Yte.deleteFragment(n, {
              direction: "backward"
            }) : Yte.deleteBackward(n, {
              unit: "word"
            }));
        if (Jxe.isDeleteWordForward(r))
          return Zxe(r),
            void (o && fne.isExpanded(o) ? Yte.deleteFragment(n, {
              direction: "forward"
            }) : Yte.deleteForward(n, {
              unit: "word"
            }))
      }
    }
  },
  keypress: function(e, t, n) {
    if (!Gme && !n.getConfig().readOnly && $xe(n, e.target)) {
      e.preventDefault();
      var r = e.key;
      Yte.insertText(n, r)
    }
  },
  copy: function(e, t, n) {
    var r = e;
    if ($xe(n, r.target)) {
      r.preventDefault();
      var o = r.clipboardData;
      null != o && n.setFragmentData(o)
    }
  },
  cut: function(e, t, n) {
    var r = e
      , o = n.selection;
    if (!n.getConfig().readOnly && $xe(n, r.target)) {
      r.preventDefault();
      var a = r.clipboardData;
      if (null != a && (n.setFragmentData(a),
        o))
        if (fne.isExpanded(o))
          Yte.deleteFragment(n);
        else {
          var i = ene.parent(n, o.anchor.path);
          Yte.isVoid(n, i) && Nne.delete(n)
        }
    }
  },
  paste: function(e, t, n) {
    Ame.set(n, !0);
    var r, o = e;
    if (!n.getConfig().readOnly && $xe(n, o.target)) {
      var a = n.getConfig().customPaste;
      if (a && !1 === a(n, o))
        return void Ame.set(n, !1);
      if (!Gme || (r = o).clipboardData && "" !== r.clipboardData.getData("text/plain") && 1 === r.clipboardData.types.length) {
        o.preventDefault();
        var i = o.clipboardData;
        null != i && n.insertData(i)
      }
    }
  },
  dragover: function(e, t, n) {
    if (zxe(n, e.target)) {
      var r = qme.toSlateNode(n, e.target);
      Yte.isVoid(n, r) && e.preventDefault()
    }
  },
  dragstart: function(e, t, n) {
    var r = e;
    if (zxe(n, r.target) && !n.getConfig().readOnly) {
      var o = qme.toSlateNode(n, r.target)
        , a = qme.findPath(n, o);
      if (Yte.isVoid(n, o) || Yte.void(n, {
        at: a,
        voids: !0
      })) {
        var i = Yte.range(n, a);
        Nne.select(n, i)
      }
      var s = r.dataTransfer;
      null != s && (t.isDraggingInternally = !0,
        n.setFragmentData(s))
    }
  },
  dragend: function(e, t, n) {
    var r = e;
    n.getConfig().readOnly || t.isDraggingInternally && zxe(n, r.target) && (t.isDraggingInternally = !1)
  },
  drop: function(e, t, n) {
    var r = e
      , o = r.dataTransfer;
    if (!n.getConfig().readOnly && zxe(n, r.target) && null != o && !(Gme && Hme && o.files.length > 0)) {
      r.preventDefault();
      var a = n.selection
        , i = qme.findEventRange(n, r);
      Nne.select(n, i),
      t.isDraggingInternally && (a && Nne.delete(n, {
        at: a
      }),
        t.isDraggingInternally = !1),
        n.insertData(o),
      n.isFocused() || n.focus()
    }
  }
}
  , tSe = 1
  , nSe = function() {
  function e(e) {
    var t = this;
    this.id = tSe++,
      this.$textArea = null,
      this.$progressBar = Qre('<div class="w-e-progress-bar"></div>'),
      this.$maxLengthInfo = Qre('<div class="w-e-max-length-info"></div>'),
      this.isComposing = !1,
      this.isUpdatingSelection = !1,
      this.isDraggingInternally = !1,
      this.latestElement = null,
      this.showPlaceholder = !1,
      this.$placeholder = null,
      this.latestEditorSelection = null,
      this.onDOMSelectionChange = uae((function() {
          var e = t.editorInstance;
          !function(e, t) {
            var n = e.isComposing
              , r = e.isUpdatingSelection
              , o = e.isDraggingInternally;
            if (!(t.getConfig().readOnly || n || r || o)) {
              var a = qme.findDocumentOrShadowRoot(t)
                , i = a.activeElement
                , s = qme.toDOMNode(t, t)
                , l = a.getSelection();
              if (i === s ? (e.latestElement = i,
                xme.set(t, !0)) : xme.delete(t),
                !l)
                return Nne.deselect(t);
              var u = l.anchorNode
                , c = l.focusNode
                , d = $xe(t, u) || Hxe(t, u)
                , f = $xe(t, c) || Hxe(t, c);
              if (d && f) {
                var p = qme.toSlateRange(t, l, {
                  exactMatch: !1,
                  suppressThrow: !1
                });
                Nne.select(t, p)
              } else
                Nne.deselect(t)
            }
          }(t, e)
        }
      ), 100);
    var n = Qre(e);
    if (0 === n.length)
      throw new Error("Cannot find textarea DOM by selector '" + e + "'");
    this.$box = n;
    var r = Qre('<div class="w-e-text-container"></div>');
    r.append(this.$progressBar),
      r.append(this.$maxLengthInfo),
      n.append(r);
    var o = Qre('<div class="w-e-scroll"></div>');
    r.append(o),
      this.$scroll = o,
      this.$textAreaContainer = r,
      Wbe((function() {
          var e = t.editorInstance
            , n = qme.getWindow(e);
          n.document.addEventListener("selectionchange", t.onDOMSelectionChange),
            e.on("destroyed", (function() {
                n.document.removeEventListener("selectionchange", t.onDOMSelectionChange)
              }
            )),
            r.on("click", (function() {
                return e.hidePanelOrModal()
              }
            )),
            e.on("change", t.changeViewState.bind(t));
          var o = e.getConfig().onChange;
          o && e.on("change", (function() {
              return o(e)
            }
          )),
            t.onFocusAndOnBlur(),
            e.on("change", t.changeMaxLengthInfo.bind(t)),
            t.bindEvent()
        }
      ))
  }
  return Object.defineProperty(e.prototype, "editorInstance", {
    get: function() {
      var e = tme.get(this);
      if (null == e)
        throw new Error("Can not get editor instance");
      return e
    },
    enumerable: !1,
    configurable: !0
  }),
    e.prototype.bindEvent = function() {
      var e = this
        , t = this.$textArea
        , n = this.$scroll
        , r = this.editorInstance;
      null != t && (Woe(eSe, (function(n, o) {
          t.on(o, (function(t) {
              n(t, e, r)
            }
          ))
        }
      )),
      r.getConfig().scroll && (n.css("overflow-y", "auto"),
        n.on("scroll", uae((function() {
            r.emit("scroll")
          }
        ), 100))))
    }
    ,
    e.prototype.onFocusAndOnBlur = function() {
      var e = this
        , t = this.editorInstance
        , n = t.getConfig()
        , r = n.onBlur
        , o = n.onFocus;
      this.latestEditorSelection = t.selection,
        t.on("change", (function() {
            null == e.latestEditorSelection && null != t.selection ? setTimeout((function() {
                return o && o(t)
              }
            )) : null != e.latestEditorSelection && null == t.selection && setTimeout((function() {
                return r && r(t)
              }
            )),
              e.latestEditorSelection = t.selection
          }
        ))
    }
    ,
    e.prototype.changeMaxLengthInfo = function() {
      var e = this.editorInstance
        , t = e.getConfig().maxLength;
      if (t) {
        var n = t - qme.getLeftLengthOfMaxLength(e);
        this.$maxLengthInfo[0].innerHTML = n + "/" + t
      }
    }
    ,
    e.prototype.changeProgress = function(e) {
      var t = this.$progressBar;
      t.css("width", e + "%"),
      e >= 100 && setTimeout((function() {
          t.hide(),
            t.css("width", "0"),
            t.show()
        }
      ), 1e3)
    }
    ,
    e.prototype.changeViewState = function() {
      var e = this
        , t = this.editorInstance;
      Fxe(this, t),
        function(e, t) {
          var n, r = t.getConfig().placeholder;
          if (r) {
            var o = t.isEmpty();
            if (o && !e.showPlaceholder && !e.isComposing) {
              if (null == e.$placeholder) {
                var a = Qre('<div class="w-e-text-placeholder">' + r + "</div>");
                e.$textAreaContainer.append(a),
                  e.$placeholder = a
              }
              return e.$placeholder.show(),
                void (e.showPlaceholder = !0)
            }
            !o && e.showPlaceholder && (null === (n = e.$placeholder) || void 0 === n || n.hide(),
              e.showPlaceholder = !1)
          }
        }(this, t),
        Wbe((function() {
            Kxe(e, t)
          }
        ))
    }
    ,
    e.prototype.destroy = function() {
      this.$textAreaContainer.remove()
    }
    ,
    e
}();
function rSe(e) {
  e.removeAttr("width"),
    e.removeAttr("height"),
    e.removeAttr("fill"),
    e.removeAttr("class"),
    e.removeAttr("t"),
    e.removeAttr("p-id");
  var t = e.children();
  t.length && rSe(t)
}
function oSe() {
  return Qre('<svg viewBox="0 0 1024 1024"><path d="M498.7 655.8l-197.6-268c-8.1-10.9-0.3-26.4 13.3-26.4h395.2c13.6 0 21.4 15.4 13.3 26.4l-197.6 268c-6.6 9-20 9-26.6 0z"></path></svg>')
}
function aSe(e, t, n, r, o) {
  if (void 0 === o && (o = !1),
    t) {
    if (r) {
      var a = Ume ? "cmd" : "ctrl";
      r = r.replace("mod", a)
    }
    if (o)
      r && (e.attr("data-tooltip", r),
        e.addClass("w-e-menu-tooltip-v5"),
        e.addClass("tooltip-right"));
    else {
      var i = r ? n + "\n" + r : n;
      e.attr("data-tooltip", i),
        e.addClass("w-e-menu-tooltip-v5")
    }
  }
}
_ve("match", (function(e, t, n) {
    return [function(t) {
      var n = gce(this)
        , r = null == t ? void 0 : sde(t, e);
      return r ? Zce(r, t, n) : new RegExp(t)[e](hpe(n))
    }
      , function(e) {
        var r = Qce(this)
          , o = hpe(e)
          , a = n(t, r, o);
        if (a.done)
          return a.value;
        if (!r.global)
          return Uve(r, o);
        var i = r.unicode;
        r.lastIndex = 0;
        for (var s, l = [], u = 0; null !== (s = Uve(r, o)); ) {
          var c = hpe(s[0]);
          l[u] = c,
          "" === c && (r.lastIndex = Lve(o, sfe(r.lastIndex), i)),
            u++
        }
        return 0 === u ? null : l
      }
    ]
  }
));
var iSe = function() {
  function e(e, t, n) {
    var r = this;
    void 0 === n && (n = !1),
      this.$elem = Qre('<div class="w-e-bar-item"></div>'),
      this.$button = Qre('<button type="button"></button>'),
      this.disabled = !1,
      this.menu = t;
    var o = t.tag
      , a = t.width;
    if ("button" !== o)
      throw new Error("Invalid tag '" + o + "', expected 'button'");
    var i = t.title
      , s = t.hotkey
      , l = void 0 === s ? "" : s
      , u = t.iconSvg
      , c = void 0 === u ? "" : u
      , d = this.$button;
    if (c) {
      var f = Qre(c);
      rSe(f),
        d.append(f)
    } else
      d.text(i);
    aSe(d, c, i, l, n),
    n && c && d.append(Qre('<span class="title">' + i + "</span>")),
    a && d.css("width", a + "px"),
      d.attr("data-menu-key", e),
      this.$elem.append(d),
      Wbe((function() {
          return r.init()
        }
      ))
  }
  return e.prototype.init = function() {
    var e = this;
    this.setActive(),
      this.setDisabled(),
      this.$button.on("click", (function(t) {
          t.preventDefault(),
            ySe(e).hidePanelOrModal(),
          e.disabled || (e.exec(),
            e.onButtonClick())
        }
      ))
  }
    ,
    e.prototype.exec = function() {
      var e = ySe(this)
        , t = this.menu
        , n = t.getValue(e);
      t.exec(e, n)
    }
    ,
    e.prototype.setActive = function() {
      var e = ySe(this)
        , t = this.$button
        , n = "active";
      this.menu.isActive(e) ? t.addClass(n) : t.removeClass(n)
    }
    ,
    e.prototype.setDisabled = function() {
      var e = ySe(this)
        , t = this.$button
        , n = this.menu.isDisabled(e);
      (null == e.selection || e.isDisabled()) && (n = !0),
      this.menu.alwaysEnable && (n = !1);
      var r = "disabled";
      n ? t.addClass(r) : t.removeClass(r),
        this.disabled = n
    }
    ,
    e.prototype.changeMenuState = function() {
      this.setActive(),
        this.setDisabled()
    }
    ,
    e
}()
  , sSe = function(e) {
  function t(t, n, r) {
    return void 0 === r && (r = !1),
    e.call(this, t, n, r) || this
  }
  return Jve(t, e),
    t.prototype.onButtonClick = function() {}
    ,
    t
}(iSe)
  , lSe = function() {
  function e(e) {
    this.isShow = !1,
      this.showTime = 0,
      this.record(e)
  }
  return e.prototype.record = function(e) {
    var t = sme.get(e);
    null == t && (t = new Set,
      sme.set(e, t)),
      t.add(this),
      lme.set(this, e)
  }
    ,
    e.prototype.renderContent = function(e) {
      var t = this.$elem;
      t.empty(),
        t.append(e);
      var n = this.genSelfElem();
      n && t.append(n)
    }
    ,
    e.prototype.appendTo = function(e) {
      var t = this.$elem;
      e.append(t)
    }
    ,
    e.prototype.show = function() {
      if (!this.isShow) {
        this.showTime = Date.now(),
          this.$elem.show(),
          this.isShow = !0;
        var e = lme.get(this);
        e && e.emit("modalOrPanelShow", this)
      }
    }
    ,
    e.prototype.hide = function() {
      if (this.isShow && !(Date.now() - this.showTime < 200)) {
        this.$elem.hide(),
          this.isShow = !1;
        var e = lme.get(this);
        e && e.emit("modalOrPanelHide")
      }
    }
    ,
    e
}()
  , uSe = function(e) {
  function t(t) {
    var n = e.call(this, t) || this;
    return n.type = "dropPanel",
      n.$elem = Qre('<div class="w-e-drop-panel"></div>'),
      n
  }
  return Jve(t, e),
    t.prototype.genSelfElem = function() {
      return null
    }
    ,
    t
}(lSe)
  , cSe = function(e) {
  function t(t, n, r) {
    void 0 === r && (r = !1);
    var o = e.call(this, t, n, r) || this;
    if (o.dropPanel = null,
      o.menu = n,
      n.showDropPanel) {
      var a = oSe();
      o.$button.append(a)
    }
    return o
  }
  return Jve(t, e),
    t.prototype.onButtonClick = function() {
      this.menu.showDropPanel && this.handleDropPanel()
    }
    ,
    t.prototype.handleDropPanel = function() {
      var e = this.menu;
      if (null != e.getPanelContentElem) {
        var t = ySe(this);
        if (null == this.dropPanel) {
          var n = new uSe(t)
            , r = e.getPanelContentElem(t);
          n.renderContent(r),
            n.appendTo(this.$elem),
            n.show(),
            this.dropPanel = n
        } else {
          var o = this.dropPanel;
          o.isShow ? o.hide() : (r = e.getPanelContentElem(t),
            o.renderContent(r),
            o.show())
        }
        var a = this.dropPanel;
        if (a.isShow) {
          var i = this.$elem
            , s = i.offset().left
            , l = i.parents(".w-e-bar");
          s - l.offset().left >= l.width() / 2 ? a.$elem.css({
            left: "none",
            right: "0"
          }) : a.$elem.css({
            left: "0",
            right: "none"
          })
        }
      }
    }
    ,
    t
}(iSe)
  , dSe = function(e) {
  function t(t, n) {
    void 0 === n && (n = 0);
    var r = e.call(this, t) || this;
    r.type = "modal",
      r.$elem = Qre('<div class="w-e-modal"></div>'),
      r.width = 0,
    n && (r.width = n);
    var o = r.$elem;
    return o.on("click", (function(e) {
        return e.stopPropagation()
      }
    )),
      o.on("keyup", (function(e) {
          "Escape" === e.code && (r.hide(),
            t.restoreSelection())
        }
      )),
      r
  }
  return Jve(t, e),
    t.prototype.genSelfElem = function() {
      var e = this
        , t = Qre('<span class="btn-close"><svg viewBox="0 0 1024 1024"><path d="M1024 896.1024l-128 128L512 640 128 1024 0 896 384 512 0 128 128 0 512 384 896.1024 0l128 128L640 512z"></path></svg></span>')
        , n = lme.get(this);
      return t.on("click", (function() {
          e.hide(),
          null == n || n.restoreSelection()
        }
      )),
        t
    }
    ,
    t.prototype.setStyle = function(e) {
      var t = this.width
        , n = this.$elem;
      n.attr("style", ""),
      t && n.css("width", t + "px"),
        n.css(e)
    }
    ,
    t
}(lSe);
function fSe(e, t, n) {
  var r = Qre('<label class="babel-container"></label>');
  r.append("<span>" + e + "</span>");
  var o = Qre('<input type="text" id="' + t + '" placeholder="' + (n || "") + '">');
  return r.append(o),
    [r[0], o[0]]
}
function pSe(e, t) {
  var n = Qre('<div class="button-container"></div>')
    , r = Qre('<button type="button" id="' + e + '">' + t + "</button>");
  return n.append(r),
    [n[0], r[0]]
}
var hSe = function(e) {
  function t(t, n, r) {
    void 0 === r && (r = !1);
    var o = e.call(this, t, n, r) || this;
    return o.$body = Qre("body"),
      o.modal = null,
      o.menu = n,
      o
  }
  return Jve(t, e),
    t.prototype.onButtonClick = function() {
      this.menu.showModal && this.handleModal()
    }
    ,
    t.prototype.getPosition = function() {
      var e = ySe(this)
        , t = this.menu.getModalPositionNode(e);
      return Hte.isElement(t) ? dxe(e, t, "modal") : cxe(e)
    }
    ,
    t.prototype.handleModal = function() {
      var e = ySe(this)
        , t = this.menu;
      if (null == this.modal) {
        var n = new dSe(e,t.modalWidth);
        this.renderAndShowModal(n, !0),
          this.modal = n
      } else
        (n = this.modal).isShow ? n.hide() : this.renderAndShowModal(n, !1)
    }
    ,
    t.prototype.renderAndShowModal = function(e, t) {
      void 0 === t && (t = !1);
      var n = ySe(this)
        , r = this.menu;
      if (null != r.getModalContentElem) {
        var o = qme.getTextarea(n)
          , a = qme.getToolbar(n)
          , i = ((null == a ? void 0 : a.getConfig()) || {}).modalAppendToBody
          , s = r.getModalContentElem(n);
        if (e.renderContent(s),
          i)
          e.setStyle({
            left: "0",
            right: "0"
          });
        else {
          var l = this.getPosition();
          e.setStyle(l)
        }
        t && (i ? e.appendTo(this.$body) : e.appendTo(o.$textAreaContainer)),
          e.show(),
        i || fxe(n, e.$elem),
          setTimeout((function() {
              n.blur()
            }
          ))
      }
    }
    ,
    t
}(iSe)
  , vSe = function(e) {
  function t(t, n) {
    var r = e.call(this, t) || this;
    return r.type = "selectList",
      r.$elem = Qre('<div class="w-e-select-list"></div>'),
    n && r.$elem.css("width", n + "px"),
      r.$elem.on("click", (function(e) {
          e.stopPropagation()
        }
      )),
      r
  }
  return Jve(t, e),
    t.prototype.renderList = function(e) {
      var t = this.$elem;
      t.empty();
      var n = Qre("<ul></ul>");
      e.forEach((function(e) {
          var t = e.value
            , r = e.text
            , o = e.selected
            , a = e.styleForRenderMenuList
            , i = Qre('<li data-value="' + t + '"></li>');
          if (a && i.css(a),
            o) {
            var s = Qre('<svg viewBox="0 0 1446 1024"><path d="M574.116299 786.736392 1238.811249 48.517862C1272.390222 11.224635 1329.414799 7.827718 1366.75664 41.450462 1403.840015 74.840484 1406.731043 132.084741 1373.10189 169.433699L655.118888 966.834607C653.072421 969.716875 650.835807 972.514337 648.407938 975.210759 615.017957 1012.29409 558.292155 1015.652019 521.195664 982.250188L72.778218 578.493306C35.910826 545.297758 32.859041 488.584019 66.481825 451.242134 99.871807 414.158803 156.597563 410.800834 193.694055 444.202665L574.116299 786.736392Z"></path></svg>');
            i.append(s),
              i.addClass("selected")
          }
          i.append(Qre('<span data-value="' + t + '">' + r + "</span>")),
            i.attr("title", r),
            n.append(i)
        }
      )),
        t.append(n)
    }
    ,
    t.prototype.genSelfElem = function() {
      return null
    }
    ,
    t
}(lSe)
  , gSe = function() {
  function e(e, t, n) {
    var r = this;
    void 0 === n && (n = !1),
      this.$elem = Qre('<div class="w-e-bar-item"></div>'),
      this.$button = Qre('<button type="button" class="select-button"></button>'),
      this.disabled = !1,
      this.selectList = null;
    var o = t.tag
      , a = t.title
      , i = t.width
      , s = t.iconSvg
      , l = void 0 === s ? "" : s
      , u = t.hotkey
      , c = void 0 === u ? "" : u;
    if ("select" !== o)
      throw new Error("Invalid tag '" + o + "', expected 'select'");
    var d = this.$button;
    i && d.css("width", i + "px"),
      d.attr("data-menu-key", e),
      aSe(d, l, a, c, n),
      this.$elem.append(d),
      this.menu = t,
      Wbe((function() {
          return r.init()
        }
      ))
  }
  return e.prototype.init = function() {
    var e = this;
    this.setSelectedValue(),
      this.$button.on("click", (function(t) {
          t.preventDefault(),
            ySe(e).hidePanelOrModal(),
            e.trigger()
        }
      ))
  }
    ,
    e.prototype.trigger = function() {
      var e = this
        , t = ySe(this);
      if (!t.isDisabled() && !this.disabled) {
        var n = this.menu;
        if (null == this.selectList) {
          this.selectList = new vSe(t,n.selectPanelWidth);
          var r = this.selectList
            , o = n.getOptions(t);
          r.renderList(o),
            r.appendTo(this.$elem),
            r.show(),
            r.$elem.on("click", "li", (function(t) {
                var n = t.target;
                if (null != n) {
                  t.preventDefault();
                  var r = Qre(n).attr("data-value");
                  e.onChange(r)
                }
              }
            ))
        } else
          (r = this.selectList).isShow ? r.hide() : (o = n.getOptions(t),
            r.renderList(o),
            r.show())
      }
    }
    ,
    e.prototype.onChange = function(e) {
      var t = ySe(this)
        , n = this.menu;
      n.exec && n.exec(t, e)
    }
    ,
    e.prototype.setSelectedValue = function() {
      var e = ySe(this)
        , t = this.menu
        , n = t.getValue(e)
        , r = function(e, t) {
        for (var n = e.length, r = "", o = 0; o < n; o++) {
          var a = e[o];
          if (a.value === t) {
            r = a.text;
            break
          }
        }
        return r
      }(t.getOptions(e), n.toString())
        , o = this.$button
        , a = oSe();
      o.empty(),
        o.text(r),
        o.append(a)
    }
    ,
    e.prototype.setDisabled = function() {
      var e = ySe(this)
        , t = this.menu.isDisabled(e)
        , n = this.$button;
      (null == e.selection || e.isDisabled()) && (t = !0);
      var r = "disabled";
      t ? n.addClass(r) : n.removeClass(r),
        this.disabled = t
    }
    ,
    e.prototype.changeMenuState = function() {
      this.setSelectedValue(),
        this.setDisabled()
    }
    ,
    e
}()
  , mSe = new WeakMap;
function ySe(e) {
  var t = ime.get(e);
  if (null == t)
    throw new Error("Can not get editor instance");
  return t
}
function bSe(e, t) {
  var n = e.selection;
  return null != n && !fne.isCollapsed(n) && !qme.getSelectedElems(e).some((function(t) {
      if (e.isVoid(t))
        return !0;
      var n = t.type;
      return !!["pre", "code", "table"].includes(n) || void 0
    }
  )) && !!bne.isText(t)
}
var wSe = function() {
  function e() {
    var e = this;
    this.$elem = Qre('<div class="w-e-bar w-e-bar-hidden w-e-hover-bar"></div>'),
      this.menus = {},
      this.hoverbarItems = [],
      this.prevSelectedNode = null,
      this.isShow = !1,
      this.changeHoverbarState = ese((function() {
          var t = e.isShow
            , n = e.getSelectedNodeAndMenuKeys() || {}
            , r = n.node
            , o = void 0 === r ? null : r
            , a = n.menuKeys
            , i = void 0 === a ? [] : a;
          null != o && e.changeItemsState(),
          o && Hte.isElement(o) && t && e.isSamePath(o, e.prevSelectedNode) || (e.hideAndClean(),
          null != o && (e.registerItems(i),
            e.setPosition(o),
            e.show()),
            e.prevSelectedNode = o)
        }
      ), 200),
      Wbe((function() {
          var t = e.getEditorInstance()
            , n = e.$elem;
          n.on("mousedown", (function(e) {
              return e.preventDefault()
            }
          ), {
            passive: !1
          }),
            qme.getTextarea(t).$textAreaContainer.append(n),
            t.on("change", e.changeHoverbarState);
          var r = e.hideAndClean.bind(e);
          t.on("scroll", r),
            t.on("fullScreen", r),
            t.on("unFullScreen", r)
        }
      ))
  }
  return e.prototype.getMenus = function() {
    return this.menus
  }
    ,
    e.prototype.hideAndClean = function() {
      var e = this.$elem;
      e.removeClass("w-e-bar-show").addClass("w-e-bar-hidden"),
        this.hoverbarItems = [],
        e.empty(),
        this.isShow = !1
    }
    ,
    e.prototype.checkPositionBottom = function() {
      var e = this.$elem
        , t = !1
        , n = window.innerHeight;
      n && n >= 360 && n - e[0].getBoundingClientRect().bottom < 360 && (t = !0),
        t ? e.addClass("w-e-bar-bottom") : e.removeClass("w-e-bar-bottom")
    }
    ,
    e.prototype.show = function() {
      this.$elem.removeClass("w-e-bar-hidden").addClass("w-e-bar-show"),
        this.isShow = !0,
        this.checkPositionBottom()
    }
    ,
    e.prototype.changeItemsState = function() {
      var e = this;
      Wbe((function() {
          e.hoverbarItems.forEach((function(e) {
              e.changeMenuState()
            }
          ))
        }
      ))
    }
    ,
    e.prototype.registerItems = function(e) {
      var t = this
        , n = this.$elem;
      e.forEach((function(e) {
          if ("|" !== e)
            t.registerSingleItem(e);
          else {
            var r = Qre('<div class="w-e-bar-divider"></div>');
            n.append(r)
          }
        }
      ))
    }
    ,
    e.prototype.registerSingleItem = function(e) {
      var t = this.getEditorInstance()
        , n = this.menus
        , r = n[e];
      if (null == r) {
        var o = Qme[e];
        if (null == o)
          throw new Error("Not found menu item factory by key '" + e + "'");
        if ("function" != typeof o)
          throw new Error("Menu item factory (key='" + e + "') is not a function");
        r = o(),
          n[e] = r
      }
      var a = function(e, t, n) {
        void 0 === n && (n = !1);
        var r = mSe.get(t);
        if (r)
          return r;
        var o = t.tag;
        if ("button" === o) {
          var a = t.showDropPanel
            , i = t.showModal;
          r = a ? new cSe(e,t,n) : i ? new hSe(e,t,n) : new sSe(e,t,n)
        }
        if ("select" === o && (r = new gSe(e,t,n)),
        null == r)
          throw new Error("Invalid tag in menu " + JSON.stringify(t));
        return mSe.set(t, r),
          r
      }(e, r);
      this.hoverbarItems.push(a),
        ime.set(a, t),
        this.$elem.append(a.$elem)
    }
    ,
    e.prototype.setPosition = function(e) {
      var t = this.getEditorInstance()
        , n = this.$elem;
      if (n.attr("style", ""),
        Hte.isElement(e)) {
        var r = dxe(t, e, "bar");
        return n.css(r),
          void fxe(t, n)
      }
      if (bne.isText(e))
        return r = cxe(t),
          n.css(r),
          void fxe(t, n);
      throw new Error("hoverbar.setPosition error, current selected node is not elem nor text")
    }
    ,
    e.prototype.getSelectedNodeAndMenuKeys = function() {
      var e = this.getEditorInstance();
      if (null == e.selection)
        return null;
      var t = this.getHoverbarKeysConf()
        , n = null
        , r = []
        , o = function(o) {
        var a = t[o]
          , i = a.match
          , s = a.menuKeys
          , l = void 0 === s ? [] : s
          , u = i || function(e, t) {
          return qme.checkNodeType(t, o)
        }
          , c = tge(Yte.nodes(e, {
          match: function(t) {
            return u(e, t)
          },
          universal: !0
        }), 1)[0];
        if (null != c)
          return n = c[0],
            r = l,
            "break"
      };
      for (var a in t)
        if ("break" === o(a))
          break;
      return null == n || 0 === r.length ? null : {
        node: n,
        menuKeys: r
      }
    }
    ,
    e.prototype.getEditorInstance = function() {
      var e = ome.get(this);
      if (null == e)
        throw new Error("Can not get editor instance");
      return e
    }
    ,
    e.prototype.getHoverbarKeysConf = function() {
      var e = this.getEditorInstance().getConfig().hoverbarKeys
        , t = void 0 === e ? {} : e
        , n = t.text;
      return n && null == n.match && (n.match = bSe),
        t
    }
    ,
    e.prototype.isSamePath = function(e, t) {
      if (null == e || null == t)
        return !1;
      var n = qme.findPath(null, e)
        , r = qme.findPath(null, t);
      return one.equals(n, r)
    }
    ,
    e.prototype.destroy = function() {
      this.changeHoverbarState.cancel(),
        this.$elem.remove(),
        this.menus = {},
        this.hoverbarItems = [],
        this.prevSelectedNode = null
    }
    ,
    e
}();
function xSe(e, t, n, r) {
  if (pme.set(e, t),
    hme.set(e, n),
    Hte.isElement(e)) {
    var o = e.children;
    if ((void 0 === o ? [] : o).forEach((function(t, n) {
        return xSe(t, n, e, r)
      }
    )),
      Yte.isVoid(r, e)) {
      var a = tge(ene.texts(e), 1)
        , i = tge(a[0], 1)[0];
      pme.set(i, 0),
        hme.set(i, e)
    }
  }
}
function SSe(e) {
  var t, n = e.selector, r = void 0 === n ? "" : n, o = e.config, a = void 0 === o ? {} : o, i = e.content, s = e.html, l = e.plugins, u = void 0 === l ? [] : l, c = (e=>{
      var t = e
        , {apply: n} = t;
      return t.history = {
        undos: [],
        redos: []
      },
        t.redo = ()=>{
          var {history: e} = t
            , {redos: n} = e;
          if (n.length > 0) {
            var r = n[n.length - 1];
            fpe.withoutSaving(t, (()=>{
                Yte.withoutNormalizing(t, (()=>{
                    for (var e of r)
                      t.apply(e)
                  }
                ))
              }
            )),
              e.redos.pop(),
              e.undos.push(r)
          }
        }
        ,
        t.undo = ()=>{
          var {history: e} = t
            , {undos: n} = e;
          if (n.length > 0) {
            var r = n[n.length - 1];
            fpe.withoutSaving(t, (()=>{
                Yte.withoutNormalizing(t, (()=>{
                    var e = r.map(rne.inverse).reverse();
                    for (var n of e)
                      t.apply(n)
                  }
                ))
              }
            )),
              e.redos.push(r),
              e.undos.pop()
          }
        }
        ,
        t.apply = e=>{
          var r, o, {operations: a, history: i} = t, {undos: s} = i, l = s[s.length - 1], u = l && l[l.length - 1], c = (r = e,
            !(!(o = u) || "set_selection" !== r.type || "set_selection" !== o.type)), d = fpe.isSaving(t), f = fpe.isMerging(t);
          if (null == d && (d = ((e,t)=>"set_selection" !== e.type || null != e.properties && null != e.newProperties)(e)),
            d) {
            if (null == f && (f = null != l && (0 !== a.length || ((e,t)=>"set_selection" === e.type || !(!t || "insert_text" !== e.type || "insert_text" !== t.type || e.offset !== t.offset + t.text.length || !one.equals(e.path, t.path)) || !(!t || "remove_text" !== e.type || "remove_text" !== t.type || e.offset + e.text.length !== t.offset || !one.equals(e.path, t.path)))(e, u) || c)),
            l && f)
              c && l.pop(),
                l.push(e);
            else {
              var p = [e];
              s.push(p)
            }
            for (; s.length > 100; )
              s.shift();
            (e=>"set_selection" !== e.type)(e) && (i.redos = [])
          }
          n(e)
        }
        ,
        t
    }
  )(function(e) {
    var t = e
      , n = t.insertText
      , r = t.insertNode
      , o = t.insertFragment
      , a = t.dangerouslyInsertHtml;
    return t.insertText = function(e) {
      if (t.getConfig().maxLength) {
        var r = qme.getLeftLengthOfMaxLength(t);
        r <= 0 || (r < e.length ? n(e.slice(0, r)) : n(e))
      } else
        n(e)
    }
      ,
      t.insertNode = function(e) {
        if (t.getConfig().maxLength) {
          var n = qme.getLeftLengthOfMaxLength(t);
          n <= 0 || n < ene.string(e).length || r(e)
        } else
          r(e)
      }
      ,
      t.insertFragment = function(e) {
        if (t.getConfig().maxLength)
          if (1 !== e.length)
            e.forEach((function(e) {
                t.insertNode(e)
              }
            ));
          else {
            var n = e[0];
            if (qme.getLeftLengthOfMaxLength(t) < ene.string(n).length)
              return;
            o(e)
          }
        else
          o(e)
      }
      ,
      t.dangerouslyInsertHtml = function(e, n) {
        if (void 0 === e && (e = ""),
        void 0 === n && (n = !1),
          e)
          if (t.getConfig().maxLength) {
            var r = qme.getLeftLengthOfMaxLength(t);
            if (!(r <= 0)) {
              var o = document.createElement("div");
              o.innerHTML = e,
              r < Array.from(o.childNodes).reduce((function(e, t) {
                  var n = t.nodeType
                    , r = t.nodeName;
                  return t ? n === Dme.TEXT_NODE ? e + (t.textContent || "") : n === Dme.ELEMENT_NODE ? Mwe.has(r.toLowerCase()) ? e : e + (t.textContent || "") : e : e
                }
              ), "").length || a(e, n)
            }
          } else
            a(e, n)
      }
      ,
      t
  }(function(e) {
    var t = e;
    return t.on = function(e, n) {
      var r = ixe(t);
      if (r.on(e, n),
      "destroyed" === e && lxe(t, n),
      "destroyed" !== e) {
        var o = function() {
          return r.off(e, n)
        };
        r.on("destroyed", o),
          lxe(t, o)
      }
    }
      ,
      t.once = function(e, n) {
        ixe(t).once(e, n)
      }
      ,
      t.off = function(e, n) {
        ixe(t).off(e, n)
      }
      ,
      t.emit = function(e) {
        for (var n = [], r = 1; r < arguments.length; r++)
          n[r - 1] = arguments[r];
        var o = ixe(t);
        o.emit.apply(o, nge([e], tge(n))),
        "destroyed" === e && (function(e) {
          return sxe.get(e) || new Set
        }(t).forEach((function(e) {
            return o.off("destroyed", e)
          }
        )),
          function(e) {
            sxe.set(e, new Set)
          }(t))
      }
      ,
      t
  }(function(e) {
    var t = e;
    return t.select = function(e) {
      Nne.select(t, e)
    }
      ,
      t.deselect = function() {
        var n = t.selection
          , r = qme.findDocumentOrShadowRoot(t).getSelection();
        r && r.rangeCount > 0 && r.removeAllRanges(),
        n && Nne.deselect(e)
      }
      ,
      t.move = function(t, n) {
        void 0 === n && (n = !1),
        t && (t < 0 || Nne.move(e, {
          distance: t,
          unit: "character",
          reverse: n
        }))
      }
      ,
      t.moveReverse = function(e) {
        t.move(e, !0)
      }
      ,
      t.restoreSelection = function() {
        var e = Sme.get(t);
        null != e && (t.focus(),
          Nne.select(t, e))
      }
      ,
      t.getSelectionPosition = function() {
        return cxe(t)
      }
      ,
      t.getNodePosition = function(e) {
        return dxe(t, e)
      }
      ,
      t.isSelectedAll = function() {
        var e = t.selection;
        if (null == e)
          return !1;
        var n = tge(fne.edges(e), 2)
          , r = n[0]
          , o = n[1]
          , a = tge(Yte.edges(t, []), 2)
          , i = a[0]
          , s = a[1];
        return !(!lne.equals(r, i) || !lne.equals(o, s))
      }
      ,
      t.selectAll = function() {
        var e = Yte.start(t, [])
          , n = Yte.end(t, []);
        Nne.select(t, {
          anchor: e,
          focus: n
        })
      }
      ,
      t
  }(function(e) {
    var t = e
      , n = t.onChange
      , r = t.insertText
      , o = t.apply
      , a = t.deleteBackward;
    return t.insertText = function(e) {
      t.getConfig().readOnly || r(e)
    }
      ,
      t.apply = function(e) {
        var n, r, a, i, s, l, u, c, d = [];
        switch (e.type) {
          case "insert_text":
          case "remove_text":
          case "set_node":
            try {
              for (var f = ege(Yte.levels(t, {
                at: e.path
              })), p = f.next(); !p.done; p = f.next()) {
                var h = tge(p.value, 2)
                  , v = h[0]
                  , g = h[1]
                  , m = qme.findKey(t, v);
                d.push([g, m])
              }
            } catch (T) {
              n = {
                error: T
              }
            } finally {
              try {
                p && !p.done && (r = f.return) && r.call(f)
              } finally {
                if (n)
                  throw n.error
              }
            }
            break;
          case "insert_node":
          case "remove_node":
          case "merge_node":
          case "split_node":
            try {
              for (var y = ege(Yte.levels(t, {
                at: one.parent(e.path)
              })), b = y.next(); !b.done; b = y.next()) {
                var w = tge(b.value, 2);
                v = w[0],
                  g = w[1],
                  m = qme.findKey(t, v),
                  d.push([g, m])
              }
            } catch (T) {
              a = {
                error: T
              }
            } finally {
              try {
                b && !b.done && (i = y.return) && i.call(y)
              } finally {
                if (a)
                  throw a.error
              }
            }
            break;
          case "move_node":
            try {
              for (var x = ege(Yte.levels(t, {
                at: one.common(one.parent(e.path), one.parent(e.newPath))
              })), S = x.next(); !S.done; S = x.next()) {
                var E = tge(S.value, 2);
                v = E[0],
                  g = E[1],
                  m = qme.findKey(t, v),
                  d.push([g, m])
              }
            } catch (T) {
              s = {
                error: T
              }
            } finally {
              try {
                S && !S.done && (l = x.return) && l.call(x)
              } finally {
                if (s)
                  throw s.error
              }
            }
        }
        o(e);
        try {
          for (var A = ege(d), C = A.next(); !C.done; C = A.next()) {
            var k = tge(C.value, 2);
            g = k[0],
              m = k[1],
              v = tge(Yte.node(t, g), 1)[0],
              bme.set(v, m)
          }
        } catch (T) {
          u = {
            error: T
          }
        } finally {
          try {
            C && !C.done && (c = A.return) && c.call(A)
          } finally {
            if (u)
              throw u.error
          }
        }
      }
      ,
      t.deleteBackward = function(n) {
        if ("line" !== n)
          return a(n);
        if (e.selection && fne.isCollapsed(e.selection)) {
          var r = Yte.above(e, {
            match: function(t) {
              return Yte.isBlock(e, t)
            },
            at: e.selection
          });
          if (r) {
            var o = tge(r, 2)[1]
              , i = Yte.range(e, o, e.selection.anchor)
              , s = function(e, t) {
              var n = Yte.range(e, fne.end(t))
                , r = Array.from(Yte.positions(e, {
                at: t
              }))
                , o = 0
                , a = r.length
                , i = Math.floor(a / 2);
              if (Xbe(e, Yte.range(e, r[o]), n))
                return Yte.range(e, r[o], n);
              if (r.length < 2)
                return Yte.range(e, r[r.length - 1], n);
              for (; i !== r.length && i !== o; )
                Xbe(e, Yte.range(e, r[i]), n) ? a = i : o = i,
                  i = Math.floor((o + a) / 2);
              return Yte.range(e, r[a], n)
            }(t, i);
            fne.isCollapsed(s) || Nne.delete(e, {
              at: s
            })
          }
        }
      }
      ,
      t.onChange = function() {
        var e = t.selection;
        null != e && Sme.set(t, e),
          t.emit("change"),
          n()
      }
      ,
      t.handleTab = function() {
        t.insertText("    ")
      }
      ,
      t.getHtml = function() {
        var e = t.children;
        return (void 0 === e ? [] : e).map((function(e) {
            return Gbe(e, t)
          }
        )).join("")
      }
      ,
      t.getText = function() {
        var e = t.children;
        return (void 0 === e ? [] : e).map((function(e) {
            return ene.string(e)
          }
        )).join("\n")
      }
      ,
      t.getSelectionText = function() {
        var n = t.selection;
        return null == n ? "" : Yte.string(e, n)
      }
      ,
      t.getElemsByType = function(e, n) {
        var r, o;
        void 0 === n && (n = !1);
        var a = []
          , i = Yte.nodes(t, {
          at: [],
          universal: !0
        });
        try {
          for (var s = ege(i), l = s.next(); !l.done; l = s.next()) {
            var u = tge(l.value, 1)[0];
            if (Hte.isElement(u) && (n ? u.type.indexOf(e) >= 0 : u.type === e)) {
              var c = qbe(qme.findKey(t, u).id);
              a.push(Zve(Zve({}, u), {
                id: c
              }))
            }
          }
        } catch (d) {
          r = {
            error: d
          }
        } finally {
          try {
            l && !l.done && (o = s.return) && o.call(s)
          } finally {
            if (r)
              throw r.error
          }
        }
        return a
      }
      ,
      t.getElemsByTypePrefix = function(e) {
        return t.getElemsByType(e, !0)
      }
      ,
      t.isEmpty = function() {
        var e = t.children
          , n = void 0 === e ? [] : e;
        if (n.length > 1)
          return !1;
        var r = n[0];
        if (null == r)
          return !0;
        if (Hte.isElement(r) && "paragraph" === r.type) {
          var o = r.children
            , a = void 0 === o ? [] : o;
          if (a.length > 1)
            return !1;
          var i = a[0];
          if (null == i)
            return !0;
          if (bne.isText(i) && "" === i.text)
            return !0
        }
        return !1
      }
      ,
      t.clear = function() {
        Nne.delete(t, {
          at: {
            anchor: Yte.start(t, []),
            focus: Yte.end(t, [])
          }
        }),
        0 === t.children.length && Nne.insertNodes(t, [{
          type: "paragraph",
          children: [{
            text: ""
          }]
        }])
      }
      ,
      t.getParentNode = function(e) {
        return qme.getParentNode(t, e)
      }
      ,
      t.dangerouslyInsertHtml = function(e, n) {
        if (void 0 === e && (e = ""),
        void 0 === n && (n = !1),
          e) {
          var r = document.createElement("div");
          r.innerHTML = e;
          var o = Array.from(r.childNodes);
          if (0 !== (o = o.filter((function(e) {
              var t = e.nodeType
                , n = e.nodeName;
              return t === Dme.TEXT_NODE || t === Dme.ELEMENT_NODE && !Mwe.has(n.toLowerCase())
            }
          ))).length) {
            var a = t.selection;
            if (null != a) {
              var i = null;
              qme.isSelectedEmptyParagraph(t) && !n && (i = [a.focus.path[0]]),
                r.setAttribute("hidden", "true"),
                document.body.appendChild(r);
              var s = 0;
              o.forEach((function(e) {
                  var n = e.nodeType
                    , r = e.nodeName
                    , o = e.textContent
                    , a = void 0 === o ? "" : o;
                  if (n !== Dme.TEXT_NODE)
                    if ("BR" !== r) {
                      var i = e
                        , l = !1;
                      if (Qbe.includes(r.toLowerCase()))
                        l = !0;
                      else
                        for (var u in ewe)
                          if (i.matches(u)) {
                            l = !0;
                            break
                          }
                      if (l) {
                        var c = Rwe(Qre(i), t);
                        return Array.isArray(c) ? (c.forEach((function(e) {
                            return jwe(t, e)
                          }
                        )),
                          s++) : (jwe(t, c),
                          s++),
                          void (qme.isSelectedVoidNode(t) && t.move(1))
                      }
                      var d = window.getComputedStyle(i).display;
                      qme.isSelectedEmptyParagraph(t) || d.indexOf("inline") < 0 && t.insertBreak(),
                        t.dangerouslyInsertHtml(i.innerHTML, !0)
                    } else
                      t.insertText("\n");
                  else {
                    if (!a || !a.trim())
                      return;
                    t.insertNode({
                      text: a
                    })
                  }
                }
              )),
              s && i && qme.isEmptyPath(t, i) && Nne.removeNodes(t, {
                at: i
              }),
                r.remove()
            }
          }
        }
      }
      ,
      t.setHtml = function(e) {
        void 0 === e && (e = "");
        var n = t.isDisabled()
          , r = t.isFocused()
          , o = JSON.stringify(t.selection);
        t.enable(),
          t.focus(),
          t.clear();
        var a = Lwe(t, e);
        if (Nne.insertFragment(t, a),
        r || (t.deselect(),
          t.blur()),
        n && (t.deselect(),
          t.disable()),
          t.isFocused())
          try {
            t.select(JSON.parse(o))
          } catch (i) {
            t.select(Yte.start(t, []))
          }
      }
      ,
      t
  }(function(e) {
    var t = e;
    return t.getAllMenuKeys = function() {
      var e = [];
      for (var t in Qme)
        e.push(t);
      return e
    }
      ,
      t.getConfig = function() {
        var e = ume.get(t);
        if (null == e)
          throw new Error("Can not get editor config");
        return e
      }
      ,
      t.getMenuConfig = function(e) {
        var n = t.getConfig().MENU_CONF;
        return (void 0 === n ? {} : n)[e] || {}
      }
      ,
      t.alert = function(e, n) {
        void 0 === n && (n = "info");
        var r = t.getConfig().customAlert;
        r && r(e, n)
      }
      ,
      t
  }(((t = Vwe(fte())).id = "wangEditor-" + Yme++,
    t.isDestroyed = !1,
    t.isFullScreen = !1,
    t.focus = function(e) {
      if (qme.toDOMNode(t, t).focus({
        preventScroll: !0
      }),
        xme.set(t, !0),
        e) {
        var n = Yte.end(t, []);
        Nne.select(t, n)
      } else {
        var r = Sme.get(t);
        r ? Nne.select(t, r) : Nne.select(t, Yte.start(t, []))
      }
    }
    ,
    t.isFocused = function() {
      return !!xme.get(t)
    }
    ,
    t.blur = function() {
      qme.toDOMNode(t, t).blur(),
        Nne.deselect(t),
        xme.set(t, !1)
    }
    ,
    t.updateView = function() {
      qme.getTextarea(t).changeViewState();
      var e = qme.getToolbar(t);
      e && e.changeToolbarState();
      var n = qme.getHoverbar(t);
      n && n.changeHoverbarState()
    }
    ,
    t.destroy = function() {
      if (!t.isDestroyed) {
        var e = qme.getTextarea(t);
        e.destroy(),
          eme.delete(t),
          tme.delete(e);
        var n = qme.getToolbar(t);
        n && (n.destroy(),
          rme.delete(t),
          nme.delete(n));
        var r = qme.getHoverbar(t);
        r && (r.destroy(),
          ame.delete(t),
          ome.delete(r)),
          t.isDestroyed = !0,
          t.emit("destroyed")
      }
    }
    ,
    t.scrollToElem = function(e) {
      if (!t.getConfig().scroll) {
        var n = "编辑器禁用了 scroll ，编辑器内容无法滚动，请自行实现该功能";
        return n += "\nYou has disabled editor scroll, please do this yourself",
          void console.warn(n)
      }
      var r = Qre("#" + e);
      if (0 !== r.length) {
        var o = r[0];
        if (!qme.hasDOMNode(t, o))
          return n = "Element (found by id is '" + e + "') is not in editor DOM",
            n += "\n 通过 id '" + e + "' 找到的 element 不在 editor DOM 之内",
            void console.error(n, o);
        var a = qme.getTextarea(t)
          , i = a.$textAreaContainer
          , s = a.$scroll
          , l = r.offset().top
          , u = i.offset().top;
        s[0].scrollBy({
          top: l - u,
          behavior: "smooth"
        })
      }
    }
    ,
    t.showProgressBar = function(e) {
      e < 1 || qme.getTextarea(t).changeProgress(e)
    }
    ,
    t.hidePanelOrModal = function() {
      var e = sme.get(t);
      null != e && e.forEach((function(e) {
          return e.hide()
        }
      ))
    }
    ,
    t.enable = function() {
      t.getConfig().readOnly = !1,
        t.updateView()
    }
    ,
    t.disable = function() {
      t.getConfig().readOnly = !0,
        t.updateView()
    }
    ,
    t.isDisabled = function() {
      return t.getConfig().readOnly
    }
    ,
    t.toDOMNode = function(e) {
      return qme.toDOMNode(t, e)
    }
    ,
    t.fullScreen = function() {
      if (!t.isFullScreen) {
        var e = null
          , n = qme.getToolbar(t);
        n && (e = n.$box);
        var r = qme.getTextarea(t).$box.parent();
        if (e && e.parent()[0] !== r[0])
          throw new Error("Can not set full screen, cause toolbar DOM parent is not equal to textarea DOM parent\n不能设置全屏，因为 toolbar DOM 父节点和 textarea DOM 父节点不一致");
        r.addClass("w-e-full-screen-container");
        var o = r.css("z-index");
        r.attr("data-z-index", o.toString()),
          t.isFullScreen = !0,
          t.emit("fullScreen")
      }
    }
    ,
    t.unFullScreen = function() {
      if (t.isFullScreen) {
        var e = qme.getTextarea(t).$box.parent();
        setTimeout((function() {
            e.removeClass("w-e-full-screen-container"),
              t.isFullScreen = !1,
              t.emit("unFullScreen")
          }
        ), 200)
      }
    }
    ,
    t.getEditableContainer = function() {
      return qme.getTextarea(t).$textAreaContainer[0]
    }
    ,
    t)))))));
  if (r && function(e, t) {
    return function(e, t, n) {
      var r = Qre(n);
      return !!r.attr(t) || (r.attr(t, "true"),
        e.on("destroyed", (function() {
            r.removeAttr(t)
          }
        )),
        !1)
    }(e, "data-w-e-textarea", t)
  }(c, r))
    throw new Error("Repeated create editor by selector '" + r + "'");
  var d = function(e) {
    void 0 === e && (e = {});
    var t = tse(Xme)
      , n = {}
      , r = e.MENU_CONF
      , o = void 0 === r ? {} : r;
    return Woe(t, (function(e, t) {
        n[t] = Zve(Zve({}, e), o[t] || {})
      }
    )),
      delete e.MENU_CONF,
      Zve({
        scroll: !0,
        readOnly: !1,
        autoFocus: !0,
        decorate: function() {
          return []
        },
        maxLength: 0,
        MENU_CONF: n,
        hoverbarKeys: {},
        customAlert: function(e, t) {
          window.alert(t + ":\n" + e)
        }
      }, e)
  }(a);
  ume.set(c, d);
  var f = d.hoverbarKeys
    , p = void 0 === f ? {} : f;
  if (u.forEach((function(e) {
      c = e(c)
    }
  )),
  null != s && (c.children = Lwe(c, s)),
  i && i.length && (c.children = i),
  0 === c.children.length && (c.children = [{
    type: "paragraph",
    children: [{
      text: ""
    }]
  }]),
    qme.normalizeContent(c),
    r) {
    var h = new nSe(r);
    eme.set(c, h),
      tme.set(h, c),
      h.changeViewState(),
      Wbe((function() {
          var e = h.$scroll;
          null != e && e.height() < 300 && console.warn("编辑区域高度 < 300px 这可能会导致 modal hoverbar 定位异常\nTextarea height < 300px . This may be cause modal and hoverbar position error", e)
        }
      ));
    var v = void 0;
    Object.keys(p).length > 0 && (v = new wSe,
      ome.set(v, c),
      ame.set(c, v)),
      c.on("change", (function() {
          c.hidePanelOrModal()
        }
      )),
      c.on("scroll", (function() {
          c.hidePanelOrModal()
        }
      ))
  } else
    c.children.forEach((function(e, t) {
        return xSe(e, t, c, c)
      }
    ));
  var g = d.onCreated
    , m = d.onDestroyed;
  return g && c.on("created", (function() {
      return g(c)
    }
  )),
  m && c.on("destroyed", (function() {
      return m(c)
    }
  )),
    Wbe((function() {
        return c.emit("created")
      }
    )),
    c
}
var ESe = eve("splice")
  , ASe = ace.TypeError
  , CSe = Math.max
  , kSe = Math.min;
ape({
  target: "Array",
  proto: !0,
  forced: !ESe
}, {
  splice: function(e, t) {
    var n, r, o, a, i, s, l = yce(this), u = lfe(l), c = Mfe(e, u), d = arguments.length;
    if (0 === d ? n = r = 0 : 1 === d ? (n = 0,
      r = u - c) : (n = d - 2,
      r = kSe(CSe(afe(t), 0), u - c)),
    u + n - r > 9007199254740991)
      throw ASe("Maximum allowed length exceeded");
    for (o = wfe(l, r),
           a = 0; a < r; a++)
      (i = c + a)in l && Xpe(o, a, l[i]);
    if (o.length = r,
    n < r) {
      for (a = c; a < u - r; a++)
        s = a + n,
          (i = a + r)in l ? l[s] = l[i] : delete l[s];
      for (a = u; a > u - r + n; a--)
        delete l[a - 1]
    } else if (n > r)
      for (a = u - r; a > c; a--)
        s = a + n - 1,
          (i = a + r - 1)in l ? l[s] = l[i] : delete l[s];
    for (a = 0; a < n; a++)
      l[a + c] = arguments[a + 2];
    return l.length = u - r + n,
      o
  }
});
var TSe = Mde.EXISTS
  , DSe = hde.f
  , OSe = Function.prototype
  , _Se = hce(OSe.toString)
  , RSe = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/
  , LSe = hce(RSe.exec);
function ISe(e) {
  var t = e.server
    , n = void 0 === t ? "" : t
    , r = e.fieldName
    , o = void 0 === r ? "" : r
    , a = e.maxFileSize
    , i = void 0 === a ? 10485760 : a
    , s = e.maxNumberOfFiles
    , l = void 0 === s ? 100 : s
    , u = e.meta
    , c = void 0 === u ? {} : u
    , d = e.metaWithUrl
    , f = void 0 !== d && d
    , p = e.headers
    , h = void 0 === p ? {} : p
    , v = e.withCredentials
    , g = void 0 !== v && v
    , m = e.timeout
    , y = void 0 === m ? 1e4 : m
    , b = e.onBeforeUpload
    , w = void 0 === b ? function(e) {
      return e
    }
    : b
    , x = e.onSuccess
    , S = void 0 === x ? function(e, t) {}
    : x
    , E = e.onError
    , A = void 0 === E ? function(e, t, n) {
      console.error(e.name + " upload error", t, n)
    }
    : E
    , C = e.onProgress
    , k = void 0 === C ? function(e) {}
    : C;
  if (!n)
    throw new Error("Cannot get upload server address\n没有配置上传地址");
  if (!o)
    throw new Error("Cannot get fieldName\n没有配置 fieldName");
  var T = n;
  f && (T = function(e, t) {
    var n = tge(e.split("#"), 2)
      , r = n[0]
      , o = n[1]
      , a = [];
    Woe(t, (function(e, t) {
        a.push(t + "=" + e)
      }
    ));
    var i = a.join("&");
    return r = r.indexOf("?") > 0 ? r + "&" + i : r + "?" + i,
      o ? r + "#" + o : r
  }(T, c));
  var D = new Ole({
    onBeforeUpload: w,
    restrictions: {
      maxFileSize: i,
      maxNumberOfFiles: l
    },
    meta: c
  }).use(Zue, {
    endpoint: T,
    headers: h,
    formData: !0,
    fieldName: o,
    bundle: !0,
    withCredentials: g,
    timeout: y
  });
  return D.on("upload-success", (function(e, t) {
      var n = t.body
        , r = void 0 === n ? {} : n;
      try {
        S(e, r)
      } catch (o) {
        console.error("wangEditor upload file - onSuccess error", o)
      }
      D.removeFile(e.id)
    }
  )),
    D.on("progress", (function(e) {
        e < 1 || k(e)
      }
    )),
    D.on("upload-error", (function(e, t, n) {
        try {
          A(e, t, n)
        } catch (r) {
          console.error("wangEditor upload file - onError error", r)
        }
        D.removeFile(e.id)
      }
    )),
    D.on("restriction-failed", (function(e, t) {
        try {
          A(e, t)
        } catch (n) {
          console.error("wangEditor upload file - onError error", n)
        }
        D.removeFile(e.id)
      }
    )),
    D
}
function PSe(e) {
  return (PSe = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
      }
      : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
      }
  )(e)
}
function FSe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n,
    e
}
function BSe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? Object(arguments[t]) : {}
      , r = Object.keys(n);
    "function" == typeof Object.getOwnPropertySymbols && r.push.apply(r, Object.getOwnPropertySymbols(n).filter((function(e) {
        return Object.getOwnPropertyDescriptor(n, e).enumerable
      }
    ))),
      r.forEach((function(t) {
          FSe(e, t, n[t])
        }
      ))
  }
  return e
}
function NSe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function MSe(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1,
      r.configurable = !0,
    "value"in r && (r.writable = !0),
      Object.defineProperty(e, r.key, r)
  }
}
function jSe(e, t, n) {
  return t && MSe(e.prototype, t),
  n && MSe(e, n),
    e
}
function VSe(e) {
  if (void 0 === e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e
}
function USe(e, t) {
  if (t && ("object" === PSe(t) || "function" == typeof t))
    return t;
  if (void 0 !== t)
    throw new TypeError("Derived constructors may only return object or undefined");
  return VSe(e)
}
function $Se(e) {
  return ($Se = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
      return e.__proto__ || Object.getPrototypeOf(e)
    }
  )(e)
}
function HSe(e, t) {
  return (HSe = Object.setPrototypeOf || function(e, t) {
      return e.__proto__ = t,
        e
    }
  )(e, t)
}
function zSe(e, t) {
  if ("function" != typeof t && null !== t)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }),
  t && HSe(e, t)
}
Hce && !TSe && DSe(OSe, "name", {
  configurable: !0,
  get: function() {
    try {
      return LSe(RSe, _Se(this))[1]
    } catch (Y_) {
      return ""
    }
  }
});
var KSe = {
  type: "logger",
  log: function(e) {
    this.output("log", e)
  },
  warn: function(e) {
    this.output("warn", e)
  },
  error: function(e) {
    this.output("error", e)
  },
  output: function(e, t) {
    console && console[e] && console[e].apply(console, t)
  }
}
  , WSe = new (function() {
  function e(t) {
    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    NSe(this, e),
      this.init(t, n)
  }
  return jSe(e, [{
    key: "init",
    value: function(e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      this.prefix = t.prefix || "i18next:",
        this.logger = e || KSe,
        this.options = t,
        this.debug = t.debug
    }
  }, {
    key: "setDebug",
    value: function(e) {
      this.debug = e
    }
  }, {
    key: "log",
    value: function() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      return this.forward(t, "log", "", !0)
    }
  }, {
    key: "warn",
    value: function() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      return this.forward(t, "warn", "", !0)
    }
  }, {
    key: "error",
    value: function() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      return this.forward(t, "error", "")
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      return this.forward(t, "warn", "WARNING DEPRECATED: ", !0)
    }
  }, {
    key: "forward",
    value: function(e, t, n, r) {
      return r && !this.debug ? null : ("string" == typeof e[0] && (e[0] = "".concat(n).concat(this.prefix, " ").concat(e[0])),
        this.logger[t](e))
    }
  }, {
    key: "create",
    value: function(t) {
      return new e(this.logger,BSe({}, {
        prefix: "".concat(this.prefix, ":").concat(t, ":")
      }, this.options))
    }
  }]),
    e
}())
  , GSe = function() {
  function e() {
    NSe(this, e),
      this.observers = {}
  }
  return jSe(e, [{
    key: "on",
    value: function(e, t) {
      var n = this;
      return e.split(" ").forEach((function(e) {
          n.observers[e] = n.observers[e] || [],
            n.observers[e].push(t)
        }
      )),
        this
    }
  }, {
    key: "off",
    value: function(e, t) {
      this.observers[e] && (t ? this.observers[e] = this.observers[e].filter((function(e) {
          return e !== t
        }
      )) : delete this.observers[e])
    }
  }, {
    key: "emit",
    value: function(e) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
        n[r - 1] = arguments[r];
      this.observers[e] && [].concat(this.observers[e]).forEach((function(e) {
          e.apply(void 0, n)
        }
      ));
      this.observers["*"] && [].concat(this.observers["*"]).forEach((function(t) {
          t.apply(t, [e].concat(n))
        }
      ))
    }
  }]),
    e
}();
function qSe() {
  var e, t, n = new Promise((function(n, r) {
      e = n,
        t = r
    }
  ));
  return n.resolve = e,
    n.reject = t,
    n
}
function YSe(e) {
  return null == e ? "" : "" + e
}
function XSe(e, t, n) {
  function r(e) {
    return e && e.indexOf("###") > -1 ? e.replace(/###/g, ".") : e
  }
  function o() {
    return !e || "string" == typeof e
  }
  for (var a = "string" != typeof t ? [].concat(t) : t.split("."); a.length > 1; ) {
    if (o())
      return {};
    var i = r(a.shift());
    !e[i] && n && (e[i] = new n),
      e = Object.prototype.hasOwnProperty.call(e, i) ? e[i] : {}
  }
  return o() ? {} : {
    obj: e,
    k: r(a.shift())
  }
}
function QSe(e, t, n) {
  var r = XSe(e, t, Object);
  r.obj[r.k] = n
}
function JSe(e, t) {
  var n = XSe(e, t)
    , r = n.obj
    , o = n.k;
  if (r)
    return r[o]
}
function ZSe(e, t, n) {
  var r = JSe(e, n);
  return void 0 !== r ? r : JSe(t, n)
}
function eEe(e, t, n) {
  for (var r in t)
    "__proto__" !== r && "constructor" !== r && (r in e ? "string" == typeof e[r] || e[r]instanceof String || "string" == typeof t[r] || t[r]instanceof String ? n && (e[r] = t[r]) : eEe(e[r], t[r], n) : e[r] = t[r]);
  return e
}
function tEe(e) {
  return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
}
var nEe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function rEe(e) {
  return "string" == typeof e ? e.replace(/[&<>"'\/]/g, (function(e) {
      return nEe[e]
    }
  )) : e
}
var oEe = "undefined" != typeof window && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
function aEe(e, t) {
  var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ".";
  if (e) {
    if (e[t])
      return e[t];
    for (var r = t.split(n), o = e, a = 0; a < r.length; ++a) {
      if (!o)
        return;
      if ("string" == typeof o[r[a]] && a + 1 < r.length)
        return;
      if (void 0 === o[r[a]]) {
        for (var i = 2, s = r.slice(a, a + i).join(n), l = o[s]; void 0 === l && r.length > a + i; )
          i++,
            l = o[s = r.slice(a, a + i).join(n)];
        if (void 0 === l)
          return;
        if ("string" == typeof l)
          return l;
        if (s && "string" == typeof l[s])
          return l[s];
        var u = r.slice(a + i).join(n);
        return u ? aEe(l, u, n) : void 0
      }
      o = o[r[a]]
    }
    return o
  }
}
var iEe = function(e) {
  function t(e) {
    var n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return NSe(this, t),
      n = USe(this, $Se(t).call(this)),
    oEe && GSe.call(VSe(n)),
      n.data = e || {},
      n.options = r,
    void 0 === n.options.keySeparator && (n.options.keySeparator = "."),
    void 0 === n.options.ignoreJSONStructure && (n.options.ignoreJSONStructure = !0),
      n
  }
  return zSe(t, GSe),
    jSe(t, [{
      key: "addNamespaces",
      value: function(e) {
        this.options.ns.indexOf(e) < 0 && this.options.ns.push(e)
      }
    }, {
      key: "removeNamespaces",
      value: function(e) {
        var t = this.options.ns.indexOf(e);
        t > -1 && this.options.ns.splice(t, 1)
      }
    }, {
      key: "getResource",
      value: function(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}
          , o = void 0 !== r.keySeparator ? r.keySeparator : this.options.keySeparator
          , a = void 0 !== r.ignoreJSONStructure ? r.ignoreJSONStructure : this.options.ignoreJSONStructure
          , i = [e, t];
        n && "string" != typeof n && (i = i.concat(n)),
        n && "string" == typeof n && (i = i.concat(o ? n.split(o) : n)),
        e.indexOf(".") > -1 && (i = e.split("."));
        var s = JSe(this.data, i);
        return s || !a || "string" != typeof n ? s : aEe(this.data && this.data[e] && this.data[e][t], n, o)
      }
    }, {
      key: "addResource",
      value: function(e, t, n, r) {
        var o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {
          silent: !1
        }
          , a = this.options.keySeparator;
        void 0 === a && (a = ".");
        var i = [e, t];
        n && (i = i.concat(a ? n.split(a) : n)),
        e.indexOf(".") > -1 && (r = t,
          t = (i = e.split("."))[1]),
          this.addNamespaces(t),
          QSe(this.data, i, r),
        o.silent || this.emit("added", e, t, n, r)
      }
    }, {
      key: "addResources",
      value: function(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
          silent: !1
        };
        for (var o in n)
          "string" != typeof n[o] && "[object Array]" !== Object.prototype.toString.apply(n[o]) || this.addResource(e, t, o, n[o], {
            silent: !0
          });
        r.silent || this.emit("added", e, t, n)
      }
    }, {
      key: "addResourceBundle",
      value: function(e, t, n, r, o) {
        var a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {
          silent: !1
        }
          , i = [e, t];
        e.indexOf(".") > -1 && (r = n,
          n = t,
          t = (i = e.split("."))[1]),
          this.addNamespaces(t);
        var s = JSe(this.data, i) || {};
        r ? eEe(s, n, o) : s = BSe({}, s, n),
          QSe(this.data, i, s),
        a.silent || this.emit("added", e, t, n)
      }
    }, {
      key: "removeResourceBundle",
      value: function(e, t) {
        this.hasResourceBundle(e, t) && delete this.data[e][t],
          this.removeNamespaces(t),
          this.emit("removed", e, t)
      }
    }, {
      key: "hasResourceBundle",
      value: function(e, t) {
        return void 0 !== this.getResource(e, t)
      }
    }, {
      key: "getResourceBundle",
      value: function(e, t) {
        return t || (t = this.options.defaultNS),
          "v1" === this.options.compatibilityAPI ? BSe({}, {}, this.getResource(e, t)) : this.getResource(e, t)
      }
    }, {
      key: "getDataByLanguage",
      value: function(e) {
        return this.data[e]
      }
    }, {
      key: "toJSON",
      value: function() {
        return this.data
      }
    }]),
    t
}()
  , sEe = {
  processors: {},
  addPostProcessor: function(e) {
    this.processors[e.name] = e
  },
  handle: function(e, t, n, r, o) {
    var a = this;
    return e.forEach((function(e) {
        a.processors[e] && (t = a.processors[e].process(t, n, r, o))
      }
    )),
      t
  }
}
  , lEe = {}
  , uEe = function(e) {
  function t(e) {
    var n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return NSe(this, t),
      n = USe(this, $Se(t).call(this)),
    oEe && GSe.call(VSe(n)),
      function(e, t, n) {
        e.forEach((function(e) {
            t[e] && (n[e] = t[e])
          }
        ))
      }(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, VSe(n)),
      n.options = r,
    void 0 === n.options.keySeparator && (n.options.keySeparator = "."),
      n.logger = WSe.create("translator"),
      n
  }
  return zSe(t, GSe),
    jSe(t, [{
      key: "changeLanguage",
      value: function(e) {
        e && (this.language = e)
      }
    }, {
      key: "exists",
      value: function(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
          interpolation: {}
        };
        if (null == e)
          return !1;
        var n = this.resolve(e, t);
        return n && void 0 !== n.res
      }
    }, {
      key: "extractFromKey",
      value: function(e, t) {
        var n = void 0 !== t.nsSeparator ? t.nsSeparator : this.options.nsSeparator;
        void 0 === n && (n = ":");
        var r = void 0 !== t.keySeparator ? t.keySeparator : this.options.keySeparator
          , o = t.ns || this.options.defaultNS;
        if (n && e.indexOf(n) > -1) {
          var a = e.match(this.interpolator.nestingRegexp);
          if (a && a.length > 0)
            return {
              key: e,
              namespaces: o
            };
          var i = e.split(n);
          (n !== r || n === r && this.options.ns.indexOf(i[0]) > -1) && (o = i.shift()),
            e = i.join(r)
        }
        return "string" == typeof o && (o = [o]),
          {
            key: e,
            namespaces: o
          }
      }
    }, {
      key: "translate",
      value: function(e, n, r) {
        var o = this;
        if ("object" !== PSe(n) && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)),
        n || (n = {}),
        null == e)
          return "";
        Array.isArray(e) || (e = [String(e)]);
        var a = void 0 !== n.keySeparator ? n.keySeparator : this.options.keySeparator
          , i = this.extractFromKey(e[e.length - 1], n)
          , s = i.key
          , l = i.namespaces
          , u = l[l.length - 1]
          , c = n.lng || this.language
          , d = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (c && "cimode" === c.toLowerCase()) {
          if (d) {
            var f = n.nsSeparator || this.options.nsSeparator;
            return u + f + s
          }
          return s
        }
        var p = this.resolve(e, n)
          , h = p && p.res
          , v = p && p.usedKey || s
          , g = p && p.exactUsedKey || s
          , m = Object.prototype.toString.apply(h)
          , y = void 0 !== n.joinArrays ? n.joinArrays : this.options.joinArrays
          , b = !this.i18nFormat || this.i18nFormat.handleAsObject;
        if (b && h && ("string" != typeof h && "boolean" != typeof h && "number" != typeof h) && ["[object Number]", "[object Function]", "[object RegExp]"].indexOf(m) < 0 && ("string" != typeof y || "[object Array]" !== m)) {
          if (!n.returnObjects && !this.options.returnObjects)
            return this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!"),
              this.options.returnedObjectHandler ? this.options.returnedObjectHandler(v, h, BSe({}, n, {
                ns: l
              })) : "key '".concat(s, " (").concat(this.language, ")' returned an object instead of string.");
          if (a) {
            var w = "[object Array]" === m
              , x = w ? [] : {}
              , S = w ? g : v;
            for (var E in h)
              if (Object.prototype.hasOwnProperty.call(h, E)) {
                var A = "".concat(S).concat(a).concat(E);
                x[E] = this.translate(A, BSe({}, n, {
                  joinArrays: !1,
                  ns: l
                })),
                x[E] === A && (x[E] = h[E])
              }
            h = x
          }
        } else if (b && "string" == typeof y && "[object Array]" === m)
          (h = h.join(y)) && (h = this.extendTranslation(h, e, n, r));
        else {
          var C = !1
            , k = !1
            , T = void 0 !== n.count && "string" != typeof n.count
            , D = t.hasDefaultValue(n)
            , O = T ? this.pluralResolver.getSuffix(c, n.count) : ""
            , _ = n["defaultValue".concat(O)] || n.defaultValue;
          !this.isValidLookup(h) && D && (C = !0,
            h = _),
          this.isValidLookup(h) || (k = !0,
            h = s);
          var R = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && k ? void 0 : h
            , L = D && _ !== h && this.options.updateMissing;
          if (k || C || L) {
            if (this.logger.log(L ? "updateKey" : "missingKey", c, u, s, L ? _ : h),
              a) {
              var I = this.resolve(s, BSe({}, n, {
                keySeparator: !1
              }));
              I && I.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
            }
            var P = []
              , F = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language);
            if ("fallback" === this.options.saveMissingTo && F && F[0])
              for (var B = 0; B < F.length; B++)
                P.push(F[B]);
            else
              "all" === this.options.saveMissingTo ? P = this.languageUtils.toResolveHierarchy(n.lng || this.language) : P.push(n.lng || this.language);
            var N = function(e, t, r) {
              o.options.missingKeyHandler ? o.options.missingKeyHandler(e, u, t, L ? r : R, L, n) : o.backendConnector && o.backendConnector.saveMissing && o.backendConnector.saveMissing(e, u, t, L ? r : R, L, n),
                o.emit("missingKey", e, u, t, h)
            };
            this.options.saveMissing && (this.options.saveMissingPlurals && T ? P.forEach((function(e) {
                o.pluralResolver.getSuffixes(e).forEach((function(t) {
                    N([e], s + t, n["defaultValue".concat(t)] || _)
                  }
                ))
              }
            )) : N(P, s, _))
          }
          h = this.extendTranslation(h, e, n, p, r),
          k && h === s && this.options.appendNamespaceToMissingKey && (h = "".concat(u, ":").concat(s)),
          (k || C) && this.options.parseMissingKeyHandler && (h = this.options.parseMissingKeyHandler(h))
        }
        return h
      }
    }, {
      key: "extendTranslation",
      value: function(e, t, n, r, o) {
        var a = this;
        if (this.i18nFormat && this.i18nFormat.parse)
          e = this.i18nFormat.parse(e, n, r.usedLng, r.usedNS, r.usedKey, {
            resolved: r
          });
        else if (!n.skipInterpolation) {
          n.interpolation && this.interpolator.init(BSe({}, n, {
            interpolation: BSe({}, this.options.interpolation, n.interpolation)
          }));
          var i, s = n.interpolation && n.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
          if (s) {
            var l = e.match(this.interpolator.nestingRegexp);
            i = l && l.length
          }
          var u = n.replace && "string" != typeof n.replace ? n.replace : n;
          if (this.options.interpolation.defaultVariables && (u = BSe({}, this.options.interpolation.defaultVariables, u)),
            e = this.interpolator.interpolate(e, u, n.lng || this.language, n),
            s) {
            var c = e.match(this.interpolator.nestingRegexp);
            i < (c && c.length) && (n.nest = !1)
          }
          !1 !== n.nest && (e = this.interpolator.nest(e, (function() {
              for (var e = arguments.length, r = new Array(e), i = 0; i < e; i++)
                r[i] = arguments[i];
              return o && o[0] === r[0] && !n.context ? (a.logger.warn("It seems you are nesting recursively key: ".concat(r[0], " in key: ").concat(t[0])),
                null) : a.translate.apply(a, r.concat([t]))
            }
          ), n)),
          n.interpolation && this.interpolator.reset()
        }
        var d = n.postProcess || this.options.postProcess
          , f = "string" == typeof d ? [d] : d;
        return null != e && f && f.length && !1 !== n.applyPostProcessor && (e = sEe.handle(f, e, t, this.options && this.options.postProcessPassResolved ? BSe({
          i18nResolved: r
        }, n) : n, this)),
          e
      }
    }, {
      key: "resolve",
      value: function(e) {
        var t, n, r, o, a, i = this, s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return "string" == typeof e && (e = [e]),
          e.forEach((function(e) {
              if (!i.isValidLookup(t)) {
                var l = i.extractFromKey(e, s)
                  , u = l.key;
                n = u;
                var c = l.namespaces;
                i.options.fallbackNS && (c = c.concat(i.options.fallbackNS));
                var d = void 0 !== s.count && "string" != typeof s.count
                  , f = void 0 !== s.context && ("string" == typeof s.context || "number" == typeof s.context) && "" !== s.context
                  , p = s.lngs ? s.lngs : i.languageUtils.toResolveHierarchy(s.lng || i.language, s.fallbackLng);
                c.forEach((function(e) {
                    i.isValidLookup(t) || (a = e,
                    !lEe["".concat(p[0], "-").concat(e)] && i.utils && i.utils.hasLoadedNamespace && !i.utils.hasLoadedNamespace(a) && (lEe["".concat(p[0], "-").concat(e)] = !0,
                      i.logger.warn('key "'.concat(n, '" for languages "').concat(p.join(", "), '" won\'t get resolved as namespace "').concat(a, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),
                      p.forEach((function(n) {
                          if (!i.isValidLookup(t)) {
                            o = n;
                            var a, l, c = u, p = [c];
                            for (i.i18nFormat && i.i18nFormat.addLookupKeys ? i.i18nFormat.addLookupKeys(p, u, n, e, s) : (d && (a = i.pluralResolver.getSuffix(n, s.count)),
                            d && f && p.push(c + a),
                            f && p.push(c += "".concat(i.options.contextSeparator).concat(s.context)),
                            d && p.push(c += a)); l = p.pop(); )
                              i.isValidLookup(t) || (r = l,
                                t = i.getResource(n, e, l, s))
                          }
                        }
                      )))
                  }
                ))
              }
            }
          )),
          {
            res: t,
            usedKey: n,
            exactUsedKey: r,
            usedLng: o,
            usedNS: a
          }
      }
    }, {
      key: "isValidLookup",
      value: function(e) {
        return !(void 0 === e || !this.options.returnNull && null === e || !this.options.returnEmptyString && "" === e)
      }
    }, {
      key: "getResource",
      value: function(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
        return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, t, n, r) : this.resourceStore.getResource(e, t, n, r)
      }
    }], [{
      key: "hasDefaultValue",
      value: function(e) {
        var t = "defaultValue";
        for (var n in e)
          if (Object.prototype.hasOwnProperty.call(e, n) && t === n.substring(0, 12) && void 0 !== e[n])
            return !0;
        return !1
      }
    }]),
    t
}();
function cEe(e) {
  return e.charAt(0).toUpperCase() + e.slice(1)
}
var dEe = function() {
  function e(t) {
    NSe(this, e),
      this.options = t,
      this.whitelist = this.options.supportedLngs || !1,
      this.supportedLngs = this.options.supportedLngs || !1,
      this.logger = WSe.create("languageUtils")
  }
  return jSe(e, [{
    key: "getScriptPartFromCode",
    value: function(e) {
      if (!e || e.indexOf("-") < 0)
        return null;
      var t = e.split("-");
      return 2 === t.length ? null : (t.pop(),
        "x" === t[t.length - 1].toLowerCase() ? null : this.formatLanguageCode(t.join("-")))
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(e) {
      if (!e || e.indexOf("-") < 0)
        return e;
      var t = e.split("-");
      return this.formatLanguageCode(t[0])
    }
  }, {
    key: "formatLanguageCode",
    value: function(e) {
      if ("string" == typeof e && e.indexOf("-") > -1) {
        var t = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"]
          , n = e.split("-");
        return this.options.lowerCaseLng ? n = n.map((function(e) {
            return e.toLowerCase()
          }
        )) : 2 === n.length ? (n[0] = n[0].toLowerCase(),
          n[1] = n[1].toUpperCase(),
        t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = cEe(n[1].toLowerCase()))) : 3 === n.length && (n[0] = n[0].toLowerCase(),
        2 === n[1].length && (n[1] = n[1].toUpperCase()),
        "sgn" !== n[0] && 2 === n[2].length && (n[2] = n[2].toUpperCase()),
        t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = cEe(n[1].toLowerCase())),
        t.indexOf(n[2].toLowerCase()) > -1 && (n[2] = cEe(n[2].toLowerCase()))),
          n.join("-")
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e
    }
  }, {
    key: "isWhitelisted",
    value: function(e) {
      return this.logger.deprecate("languageUtils.isWhitelisted", 'function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it\'s usage asap.'),
        this.isSupportedCode(e)
    }
  }, {
    key: "isSupportedCode",
    value: function(e) {
      return ("languageOnly" === this.options.load || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)),
      !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function(e) {
      var t, n = this;
      return e ? (e.forEach((function(e) {
          if (!t) {
            var r = n.formatLanguageCode(e);
            n.options.supportedLngs && !n.isSupportedCode(r) || (t = r)
          }
        }
      )),
      !t && this.options.supportedLngs && e.forEach((function(e) {
          if (!t) {
            var r = n.getLanguagePartFromCode(e);
            if (n.isSupportedCode(r))
              return t = r;
            t = n.options.supportedLngs.find((function(e) {
                if (0 === e.indexOf(r))
                  return e
              }
            ))
          }
        }
      )),
      t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]),
        t) : null
    }
  }, {
    key: "getFallbackCodes",
    value: function(e, t) {
      if (!e)
        return [];
      if ("function" == typeof e && (e = e(t)),
      "string" == typeof e && (e = [e]),
      "[object Array]" === Object.prototype.toString.apply(e))
        return e;
      if (!t)
        return e.default || [];
      var n = e[t];
      return n || (n = e[this.getScriptPartFromCode(t)]),
      n || (n = e[this.formatLanguageCode(t)]),
      n || (n = e[this.getLanguagePartFromCode(t)]),
      n || (n = e.default),
      n || []
    }
  }, {
    key: "toResolveHierarchy",
    value: function(e, t) {
      var n = this
        , r = this.getFallbackCodes(t || this.options.fallbackLng || [], e)
        , o = []
        , a = function(e) {
        e && (n.isSupportedCode(e) ? o.push(e) : n.logger.warn("rejecting language code not found in supportedLngs: ".concat(e)))
      };
      return "string" == typeof e && e.indexOf("-") > -1 ? ("languageOnly" !== this.options.load && a(this.formatLanguageCode(e)),
      "languageOnly" !== this.options.load && "currentOnly" !== this.options.load && a(this.getScriptPartFromCode(e)),
      "currentOnly" !== this.options.load && a(this.getLanguagePartFromCode(e))) : "string" == typeof e && a(this.formatLanguageCode(e)),
        r.forEach((function(e) {
            o.indexOf(e) < 0 && a(n.formatLanguageCode(e))
          }
        )),
        o
    }
  }]),
    e
}()
  , fEe = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}]
  , pEe = {
  1: function(e) {
    return Number(e > 1)
  },
  2: function(e) {
    return Number(1 != e)
  },
  3: function(e) {
    return 0
  },
  4: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2)
  },
  5: function(e) {
    return Number(0 == e ? 0 : 1 == e ? 1 : 2 == e ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5)
  },
  6: function(e) {
    return Number(1 == e ? 0 : e >= 2 && e <= 4 ? 1 : 2)
  },
  7: function(e) {
    return Number(1 == e ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2)
  },
  8: function(e) {
    return Number(1 == e ? 0 : 2 == e ? 1 : 8 != e && 11 != e ? 2 : 3)
  },
  9: function(e) {
    return Number(e >= 2)
  },
  10: function(e) {
    return Number(1 == e ? 0 : 2 == e ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4)
  },
  11: function(e) {
    return Number(1 == e || 11 == e ? 0 : 2 == e || 12 == e ? 1 : e > 2 && e < 20 ? 2 : 3)
  },
  12: function(e) {
    return Number(e % 10 != 1 || e % 100 == 11)
  },
  13: function(e) {
    return Number(0 !== e)
  },
  14: function(e) {
    return Number(1 == e ? 0 : 2 == e ? 1 : 3 == e ? 2 : 3)
  },
  15: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2)
  },
  16: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : 0 !== e ? 1 : 2)
  },
  17: function(e) {
    return Number(1 == e || e % 10 == 1 && e % 100 != 11 ? 0 : 1)
  },
  18: function(e) {
    return Number(0 == e ? 0 : 1 == e ? 1 : 2)
  },
  19: function(e) {
    return Number(1 == e ? 0 : 0 == e || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3)
  },
  20: function(e) {
    return Number(1 == e ? 0 : 0 == e || e % 100 > 0 && e % 100 < 20 ? 1 : 2)
  },
  21: function(e) {
    return Number(e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0)
  },
  22: function(e) {
    return Number(1 == e ? 0 : 2 == e ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3)
  }
};
var hEe = function() {
  function e(t) {
    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    NSe(this, e),
      this.languageUtils = t,
      this.options = n,
      this.logger = WSe.create("pluralResolver"),
      this.rules = function() {
        var e = {};
        return fEe.forEach((function(t) {
            t.lngs.forEach((function(n) {
                e[n] = {
                  numbers: t.nr,
                  plurals: pEe[t.fc]
                }
              }
            ))
          }
        )),
          e
      }()
  }
  return jSe(e, [{
    key: "addRule",
    value: function(e, t) {
      this.rules[e] = t
    }
  }, {
    key: "getRule",
    value: function(e) {
      return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)]
    }
  }, {
    key: "needsPlural",
    value: function(e) {
      var t = this.getRule(e);
      return t && t.numbers.length > 1
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(e, t) {
      return this.getSuffixes(e).map((function(e) {
          return t + e
        }
      ))
    }
  }, {
    key: "getSuffixes",
    value: function(e) {
      var t = this
        , n = this.getRule(e);
      return n ? n.numbers.map((function(n) {
          return t.getSuffix(e, n)
        }
      )) : []
    }
  }, {
    key: "getSuffix",
    value: function(e, t) {
      var n = this
        , r = this.getRule(e);
      if (r) {
        var o = r.noAbs ? r.plurals(t) : r.plurals(Math.abs(t))
          , a = r.numbers[o];
        this.options.simplifyPluralSuffix && 2 === r.numbers.length && 1 === r.numbers[0] && (2 === a ? a = "plural" : 1 === a && (a = ""));
        var i = function() {
          return n.options.prepend && a.toString() ? n.options.prepend + a.toString() : a.toString()
        };
        return "v1" === this.options.compatibilityJSON ? 1 === a ? "" : "number" == typeof a ? "_plural_".concat(a.toString()) : i() : "v2" === this.options.compatibilityJSON || this.options.simplifyPluralSuffix && 2 === r.numbers.length && 1 === r.numbers[0] ? i() : this.options.prepend && o.toString() ? this.options.prepend + o.toString() : o.toString()
      }
      return this.logger.warn("no plural rule found for: ".concat(e)),
        ""
    }
  }]),
    e
}()
  , vEe = function() {
  function e() {
    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    NSe(this, e),
      this.logger = WSe.create("interpolator"),
      this.options = t,
      this.format = t.interpolation && t.interpolation.format || function(e) {
        return e
      }
      ,
      this.init(t)
  }
  return jSe(e, [{
    key: "init",
    value: function() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      e.interpolation || (e.interpolation = {
        escapeValue: !0
      });
      var t = e.interpolation;
      this.escape = void 0 !== t.escape ? t.escape : rEe,
        this.escapeValue = void 0 === t.escapeValue || t.escapeValue,
        this.useRawValueToEscape = void 0 !== t.useRawValueToEscape && t.useRawValueToEscape,
        this.prefix = t.prefix ? tEe(t.prefix) : t.prefixEscaped || "{{",
        this.suffix = t.suffix ? tEe(t.suffix) : t.suffixEscaped || "}}",
        this.formatSeparator = t.formatSeparator ? t.formatSeparator : t.formatSeparator || ",",
        this.unescapePrefix = t.unescapeSuffix ? "" : t.unescapePrefix || "-",
        this.unescapeSuffix = this.unescapePrefix ? "" : t.unescapeSuffix || "",
        this.nestingPrefix = t.nestingPrefix ? tEe(t.nestingPrefix) : t.nestingPrefixEscaped || tEe("$t("),
        this.nestingSuffix = t.nestingSuffix ? tEe(t.nestingSuffix) : t.nestingSuffixEscaped || tEe(")"),
        this.nestingOptionsSeparator = t.nestingOptionsSeparator ? t.nestingOptionsSeparator : t.nestingOptionsSeparator || ",",
        this.maxReplaces = t.maxReplaces ? t.maxReplaces : 1e3,
        this.alwaysFormat = void 0 !== t.alwaysFormat && t.alwaysFormat,
        this.resetRegExp()
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options)
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var e = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(e,"g");
      var t = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(t,"g");
      var n = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(n,"g")
    }
  }, {
    key: "interpolate",
    value: function(e, t, n, r) {
      var o, a, i, s = this, l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function u(e) {
        return e.replace(/\$/g, "$$$$")
      }
      var c = function(e) {
        if (e.indexOf(s.formatSeparator) < 0) {
          var o = ZSe(t, l, e);
          return s.alwaysFormat ? s.format(o, void 0, n, BSe({}, r, t, {
            interpolationkey: e
          })) : o
        }
        var a = e.split(s.formatSeparator)
          , i = a.shift().trim()
          , u = a.join(s.formatSeparator).trim();
        return s.format(ZSe(t, l, i), u, n, BSe({}, r, t, {
          interpolationkey: i
        }))
      };
      this.resetRegExp();
      var d = r && r.missingInterpolationHandler || this.options.missingInterpolationHandler
        , f = r && r.interpolation && r.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
      return [{
        regex: this.regexpUnescape,
        safeValue: function(e) {
          return u(e)
        }
      }, {
        regex: this.regexp,
        safeValue: function(e) {
          return s.escapeValue ? u(s.escape(e)) : u(e)
        }
      }].forEach((function(t) {
          for (i = 0; o = t.regex.exec(e); ) {
            if (void 0 === (a = c(o[1].trim())))
              if ("function" == typeof d) {
                var n = d(e, o, r);
                a = "string" == typeof n ? n : ""
              } else {
                if (f) {
                  a = o[0];
                  continue
                }
                s.logger.warn("missed to pass in variable ".concat(o[1], " for interpolating ").concat(e)),
                  a = ""
              }
            else
              "string" == typeof a || s.useRawValueToEscape || (a = YSe(a));
            var l = t.safeValue(a);
            if (e = e.replace(o[0], l),
              f ? (t.regex.lastIndex += l.length,
                t.regex.lastIndex -= o[0].length) : t.regex.lastIndex = 0,
            ++i >= s.maxReplaces)
              break
          }
        }
      )),
        e
    }
  }, {
    key: "nest",
    value: function(e, t) {
      var n, r, o = this, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = BSe({}, a);
      function s(e, t) {
        var n = this.nestingOptionsSeparator;
        if (e.indexOf(n) < 0)
          return e;
        var r = e.split(new RegExp("".concat(n, "[ ]*{")))
          , o = "{".concat(r[1]);
        e = r[0],
          o = (o = this.interpolate(o, i)).replace(/'/g, '"');
        try {
          i = JSON.parse(o),
          t && (i = BSe({}, t, i))
        } catch (a) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(e), a),
            "".concat(e).concat(n).concat(o)
        }
        return delete i.defaultValue,
          e
      }
      for (i.applyPostProcessor = !1,
             delete i.defaultValue; n = this.nestingRegexp.exec(e); ) {
        var l = []
          , u = !1;
        if (-1 !== n[0].indexOf(this.formatSeparator) && !/{.*}/.test(n[1])) {
          var c = n[1].split(this.formatSeparator).map((function(e) {
              return e.trim()
            }
          ));
          n[1] = c.shift(),
            l = c,
            u = !0
        }
        if ((r = t(s.call(this, n[1].trim(), i), i)) && n[0] === e && "string" != typeof r)
          return r;
        "string" != typeof r && (r = YSe(r)),
        r || (this.logger.warn("missed to resolve ".concat(n[1], " for nesting ").concat(e)),
          r = ""),
        u && (r = l.reduce((function(e, t) {
            return o.format(e, t, a.lng, BSe({}, a, {
              interpolationkey: n[1].trim()
            }))
          }
        ), r.trim())),
          e = e.replace(n[0], r),
          this.regexp.lastIndex = 0
      }
      return e
    }
  }]),
    e
}()
  , gEe = function(e) {
  function t(e, n, r) {
    var o, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    return NSe(this, t),
      o = USe(this, $Se(t).call(this)),
    oEe && GSe.call(VSe(o)),
      o.backend = e,
      o.store = n,
      o.services = r,
      o.languageUtils = r.languageUtils,
      o.options = a,
      o.logger = WSe.create("backendConnector"),
      o.state = {},
      o.queue = [],
    o.backend && o.backend.init && o.backend.init(r, a.backend, a),
      o
  }
  return zSe(t, GSe),
    jSe(t, [{
      key: "queueLoad",
      value: function(e, t, n, r) {
        var o = this
          , a = []
          , i = []
          , s = []
          , l = [];
        return e.forEach((function(e) {
            var r = !0;
            t.forEach((function(t) {
                var s = "".concat(e, "|").concat(t);
                !n.reload && o.store.hasResourceBundle(e, t) ? o.state[s] = 2 : o.state[s] < 0 || (1 === o.state[s] ? i.indexOf(s) < 0 && i.push(s) : (o.state[s] = 1,
                  r = !1,
                i.indexOf(s) < 0 && i.push(s),
                a.indexOf(s) < 0 && a.push(s),
                l.indexOf(t) < 0 && l.push(t)))
              }
            )),
            r || s.push(e)
          }
        )),
        (a.length || i.length) && this.queue.push({
          pending: i,
          loaded: {},
          errors: [],
          callback: r
        }),
          {
            toLoad: a,
            pending: i,
            toLoadLanguages: s,
            toLoadNamespaces: l
          }
      }
    }, {
      key: "loaded",
      value: function(e, t, n) {
        var r = e.split("|")
          , o = r[0]
          , a = r[1];
        t && this.emit("failedLoading", o, a, t),
        n && this.store.addResourceBundle(o, a, n),
          this.state[e] = t ? -1 : 2;
        var i = {};
        this.queue.forEach((function(n) {
            var r, s, l, u, c;
            r = n.loaded,
              s = a,
              l = XSe(r, [o], Object),
              u = l.obj,
              c = l.k,
              u[c] = u[c] || [],
              u[c].push(s),
              function(e, t) {
                for (var n = e.indexOf(t); -1 !== n; )
                  e.splice(n, 1),
                    n = e.indexOf(t)
              }(n.pending, e),
            t && n.errors.push(t),
            0 !== n.pending.length || n.done || (Object.keys(n.loaded).forEach((function(e) {
                i[e] || (i[e] = []),
                n.loaded[e].length && n.loaded[e].forEach((function(t) {
                    i[e].indexOf(t) < 0 && i[e].push(t)
                  }
                ))
              }
            )),
              n.done = !0,
              n.errors.length ? n.callback(n.errors) : n.callback())
          }
        )),
          this.emit("loaded", i),
          this.queue = this.queue.filter((function(e) {
              return !e.done
            }
          ))
      }
    }, {
      key: "read",
      value: function(e, t, n) {
        var r = this
          , o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
          , a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 350
          , i = arguments.length > 5 ? arguments[5] : void 0;
        return e.length ? this.backend[n](e, t, (function(s, l) {
            s && l && o < 5 ? setTimeout((function() {
                r.read.call(r, e, t, n, o + 1, 2 * a, i)
              }
            ), a) : i(s, l)
          }
        )) : i(null, {})
      }
    }, {
      key: "prepareLoading",
      value: function(e, t) {
        var n = this
          , r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          , o = arguments.length > 3 ? arguments[3] : void 0;
        if (!this.backend)
          return this.logger.warn("No backend was added via i18next.use. Will not load resources."),
          o && o();
        "string" == typeof e && (e = this.languageUtils.toResolveHierarchy(e)),
        "string" == typeof t && (t = [t]);
        var a = this.queueLoad(e, t, r, o);
        if (!a.toLoad.length)
          return a.pending.length || o(),
            null;
        a.toLoad.forEach((function(e) {
            n.loadOne(e)
          }
        ))
      }
    }, {
      key: "load",
      value: function(e, t, n) {
        this.prepareLoading(e, t, {}, n)
      }
    }, {
      key: "reload",
      value: function(e, t, n) {
        this.prepareLoading(e, t, {
          reload: !0
        }, n)
      }
    }, {
      key: "loadOne",
      value: function(e) {
        var t = this
          , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ""
          , r = e.split("|")
          , o = r[0]
          , a = r[1];
        this.read(o, a, "read", void 0, void 0, (function(r, i) {
            r && t.logger.warn("".concat(n, "loading namespace ").concat(a, " for language ").concat(o, " failed"), r),
            !r && i && t.logger.log("".concat(n, "loaded namespace ").concat(a, " for language ").concat(o), i),
              t.loaded(e, r, i)
          }
        ))
      }
    }, {
      key: "saveMissing",
      value: function(e, t, n, r, o) {
        var a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {};
        this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(t) ? this.logger.warn('did not save key "'.concat(n, '" as the namespace "').concat(t, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!") : null != n && "" !== n && (this.backend && this.backend.create && this.backend.create(e, t, n, r, null, BSe({}, a, {
          isUpdate: o
        })),
        e && e[0] && this.store.addResource(e[0], t, n, r))
      }
    }]),
    t
}();
function mEe(e) {
  return "string" == typeof e.ns && (e.ns = [e.ns]),
  "string" == typeof e.fallbackLng && (e.fallbackLng = [e.fallbackLng]),
  "string" == typeof e.fallbackNS && (e.fallbackNS = [e.fallbackNS]),
  e.whitelist && (e.whitelist && e.whitelist.indexOf("cimode") < 0 && (e.whitelist = e.whitelist.concat(["cimode"])),
    e.supportedLngs = e.whitelist),
  e.nonExplicitWhitelist && (e.nonExplicitSupportedLngs = e.nonExplicitWhitelist),
  e.supportedLngs && e.supportedLngs.indexOf("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])),
    e
}
function yEe() {}
var bEe = function(e) {
  function t() {
    var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
    if (NSe(this, t),
      e = USe(this, $Se(t).call(this)),
    oEe && GSe.call(VSe(e)),
      e.options = mEe(n),
      e.services = {},
      e.logger = WSe,
      e.modules = {
        external: []
      },
    r && !e.isInitialized && !n.isClone) {
      if (!e.options.initImmediate)
        return e.init(n, r),
          USe(e, VSe(e));
      setTimeout((function() {
          e.init(n, r)
        }
      ), 0)
    }
    return e
  }
  return zSe(t, GSe),
    jSe(t, [{
      key: "init",
      value: function() {
        var e = this
          , t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
          , n = arguments.length > 1 ? arguments[1] : void 0;
        function r(e) {
          return e ? "function" == typeof e ? new e : e : null
        }
        if ("function" == typeof t && (n = t,
          t = {}),
        t.whitelist && !t.supportedLngs && this.logger.deprecate("whitelist", 'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.'),
        t.nonExplicitWhitelist && !t.nonExplicitSupportedLngs && this.logger.deprecate("whitelist", 'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.'),
          this.options = BSe({}, {
            debug: !1,
            initImmediate: !0,
            ns: ["translation"],
            defaultNS: ["translation"],
            fallbackLng: ["dev"],
            fallbackNS: !1,
            whitelist: !1,
            nonExplicitWhitelist: !1,
            supportedLngs: !1,
            nonExplicitSupportedLngs: !1,
            load: "all",
            preload: !1,
            simplifyPluralSuffix: !0,
            keySeparator: ".",
            nsSeparator: ":",
            pluralSeparator: "_",
            contextSeparator: "_",
            partialBundledLanguages: !1,
            saveMissing: !1,
            updateMissing: !1,
            saveMissingTo: "fallback",
            saveMissingPlurals: !0,
            missingKeyHandler: !1,
            missingInterpolationHandler: !1,
            postProcess: !1,
            postProcessPassResolved: !1,
            returnNull: !0,
            returnEmptyString: !0,
            returnObjects: !1,
            joinArrays: !1,
            returnedObjectHandler: !1,
            parseMissingKeyHandler: !1,
            appendNamespaceToMissingKey: !1,
            appendNamespaceToCIMode: !1,
            overloadTranslationOptionHandler: function(e) {
              var t = {};
              if ("object" === PSe(e[1]) && (t = e[1]),
              "string" == typeof e[1] && (t.defaultValue = e[1]),
              "string" == typeof e[2] && (t.tDescription = e[2]),
              "object" === PSe(e[2]) || "object" === PSe(e[3])) {
                var n = e[3] || e[2];
                Object.keys(n).forEach((function(e) {
                    t[e] = n[e]
                  }
                ))
              }
              return t
            },
            interpolation: {
              escapeValue: !0,
              format: function(e, t, n, r) {
                return e
              },
              prefix: "{{",
              suffix: "}}",
              formatSeparator: ",",
              unescapePrefix: "-",
              nestingPrefix: "$t(",
              nestingSuffix: ")",
              nestingOptionsSeparator: ",",
              maxReplaces: 1e3,
              skipOnVariables: !1
            }
          }, this.options, mEe(t)),
          this.format = this.options.interpolation.format,
        n || (n = yEe),
          !this.options.isClone) {
          this.modules.logger ? WSe.init(r(this.modules.logger), this.options) : WSe.init(null, this.options);
          var o = new dEe(this.options);
          this.store = new iEe(this.options.resources,this.options);
          var a = this.services;
          a.logger = WSe,
            a.resourceStore = this.store,
            a.languageUtils = o,
            a.pluralResolver = new hEe(o,{
              prepend: this.options.pluralSeparator,
              compatibilityJSON: this.options.compatibilityJSON,
              simplifyPluralSuffix: this.options.simplifyPluralSuffix
            }),
            a.interpolator = new vEe(this.options),
            a.utils = {
              hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            },
            a.backendConnector = new gEe(r(this.modules.backend),a.resourceStore,a,this.options),
            a.backendConnector.on("*", (function(t) {
                for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
                  r[o - 1] = arguments[o];
                e.emit.apply(e, [t].concat(r))
              }
            )),
          this.modules.languageDetector && (a.languageDetector = r(this.modules.languageDetector),
            a.languageDetector.init(a, this.options.detection, this.options)),
          this.modules.i18nFormat && (a.i18nFormat = r(this.modules.i18nFormat),
          a.i18nFormat.init && a.i18nFormat.init(this)),
            this.translator = new uEe(this.services,this.options),
            this.translator.on("*", (function(t) {
                for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
                  r[o - 1] = arguments[o];
                e.emit.apply(e, [t].concat(r))
              }
            )),
            this.modules.external.forEach((function(t) {
                t.init && t.init(e)
              }
            ))
        }
        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
          var i = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          i.length > 0 && "dev" !== i[0] && (this.options.lng = i[0])
        }
        this.services.languageDetector || this.options.lng || this.logger.warn("init: no languageDetector is used and no lng is defined");
        ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((function(t) {
            e[t] = function() {
              var n;
              return (n = e.store)[t].apply(n, arguments)
            }
          }
        ));
        ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((function(t) {
            e[t] = function() {
              var n;
              return (n = e.store)[t].apply(n, arguments),
                e
            }
          }
        ));
        var s = qSe()
          , l = function() {
          var t = function(t, r) {
            e.isInitialized && !e.initializedStoreOnce && e.logger.warn("init: i18next is already initialized. You should call init just once!"),
              e.isInitialized = !0,
            e.options.isClone || e.logger.log("initialized", e.options),
              e.emit("initialized", e.options),
              s.resolve(r),
              n(t, r)
          };
          if (e.languages && "v1" !== e.options.compatibilityAPI && !e.isInitialized)
            return t(null, e.t.bind(e));
          e.changeLanguage(e.options.lng, t)
        };
        return this.options.resources || !this.options.initImmediate ? l() : setTimeout(l, 0),
          s
      }
    }, {
      key: "loadResources",
      value: function(e) {
        var t = this
          , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : yEe
          , r = "string" == typeof e ? e : this.language;
        if ("function" == typeof e && (n = e),
        !this.options.resources || this.options.partialBundledLanguages) {
          if (r && "cimode" === r.toLowerCase())
            return n();
          var o = []
            , a = function(e) {
            e && t.services.languageUtils.toResolveHierarchy(e).forEach((function(e) {
                o.indexOf(e) < 0 && o.push(e)
              }
            ))
          };
          if (r)
            a(r);
          else
            this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((function(e) {
                return a(e)
              }
            ));
          this.options.preload && this.options.preload.forEach((function(e) {
              return a(e)
            }
          )),
            this.services.backendConnector.load(o, this.options.ns, n)
        } else
          n(null)
      }
    }, {
      key: "reloadResources",
      value: function(e, t, n) {
        var r = qSe();
        return e || (e = this.languages),
        t || (t = this.options.ns),
        n || (n = yEe),
          this.services.backendConnector.reload(e, t, (function(e) {
              r.resolve(),
                n(e)
            }
          )),
          r
      }
    }, {
      key: "use",
      value: function(e) {
        if (!e)
          throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
        if (!e.type)
          throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
        return "backend" === e.type && (this.modules.backend = e),
        ("logger" === e.type || e.log && e.warn && e.error) && (this.modules.logger = e),
        "languageDetector" === e.type && (this.modules.languageDetector = e),
        "i18nFormat" === e.type && (this.modules.i18nFormat = e),
        "postProcessor" === e.type && sEe.addPostProcessor(e),
        "3rdParty" === e.type && this.modules.external.push(e),
          this
      }
    }, {
      key: "changeLanguage",
      value: function(e, t) {
        var n = this;
        this.isLanguageChangingTo = e;
        var r = qSe();
        this.emit("languageChanging", e);
        var o = function(o) {
          e || o || !n.services.languageDetector || (o = []);
          var a = "string" == typeof o ? o : n.services.languageUtils.getBestMatchFromCodes(o);
          a && (n.language || (n.language = a,
            n.languages = n.services.languageUtils.toResolveHierarchy(a)),
          n.translator.language || n.translator.changeLanguage(a),
          n.services.languageDetector && n.services.languageDetector.cacheUserLanguage(a)),
            n.loadResources(a, (function(e) {
                var o, i;
                o = e,
                  (i = a) ? (n.language = i,
                    n.languages = n.services.languageUtils.toResolveHierarchy(i),
                    n.translator.changeLanguage(i),
                    n.isLanguageChangingTo = void 0,
                    n.emit("languageChanged", i),
                    n.logger.log("languageChanged", i)) : n.isLanguageChangingTo = void 0,
                  r.resolve((function() {
                      return n.t.apply(n, arguments)
                    }
                  )),
                t && t(o, (function() {
                    return n.t.apply(n, arguments)
                  }
                ))
              }
            ))
        };
        return e || !this.services.languageDetector || this.services.languageDetector.async ? !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(o) : o(e) : o(this.services.languageDetector.detect()),
          r
      }
    }, {
      key: "getFixedT",
      value: function(e, t, n) {
        var r = this
          , o = function e(t, o) {
          var a;
          if ("object" !== PSe(o)) {
            for (var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), l = 2; l < i; l++)
              s[l - 2] = arguments[l];
            a = r.options.overloadTranslationOptionHandler([t, o].concat(s))
          } else
            a = BSe({}, o);
          a.lng = a.lng || e.lng,
            a.lngs = a.lngs || e.lngs,
            a.ns = a.ns || e.ns;
          var u = r.options.keySeparator || "."
            , c = n ? "".concat(n).concat(u).concat(t) : t;
          return r.t(c, a)
        };
        return "string" == typeof e ? o.lng = e : o.lngs = e,
          o.ns = t,
          o.keyPrefix = n,
          o
      }
    }, {
      key: "t",
      value: function() {
        var e;
        return this.translator && (e = this.translator).translate.apply(e, arguments)
      }
    }, {
      key: "exists",
      value: function() {
        var e;
        return this.translator && (e = this.translator).exists.apply(e, arguments)
      }
    }, {
      key: "setDefaultNamespace",
      value: function(e) {
        this.options.defaultNS = e
      }
    }, {
      key: "hasLoadedNamespace",
      value: function(e) {
        var t = this
          , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!this.isInitialized)
          return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages),
            !1;
        if (!this.languages || !this.languages.length)
          return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages),
            !1;
        var r = this.languages[0]
          , o = !!this.options && this.options.fallbackLng
          , a = this.languages[this.languages.length - 1];
        if ("cimode" === r.toLowerCase())
          return !0;
        var i = function(e, n) {
          var r = t.services.backendConnector.state["".concat(e, "|").concat(n)];
          return -1 === r || 2 === r
        };
        if (n.precheck) {
          var s = n.precheck(this, i);
          if (void 0 !== s)
            return s
        }
        return !!this.hasResourceBundle(r, e) || !this.services.backendConnector.backend || !(!i(r, e) || o && !i(a, e))
      }
    }, {
      key: "loadNamespaces",
      value: function(e, t) {
        var n = this
          , r = qSe();
        return this.options.ns ? ("string" == typeof e && (e = [e]),
          e.forEach((function(e) {
              n.options.ns.indexOf(e) < 0 && n.options.ns.push(e)
            }
          )),
          this.loadResources((function(e) {
              r.resolve(),
              t && t(e)
            }
          )),
          r) : (t && t(),
          Promise.resolve())
      }
    }, {
      key: "loadLanguages",
      value: function(e, t) {
        var n = qSe();
        "string" == typeof e && (e = [e]);
        var r = this.options.preload || []
          , o = e.filter((function(e) {
            return r.indexOf(e) < 0
          }
        ));
        return o.length ? (this.options.preload = r.concat(o),
          this.loadResources((function(e) {
              n.resolve(),
              t && t(e)
            }
          )),
          n) : (t && t(),
          Promise.resolve())
      }
    }, {
      key: "dir",
      value: function(e) {
        return e || (e = this.languages && this.languages.length > 0 ? this.languages[0] : this.language),
          e ? ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"].indexOf(this.services.languageUtils.getLanguagePartFromCode(e)) >= 0 ? "rtl" : "ltr" : "rtl"
      }
    }, {
      key: "createInstance",
      value: function() {
        return new t(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},arguments.length > 1 ? arguments[1] : void 0)
      }
    }, {
      key: "cloneInstance",
      value: function() {
        var e = this
          , n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
          , r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : yEe
          , o = BSe({}, this.options, n, {
          isClone: !0
        })
          , a = new t(o);
        return ["store", "services", "language"].forEach((function(t) {
            a[t] = e[t]
          }
        )),
          a.services = BSe({}, this.services),
          a.services.utils = {
            hasLoadedNamespace: a.hasLoadedNamespace.bind(a)
          },
          a.translator = new uEe(a.services,a.options),
          a.translator.on("*", (function(e) {
              for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
                n[r - 1] = arguments[r];
              a.emit.apply(a, [e].concat(n))
            }
          )),
          a.init(o, r),
          a.translator.options = a.options,
          a.translator.backendConnector.services.utils = {
            hasLoadedNamespace: a.hasLoadedNamespace.bind(a)
          },
          a
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          options: this.options,
          store: this.store,
          language: this.language,
          languages: this.languages
        }
      }
    }]),
    t
}()
  , wEe = new bEe;
function xEe(e, t) {
  wEe.addResourceBundle(e, "translation", t, !0, !0)
}
wEe.init({
  lng: "zh-CN",
  resources: {}
});
var SEe = wEe.t.bind(wEe);
xEe("en", {
  editor: {
    more: "More",
    justify: "Justify",
    indent: "Indent",
    image: "Image",
    video: "Video"
  }
}),
  xEe("zh-CN", {
    editor: {
      more: "更多",
      justify: "对齐",
      indent: "缩进",
      image: "图片",
      video: "视频"
    }
  });
var EEe = D6 ? {}.toString : function() {
    return "[object " + L6(this) + "]"
  }
;
D6 || Y8(Object.prototype, "toString", EEe, {
  unsafe: !0
});
var AEe, CEe = Array.isArray || function(e) {
  return "Array" == b3(e)
}
  , kEe = function() {}, TEe = [], DEe = D3("Reflect", "construct"), OEe = /^\s*(?:class|function)\b/, _Ee = g3(OEe.exec), REe = !OEe.exec(kEe), LEe = function(e) {
  if (!k3(e))
    return !1;
  try {
    return DEe(kEe, TEe, e),
      !0
  } catch (t) {
    return !1
  }
}, IEe = !DEe || r3((function() {
    var e;
    return LEe(LEe.call) || !LEe(Object) || !LEe((function() {
        e = !0
      }
    )) || e
  }
)) ? function(e) {
    if (!k3(e))
      return !1;
    switch (L6(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    return REe || !!_Ee(OEe, R8(e))
  }
  : LEe, PEe = l8("species"), FEe = n3.Array, BEe = function(e, t) {
  return new (CEe(n = e) && (r = n.constructor,
  (IEe(r) && (r === FEe || CEe(r.prototype)) || T3(r) && null === (r = r[PEe])) && (r = void 0)),
    void 0 === r ? FEe : r)(0 === t ? 0 : t);
  var n, r
}, NEe = g3([].push), MEe = function(e) {
  var t = 1 == e
    , n = 2 == e
    , r = 3 == e
    , o = 4 == e
    , a = 6 == e
    , i = 7 == e
    , s = 5 == e || a;
  return function(l, u, c, d) {
    for (var f, p, h = Q3(l), v = S3(h), g = $5(u, c), m = o6(v), y = 0, b = d || BEe, w = t ? b(l, m) : n || i ? b(l, 0) : void 0; m > y; y++)
      if ((s || y in v) && (p = g(f = v[y], y, h),
        e))
        if (t)
          w[y] = p;
        else if (p)
          switch (e) {
            case 3:
              return !0;
            case 5:
              return f;
            case 6:
              return y;
            case 2:
              NEe(w, f)
          }
        else
          switch (e) {
            case 4:
              return !1;
            case 7:
              NEe(w, f)
          }
    return a ? -1 : r || o ? o : w
  }
}, jEe = [MEe(0), MEe(1), MEe(2), MEe(3), MEe(4), MEe(5), MEe(6), MEe(7)][0], VEe = !!(AEe = [].forEach) && r3((function() {
    AEe.call(null, (function() {
        throw 1
      }
    ), 1)
  }
)) ? [].forEach : function(e) {
  return jEe(this, e, arguments.length > 1 ? arguments[1] : void 0)
}
  , UEe = function(e) {
  if (e && e.forEach !== VEe)
    try {
      k8(e, "forEach", VEe)
    } catch (X_) {
      e.forEach = VEe
    }
};
for (var $Ee in P9)
  P9[$Ee] && UEe(n3[$Ee] && n3[$Ee].prototype);
UEe(N9),
  xEe("en", {
    common: {
      ok: "OK",
      delete: "Delete",
      enter: "Enter"
    },
    blockQuote: {
      title: "Quote"
    },
    codeBlock: {
      title: "Code block"
    },
    color: {
      color: "Font color",
      bgColor: "Back color",
      default: "Default color",
      clear: "Clear back color"
    },
    divider: {
      title: "Divider"
    },
    emotion: {
      title: "Emotion"
    },
    fontSize: {
      title: "Font size",
      default: "Default"
    },
    fontFamily: {
      title: "Font family",
      default: "Default"
    },
    fullScreen: {
      title: "Full screen"
    },
    header: {
      title: "Header",
      text: "Text"
    },
    image: {
      netImage: "Net image",
      delete: "Delete image",
      edit: "Edit image",
      viewLink: "View link",
      src: "Image src",
      desc: "Description",
      link: "Image link"
    },
    indent: {
      decrease: "Decrease",
      increase: "Increase"
    },
    justify: {
      left: "Left",
      right: "Right",
      center: "Center",
      justify: "Justify"
    },
    lineHeight: {
      title: "Line height",
      default: "Default"
    },
    link: {
      insert: "Insert link",
      text: "Link text",
      url: "Link source",
      unLink: "Unlink",
      edit: "Edit link",
      view: "View link"
    },
    textStyle: {
      bold: "Bold",
      clear: "Clear styles",
      code: "Inline code",
      italic: "Italic",
      sub: "Sub",
      sup: "Sup",
      through: "Through",
      underline: "Underline"
    },
    undo: {
      undo: "undo",
      redo: "Redo"
    },
    todo: {
      todo: "Todo"
    }
  }),
  xEe("zh-CN", {
    common: {
      ok: "确定",
      delete: "删除",
      enter: "回车"
    },
    blockQuote: {
      title: "引用"
    },
    codeBlock: {
      title: "代码块"
    },
    color: {
      color: "文字颜色",
      bgColor: "背景色",
      default: "默认颜色",
      clear: "清除背景色"
    },
    divider: {
      title: "分割线"
    },
    emotion: {
      title: "表情"
    },
    fontSize: {
      title: "字号",
      default: "默认字号"
    },
    fontFamily: {
      title: "字体",
      default: "默认字体"
    },
    fullScreen: {
      title: "全屏"
    },
    header: {
      title: "标题",
      text: "正文"
    },
    image: {
      netImage: "网络图片",
      delete: "删除图片",
      edit: "编辑图片",
      viewLink: "查看链接",
      src: "图片地址",
      desc: "图片描述",
      link: "图片链接"
    },
    indent: {
      decrease: "减少缩进",
      increase: "增加缩进"
    },
    justify: {
      left: "左对齐",
      right: "右对齐",
      center: "居中对齐",
      justify: "两端对齐"
    },
    lineHeight: {
      title: "行高",
      default: "默认行高"
    },
    link: {
      insert: "插入链接",
      text: "链接文本",
      url: "链接地址",
      unLink: "取消链接",
      edit: "修改链接",
      view: "查看链接"
    },
    textStyle: {
      bold: "粗体",
      clear: "清除格式",
      code: "行内代码",
      italic: "斜体",
      sub: "下标",
      sup: "上标",
      through: "删除线",
      underline: "下划线"
    },
    undo: {
      undo: "撤销",
      redo: "重做"
    },
    todo: {
      todo: "待办"
    }
  });
var HEe = {
  type: "paragraph",
  renderElem: function(e, t, n) {
    return $ae("p", null, t)
  }
}
  , zEe = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function KEe(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports),
    t.exports
}
var WEe, GEe, qEe = function(e) {
  return e && e.Math == Math && e
}, YEe = qEe("object" == typeof globalThis && globalThis) || qEe("object" == typeof window && window) || qEe("object" == typeof self && self) || qEe("object" == typeof zEe && zEe) || function() {
  return this
}() || Function("return this")(), XEe = function(e) {
  try {
    return !!e()
  } catch (t) {
    return !0
  }
}, QEe = !XEe((function() {
    return 7 != Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1]
  }
)), JEe = Function.prototype.call, ZEe = JEe.bind ? JEe.bind(JEe) : function() {
  return JEe.apply(JEe, arguments)
}
  , eAe = {}.propertyIsEnumerable, tAe = Object.getOwnPropertyDescriptor, nAe = tAe && !eAe.call({
  1: 2
}, 1) ? function(e) {
    var t = tAe(this, e);
    return !!t && t.enumerable
  }
  : eAe, rAe = {
  f: nAe
}, oAe = function(e, t) {
  return {
    enumerable: !(1 & e),
    configurable: !(2 & e),
    writable: !(4 & e),
    value: t
  }
}, aAe = Function.prototype, iAe = aAe.bind, sAe = aAe.call, lAe = iAe && iAe.bind(sAe), uAe = iAe ? function(e) {
    return e && lAe(sAe, e)
  }
  : function(e) {
    return e && function() {
      return sAe.apply(e, arguments)
    }
  }
  , cAe = uAe({}.toString), dAe = uAe("".slice), fAe = function(e) {
  return dAe(cAe(e), 8, -1)
}, pAe = YEe.Object, hAe = uAe("".split), vAe = XEe((function() {
    return !pAe("z").propertyIsEnumerable(0)
  }
)) ? function(e) {
    return "String" == fAe(e) ? hAe(e, "") : pAe(e)
  }
  : pAe, gAe = YEe.TypeError, mAe = function(e) {
  if (null == e)
    throw gAe("Can't call method on " + e);
  return e
}, yAe = function(e) {
  return vAe(mAe(e))
}, bAe = function(e) {
  return "function" == typeof e
}, wAe = function(e) {
  return "object" == typeof e ? null !== e : bAe(e)
}, xAe = function(e, t) {
  return arguments.length < 2 ? function(e) {
    return bAe(e) ? e : void 0
  }(YEe[e]) : YEe[e] && YEe[e][t]
}, SAe = uAe({}.isPrototypeOf), EAe = xAe("navigator", "userAgent") || "", AAe = YEe.process, CAe = YEe.Deno, kAe = AAe && AAe.versions || CAe && CAe.version, TAe = kAe && kAe.v8;
TAe && (GEe = (WEe = TAe.split("."))[0] > 0 && WEe[0] < 4 ? 1 : +(WEe[0] + WEe[1])),
!GEe && EAe && (!(WEe = EAe.match(/Edge\/(\d+)/)) || WEe[1] >= 74) && (WEe = EAe.match(/Chrome\/(\d+)/)) && (GEe = +WEe[1]);
var DAe = GEe
  , OAe = !!Object.getOwnPropertySymbols && !XEe((function() {
    var e = Symbol();
    return !String(e) || !(Object(e)instanceof Symbol) || !Symbol.sham && DAe && DAe < 41
  }
))
  , _Ae = OAe && !Symbol.sham && "symbol" == typeof Symbol.iterator
  , RAe = YEe.Object
  , LAe = _Ae ? function(e) {
    return "symbol" == typeof e
  }
  : function(e) {
    var t = xAe("Symbol");
    return bAe(t) && SAe(t.prototype, RAe(e))
  }
  , IAe = YEe.String
  , PAe = function(e) {
  try {
    return IAe(e)
  } catch (t) {
    return "Object"
  }
}
  , FAe = YEe.TypeError
  , BAe = function(e) {
  if (bAe(e))
    return e;
  throw FAe(PAe(e) + " is not a function")
}
  , NAe = function(e, t) {
  var n = e[t];
  return null == n ? void 0 : BAe(n)
}
  , MAe = YEe.TypeError
  , jAe = Object.defineProperty
  , VAe = function(e, t) {
  try {
    jAe(YEe, e, {
      value: t,
      configurable: !0,
      writable: !0
    })
  } catch (AEe) {
    YEe[e] = t
  }
  return t
}
  , UAe = YEe["__core-js_shared__"] || VAe("__core-js_shared__", {})
  , $Ae = KEe((function(e) {
    (e.exports = function(e, t) {
        return UAe[e] || (UAe[e] = void 0 !== t ? t : {})
      }
    )("versions", []).push({
      version: "3.19.3",
      mode: "global",
      copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
    })
  }
))
  , HAe = YEe.Object
  , zAe = function(e) {
  return HAe(mAe(e))
}
  , KAe = uAe({}.hasOwnProperty)
  , WAe = Object.hasOwn || function(e, t) {
  return KAe(zAe(e), t)
}
  , GAe = 0
  , qAe = Math.random()
  , YAe = uAe(1..toString)
  , XAe = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + YAe(++GAe + qAe, 36)
}
  , QAe = $Ae("wks")
  , JAe = YEe.Symbol
  , ZAe = JAe && JAe.for
  , eCe = _Ae ? JAe : JAe && JAe.withoutSetter || XAe
  , tCe = function(e) {
  if (!WAe(QAe, e) || !OAe && "string" != typeof QAe[e]) {
    var t = "Symbol." + e;
    OAe && WAe(JAe, e) ? QAe[e] = JAe[e] : QAe[e] = _Ae && ZAe ? ZAe(t) : eCe(t)
  }
  return QAe[e]
}
  , nCe = YEe.TypeError
  , rCe = tCe("toPrimitive")
  , oCe = function(e) {
  var t = function(e, t) {
    if (!wAe(e) || LAe(e))
      return e;
    var n, r = NAe(e, rCe);
    if (r) {
      if (void 0 === t && (t = "default"),
        n = ZEe(r, e, t),
      !wAe(n) || LAe(n))
        return n;
      throw nCe("Can't convert object to primitive value")
    }
    return void 0 === t && (t = "number"),
      function(e, t) {
        var n, r;
        if ("string" === t && bAe(n = e.toString) && !wAe(r = ZEe(n, e)))
          return r;
        if (bAe(n = e.valueOf) && !wAe(r = ZEe(n, e)))
          return r;
        if ("string" !== t && bAe(n = e.toString) && !wAe(r = ZEe(n, e)))
          return r;
        throw MAe("Can't convert object to primitive value")
      }(e, t)
  }(e, "string");
  return LAe(t) ? t : t + ""
}
  , aCe = YEe.document
  , iCe = wAe(aCe) && wAe(aCe.createElement)
  , sCe = function(e) {
  return iCe ? aCe.createElement(e) : {}
}
  , lCe = !QEe && !XEe((function() {
    return 7 != Object.defineProperty(sCe("div"), "a", {
      get: function() {
        return 7
      }
    }).a
  }
))
  , uCe = Object.getOwnPropertyDescriptor
  , cCe = {
  f: QEe ? uCe : function(e, t) {
    if (e = yAe(e),
      t = oCe(t),
      lCe)
      try {
        return uCe(e, t)
      } catch (n) {}
    if (WAe(e, t))
      return oAe(!ZEe(rAe.f, e, t), e[t])
  }
}
  , dCe = YEe.String
  , fCe = YEe.TypeError
  , pCe = function(e) {
  if (wAe(e))
    return e;
  throw fCe(dCe(e) + " is not an object")
}
  , hCe = YEe.TypeError
  , vCe = Object.defineProperty
  , gCe = {
  f: QEe ? vCe : function(e, t, n) {
    if (pCe(e),
      t = oCe(t),
      pCe(n),
      lCe)
      try {
        return vCe(e, t, n)
      } catch (r) {}
    if ("get"in n || "set"in n)
      throw hCe("Accessors not supported");
    return "value"in n && (e[t] = n.value),
      e
  }
}
  , mCe = QEe ? function(e, t, n) {
    return gCe.f(e, t, oAe(1, n))
  }
  : function(e, t, n) {
    return e[t] = n,
      e
  }
  , yCe = uAe(Function.toString);
bAe(UAe.inspectSource) || (UAe.inspectSource = function(e) {
    return yCe(e)
  }
);
var bCe, wCe, xCe, SCe = UAe.inspectSource, ECe = YEe.WeakMap, ACe = bAe(ECe) && /native code/.test(SCe(ECe)), CCe = $Ae("keys"), kCe = function(e) {
  return CCe[e] || (CCe[e] = XAe(e))
}, TCe = {}, DCe = YEe.TypeError, OCe = YEe.WeakMap;
if (ACe || UAe.state) {
  var _Ce = UAe.state || (UAe.state = new OCe)
    , RCe = uAe(_Ce.get)
    , LCe = uAe(_Ce.has)
    , ICe = uAe(_Ce.set);
  bCe = function(e, t) {
    if (LCe(_Ce, e))
      throw new DCe("Object already initialized");
    return t.facade = e,
      ICe(_Ce, e, t),
      t
  }
    ,
    wCe = function(e) {
      return RCe(_Ce, e) || {}
    }
    ,
    xCe = function(e) {
      return LCe(_Ce, e)
    }
} else {
  var PCe = kCe("state");
  TCe[PCe] = !0,
    bCe = function(e, t) {
      if (WAe(e, PCe))
        throw new DCe("Object already initialized");
      return t.facade = e,
        mCe(e, PCe, t),
        t
    }
    ,
    wCe = function(e) {
      return WAe(e, PCe) ? e[PCe] : {}
    }
    ,
    xCe = function(e) {
      return WAe(e, PCe)
    }
}
var FCe = {
  set: bCe,
  get: wCe,
  has: xCe,
  enforce: function(e) {
    return xCe(e) ? wCe(e) : bCe(e, {})
  },
  getterFor: function(e) {
    return function(t) {
      var n;
      if (!wAe(t) || (n = wCe(t)).type !== e)
        throw DCe("Incompatible receiver, " + e + " required");
      return n
    }
  }
}
  , BCe = Function.prototype
  , NCe = QEe && Object.getOwnPropertyDescriptor
  , MCe = WAe(BCe, "name")
  , jCe = {
  EXISTS: MCe,
  PROPER: MCe && "something" === function() {}
    .name,
  CONFIGURABLE: MCe && (!QEe || QEe && NCe(BCe, "name").configurable)
}
  , VCe = KEe((function(e) {
    var t = jCe.CONFIGURABLE
      , n = FCe.get
      , r = FCe.enforce
      , o = String(String).split("String");
    (e.exports = function(e, n, a, i) {
        var s, l = !!i && !!i.unsafe, u = !!i && !!i.enumerable, c = !!i && !!i.noTargetGet, d = i && void 0 !== i.name ? i.name : n;
        bAe(a) && ("Symbol(" === String(d).slice(0, 7) && (d = "[" + String(d).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
        (!WAe(a, "name") || t && a.name !== d) && mCe(a, "name", d),
        (s = r(a)).source || (s.source = o.join("string" == typeof d ? d : ""))),
          e !== YEe ? (l ? !c && e[n] && (u = !0) : delete e[n],
            u ? e[n] = a : mCe(e, n, a)) : u ? e[n] = a : VAe(n, a)
      }
    )(Function.prototype, "toString", (function() {
        return bAe(this) && n(this).source || SCe(this)
      }
    ))
  }
))
  , UCe = Math.ceil
  , $Ce = Math.floor
  , HCe = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : (t > 0 ? $Ce : UCe)(t)
}
  , zCe = Math.max
  , KCe = Math.min
  , WCe = function(e, t) {
  var n = HCe(e);
  return n < 0 ? zCe(n + t, 0) : KCe(n, t)
}
  , GCe = Math.min
  , qCe = function(e) {
  return e > 0 ? GCe(HCe(e), 9007199254740991) : 0
}
  , YCe = function(e) {
  return qCe(e.length)
}
  , XCe = function(e) {
  return function(t, n, r) {
    var o, a = yAe(t), i = YCe(a), s = WCe(r, i);
    if (e && n != n) {
      for (; i > s; )
        if ((o = a[s++]) != o)
          return !0
    } else
      for (; i > s; s++)
        if ((e || s in a) && a[s] === n)
          return e || s || 0;
    return !e && -1
  }
}
  , QCe = {
  includes: XCe(!0),
  indexOf: XCe(!1)
}
  , JCe = QCe.indexOf
  , ZCe = uAe([].push)
  , eke = function(e, t) {
  var n, r = yAe(e), o = 0, a = [];
  for (n in r)
    !WAe(TCe, n) && WAe(r, n) && ZCe(a, n);
  for (; t.length > o; )
    WAe(r, n = t[o++]) && (~JCe(a, n) || ZCe(a, n));
  return a
}
  , tke = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
  , nke = tke.concat("length", "prototype")
  , rke = {
  f: Object.getOwnPropertyNames || function(e) {
    return eke(e, nke)
  }
}
  , oke = {
  f: Object.getOwnPropertySymbols
}
  , ake = uAe([].concat)
  , ike = xAe("Reflect", "ownKeys") || function(e) {
  var t = rke.f(pCe(e))
    , n = oke.f;
  return n ? ake(t, n(e)) : t
}
  , ske = function(e, t) {
  for (var n = ike(t), r = gCe.f, o = cCe.f, a = 0; a < n.length; a++) {
    var i = n[a];
    WAe(e, i) || r(e, i, o(t, i))
  }
}
  , lke = /#|\.prototype\./
  , uke = function(e, t) {
  var n = dke[cke(e)];
  return n == pke || n != fke && (bAe(t) ? XEe(t) : !!t)
}
  , cke = uke.normalize = function(e) {
  return String(e).replace(lke, ".").toLowerCase()
}
  , dke = uke.data = {}
  , fke = uke.NATIVE = "N"
  , pke = uke.POLYFILL = "P"
  , hke = uke
  , vke = cCe.f
  , gke = function(e, t) {
  var n, r, o, a, i, s = e.target, l = e.global, u = e.stat;
  if (n = l ? YEe : u ? YEe[s] || VAe(s, {}) : (YEe[s] || {}).prototype)
    for (r in t) {
      if (a = t[r],
        o = e.noTargetGet ? (i = vke(n, r)) && i.value : n[r],
      !hke(l ? r : s + (u ? "." : "#") + r, e.forced) && void 0 !== o) {
        if (typeof a == typeof o)
          continue;
        ske(a, o)
      }
      (e.sham || o && o.sham) && mCe(a, "sham", !0),
        VCe(n, r, a, e)
    }
}
  , mke = uAe(uAe.bind)
  , yke = Array.isArray || function(e) {
  return "Array" == fAe(e)
}
  , bke = {};
bke[tCe("toStringTag")] = "z";
var wke = "[object z]" === String(bke)
  , xke = tCe("toStringTag")
  , Ske = YEe.Object
  , Eke = "Arguments" == fAe(function() {
  return arguments
}())
  , Ake = wke ? fAe : function(e) {
  var t, n, r;
  return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
    try {
      return e[t]
    } catch (n) {}
  }(t = Ske(e), xke)) ? n : Eke ? fAe(t) : "Object" == (r = fAe(t)) && bAe(t.callee) ? "Arguments" : r
}
  , Cke = function() {}
  , kke = []
  , Tke = xAe("Reflect", "construct")
  , Dke = /^\s*(?:class|function)\b/
  , Oke = uAe(Dke.exec)
  , _ke = !Dke.exec(Cke)
  , Rke = function(e) {
  if (!bAe(e))
    return !1;
  try {
    return Tke(Cke, kke, e),
      !0
  } catch (t) {
    return !1
  }
}
  , Lke = !Tke || XEe((function() {
    var e;
    return Rke(Rke.call) || !Rke(Object) || !Rke((function() {
        e = !0
      }
    )) || e
  }
)) ? function(e) {
    if (!bAe(e))
      return !1;
    switch (Ake(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    return _ke || !!Oke(Dke, SCe(e))
  }
  : Rke
  , Ike = tCe("species")
  , Pke = YEe.Array
  , Fke = function(e, t) {
  return new (yke(n = e) && (r = n.constructor,
  (Lke(r) && (r === Pke || yke(r.prototype)) || wAe(r) && null === (r = r[Ike])) && (r = void 0)),
    void 0 === r ? Pke : r)(0 === t ? 0 : t);
  var n, r
}
  , Bke = uAe([].push)
  , Nke = function(e) {
  var t = 1 == e
    , n = 2 == e
    , r = 3 == e
    , o = 4 == e
    , a = 6 == e
    , i = 7 == e
    , s = 5 == e || a;
  return function(l, u, c, d) {
    for (var f, p, h = zAe(l), v = vAe(h), g = function(e, t) {
      return BAe(e),
        void 0 === t ? e : mke ? mke(e, t) : function() {
          return e.apply(t, arguments)
        }
    }(u, c), m = YCe(v), y = 0, b = d || Fke, w = t ? b(l, m) : n || i ? b(l, 0) : void 0; m > y; y++)
      if ((s || y in v) && (p = g(f = v[y], y, h),
        e))
        if (t)
          w[y] = p;
        else if (p)
          switch (e) {
            case 3:
              return !0;
            case 5:
              return f;
            case 6:
              return y;
            case 2:
              Bke(w, f)
          }
        else
          switch (e) {
            case 4:
              return !1;
            case 7:
              Bke(w, f)
          }
    return a ? -1 : r || o ? o : w
  }
}
  , Mke = {
  forEach: Nke(0),
  map: Nke(1),
  filter: Nke(2),
  some: Nke(3),
  every: Nke(4),
  find: Nke(5),
  findIndex: Nke(6),
  filterReject: Nke(7)
}
  , jke = tCe("species")
  , Vke = function(e) {
  return DAe >= 51 || !XEe((function() {
      var t = [];
      return (t.constructor = {})[jke] = function() {
        return {
          foo: 1
        }
      }
        ,
      1 !== t[e](Boolean).foo
    }
  ))
}
  , Uke = Mke.filter;
gke({
  target: "Array",
  proto: !0,
  forced: !Vke("filter")
}, {
  filter: function(e) {
    return Uke(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var $ke = wke ? {}.toString : function() {
    return "[object " + Ake(this) + "]"
  }
;
wke || VCe(Object.prototype, "toString", $ke, {
  unsafe: !0
});
var Hke, zke = YEe.String, Kke = function(e) {
  if ("Symbol" === Ake(e))
    throw TypeError("Cannot convert a Symbol value to a string");
  return zke(e)
}, Wke = function() {
  var e = pCe(this)
    , t = "";
  return e.global && (t += "g"),
  e.ignoreCase && (t += "i"),
  e.multiline && (t += "m"),
  e.dotAll && (t += "s"),
  e.unicode && (t += "u"),
  e.sticky && (t += "y"),
    t
}, Gke = YEe.RegExp, qke = XEe((function() {
    var e = Gke("a", "y");
    return e.lastIndex = 2,
    null != e.exec("abcd")
  }
)), Yke = qke || XEe((function() {
    return !Gke("a", "y").sticky
  }
)), Xke = {
  BROKEN_CARET: qke || XEe((function() {
      var e = Gke("^r", "gy");
      return e.lastIndex = 2,
      null != e.exec("str")
    }
  )),
  MISSED_STICKY: Yke,
  UNSUPPORTED_Y: qke
}, Qke = Object.keys || function(e) {
  return eke(e, tke)
}
  , Jke = QEe ? Object.defineProperties : function(e, t) {
  pCe(e);
  for (var n, r = yAe(t), o = Qke(t), a = o.length, i = 0; a > i; )
    gCe.f(e, n = o[i++], r[n]);
  return e
}
  , Zke = xAe("document", "documentElement"), eTe = kCe("IE_PROTO"), tTe = function() {}, nTe = function(e) {
  return "<script>" + e + "<\/script>"
}, rTe = function(e) {
  e.write(nTe("")),
    e.close();
  var t = e.parentWindow.Object;
  return e = null,
    t
}, oTe = function() {
  try {
    Hke = new ActiveXObject("htmlfile")
  } catch (r) {}
  var e, t;
  oTe = "undefined" != typeof document ? document.domain && Hke ? rTe(Hke) : ((t = sCe("iframe")).style.display = "none",
    Zke.appendChild(t),
    t.src = String("javascript:"),
    (e = t.contentWindow.document).open(),
    e.write(nTe("document.F=Object")),
    e.close(),
    e.F) : rTe(Hke);
  for (var n = tke.length; n--; )
    delete oTe.prototype[tke[n]];
  return oTe()
};
TCe[eTe] = !0;
var aTe, iTe, sTe = Object.create || function(e, t) {
  var n;
  return null !== e ? (tTe.prototype = pCe(e),
    n = new tTe,
    tTe.prototype = null,
    n[eTe] = e) : n = oTe(),
    void 0 === t ? n : Jke(n, t)
}
  , lTe = YEe.RegExp, uTe = XEe((function() {
    var e = lTe(".", "s");
    return !(e.dotAll && e.exec("\n") && "s" === e.flags)
  }
)), cTe = YEe.RegExp, dTe = XEe((function() {
    var e = cTe("(?<a>b)", "g");
    return "b" !== e.exec("b").groups.a || "bc" !== "b".replace(e, "$<a>c")
  }
)), fTe = FCe.get, pTe = $Ae("native-string-replace", String.prototype.replace), hTe = RegExp.prototype.exec, vTe = hTe, gTe = uAe("".charAt), mTe = uAe("".indexOf), yTe = uAe("".replace), bTe = uAe("".slice), wTe = (iTe = /b*/g,
  ZEe(hTe, aTe = /a/, "a"),
  ZEe(hTe, iTe, "a"),
0 !== aTe.lastIndex || 0 !== iTe.lastIndex), xTe = Xke.BROKEN_CARET, STe = void 0 !== /()??/.exec("")[1];
(wTe || STe || xTe || uTe || dTe) && (vTe = function(e) {
    var t, n, r, o, a, i, s, l = this, u = fTe(l), c = Kke(e), d = u.raw;
    if (d)
      return d.lastIndex = l.lastIndex,
        t = ZEe(vTe, d, c),
        l.lastIndex = d.lastIndex,
        t;
    var f = u.groups
      , p = xTe && l.sticky
      , h = ZEe(Wke, l)
      , v = l.source
      , g = 0
      , m = c;
    if (p && (h = yTe(h, "y", ""),
    -1 === mTe(h, "g") && (h += "g"),
      m = bTe(c, l.lastIndex),
    l.lastIndex > 0 && (!l.multiline || l.multiline && "\n" !== gTe(c, l.lastIndex - 1)) && (v = "(?: " + v + ")",
      m = " " + m,
      g++),
      n = new RegExp("^(?:" + v + ")",h)),
    STe && (n = new RegExp("^" + v + "$(?!\\s)",h)),
    wTe && (r = l.lastIndex),
      o = ZEe(hTe, p ? n : l, m),
      p ? o ? (o.input = bTe(o.input, g),
        o[0] = bTe(o[0], g),
        o.index = l.lastIndex,
        l.lastIndex += o[0].length) : l.lastIndex = 0 : wTe && o && (l.lastIndex = l.global ? o.index + o[0].length : r),
    STe && o && o.length > 1 && ZEe(pTe, o[0], n, (function() {
        for (a = 1; a < arguments.length - 2; a++)
          void 0 === arguments[a] && (o[a] = void 0)
      }
    )),
    o && f)
      for (o.groups = i = sTe(null),
             a = 0; a < f.length; a++)
        i[(s = f[a])[0]] = o[s[1]];
    return o
  }
);
var ETe = vTe;
gke({
  target: "RegExp",
  proto: !0,
  forced: /./.exec !== ETe
}, {
  exec: ETe
});
var ATe = Function.prototype
  , CTe = ATe.apply
  , kTe = ATe.bind
  , TTe = ATe.call
  , DTe = "object" == typeof Reflect && Reflect.apply || (kTe ? TTe.bind(CTe) : function() {
    return TTe.apply(CTe, arguments)
  }
)
  , OTe = tCe("species")
  , _Te = RegExp.prototype
  , RTe = function(e, t, n, r) {
  var o = tCe(e)
    , a = !XEe((function() {
      var t = {};
      return t[o] = function() {
        return 7
      }
        ,
      7 != ""[e](t)
    }
  ))
    , i = a && !XEe((function() {
      var t = !1
        , n = /a/;
      return "split" === e && ((n = {}).constructor = {},
        n.constructor[OTe] = function() {
          return n
        }
        ,
        n.flags = "",
        n[o] = /./[o]),
        n.exec = function() {
          return t = !0,
            null
        }
        ,
        n[o](""),
        !t
    }
  ));
  if (!a || !i || n) {
    var s = uAe(/./[o])
      , l = t(o, ""[e], (function(e, t, n, r, o) {
        var i = uAe(e)
          , l = t.exec;
        return l === ETe || l === _Te.exec ? a && !o ? {
          done: !0,
          value: s(t, n, r)
        } : {
          done: !0,
          value: i(n, t, r)
        } : {
          done: !1
        }
      }
    ));
    VCe(String.prototype, e, l[0]),
      VCe(_Te, o, l[1])
  }
  r && mCe(_Te[o], "sham", !0)
}
  , LTe = uAe("".charAt)
  , ITe = uAe("".charCodeAt)
  , PTe = uAe("".slice)
  , FTe = function(e) {
  return function(t, n) {
    var r, o, a = Kke(mAe(t)), i = HCe(n), s = a.length;
    return i < 0 || i >= s ? e ? "" : void 0 : (r = ITe(a, i)) < 55296 || r > 56319 || i + 1 === s || (o = ITe(a, i + 1)) < 56320 || o > 57343 ? e ? LTe(a, i) : r : e ? PTe(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536
  }
}(!0)
  , BTe = function(e, t, n) {
  return t + (n ? FTe(e, t).length : 1)
}
  , NTe = Math.floor
  , MTe = uAe("".charAt)
  , jTe = uAe("".replace)
  , VTe = uAe("".slice)
  , UTe = /\$([$&'`]|\d{1,2}|<[^>]*>)/g
  , $Te = /\$([$&'`]|\d{1,2})/g
  , HTe = function(e, t, n, r, o, a) {
  var i = n + e.length
    , s = r.length
    , l = $Te;
  return void 0 !== o && (o = zAe(o),
    l = UTe),
    jTe(a, l, (function(a, l) {
        var u;
        switch (MTe(l, 0)) {
          case "$":
            return "$";
          case "&":
            return e;
          case "`":
            return VTe(t, 0, n);
          case "'":
            return VTe(t, i);
          case "<":
            u = o[VTe(l, 1, -1)];
            break;
          default:
            var c = +l;
            if (0 === c)
              return a;
            if (c > s) {
              var d = NTe(c / 10);
              return 0 === d ? a : d <= s ? void 0 === r[d - 1] ? MTe(l, 1) : r[d - 1] + MTe(l, 1) : a
            }
            u = r[c - 1]
        }
        return void 0 === u ? "" : u
      }
    ))
}
  , zTe = YEe.TypeError
  , KTe = function(e, t) {
  var n = e.exec;
  if (bAe(n)) {
    var r = ZEe(n, e, t);
    return null !== r && pCe(r),
      r
  }
  if ("RegExp" === fAe(e))
    return ZEe(ETe, e, t);
  throw zTe("RegExp#exec called on incompatible receiver")
}
  , WTe = tCe("replace")
  , GTe = Math.max
  , qTe = Math.min
  , YTe = uAe([].concat)
  , XTe = uAe([].push)
  , QTe = uAe("".indexOf)
  , JTe = uAe("".slice)
  , ZTe = "$0" === "a".replace(/./, "$0")
  , eDe = !!/./[WTe] && "" === /./[WTe]("a", "$0");
RTe("replace", (function(e, t, n) {
    var r = eDe ? "$" : "$0";
    return [function(e, n) {
      var r = mAe(this)
        , o = null == e ? void 0 : NAe(e, WTe);
      return o ? ZEe(o, e, r, n) : ZEe(t, Kke(r), e, n)
    }
      , function(e, o) {
        var a = pCe(this)
          , i = Kke(e);
        if ("string" == typeof o && -1 === QTe(o, r) && -1 === QTe(o, "$<")) {
          var s = n(t, a, i, o);
          if (s.done)
            return s.value
        }
        var l = bAe(o);
        l || (o = Kke(o));
        var u = a.global;
        if (u) {
          var c = a.unicode;
          a.lastIndex = 0
        }
        for (var d = []; ; ) {
          var f = KTe(a, i);
          if (null === f)
            break;
          if (XTe(d, f),
            !u)
            break;
          "" === Kke(f[0]) && (a.lastIndex = BTe(i, qCe(a.lastIndex), c))
        }
        for (var p, h = "", v = 0, g = 0; g < d.length; g++) {
          for (var m = Kke((f = d[g])[0]), y = GTe(qTe(HCe(f.index), i.length), 0), b = [], w = 1; w < f.length; w++)
            XTe(b, void 0 === (p = f[w]) ? p : String(p));
          var x = f.groups;
          if (l) {
            var S = YTe([m], b, y, i);
            void 0 !== x && XTe(S, x);
            var E = Kke(DTe(o, void 0, S))
          } else
            E = HTe(m, i, y, b, x, o);
          y >= v && (h += JTe(i, v, y) + E,
            v = y + m.length)
        }
        return h + JTe(i, v)
      }
    ]
  }
), !!XEe((function() {
    var e = /./;
    return e.exec = function() {
      var e = [];
      return e.groups = {
        a: "7"
      },
        e
    }
      ,
    "7" !== "".replace(e, "$<a>")
  }
)) || !ZTe || eDe);
var tDe = tCe("unscopables")
  , nDe = Array.prototype;
null == nDe[tDe] && gCe.f(nDe, tDe, {
  configurable: !0,
  value: sTe(null)
});
var rDe = function(e) {
  nDe[tDe][e] = !0
}
  , oDe = Mke.find
  , aDe = !0;
"find"in [] && Array(1).find((function() {
    aDe = !1
  }
)),
  gke({
    target: "Array",
    proto: !0,
    forced: aDe
  }, {
    find: function(e) {
      return oDe(this, e, arguments.length > 1 ? arguments[1] : void 0)
    }
  }),
  rDe("find");
var iDe = tCe("match")
  , sDe = function(e) {
  var t;
  return wAe(e) && (void 0 !== (t = e[iDe]) ? !!t : "RegExp" == fAe(e))
}
  , lDe = YEe.TypeError
  , uDe = tCe("species")
  , cDe = function(e, t, n) {
  var r = oCe(t);
  r in e ? gCe.f(e, r, oAe(0, n)) : e[r] = n
}
  , dDe = YEe.Array
  , fDe = Math.max
  , pDe = function(e, t, n) {
  for (var r = YCe(e), o = WCe(t, r), a = WCe(void 0 === n ? r : n, r), i = dDe(fDe(a - o, 0)), s = 0; o < a; o++,
    s++)
    cDe(i, s, e[o]);
  return i.length = s,
    i
}
  , hDe = Xke.UNSUPPORTED_Y
  , vDe = Math.min
  , gDe = [].push
  , mDe = uAe(/./.exec)
  , yDe = uAe(gDe)
  , bDe = uAe("".slice);
RTe("split", (function(e, t, n) {
    var r;
    return r = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e, n) {
        var r = Kke(mAe(this))
          , o = void 0 === n ? 4294967295 : n >>> 0;
        if (0 === o)
          return [];
        if (void 0 === e)
          return [r];
        if (!sDe(e))
          return ZEe(t, r, e, o);
        for (var a, i, s, l = [], u = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), c = 0, d = new RegExp(e.source,u + "g"); (a = ZEe(ETe, d, r)) && !((i = d.lastIndex) > c && (yDe(l, bDe(r, c, a.index)),
        a.length > 1 && a.index < r.length && DTe(gDe, l, pDe(a, 1)),
          s = a[0].length,
          c = i,
        l.length >= o)); )
          d.lastIndex === a.index && d.lastIndex++;
        return c === r.length ? !s && mDe(d, "") || yDe(l, "") : yDe(l, bDe(r, c)),
          l.length > o ? pDe(l, 0, o) : l
      }
      : "0".split(void 0, 0).length ? function(e, n) {
          return void 0 === e && 0 === n ? [] : ZEe(t, this, e, n)
        }
        : t,
      [function(t, n) {
        var o = mAe(this)
          , a = null == t ? void 0 : NAe(t, e);
        return a ? ZEe(a, t, o, n) : ZEe(r, Kke(o), t, n)
      }
        , function(e, o) {
        var a = pCe(this)
          , i = Kke(e)
          , s = n(r, a, i, o, r !== t);
        if (s.done)
          return s.value;
        var l, u, c, d = (l = RegExp,
          void 0 === (c = pCe(a).constructor) || null == (u = pCe(c)[uDe]) ? l : function(e) {
            if (Lke(e))
              return e;
            throw lDe(PAe(e) + " is not a constructor")
          }(u)), f = a.unicode, p = (a.ignoreCase ? "i" : "") + (a.multiline ? "m" : "") + (a.unicode ? "u" : "") + (hDe ? "g" : "y"), h = new d(hDe ? "^(?:" + a.source + ")" : a,p), v = void 0 === o ? 4294967295 : o >>> 0;
        if (0 === v)
          return [];
        if (0 === i.length)
          return null === KTe(h, i) ? [i] : [];
        for (var g = 0, m = 0, y = []; m < i.length; ) {
          h.lastIndex = hDe ? 0 : m;
          var b, w = KTe(h, hDe ? bDe(i, m) : i);
          if (null === w || (b = vDe(qCe(h.lastIndex + (hDe ? m : 0)), i.length)) === g)
            m = BTe(i, m, f);
          else {
            if (yDe(y, bDe(i, g, m)),
            y.length === v)
              return y;
            for (var x = 1; x <= w.length - 1; x++)
              if (yDe(y, w[x]),
              y.length === v)
                return y;
            m = g = b
          }
        }
        return yDe(y, bDe(i, g)),
          y
      }
      ]
  }
), !!XEe((function() {
    var e = /(?:)/
      , t = e.exec;
    e.exec = function() {
      return t.apply(this, arguments)
    }
    ;
    var n = "ab".split(e);
    return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
  }
)), hDe);
var wDe = "\t\n\v\f\r                　\u2028\u2029\ufeff"
  , xDe = uAe("".replace)
  , SDe = "[" + wDe + "]"
  , EDe = RegExp("^" + SDe + SDe + "*")
  , ADe = RegExp(SDe + SDe + "*$")
  , CDe = function(e) {
  return function(t) {
    var n = Kke(mAe(t));
    return 1 & e && (n = xDe(n, EDe, "")),
    2 & e && (n = xDe(n, ADe, "")),
      n
  }
}
  , kDe = {
  start: CDe(1),
  end: CDe(2),
  trim: CDe(3)
}
  , TDe = jCe.PROPER
  , DDe = kDe.trim;
function ODe(e) {
  return 0 === Qre("<div>" + e + "</div>").children().filter((function(e) {
      return "BR" !== e.tagName
    }
  )).length
}
function _De(e) {
  return 0 === e.length ? "" : e[0].outerHTML
}
function RDe(e) {
  return e.length ? e[0].tagName.toLowerCase() : ""
}
function LDe(e, t) {
  for (var n = "", r = (e.attr("style") || "").split(";"), o = r.length, a = 0; a < o; a++) {
    var i = r[a];
    if (i) {
      var s = i.split(":");
      s[0].trim() === t && (n = s[1].trim())
    }
  }
  return n
}
gke({
  target: "String",
  proto: !0,
  forced: XEe((function() {
      return !!wDe.trim() || "​᠎" !== "​᠎".trim() || TDe && "trim" !== wDe.trim.name
    }
  ))
}, {
  trim: function() {
    return DDe(this)
  }
}),
  gke({
    global: !0
  }, {
    globalThis: YEe
  }),
foe && (Qre.fn.css = foe),
yoe && (Qre.fn.append = yoe),
boe && (Qre.fn.prepend = boe),
Jre && (Qre.fn.addClass = Jre),
Zre && (Qre.fn.removeClass = Zre),
eoe && (Qre.fn.hasClass = eoe),
aoe && (Qre.fn.on = aoe),
ioe && (Qre.fn.off = ioe),
Ooe && (Qre.fn.focus = Ooe),
toe && (Qre.fn.attr = toe),
noe && (Qre.fn.removeAttr = noe),
coe && (Qre.fn.hide = coe),
doe && (Qre.fn.show = doe),
xoe && (Qre.fn.parents = xoe),
roe && (Qre.fn.dataset = roe),
ooe && (Qre.fn.val = ooe),
goe && (Qre.fn.text = goe),
voe && (Qre.fn.html = voe),
Eoe && (Qre.fn.children = Eoe),
Aoe && (Qre.fn.remove = Aoe),
Soe && (Qre.fn.find = Soe),
soe && (Qre.fn.width = soe),
loe && (Qre.fn.height = loe),
hoe && (Qre.fn.filter = hoe),
Coe && (Qre.fn.empty = Coe);
var IDe = {
  selector: "p:not([data-w-e-type])",
  parseElemHtml: function(e, t, n) {
    var r = Qre(e);
    return 0 === (t = t.filter((function(e) {
        return !!bne.isText(e) || !!n.isInline(e)
      }
    ))).length && (t = [{
      text: r.text().replace(/\s+/gm, " ")
    }]),
      {
        type: "paragraph",
        children: t
      }
  }
}
  , PDe = function(e, t) {
  return PDe = Object.setPrototypeOf || {
      __proto__: []
    }instanceof Array && function(e, t) {
      e.__proto__ = t
    }
    || function(e, t) {
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    ,
    PDe(e, t);
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
};
function FDe(e, t) {
  if ("function" != typeof t && null !== t)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function n() {
    this.constructor = e
  }
  PDe(e, t),
    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype,
      new n)
}
var BDe = function() {
  return BDe = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++)
      for (var o in t = arguments[n])
        Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    return e
  }
    ,
    BDe.apply(this, arguments)
};
function NDe(e, t, n, r) {
  return new (n || (n = Promise))((function(o, a) {
      function i(e) {
        try {
          l(r.next(e))
        } catch (t) {
          a(t)
        }
      }
      function s(e) {
        try {
          l(r.throw(e))
        } catch (t) {
          a(t)
        }
      }
      function l(e) {
        var t;
        e.done ? o(e.value) : (t = e.value,
          t instanceof n ? t : new n((function(e) {
              e(t)
            }
          ))).then(i, s)
      }
      l((r = r.apply(e, t || [])).next())
    }
  ))
}
function MDe(e, t) {
  var n, r, o, a, i = {
    label: 0,
    sent: function() {
      if (1 & o[0])
        throw o[1];
      return o[1]
    },
    trys: [],
    ops: []
  };
  return a = {
    next: s(0),
    throw: s(1),
    return: s(2)
  },
  "function" == typeof Symbol && (a[Symbol.iterator] = function() {
      return this
    }
  ),
    a;
  function s(a) {
    return function(s) {
      return function(a) {
        if (n)
          throw new TypeError("Generator is already executing.");
        for (; i; )
          try {
            if (n = 1,
            r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r),
              0) : r.next) && !(o = o.call(r, a[1])).done)
              return o;
            switch (r = 0,
            o && (a = [2 & a[0], o.value]),
              a[0]) {
              case 0:
              case 1:
                o = a;
                break;
              case 4:
                return i.label++,
                  {
                    value: a[1],
                    done: !1
                  };
              case 5:
                i.label++,
                  r = a[1],
                  a = [0];
                continue;
              case 7:
                a = i.ops.pop(),
                  i.trys.pop();
                continue;
              default:
                if (!((o = (o = i.trys).length > 0 && o[o.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                  i = 0;
                  continue
                }
                if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {
                  i.label = a[1];
                  break
                }
                if (6 === a[0] && i.label < o[1]) {
                  i.label = o[1],
                    o = a;
                  break
                }
                if (o && i.label < o[2]) {
                  i.label = o[2],
                    i.ops.push(a);
                  break
                }
                o[2] && i.ops.pop(),
                  i.trys.pop();
                continue
            }
            a = t.call(e, i)
          } catch (s) {
            a = [6, s],
              r = 0
          } finally {
            n = o = 0
          }
        if (5 & a[0])
          throw a[1];
        return {
          value: a[0] ? a[1] : void 0,
          done: !0
        }
      }([a, s])
    }
  }
}
function jDe(e) {
  var t = "function" == typeof Symbol && Symbol.iterator
    , n = t && e[t]
    , r = 0;
  if (n)
    return n.call(e);
  if (e && "number" == typeof e.length)
    return {
      next: function() {
        return e && r >= e.length && (e = void 0),
          {
            value: e && e[r++],
            done: !e
          }
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function VDe(e, t) {
  var n = "function" == typeof Symbol && e[Symbol.iterator];
  if (!n)
    return e;
  var r, o, a = n.call(e), i = [];
  try {
    for (; (void 0 === t || t-- > 0) && !(r = a.next()).done; )
      i.push(r.value)
  } catch (s) {
    o = {
      error: s
    }
  } finally {
    try {
      r && !r.done && (n = a.return) && n.call(a)
    } finally {
      if (o)
        throw o.error
    }
  }
  return i
}
function UDe(e) {
  var t = VDe(Yte.nodes(e, {
    match: function(t) {
      return e.children[0] === t
    },
    mode: "highest"
  }), 1)[0];
  if (null == t)
    return !1;
  var n = t[0];
  if (!Hte.isElement(n))
    return !1;
  if ("paragraph" === n.type)
    return !1;
  if ("" !== ene.string(n))
    return !1;
  var r = n.children
    , o = void 0 === r ? [] : r;
  return !!bne.isText(o[0]) && (Nne.setNodes(e, {
    type: "paragraph"
  }),
    !0)
}
var $De = {
  renderElems: [HEe],
  elemsToHtml: [{
    type: "paragraph",
    elemToHtml: function(e, t) {
      return "" === t ? "<p><br></p>" : "<p>" + t + "</p>"
    }
  }],
  parseElemsHtml: [IDe],
  editorPlugin: function(e) {
    var t = e.deleteBackward
      , n = e.deleteForward;
    e.insertText,
      e.insertBreak;
    var r = e;
    return r.deleteBackward = function(e) {
      UDe(r) || t(e)
    }
      ,
      r.deleteForward = function(e) {
        UDe(r) || n(e)
      }
      ,
      r
  }
}
  , HDe = /"/g
  , zDe = uAe("".replace)
  , KDe = function(e, t, n, r) {
  var o = Kke(mAe(e))
    , a = "<" + t;
  return "" !== n && (a += " " + n + '="' + zDe(Kke(r), HDe, "&quot;") + '"'),
  a + ">" + o + "</" + t + ">"
}
  , WDe = function(e) {
  return XEe((function() {
      var t = ""[e]('"');
      return t !== t.toLowerCase() || t.split('"').length > 3
    }
  ))
};
function GDe(e, t) {
  var n = t
    , r = e
    , o = r.bold
    , a = r.italic
    , i = r.underline;
  return o && (n = "<strong>" + n + "</strong>"),
  r.code && (n = "<code>" + n + "</code>"),
  a && (n = "<em>" + n + "</em>"),
  i && (n = "<u>" + n + "</u>"),
  r.through && (n = "<s>" + n + "</s>"),
  r.sub && (n = "<sub>" + n + "</sub>"),
  r.sup && (n = "<sup>" + n + "</sup>"),
    n
}
function qDe(e, t) {
  return 0 !== e.length && (!!e[0].matches(t) || e.find(t).length > 0)
}
gke({
  target: "String",
  proto: !0,
  forced: WDe("bold")
}, {
  bold: function() {
    return KDe(this, "b", "", "")
  }
}),
  gke({
    target: "String",
    proto: !0,
    forced: WDe("italics")
  }, {
    italics: function() {
      return KDe(this, "i", "", "")
    }
  }),
  gke({
    target: "String",
    proto: !0,
    forced: WDe("sub")
  }, {
    sub: function() {
      return KDe(this, "sub", "", "")
    }
  }),
  gke({
    target: "String",
    proto: !0,
    forced: WDe("sup")
  }, {
    sup: function() {
      return KDe(this, "sup", "", "")
    }
  });
var YDe = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}
  , XDe = sCe("span").classList
  , QDe = XDe && XDe.constructor && XDe.constructor.prototype
  , JDe = QDe === Object.prototype ? void 0 : QDe
  , ZDe = function(e, t) {
  var n = [][e];
  return !!n && XEe((function() {
      n.call(null, t || function() {
        throw 1
      }
        , 1)
    }
  ))
}
  , eOe = Mke.forEach
  , tOe = ZDe("forEach") ? [].forEach : function(e) {
  return eOe(this, e, arguments.length > 1 ? arguments[1] : void 0)
}
  , nOe = function(e) {
  if (e && e.forEach !== tOe)
    try {
      mCe(e, "forEach", tOe)
    } catch (X_) {
      e.forEach = tOe
    }
};
for (var rOe in YDe)
  YDe[rOe] && nOe(YEe[rOe] && YEe[rOe].prototype);
function oOe(e, t) {
  return null == e.selection || !!VDe(Yte.nodes(e, {
    match: function(t) {
      return "pre" === qme.getNodeType(t) || !!Yte.isVoid(e, t)
    },
    universal: !0
  }), 1)[0]
}
function aOe(e, t) {
  Object.keys(t).forEach((function(t) {
      "text" !== t && Yte.removeMark(e, t)
    }
  ))
}
nOe(JDe),
  gke({
    target: "Object",
    stat: !0,
    forced: XEe((function() {
        Qke(1)
      }
    ))
  }, {
    keys: function(e) {
      return Qke(zAe(e))
    }
  });
var iOe = function() {
  function e() {
    this.marksNeedToRemove = [],
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    var t = this.mark
      , n = Yte.marks(e);
    return n ? n[t] : !!VDe(Yte.nodes(e, {
      match: function(e) {
        return !0 === e[t]
      }
    }), 1)[0]
  }
    ,
    e.prototype.isActive = function(e) {
      return !!this.getValue(e)
    }
    ,
    e.prototype.isDisabled = function(e) {
      return oOe(e, this.mark)
    }
    ,
    e.prototype.exec = function(e, t) {
      var n = this.mark
        , r = this.marksNeedToRemove;
      t ? e.removeMark(n) : (e.addMark(n, !0),
      r && r.forEach((function(t) {
          return e.removeMark(t)
        }
      )))
    }
    ,
    e
}()
  , sOe = '<svg viewBox="0 0 1024 1024"><path d="M864 0a160 160 0 0 1 128 256l-64 64-224-224 64-64c26.752-20.096 59.968-32 96-32zM64 736l-64 288 288-64 592-592-224-224L64 736z m651.584-372.416l-448 448-55.168-55.168 448-448 55.168 55.168z"></path></svg>'
  , lOe = '<svg viewBox="0 0 1024 1024"><path d="M924.402464 1023.068211H0.679665V99.345412h461.861399v98.909208H99.596867v725.896389h725.896389V561.206811h98.909208z" p-id="10909"></path><path d="M930.805104 22.977336l69.965436 69.965436-453.492405 453.492404-69.965435-69.901489z" p-id="10910"></path><path d="M1022.464381 304.030081h-98.917201V99.345412H709.230573V0.428211h313.233808z"></path></svg>'
  , uOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.mark = "bold",
      t.title = SEe("textStyle.bold"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M707.872 484.64A254.88 254.88 0 0 0 768 320c0-141.152-114.848-256-256-256H192v896h384c141.152 0 256-114.848 256-256a256.096 256.096 0 0 0-124.128-219.36zM384 192h101.504c55.968 0 101.504 57.408 101.504 128s-45.536 128-101.504 128H384V192z m159.008 640H384v-256h159.008c58.464 0 106.016 57.408 106.016 128s-47.552 128-106.016 128z"></path></svg>',
      t.hotkey = "mod+b",
      t
  }
  return FDe(t, e),
    t
}(iOe)
  , cOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.mark = "code",
      t.title = SEe("textStyle.code"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M576 736l96 96 320-320L672 192l-96 96 224 224zM448 288l-96-96L32 512l320 320 96-96-224-224z"></path></svg>',
      t.hotkey = "mod+e",
      t
  }
  return FDe(t, e),
    t
}(iOe)
  , dOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.mark = "italic",
      t.title = SEe("textStyle.italic"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M896 64v64h-128L448 896h128v64H128v-64h128L576 128h-128V64z"></path></svg>',
      t.hotkey = "mod+i",
      t
  }
  return FDe(t, e),
    t
}(iOe)
  , fOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.mark = "through",
      t.title = SEe("textStyle.through"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M1024 512v64h-234.496c27.52 38.496 42.496 82.688 42.496 128 0 70.88-36.672 139.04-100.576 186.976C672.064 935.488 594.144 960 512 960s-160.064-24.512-219.424-69.024C228.64 843.04 192 774.88 192 704h128c0 69.376 87.936 128 192 128s192-58.624 192-128-87.936-128-192-128H0v-64h299.52a385.984 385.984 0 0 1-6.944-5.024C228.64 459.04 192 390.88 192 320s36.672-139.04 100.576-186.976C351.936 88.512 429.856 64 512 64s160.064 24.512 219.424 69.024C795.328 180.96 832 249.12 832 320h-128c0-69.376-87.936-128-192-128s-192 58.624-192 128 87.936 128 192 128c78.976 0 154.048 22.688 212.48 64H1024z"></path></svg>',
      t.hotkey = "mod+shift+x",
      t
  }
  return FDe(t, e),
    t
}(iOe)
  , pOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.mark = "underline",
      t.title = SEe("textStyle.underline"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M704 64l128 0 0 416c0 159.072-143.264 288-320 288s-320-128.928-320-288l0-416 128 0 0 416c0 40.16 18.24 78.688 51.36 108.512 36.896 33.216 86.848 51.488 140.64 51.488s103.744-18.304 140.64-51.488c33.12-29.792 51.36-68.352 51.36-108.512l0-416zM192 832l640 0 0 128-640 0z"></path></svg>',
      t.hotkey = "mod+u",
      t
  }
  return FDe(t, e),
    t
}(iOe)
  , hOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.mark = "sub",
      t.marksNeedToRemove = ["sup"],
      t.title = SEe("textStyle.sub"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M768 910.016v50.016h128v64h-192v-146.016l128-60V768h-128v-64h192v146.016zM676 256h-136L352 444 164 256H28l256 256-256 256h136L352 580 540 768h136l-256-256z"></path></svg>',
      t.hotkey = "",
      t
  }
  return FDe(t, e),
    t
}(iOe)
  , vOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.mark = "sup",
      t.marksNeedToRemove = ["sub"],
      t.title = SEe("textStyle.sup"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M768 206.016v50.016h128v64h-192V174.016l128-60V64h-128V0h192v146.016zM676 256h-136L352 444 164 256H28l256 256-256 256h136L352 580 540 768h136l-256-256z"></path></svg>',
      t.hotkey = "",
      t
  }
  return FDe(t, e),
    t
}(iOe)
  , gOe = function() {
  function e() {
    this.title = SEe("textStyle.clear"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M969.382408 288.738615l-319.401123-270.852152a67.074236 67.074236 0 0 0-96.459139 5.74922l-505.931379 574.922021a68.35184 68.35184 0 0 0-17.886463 47.910169 74.101061 74.101061 0 0 0 24.274486 47.910168l156.50655 132.232065h373.060512L975.131628 383.281347a67.074236 67.074236 0 0 0-5.74922-96.459139z m-440.134747 433.746725H264.144729l-90.071117-78.572676c-5.74922-5.74922-12.137243-12.137243-12.137243-17.886463a36.411728 36.411728 0 0 1 5.749221-24.274485l210.804741-240.828447 265.102932 228.691204z m-439.495945 180.781036h843.218964a60.047411 60.047411 0 1 1 0 120.733624H89.751716a60.047411 60.047411 0 1 1 0-120.733624z m0 0"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return oOe(e)
    }
    ,
    e.prototype.exec = function(e, t) {
      var n, r, o = Yte.nodes(e, {
        match: function(e) {
          return bne.isText(e)
        },
        universal: !0
      });
      try {
        for (var a = jDe(o), i = a.next(); !i.done; i = a.next())
          aOe(e, i.value[0])
      } catch (s) {
        n = {
          error: s
        }
      } finally {
        try {
          i && !i.done && (r = a.return) && r.call(a)
        } finally {
          if (n)
            throw n.error
        }
      }
    }
    ,
    e
}()
  , mOe = {
  renderStyle: function(e, t) {
    var n = e
      , r = n.bold
      , o = n.italic
      , a = n.underline
      , i = n.code
      , s = n.through
      , l = n.sub
      , u = n.sup
      , c = t;
    return r && (c = $ae("strong", null, c)),
    i && (c = $ae("code", null, c)),
    o && (c = $ae("em", null, c)),
    a && (c = $ae("u", null, c)),
    s && (c = $ae("s", null, c)),
    l && (c = $ae("sub", null, c)),
    u && (c = $ae("sup", null, c)),
      c
  },
  menus: [{
    key: "bold",
    factory: function() {
      return new uOe
    }
  }, {
    key: "underline",
    factory: function() {
      return new pOe
    }
  }, {
    key: "italic",
    factory: function() {
      return new dOe
    }
  }, {
    key: "through",
    factory: function() {
      return new fOe
    }
  }, {
    key: "code",
    factory: function() {
      return new cOe
    }
  }, {
    key: "sub",
    factory: function() {
      return new hOe
    }
  }, {
    key: "sup",
    factory: function() {
      return new vOe
    }
  }, {
    key: "clearStyle",
    factory: function() {
      return new gOe
    }
  }],
  styleToHtml: function(e, t) {
    if (!bne.isText(e))
      return t;
    if (ODe(t))
      return GDe(e, t);
    var n = Qre(t);
    if ("br" === RDe(n))
      return GDe(e, "<br>");
    var r = n.html();
    return r = GDe(e, r),
      n.html(r),
      _De(n)
  },
  parseStyleHtml: function(e, t, n) {
    var r = Qre(e);
    if (!bne.isText(t))
      return t;
    var o = t;
    return qDe(r, "b,strong") && (o.bold = !0),
    qDe(r, "i,em") && (o.italic = !0),
    qDe(r, "u") && (o.underline = !0),
    qDe(r, "s,strike") && (o.through = !0),
    qDe(r, "sub") && (o.sub = !0),
    qDe(r, "sup") && (o.sup = !0),
    qDe(r, "code") && (o.code = !0),
      o
  }
};
function yOe(e) {
  return function(t, n, r) {
    return $ae("h" + e, null, n)
  }
}
var bOe = {
  type: "header1",
  renderElem: yOe(1)
}
  , wOe = {
  type: "header2",
  renderElem: yOe(2)
}
  , xOe = {
  type: "header3",
  renderElem: yOe(3)
}
  , SOe = {
  type: "header4",
  renderElem: yOe(4)
}
  , EOe = {
  type: "header5",
  renderElem: yOe(5)
}
  , AOe = jCe.PROPER
  , COe = RegExp.prototype
  , kOe = COe.toString
  , TOe = uAe(Wke)
  , DOe = XEe((function() {
    return "/a/b" != kOe.call({
      source: "a",
      flags: "b"
    })
  }
))
  , OOe = AOe && "toString" != kOe.name;
(DOe || OOe) && VCe(RegExp.prototype, "toString", (function() {
    var e = pCe(this)
      , t = Kke(e.source)
      , n = e.flags;
    return "/" + t + "/" + Kke(void 0 === n && SAe(COe, e) && !("flags"in COe) ? TOe(e) : n)
  }
), {
  unsafe: !0
});
var _Oe, ROe = YEe.TypeError, LOe = function(e) {
  if (sDe(e))
    throw ROe("The method doesn't accept regular expressions");
  return e
}, IOe = tCe("match"), POe = function(e) {
  var t = /./;
  try {
    "/./"[e](t)
  } catch (AEe) {
    try {
      return t[IOe] = !1,
        "/./"[e](t)
    } catch (n) {}
  }
  return !1
}, FOe = cCe.f, BOe = uAe("".startsWith), NOe = uAe("".slice), MOe = Math.min, jOe = POe("startsWith");
function VOe(e) {
  var t = VDe(Yte.nodes(e, {
    match: function(e) {
      return qme.getNodeType(e).startsWith("header")
    },
    universal: !0
  }), 1)[0];
  if (null == t)
    return "paragraph";
  var n = VDe(t, 1)[0];
  return qme.getNodeType(n)
}
function UOe(e) {
  return null == e.selection || !VDe(Yte.nodes(e, {
    match: function(e) {
      var t = qme.getNodeType(e);
      return "paragraph" === t || !!t.startsWith("header")
    },
    universal: !0,
    mode: "highest"
  }), 1)[0]
}
function $Oe(e, t) {
  t && Nne.setNodes(e, {
    type: t
  })
}
gke({
  target: "String",
  proto: !0,
  forced: !(!jOe && (_Oe = FOe(String.prototype, "startsWith"),
  _Oe && !_Oe.writable) || jOe)
}, {
  startsWith: function(e) {
    var t = Kke(mAe(this));
    LOe(e);
    var n = qCe(MOe(arguments.length > 1 ? arguments[1] : void 0, t.length))
      , r = Kke(e);
    return BOe ? BOe(t, r, n) : NOe(t, n, n + r.length) === r
  }
});
var HOe = function() {
  function e() {
    this.title = SEe("header.title"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M960 960c-51.2 0-102.4-3.2-153.6-3.2-51.2 0-99.2 3.2-150.4 3.2-19.2 0-28.8-22.4-28.8-38.4 0-51.2 57.6-28.8 86.4-48 19.2-12.8 19.2-60.8 19.2-80v-224-19.2c-9.6-3.2-19.2-3.2-28.8-3.2H320c-9.6 0-19.2 0-28.8 3.2V780.8c0 22.4 0 80 22.4 92.8 28.8 19.2 96-6.4 96 44.8 0 16-9.6 41.6-28.8 41.6-54.4 0-105.6-3.2-160-3.2-48 0-96 3.2-147.2 3.2-19.2 0-28.8-22.4-28.8-38.4 0-51.2 51.2-28.8 80-48 19.2-12.8 19.2-60.8 19.2-83.2V294.4c0-28.8 3.2-115.2-22.4-131.2-25.6-16-86.4 9.6-86.4-41.6 0-16 6.4-41.6 28.8-41.6 51.2 0 105.6 3.2 156.8 3.2 48 0 96-3.2 144-3.2 19.2 0 28.8 22.4 28.8 41.6 0 48-57.6 25.6-83.2 41.6-19.2 12.8-19.2 73.6-19.2 92.8v201.6c6.4 3.2 16 3.2 22.4 3.2h400c6.4 0 12.8 0 22.4-3.2V256c0-22.4 0-80-19.2-92.8-28.8-16-86.4 6.4-86.4-41.6 0-16 9.6-41.6 28.8-41.6 51.2 0 99.2 3.2 150.4 3.2 48 0 99.2-3.2 147.2-3.2 19.2 0 28.8 22.4 28.8 41.6 0 51.2-57.6 25.6-86.4 41.6-19.2 12.8-19.2 70.4-19.2 92.8v537.6c0 19.2 0 67.2 19.2 80 28.8 19.2 89.6-6.4 89.6 44.8 0 19.2-6.4 41.6-28.8 41.6z"></path></svg>',
      this.tag = "select",
      this.width = 60
  }
  return e.prototype.getOptions = function(e) {
    var t = [{
      value: "header1",
      text: "H1",
      styleForRenderMenuList: {
        "font-size": "32px",
        "font-weight": "bold"
      }
    }, {
      value: "header2",
      text: "H2",
      styleForRenderMenuList: {
        "font-size": "24px",
        "font-weight": "bold"
      }
    }, {
      value: "header3",
      text: "H3",
      styleForRenderMenuList: {
        "font-size": "18px",
        "font-weight": "bold"
      }
    }, {
      value: "header4",
      text: "H4",
      styleForRenderMenuList: {
        "font-size": "16px",
        "font-weight": "bold"
      }
    }, {
      value: "header5",
      text: "H5",
      styleForRenderMenuList: {
        "font-size": "13px",
        "font-weight": "bold"
      }
    }, {
      value: "paragraph",
      text: SEe("header.text")
    }]
      , n = this.getValue(e).toString();
    return t.forEach((function(e) {
        e.value === n ? e.selected = !0 : delete e.selected
      }
    )),
      t
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.getValue = function(e) {
      return VOe(e)
    }
    ,
    e.prototype.isDisabled = function(e) {
      return UOe(e)
    }
    ,
    e.prototype.exec = function(e, t) {
      $Oe(e, t.toString())
    }
    ,
    e
}()
  , zOe = function() {
  function e() {
    this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return VOe(e)
  }
    ,
    e.prototype.isActive = function(e) {
      return this.getValue(e) === this.type
    }
    ,
    e.prototype.isDisabled = function(e) {
      return UOe(e)
    }
    ,
    e.prototype.exec = function(e, t) {
      var n = this.type;
      $Oe(e, t === n ? "paragraph" : n)
    }
    ,
    e
}()
  , KOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = "H1",
      t.type = "header1",
      t
  }
  return FDe(t, e),
    t
}(zOe)
  , WOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = "H2",
      t.type = "header2",
      t
  }
  return FDe(t, e),
    t
}(zOe)
  , GOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = "H3",
      t.type = "header3",
      t
  }
  return FDe(t, e),
    t
}(zOe)
  , qOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = "H4",
      t.type = "header4",
      t
  }
  return FDe(t, e),
    t
}(zOe)
  , YOe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = "H5",
      t.type = "header5",
      t
  }
  return FDe(t, e),
    t
}(zOe)
  , XOe = {
  key: "headerSelect",
  factory: function() {
    return new HOe
  }
}
  , QOe = {
  key: "header1",
  factory: function() {
    return new KOe
  }
}
  , JOe = {
  key: "header2",
  factory: function() {
    return new WOe
  }
}
  , ZOe = {
  key: "header3",
  factory: function() {
    return new GOe
  }
}
  , e_e = {
  key: "header4",
  factory: function() {
    return new qOe
  }
}
  , t_e = {
  key: "header5",
  factory: function() {
    return new YOe
  }
};
function n_e(e) {
  return function(t, n) {
    return "<h" + e + ">" + n + "</h" + e + ">"
  }
}
function r_e(e) {
  return function(t, n, r) {
    var o = Qre(t);
    return 0 === (n = n.filter((function(e) {
        return !!bne.isText(e) || !!r.isInline(e)
      }
    ))).length && (n = [{
      text: o.text().replace(/\s+/gm, " ")
    }]),
      {
        type: "header" + e,
        children: n
      }
  }
}
var o_e = {
  renderElems: [bOe, wOe, xOe, SOe, EOe],
  elemsToHtml: [{
    type: "header1",
    elemToHtml: n_e(1)
  }, {
    type: "header2",
    elemToHtml: n_e(2)
  }, {
    type: "header3",
    elemToHtml: n_e(3)
  }, {
    type: "header4",
    elemToHtml: n_e(4)
  }, {
    type: "header5",
    elemToHtml: n_e(5)
  }],
  parseElemsHtml: [{
    selector: "h1:not([data-w-e-type])",
    parseElemHtml: r_e(1)
  }, {
    selector: "h2:not([data-w-e-type])",
    parseElemHtml: r_e(2)
  }, {
    selector: "h3:not([data-w-e-type])",
    parseElemHtml: r_e(3)
  }, {
    selector: "h4:not([data-w-e-type])",
    parseElemHtml: r_e(4)
  }, {
    selector: "h5:not([data-w-e-type])",
    parseElemHtml: r_e(5)
  }],
  menus: [XOe, QOe, JOe, ZOe, e_e, t_e],
  editorPlugin: function(e) {
    var t = e.insertBreak;
    e.insertNode;
    var n = e;
    return n.insertBreak = function() {
      var r = VDe(Yte.nodes(n, {
        match: function(e) {
          return qme.getNodeType(e).startsWith("header")
        },
        universal: !0
      }), 1)[0];
      r && qme.isSelectionAtLineEnd(e, r[1]) ? Nne.insertNodes(n, {
        type: "paragraph",
        children: [{
          text: ""
        }]
      }, {
        mode: "highest"
      }) : t()
    }
      ,
      n
  }
}
  , a_e = Object.assign
  , i_e = Object.defineProperty
  , s_e = uAe([].concat)
  , l_e = !a_e || XEe((function() {
    if (QEe && 1 !== a_e({
      b: 1
    }, a_e(i_e({}, "a", {
      enumerable: !0,
      get: function() {
        i_e(this, "b", {
          value: 3,
          enumerable: !1
        })
      }
    }), {
      b: 2
    })).b)
      return !0;
    var e = {}
      , t = {}
      , n = Symbol()
      , r = "abcdefghijklmnopqrst";
    return e[n] = 7,
      r.split("").forEach((function(e) {
          t[e] = e
        }
      )),
    7 != a_e({}, e)[n] || Qke(a_e({}, t)).join("") != r
  }
)) ? function(e, t) {
    for (var n = zAe(e), r = arguments.length, o = 1, a = oke.f, i = rAe.f; r > o; )
      for (var s, l = vAe(arguments[o++]), u = a ? s_e(Qke(l), a(l)) : Qke(l), c = u.length, d = 0; c > d; )
        s = u[d++],
        QEe && !ZEe(i, l, s) || (n[s] = l[s]);
    return n
  }
  : a_e;
function u_e(e, t) {
  null == e.data && (e.data = {});
  var n = e.data;
  null == n.style && (n.style = {}),
    Object.assign(n.style, t)
}
gke({
  target: "Object",
  stat: !0,
  forced: Object.assign !== l_e
}, {
  assign: l_e
});
var c_e = {
  selector: "font",
  preParseHtml: function(e) {
    var t = Qre(e);
    if ("font" !== RDe(t))
      return e;
    var n = t.attr("color") || "";
    return n && (t.removeAttr("color"),
      t.css("color", n)),
      t[0]
  }
}
  , d_e = function() {
  function e() {
    this.tag = "button",
      this.showDropPanel = !0,
      this.$content = null
  }
  return e.prototype.exec = function(e, t) {}
    ,
    e.prototype.getValue = function(e) {
      var t = this.mark
        , n = Yte.marks(e);
      return n && n[t] ? n[t] : ""
    }
    ,
    e.prototype.isActive = function(e) {
      return !!this.getValue(e)
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || !!VDe(Yte.nodes(e, {
        match: function(t) {
          return "pre" === qme.getNodeType(t) || !!Yte.isVoid(e, t)
        },
        universal: !0
      }), 1)[0]
    }
    ,
    e.prototype.getPanelContentElem = function(e) {
      var t = this.mark;
      if (null == this.$content) {
        var n = Qre('<ul class="w-e-panel-content-color"></ul>');
        n.on("click", "li", (function(n) {
            var r = n.target;
            if (null != r && (n.preventDefault(),
            null != e.selection)) {
              var o = Qre(r).attr("data-value");
              "0" === o ? Yte.removeMark(e, t) : Yte.addMark(e, t, o)
            }
          }
        )),
          this.$content = n
      }
      var r = this.$content;
      if (null == r)
        return document.createElement("ul");
      r.empty();
      var o = this.getValue(e)
        , a = e.getMenuConfig(t).colors;
      (void 0 === a ? [] : a).forEach((function(e) {
          var t = Qre('<div class="color-block" data-value="' + e + '"></div>');
          t.css("background-color", e);
          var n = Qre('<li data-value="' + e + '"></li>');
          o === e && n.addClass("active"),
            n.append(t),
            r.append(n)
        }
      ));
      var i = "";
      "color" === t && (i = SEe("color.default")),
      "bgColor" === t && (i = SEe("color.clear"));
      var s = Qre('\n      <li data-value="0" class="clear">\n        <svg viewBox="0 0 1024 1024"><path d="M236.8 128L896 787.2V128H236.8z m614.4 704L192 172.8V832h659.2zM192 64h704c38.4 0 64 25.6 64 64v704c0 38.4-25.6 64-64 64H192c-38.4 0-64-25.6-64-64V128c0-38.4 25.6-64 64-64z"></path></svg>\n        ' + i + "\n      </li>\n    ");
      return r.prepend(s),
        r[0]
    }
    ,
    e
}()
  , f_e = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = SEe("color.color"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M64 864h896v96H64zM360.58 576h302.85l81.53 224h102.16L579.24 64H444.77L176.89 800h102.16l81.53-224zM512 159.96L628.49 480H395.52L512 159.96z"></path></svg>',
      t.mark = "color",
      t
  }
  return FDe(t, e),
    t
}(d_e)
  , p_e = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = SEe("color.bgColor"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M510.030769 315.076923l84.676923 196.923077h-177.230769l76.8-196.923077h15.753846zM945.230769 157.538462v708.923076c0 43.323077-35.446154 78.769231-78.769231 78.769231H157.538462c-43.323077 0-78.769231-35.446154-78.769231-78.769231V157.538462c0-43.323077 35.446154-78.769231 78.769231-78.769231h708.923076c43.323077 0 78.769231 35.446154 78.769231 78.769231z m-108.307692 643.938461L600.615385 216.615385c-5.907692-11.815385-15.753846-19.692308-29.538462-19.692308h-139.815385c-11.815385 0-23.630769 7.876923-27.56923 19.692308l-216.615385 584.861538c-3.938462 11.815385 3.938462 25.6 17.723077 25.6h80.738462c11.815385 0 23.630769-9.846154 27.56923-21.661538l63.015385-175.261539h263.876923l68.923077 175.261539c3.938462 11.815385 15.753846 21.661538 27.569231 21.661538h80.738461c13.784615 0 23.630769-13.784615 19.692308-25.6z"></path></svg>',
      t.mark = "bgColor",
      t
  }
  return FDe(t, e),
    t
}(d_e)
  , h_e = ["rgb(0, 0, 0)", "rgb(38, 38, 38)", "rgb(89, 89, 89)", "rgb(140, 140, 140)", "rgb(191, 191, 191)", "rgb(217, 217, 217)", "rgb(233, 233, 233)", "rgb(245, 245, 245)", "rgb(250, 250, 250)", "rgb(255, 255, 255)", "rgb(225, 60, 57)", "rgb(231, 95, 51)", "rgb(235, 144, 58)", "rgb(245, 219, 77)", "rgb(114, 192, 64)", "rgb(89, 191, 192)", "rgb(66, 144, 247)", "rgb(54, 88, 226)", "rgb(106, 57, 201)", "rgb(216, 68, 147)", "rgb(251, 233, 230)", "rgb(252, 237, 225)", "rgb(252, 239, 212)", "rgb(252, 251, 207)", "rgb(231, 246, 213)", "rgb(218, 244, 240)", "rgb(217, 237, 250)", "rgb(224, 232, 250)", "rgb(237, 225, 248)", "rgb(246, 226, 234)", "rgb(255, 163, 158)", "rgb(255, 187, 150)", "rgb(255, 213, 145)", "rgb(255, 251, 143)", "rgb(183, 235, 143)", "rgb(135, 232, 222)", "rgb(145, 213, 255)", "rgb(173, 198, 255)", "rgb(211, 173, 247)", "rgb(255, 173, 210)", "rgb(255, 77, 79)", "rgb(255, 122, 69)", "rgb(255, 169, 64)", "rgb(255, 236, 61)", "rgb(115, 209, 61)", "rgb(54, 207, 201)", "rgb(64, 169, 255)", "rgb(89, 126, 247)", "rgb(146, 84, 222)", "rgb(247, 89, 171)", "rgb(207, 19, 34)", "rgb(212, 56, 13)", "rgb(212, 107, 8)", "rgb(212, 177, 6)", "rgb(56, 158, 13)", "rgb(8, 151, 156)", "rgb(9, 109, 217)", "rgb(29, 57, 196)", "rgb(83, 29, 171)", "rgb(196, 29, 127)", "rgb(130, 0, 20)", "rgb(135, 20, 0)", "rgb(135, 56, 0)", "rgb(97, 71, 0)", "rgb(19, 82, 0)", "rgb(0, 71, 79)", "rgb(0, 58, 140)", "rgb(6, 17, 120)", "rgb(34, 7, 94)", "rgb(120, 6, 80)"]
  , v_e = {
  renderStyle: function(e, t) {
    var n = e
      , r = n.color
      , o = n.bgColor
      , a = t;
    return r && u_e(a, {
      color: r
    }),
    o && u_e(a, {
      backgroundColor: o
    }),
      a
  },
  styleToHtml: function(e, t) {
    if (!bne.isText(e))
      return t;
    var n, r = e, o = r.color, a = r.bgColor;
    return o || a ? ((ODe(t) || "span" !== RDe(n = Qre(t))) && (n = Qre("<span>" + t + "</span>")),
    o && n.css("color", o),
    a && n.css("background-color", a),
      _De(n)) : t
  },
  preParseHtml: [c_e],
  parseStyleHtml: function(e, t, n) {
    var r = Qre(e);
    if (!bne.isText(t))
      return t;
    var o = t
      , a = LDe(r, "color");
    a && (o.color = a);
    var i = LDe(r, "background-color");
    return i || (i = LDe(r, "background")),
    i && (o.bgColor = i),
      o
  },
  menus: [{
    key: "color",
    factory: function() {
      return new f_e
    },
    config: {
      colors: h_e
    }
  }, {
    key: "bgColor",
    factory: function() {
      return new p_e
    },
    config: {
      colors: h_e
    }
  }]
}
  , g_e = /^(?:\w+:)?\/\/(\S+)$/
  , m_e = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/
  , y_e = /^[^\s\.]+\.\S{2,}$/
  , b_e = QCe.includes;
function w_e(e) {
  return void 0 === e && (e = "r"),
  e + "-" + Goe()
}
function x_e(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;")
}
function S_e(e, t, n, r) {
  return NDe(this, void 0, void 0, (function() {
      var o, a;
      return MDe(this, (function(i) {
          switch (i.label) {
            case 0:
              return (o = t.getMenuConfig(e).checkLink) ? [4, o(n, r)] : [3, 2];
            case 1:
              if ("string" == typeof (a = i.sent()))
                return t.alert(a, "error"),
                  [2, !1];
              if (null == a)
                return [2, !1];
              i.label = 2;
            case 2:
              return [2, !0]
          }
        }
      ))
    }
  ))
}
function E_e(e, t, n) {
  return NDe(this, void 0, void 0, (function() {
      var r;
      return MDe(this, (function(o) {
          switch (o.label) {
            case 0:
              return (r = t.getMenuConfig(e).parseLinkUrl) ? [4, r(n)] : [3, 2];
            case 1:
              return [2, o.sent()];
            case 2:
              return [2, n]
          }
        }
      ))
    }
  ))
}
function A_e(e) {
  return null == e.selection || !!qme.getSelectedElems(e).some((function(t) {
      var n = t.type;
      return !!e.isVoid(t) || !!["pre", "code", "link"].includes(n) || void 0
    }
  ))
}
function C_e(e, t) {
  return {
    type: "link",
    url: x_e(e),
    children: t ? [{
      text: t
    }] : []
  }
}
function k_e(e, t, n) {
  return NDe(this, void 0, void 0, (function() {
      var r, o, a;
      return MDe(this, (function(i) {
          switch (i.label) {
            case 0:
              return n ? (t || (t = n),
                e.restoreSelection(),
                A_e(e) ? [2] : [4, S_e("insertLink", e, t, n)]) : [2];
            case 1:
              return i.sent() ? [4, E_e("insertLink", e, n)] : [2];
            case 2:
              return r = i.sent(),
              null == (o = e.selection) || (fne.isCollapsed(o) ? (e.insertText(" "),
                a = C_e(r, t),
                Nne.insertNodes(e, a),
                e.insertFragment([{
                  text: " "
                }])) : Yte.string(e, o) !== t ? (e.deleteFragment(),
                a = C_e(r, t),
                Nne.insertNodes(e, a)) : (a = C_e(r),
                Nne.wrapNodes(e, a, {
                  split: !0
                }),
                Nne.collapse(e, {
                  edge: "end"
                }))),
                [2]
          }
        }
      ))
    }
  ))
}
gke({
  target: "Array",
  proto: !0
}, {
  includes: function(e) {
    return b_e(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
}),
  rDe("includes");
var T_e = {
  type: "link",
  renderElem: function(e, t, n) {
    var r = e
      , o = r.url
      , a = r.target;
    return $ae("a", {
      href: o,
      target: void 0 === a ? "_blank" : a
    }, t)
  }
}
  , D_e = {
  selector: "a:not([data-w-e-type])",
  parseElemHtml: function(e, t, n) {
    var r = Qre(e);
    return 0 === (t = t.filter((function(e) {
        return !!bne.isText(e) || !!n.isInline(e)
      }
    ))).length && (t = [{
      text: r.text().replace(/\s+/gm, " ")
    }]),
      {
        type: "link",
        url: r.attr("href") || "",
        target: r.attr("target") || "",
        children: t
      }
  }
};
function O_e() {
  return w_e("w-e-insert-link")
}
var __e = function() {
  function e() {
    this.title = SEe("link.insert"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M440.224 635.776a51.84 51.84 0 0 1-36.768-15.232c-95.136-95.136-95.136-249.92 0-345.056l192-192C641.536 37.408 702.816 12.032 768 12.032s126.432 25.376 172.544 71.456c95.136 95.136 95.136 249.92 0 345.056l-87.776 87.776a51.968 51.968 0 1 1-73.536-73.536l87.776-87.776a140.16 140.16 0 0 0 0-197.984c-26.432-26.432-61.6-40.992-99.008-40.992s-72.544 14.56-99.008 40.992l-192 192a140.16 140.16 0 0 0 0 197.984 51.968 51.968 0 0 1-36.768 88.768z"></path><path d="M256 1012a242.4 242.4 0 0 1-172.544-71.456c-95.136-95.136-95.136-249.92 0-345.056l87.776-87.776a51.968 51.968 0 1 1 73.536 73.536l-87.776 87.776a140.16 140.16 0 0 0 0 197.984c26.432 26.432 61.6 40.992 99.008 40.992s72.544-14.56 99.008-40.992l192-192a140.16 140.16 0 0 0 0-197.984 51.968 51.968 0 1 1 73.536-73.536c95.136 95.136 95.136 249.92 0 345.056l-192 192A242.4 242.4 0 0 1 256 1012z"></path></svg>',
      this.tag = "button",
      this.showModal = !0,
      this.modalWidth = 300,
      this.$content = null,
      this.textInputId = O_e(),
      this.urlInputId = O_e(),
      this.buttonId = O_e()
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.exec = function(e, t) {}
    ,
    e.prototype.isDisabled = function(e) {
      return A_e(e)
    }
    ,
    e.prototype.getModalPositionNode = function(e) {
      return null
    }
    ,
    e.prototype.getModalContentElem = function(e) {
      var t = e.selection
        , n = this
        , r = n.textInputId
        , o = n.urlInputId
        , a = n.buttonId
        , i = VDe(fSe(SEe("link.text"), r), 2)
        , s = i[0]
        , l = Qre(i[1])
        , u = VDe(fSe(SEe("link.url"), o), 2)
        , c = u[0]
        , d = Qre(u[1])
        , f = VDe(pSe(a, SEe("common.ok")), 1)[0];
      if (null == this.$content) {
        var p = Qre("<div></div>");
        p.on("click", "#" + a, (function(t) {
            t.preventDefault();
            var n = p.find("#" + r).val()
              , a = p.find("#" + o).val();
            k_e(e, n, a),
              e.hidePanelOrModal()
          }
        )),
          this.$content = p
      }
      var h = this.$content;
      if (h.empty(),
        h.append(s),
        h.append(c),
        h.append(f),
      null == t || fne.isCollapsed(t))
        l.val("");
      else {
        var v = Yte.string(e, t);
        l.val(v)
      }
      return d.val(""),
        setTimeout((function() {
            l.focus()
          }
        )),
        h[0]
    }
    ,
    e
}();
function R_e() {
  return w_e("w-e-update-link")
}
var L_e = function() {
  function e() {
    this.title = SEe("link.edit"),
      this.iconSvg = sOe,
      this.tag = "button",
      this.showModal = !0,
      this.modalWidth = 300,
      this.$content = null,
      this.urlInputId = R_e(),
      this.buttonId = R_e()
  }
  return e.prototype.getSelectedLinkElem = function(e) {
    var t = qme.getSelectedNodeByType(e, "link");
    return null == t ? null : t
  }
    ,
    e.prototype.getValue = function(e) {
      var t = this.getSelectedLinkElem(e);
      return t && t.url || ""
    }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.exec = function(e, t) {}
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || null == this.getSelectedLinkElem(e)
    }
    ,
    e.prototype.getModalPositionNode = function(e) {
      return qme.getSelectedNodeByType(e, "link")
    }
    ,
    e.prototype.getModalContentElem = function(e) {
      var t = this.urlInputId
        , n = this.buttonId
        , r = VDe(fSe(SEe("link.url"), t), 2)
        , o = r[0]
        , a = Qre(r[1])
        , i = VDe(pSe(n, SEe("common.ok")), 1)[0];
      if (null == this.$content) {
        var s = Qre("<div></div>");
        s.on("click", "button", (function(n) {
            n.preventDefault(),
              e.restoreSelection();
            var r = qme.getSelectedNodeByType(e, "link")
              , o = r ? ene.string(r) : ""
              , a = s.find("#" + t).val();
            !function(e, t, n) {
              NDe(this, void 0, void 0, (function() {
                  var r, o;
                  return MDe(this, (function(a) {
                      switch (a.label) {
                        case 0:
                          return n ? [4, S_e("editLink", e, t, n)] : [2];
                        case 1:
                          return a.sent() ? [4, E_e("editLink", e, n)] : [2];
                        case 2:
                          return r = a.sent(),
                            o = {
                              url: x_e(r)
                            },
                            Nne.setNodes(e, o, {
                              match: function(e) {
                                return qme.checkNodeType(e, "link")
                              }
                            }),
                            [2]
                      }
                    }
                  ))
                }
              ))
            }(e, o, a),
              e.hidePanelOrModal()
          }
        )),
          this.$content = s
      }
      var l = this.$content;
      l.empty(),
        l.append(o),
        l.append(i);
      var u = this.getValue(e);
      return a.val(u),
        setTimeout((function() {
            a.focus()
          }
        )),
        l[0]
    }
    ,
    e
}()
  , I_e = function() {
  function e() {
    this.title = SEe("link.unLink"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M608.16328 811.815036c9.371954 9.371954 9.371954 24.56788 0 33.941834l-89.347563 89.347564c-118.525421 118.523421-311.38448 118.531421-429.919901 0-118.527421-118.529421-118.527421-311.39048 0-429.917901l89.349564-89.349563c9.371954-9.371954 24.56788-9.371954 33.941834 0l79.195613 79.195613c9.371954 9.371954 9.371954 24.56788 0 33.941834l-89.349563 89.347564c-56.143726 56.145726-56.143726 147.49928 0 203.645005 56.143726 56.143726 147.49928 56.145726 203.647005 0l89.347564-89.347563c9.371954-9.371954 24.56788-9.371954 33.941834 0l79.193613 79.195613z m-113.135447-520.429459c9.371954 9.371954 24.56788 9.371954 33.941834 0l89.347564-89.347564c56.143726-56.149726 147.49928-56.145726 203.647006 0 56.143726 56.145726 56.143726 147.49928 0 203.645006l-89.349564 89.347564c-9.371954 9.371954-9.371954 24.56788 0 33.941834l79.195613 79.195613c9.371954 9.371954 24.56788 9.371954 33.941834 0l89.349564-89.349563c118.529421-118.529421 118.529421-311.38848 0-429.917901-118.531421-118.527421-311.38848-118.527421-429.919901 0l-89.347563 89.347564c-9.371954 9.371954-9.371954 24.56788 0 33.941834l79.193613 79.195613z m469.653707 718.556492l45.253779-45.253779c18.745908-18.745908 18.745908-49.13776 0-67.881669L127.195629 14.062931c-18.745908-18.745908-49.13776-18.745908-67.881669 0L14.058181 59.31871c-18.745908 18.745908-18.745908 49.13776 0 67.881669l882.74169 882.74169c18.745908 18.743908 49.13776 18.743908 67.881669 0z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || null == qme.getSelectedNodeByType(e, "link")
    }
    ,
    e.prototype.exec = function(e, t) {
      this.isDisabled(e) || Nne.unwrapNodes(e, {
        match: function(e) {
          return qme.checkNodeType(e, "link")
        }
      })
    }
    ,
    e
}()
  , P_e = function() {
  function e() {
    this.title = SEe("link.view"),
      this.iconSvg = lOe,
      this.tag = "button"
  }
  return e.prototype.getSelectedLinkElem = function(e) {
    var t = qme.getSelectedNodeByType(e, "link");
    return null == t ? null : t
  }
    ,
    e.prototype.getValue = function(e) {
      var t = this.getSelectedLinkElem(e);
      return t && t.url || ""
    }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || null == this.getSelectedLinkElem(e)
    }
    ,
    e.prototype.exec = function(e, t) {
      if (!this.isDisabled(e)) {
        if (!t || "string" != typeof t)
          throw new Error("View link failed, link url is '" + t + "'");
        window.open(t, "_blank")
      }
    }
    ,
    e
}()
  , F_e = {
  checkLink: function(e, t) {
    return !0
  },
  parseLinkUrl: function(e) {
    return e
  }
}
  , B_e = {
  renderElems: [T_e],
  elemsToHtml: [{
    type: "link",
    elemToHtml: function(e, t) {
      var n = e
        , r = n.url
        , o = n.target;
      return '<a href="' + r + '" target="' + (void 0 === o ? "_blank" : o) + '">' + t + "</a>"
    }
  }],
  parseElemsHtml: [D_e],
  menus: [{
    key: "insertLink",
    factory: function() {
      return new __e
    },
    config: F_e
  }, {
    key: "editLink",
    factory: function() {
      return new L_e
    },
    config: F_e
  }, {
    key: "unLink",
    factory: function() {
      return new I_e
    }
  }, {
    key: "viewLink",
    factory: function() {
      return new P_e
    }
  }],
  editorPlugin: function(e) {
    var t = e.isInline
      , n = e.insertData
      , r = e.normalizeNode;
    e.insertNode,
      e.insertText;
    var o = e;
    return o.isInline = function(e) {
      return "link" === e.type || t(e)
    }
      ,
      o.insertData = function(e) {
        var t = e.getData("text/plain");
        if (function(e) {
          if ("string" != typeof e)
            return !1;
          var t = e.match(g_e);
          if (!t)
            return !1;
          var n = t[1];
          return !(!n || !m_e.test(n) && !y_e.test(n))
        }(t)) {
          if (!A_e(o)) {
            var r = o.selection;
            if (null != r) {
              var a = Yte.string(o, r);
              k_e(o, a, t)
            }
          }
        } else
          n(e)
      }
      ,
      o.normalizeNode = function(e) {
        var t = VDe(e, 2)
          , n = t[0]
          , a = t[1];
        return "link" !== qme.getNodeType(n) ? r([n, a]) : "" === ene.string(n) ? Nne.removeNodes(o, {
          at: a
        }) : r([n, a])
      }
      ,
      o
  }
}
  , N_e = uAe(1..valueOf)
  , M_e = YEe.RangeError
  , j_e = YEe.RangeError
  , V_e = YEe.String
  , U_e = Math.floor
  , $_e = uAe((function(e) {
    var t = Kke(mAe(this))
      , n = ""
      , r = HCe(e);
    if (r < 0 || r == 1 / 0)
      throw M_e("Wrong number of repetitions");
    for (; r > 0; (r >>>= 1) && (t += t))
      1 & r && (n += t);
    return n
  }
))
  , H_e = uAe("".slice)
  , z_e = uAe(1..toFixed)
  , K_e = function(e, t, n) {
  return 0 === t ? n : t % 2 == 1 ? K_e(e, t - 1, n * e) : K_e(e * e, t / 2, n)
}
  , W_e = function(e, t, n) {
  for (var r = -1, o = n; ++r < 6; )
    o += t * e[r],
      e[r] = o % 1e7,
      o = U_e(o / 1e7)
}
  , G_e = function(e, t) {
  for (var n = 6, r = 0; --n >= 0; )
    r += e[n],
      e[n] = U_e(r / t),
      r = r % t * 1e7
}
  , q_e = function(e) {
  for (var t = 6, n = ""; --t >= 0; )
    if ("" !== n || 0 === t || 0 !== e[t]) {
      var r = V_e(e[t]);
      n = "" === n ? r : n + $_e("0", 7 - r.length) + r
    }
  return n
};
function Y_e(e, t) {
  return "w-e-image-container-" + qme.findKey(e, t).id
}
gke({
  target: "Number",
  proto: !0,
  forced: XEe((function() {
      return "0.000" !== z_e(8e-5, 3) || "1" !== z_e(.9, 0) || "1.25" !== z_e(1.255, 2) || "1000000000000000128" !== z_e(0xde0b6b3a7640080, 0)
    }
  )) || !XEe((function() {
      z_e({})
    }
  ))
}, {
  toFixed: function(e) {
    var t, n, r, o, a = N_e(this), i = HCe(e), s = [0, 0, 0, 0, 0, 0], l = "", u = "0";
    if (i < 0 || i > 20)
      throw j_e("Incorrect fraction digits");
    if (a != a)
      return "NaN";
    if (a <= -1e21 || a >= 1e21)
      return V_e(a);
    if (a < 0 && (l = "-",
      a = -a),
    a > 1e-21)
      if (n = (t = function(e) {
        for (var t = 0, n = e; n >= 4096; )
          t += 12,
            n /= 4096;
        for (; n >= 2; )
          t += 1,
            n /= 2;
        return t
      }(a * K_e(2, 69, 1)) - 69) < 0 ? a * K_e(2, -t, 1) : a / K_e(2, t, 1),
        n *= 4503599627370496,
      (t = 52 - t) > 0) {
        for (W_e(s, 0, n),
               r = i; r >= 7; )
          W_e(s, 1e7, 0),
            r -= 7;
        for (W_e(s, K_e(10, r, 1), 0),
               r = t - 1; r >= 23; )
          G_e(s, 1 << 23),
            r -= 23;
        G_e(s, 1 << r),
          W_e(s, 1, 1),
          G_e(s, 2),
          u = q_e(s)
      } else
        W_e(s, 0, n),
          W_e(s, 1 << -t, 0),
          u = q_e(s) + $_e("0", i);
    return i > 0 ? l + ((o = u.length) <= i ? "0." + $_e("0", i - o) + u : H_e(u, 0, o - i) + "." + H_e(u, o - i)) : l + u
  }
});
var X_e = {
  type: "image",
  renderElem: function(e, t, n) {
    var r = e
      , o = r.src
      , a = r.alt
      , i = void 0 === a ? "" : a
      , s = r.href
      , l = void 0 === s ? "" : s
      , u = r.style
      , c = void 0 === u ? {} : u
      , d = c.width
      , f = void 0 === d ? "" : d
      , p = c.height
      , h = void 0 === p ? "" : p
      , v = qme.isNodeSelected(n, e)
      , g = {};
    f && (g.width = "100%"),
    h && (g.height = "100%");
    var m, y, b, w, x, S, E, A = $ae("img", {
      style: g,
      src: o,
      alt: i,
      "data-href": l
    }), C = n.isDisabled();
    return v && !C ? function(e, t, n, r) {
      var o = Qre("body")
        , a = Y_e(e, t)
        , i = r.width
        , s = r.height
        , l = 0
        , u = 0
        , c = 0
        , d = !1
        , f = null;
      var p = uae((function(e) {
          e.preventDefault();
          var t = e.clientX
            , n = u + (d ? l - t : t - l)
            , r = c * (n / u);
          null != f && (n <= 15 || r <= 15 || (f.css("width", n + "px"),
            f.css("height", r + "px")))
        }
      ), 100);
      function h(n) {
        if (o.off("mousemove", p),
        null != f) {
          var r = f.width().toFixed(2)
            , a = f.height().toFixed(2)
            , i = {
            style: BDe(BDe({}, t.style), {
              width: r + "px",
              height: a + "px"
            })
          };
          Nne.setNodes(e, i, {
            at: qme.findPath(e, t)
          }),
            o.off("mouseup", h)
        }
      }
      var v = {};
      return i && (v.width = i),
      s && (v.height = s),
        $ae("div", {
          id: a,
          style: v,
          className: "w-e-image-container w-e-selected-image-container",
          on: {
            mousedown: function(t) {
              var n = Qre(t.target);
              n.hasClass("w-e-image-dragger") && (t.preventDefault(),
              (n.hasClass("left-top") || n.hasClass("left-bottom")) && (d = !0),
                function(t) {
                  f = function() {
                    var e = Qre("#" + a);
                    if (0 === e.length)
                      throw new Error("Cannot find image container elem");
                    return e
                  }(),
                    l = t;
                  var n = f.find("img");
                  if (0 === n.length)
                    throw new Error("Cannot find image elem");
                  u = n.width(),
                    c = n.height(),
                    o.on("mousemove", p),
                    o.on("mouseup", h);
                  var r = qme.getHoverbar(e);
                  r && r.hideAndClean()
                }(t.clientX))
            }
          }
        }, n, $ae("div", {
          className: "w-e-image-dragger left-top"
        }), $ae("div", {
          className: "w-e-image-dragger right-top"
        }), $ae("div", {
          className: "w-e-image-dragger left-bottom"
        }), $ae("div", {
          className: "w-e-image-dragger right-bottom"
        }))
    }(n, e, A, {
      width: f,
      height: h
    }) : (m = n,
      y = e,
      b = A,
      S = (w = {
        width: f,
        height: h
      }).height,
      E = {},
    (x = w.width) && (E.width = x),
    S && (E.height = S),
      $ae("div", {
        id: Y_e(m, y),
        style: E,
        className: "w-e-image-container"
      }, b))
  }
}
  , Q_e = {
  selector: "img:not([data-w-e-type])",
  parseElemHtml: function(e, t, n) {
    var r = Qre(e)
      , o = r.attr("data-href") || "";
    return o = decodeURIComponent(o),
      {
        type: "image",
        src: r.attr("src") || "",
        alt: r.attr("alt") || "",
        href: o,
        style: {
          width: LDe(r, "width"),
          height: LDe(r, "height")
        },
        children: [{
          text: ""
        }]
      }
  }
};
function J_e(e, t, n, r, o) {
  return void 0 === r && (r = ""),
  void 0 === o && (o = ""),
    NDe(this, void 0, void 0, (function() {
        var a, i;
        return MDe(this, (function(s) {
            switch (s.label) {
              case 0:
                return (a = t.getMenuConfig(e).checkImage) ? [4, a(n, r, o)] : [3, 2];
              case 1:
                if ("string" == typeof (i = s.sent()))
                  return t.alert(i, "error"),
                    [2, !1];
                if (null == i)
                  return [2, !1];
                s.label = 2;
              case 2:
                return [2, !0]
            }
          }
        ))
      }
    ))
}
function Z_e(e, t, n) {
  return NDe(this, void 0, void 0, (function() {
      var r;
      return MDe(this, (function(o) {
          switch (o.label) {
            case 0:
              return (r = t.getMenuConfig(e).parseImageSrc) ? [4, r(n)] : [3, 2];
            case 1:
              return [2, o.sent()];
            case 2:
              return [2, n]
          }
        }
      ))
    }
  ))
}
function eRe(e, t, n, r) {
  return void 0 === n && (n = ""),
  void 0 === r && (r = ""),
    NDe(this, void 0, void 0, (function() {
        var o, a, i;
        return MDe(this, (function(s) {
            switch (s.label) {
              case 0:
                return [4, J_e("insertImage", e, t, n, r)];
              case 1:
                return s.sent() ? [4, Z_e("insertImage", e, t)] : [2];
              case 2:
                return o = s.sent(),
                  a = {
                    type: "image",
                    src: x_e(o),
                    href: r,
                    alt: n,
                    style: {},
                    children: [{
                      text: ""
                    }]
                  },
                null === e.selection && e.restoreSelection(),
                qme.getSelectedNodeByType(e, "image") && e.move(1),
                tRe(e) || (Nne.insertNodes(e, a),
                (i = e.getMenuConfig("insertImage").onInsertedImage) && i(a)),
                  [2]
            }
          }
        ))
      }
    ))
}
function tRe(e) {
  var t = e.selection;
  return null == t || !fne.isCollapsed(t) || !!VDe(Yte.nodes(e, {
    match: function(t) {
      var n = qme.getNodeType(t);
      return "code" === n || "pre" === n || "link" === n || "list-item" === n || !!n.startsWith("header") || "blockquote" === n || !!Yte.isVoid(e, t)
    },
    universal: !0
  }), 1)[0]
}
function nRe() {
  return w_e("w-e-insert-image")
}
var rRe = function() {
  function e() {
    this.title = SEe("image.netImage"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M959.877 128l0.123 0.123v767.775l-0.123 0.122H64.102l-0.122-0.122V128.123l0.122-0.123h895.775zM960 64H64C28.795 64 0 92.795 0 128v768c0 35.205 28.795 64 64 64h896c35.205 0 64-28.795 64-64V128c0-35.205-28.795-64-64-64zM832 288.01c0 53.023-42.988 96.01-96.01 96.01s-96.01-42.987-96.01-96.01S682.967 192 735.99 192 832 234.988 832 288.01zM896 832H128V704l224.01-384 256 320h64l224.01-192z"></path></svg>',
      this.tag = "button",
      this.showModal = !0,
      this.modalWidth = 300,
      this.$content = null,
      this.srcInputId = nRe(),
      this.altInputId = nRe(),
      this.hrefInputId = nRe(),
      this.buttonId = nRe()
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.exec = function(e, t) {}
    ,
    e.prototype.isDisabled = function(e) {
      return tRe(e)
    }
    ,
    e.prototype.getModalPositionNode = function(e) {
      return null
    }
    ,
    e.prototype.getModalContentElem = function(e) {
      var t = this
        , n = this
        , r = n.srcInputId
        , o = n.altInputId
        , a = n.hrefInputId
        , i = n.buttonId
        , s = VDe(fSe(SEe("image.src"), r), 2)
        , l = s[0]
        , u = Qre(s[1])
        , c = VDe(fSe(SEe("image.desc"), o), 2)
        , d = c[0]
        , f = Qre(c[1])
        , p = VDe(fSe(SEe("image.link"), a), 2)
        , h = p[0]
        , v = Qre(p[1])
        , g = VDe(pSe(i, SEe("common.ok")), 1)[0];
      if (null == this.$content) {
        var m = Qre("<div></div>");
        m.on("click", "#" + i, (function(n) {
            n.preventDefault();
            var i = m.find("#" + r).val().trim()
              , s = m.find("#" + o).val().trim()
              , l = m.find("#" + a).val().trim();
            t.insertImage(e, i, s, l),
              e.hidePanelOrModal()
          }
        )),
          this.$content = m
      }
      var y = this.$content;
      return y.empty(),
        y.append(l),
        y.append(d),
        y.append(h),
        y.append(g),
        u.val(""),
        f.val(""),
        v.val(""),
        setTimeout((function() {
            u.focus()
          }
        )),
        y[0]
    }
    ,
    e.prototype.insertImage = function(e, t, n, r) {
      void 0 === n && (n = ""),
      void 0 === r && (r = ""),
      t && (e.restoreSelection(),
      this.isDisabled(e) || eRe(e, t, n, r))
    }
    ,
    e
}()
  , oRe = function() {
  function e() {
    this.title = SEe("image.delete"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M826.8032 356.5312c-19.328 0-36.3776 15.6928-36.3776 35.0464v524.2624c0 19.328-16 34.56-35.328 34.56H264.9344c-19.328 0-35.5072-15.3088-35.5072-34.56V390.0416c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.6928-33.5104 35.0464V915.712c0 57.9328 44.6208 108.288 102.528 108.288H755.2c57.9328 0 108.0832-50.4576 108.0832-108.288V391.4752c-0.1024-19.2512-17.1264-34.944-36.48-34.944z" p-id="9577"></path><path d="M437.1712 775.7568V390.6048c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.616-33.5104 35.0464v385.152c0 19.328 14.1568 35.0464 33.5104 35.0464s33.5104-15.7184 33.5104-35.0464zM649.7024 775.7568V390.6048c0-19.328-17.0496-35.0464-36.3776-35.0464s-36.3776 15.616-36.3776 35.0464v385.152c0 19.328 17.0496 35.0464 36.3776 35.0464s36.3776-15.7184 36.3776-35.0464zM965.0432 217.0368h-174.6176V145.5104c0-57.9328-47.2064-101.76-104.6528-101.76h-350.976c-57.8304 0-105.3952 43.8528-105.3952 101.76v71.5264H54.784c-19.4304 0-35.0464 14.1568-35.0464 33.5104 0 19.328 15.616 33.5104 35.0464 33.5104h910.3616c19.328 0 35.0464-14.1568 35.0464-33.5104 0-19.3536-15.6928-33.5104-35.1488-33.5104z m-247.3728 0H297.3952V145.5104c0-19.328 18.2016-34.7648 37.4272-34.7648h350.976c19.1488 0 31.872 15.1296 31.872 34.7648v71.5264z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || null == qme.getSelectedNodeByType(e, "image")
    }
    ,
    e.prototype.exec = function(e, t) {
      this.isDisabled(e) || Nne.removeNodes(e, {
        match: function(e) {
          return qme.checkNodeType(e, "image")
        }
      })
    }
    ,
    e
}();
function aRe() {
  return w_e("w-e-edit-image")
}
var iRe = function() {
  function e() {
    this.title = SEe("image.edit"),
      this.iconSvg = sOe,
      this.tag = "button",
      this.showModal = !0,
      this.modalWidth = 300,
      this.$content = null,
      this.srcInputId = aRe(),
      this.altInputId = aRe(),
      this.hrefInputId = aRe(),
      this.buttonId = aRe()
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.getImageNode = function(e) {
      return qme.getSelectedNodeByType(e, "image")
    }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.exec = function(e, t) {}
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !fne.isCollapsed(t) || null == qme.getSelectedNodeByType(e, "image")
    }
    ,
    e.prototype.getModalPositionNode = function(e) {
      return this.getImageNode(e)
    }
    ,
    e.prototype.getModalContentElem = function(e) {
      var t = this
        , n = this
        , r = n.srcInputId
        , o = n.altInputId
        , a = n.hrefInputId
        , i = n.buttonId
        , s = this.getImageNode(e);
      if (null == s)
        throw new Error("Not found selected image node");
      var l = VDe(fSe(SEe("image.src"), r), 2)
        , u = l[0]
        , c = Qre(l[1])
        , d = VDe(fSe(SEe("image.desc"), o), 2)
        , f = d[0]
        , p = Qre(d[1])
        , h = VDe(fSe(SEe("image.link"), a), 2)
        , v = h[0]
        , g = Qre(h[1])
        , m = VDe(pSe(i, SEe("common.ok")), 1)[0];
      if (null == this.$content) {
        var y = Qre("<div></div>");
        y.on("click", "#" + i, (function(n) {
            n.preventDefault();
            var i = y.find("#" + r).val()
              , s = y.find("#" + o).val()
              , l = y.find("#" + a).val();
            t.updateImage(e, i, s, l),
              e.hidePanelOrModal()
          }
        )),
          this.$content = y
      }
      var b = this.$content;
      b.empty(),
        b.append(u),
        b.append(f),
        b.append(v),
        b.append(m);
      var w = s
        , x = w.src
        , S = w.alt
        , E = void 0 === S ? "" : S
        , A = w.href
        , C = void 0 === A ? "" : A;
      return c.val(x),
        p.val(E),
        g.val(C),
        setTimeout((function() {
            c.focus()
          }
        )),
        b[0]
    }
    ,
    e.prototype.updateImage = function(e, t, n, r, o) {
      void 0 === n && (n = ""),
      void 0 === r && (r = ""),
      void 0 === o && (o = {}),
      t && (e.restoreSelection(),
      this.isDisabled(e) || function(e, t, n, r, o) {
        void 0 === n && (n = ""),
        void 0 === r && (r = ""),
        void 0 === o && (o = {}),
          NDe(this, void 0, void 0, (function() {
              var a, i, s, l, u, c;
              return MDe(this, (function(d) {
                  switch (d.label) {
                    case 0:
                      return [4, J_e("editImage", e, t, n, r)];
                    case 1:
                      return d.sent() ? [4, Z_e("editImage", e, t)] : [2];
                    case 2:
                      return a = d.sent(),
                      null == (i = qme.getSelectedNodeByType(e, "image")) || (s = i.style,
                        l = {
                          src: a,
                          alt: n,
                          href: r,
                          style: BDe(BDe({}, void 0 === s ? {} : s), o)
                        },
                        Nne.setNodes(e, l, {
                          match: function(e) {
                            return qme.checkNodeType(e, "image")
                          }
                        }),
                        u = qme.getSelectedNodeByType(e, "image"),
                      (c = e.getMenuConfig("editImage").onUpdatedImage) && c(u)),
                        [2]
                  }
                }
              ))
            }
          ))
      }(e, t, n, r, o))
    }
    ,
    e
}()
  , sRe = function() {
  function e() {
    this.title = SEe("image.viewLink"),
      this.iconSvg = lOe,
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    var t = qme.getSelectedNodeByType(e, "image");
    return t && t.href || ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || !this.getValue(e)
    }
    ,
    e.prototype.exec = function(e, t) {
      if (!this.isDisabled(e)) {
        if (!t || "string" != typeof t)
          throw new Error("View image link failed, image.href is '" + t + "'");
        window.open(t, "_blank")
      }
    }
    ,
    e
}()
  , lRe = function() {
  function e() {
    this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.getSelectedNode = function(e) {
      return qme.getSelectedNodeByType(e, "image")
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || null == this.getSelectedNode(e)
    }
    ,
    e.prototype.exec = function(e, t) {
      if (!this.isDisabled(e)) {
        var n = this.getSelectedNode(e);
        if (null != n) {
          var r = qme.getHoverbar(e);
          r && r.hideAndClean();
          var o = n.style
            , a = {
            style: BDe(BDe({}, void 0 === o ? {} : o), {
              width: this.value,
              height: ""
            })
          };
          Nne.setNodes(e, a, {
            match: function(e) {
              return qme.checkNodeType(e, "image")
            }
          })
        }
      }
    }
    ,
    e
}()
  , uRe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = "30%",
      t.value = "30%",
      t
  }
  return FDe(t, e),
    t
}(lRe)
  , cRe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = "50%",
      t.value = "50%",
      t
  }
  return FDe(t, e),
    t
}(lRe)
  , dRe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = "100%",
      t.value = "100%",
      t
  }
  return FDe(t, e),
    t
}(lRe)
  , fRe = {
  onInsertedImage: function(e) {},
  onUpdatedImage: function(e) {},
  checkImage: function(e, t, n) {
    return !0
  },
  parseImageSrc: function(e) {
    return e
  }
}
  , pRe = {
  renderElems: [X_e],
  elemsToHtml: [{
    type: "image",
    elemToHtml: function(e, t) {
      var n = e
        , r = n.src
        , o = n.alt
        , a = void 0 === o ? "" : o
        , i = n.href
        , s = void 0 === i ? "" : i
        , l = n.style
        , u = void 0 === l ? {} : l
        , c = u.width
        , d = void 0 === c ? "" : c
        , f = u.height
        , p = void 0 === f ? "" : f
        , h = "";
      return d && (h += "width: " + d + ";"),
      p && (h += "height: " + p + ";"),
      '<img src="' + r + '" alt="' + a + '" data-href="' + s + '" style="' + h + '"/>'
    }
  }],
  parseElemsHtml: [Q_e],
  menus: [{
    key: "insertImage",
    factory: function() {
      return new rRe
    },
    config: fRe
  }, {
    key: "deleteImage",
    factory: function() {
      return new oRe
    }
  }, {
    key: "editImage",
    factory: function() {
      return new iRe
    },
    config: fRe
  }, {
    key: "viewImageLink",
    factory: function() {
      return new sRe
    }
  }, {
    key: "imageWidth30",
    factory: function() {
      return new uRe
    }
  }, {
    key: "imageWidth50",
    factory: function() {
      return new cRe
    }
  }, {
    key: "imageWidth100",
    factory: function() {
      return new dRe
    }
  }],
  editorPlugin: function(e) {
    var t = e.isInline
      , n = e.isVoid;
    e.insertNode;
    var r = e;
    return r.isInline = function(e) {
      return "image" === e.type || t(e)
    }
      ,
      r.isVoid = function(e) {
        return "image" === e.type || n(e)
      }
      ,
      r
  }
}
  , hRe = {
  type: "todo",
  renderElem: function(e, t, n) {
    var r = !1;
    return n.isDisabled() && (r = !0),
      $ae("div", {
        style: {
          margin: "5px 0"
        }
      }, $ae("span", {
        contentEditable: !1,
        style: {
          marginRight: "0.5em"
        }
      }, $ae("input", {
        type: "checkbox",
        checked: e.checked,
        disabled: r,
        on: {
          change: function(t) {
            var r = qme.findPath(n, e)
              , o = {
              checked: t.target.checked
            };
            Nne.setNodes(n, o, {
              at: r
            })
          }
        }
      })), $ae("span", null, t))
  }
}
  , vRe = function() {
  function e() {
    this.title = SEe("todo.todo"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M278.755556 403.911111l-79.644445 79.644445L455.111111 739.555556l568.888889-568.888889-79.644444-79.644445L455.111111 580.266667l-176.355555-176.355556zM910.222222 910.222222H113.777778V113.777778h568.888889V0H113.777778C51.2 0 0 51.2 0 113.777778v796.444444c0 62.577778 51.2 113.777778 113.777778 113.777778h796.444444c62.577778 0 113.777778-51.2 113.777778-113.777778V455.111111h-113.777778v455.111111z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !!qme.getSelectedNodeByType(e, "todo")
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || !!qme.getSelectedElems(e).some((function(t) {
          if (Yte.isVoid(e, t) && Yte.isBlock(e, t))
            return !0;
          var n = t.type;
          return !!["pre", "table", "list-item"].includes(n) || void 0
        }
      ))
    }
    ,
    e.prototype.exec = function(e, t) {
      var n = this.isActive(e);
      Nne.setNodes(e, {
        type: n ? "paragraph" : "todo"
      })
    }
    ,
    e
}()
  , gRe = {
  selector: 'div[data-w-e-type="todo"]',
  parseElemHtml: function(e, t, n) {
    var r = Qre(e);
    0 === (t = t.filter((function(e) {
        return !!bne.isText(e) || !!n.isInline(e)
      }
    ))).length && (t = [{
      text: r.text().replace(/\s+/gm, " ")
    }]);
    var o = !1;
    return null != r.find('input[type="checkbox"]').attr("checked") && (o = !0),
      {
        type: "todo",
        checked: o,
        children: t
      }
  }
}
  , mRe = {
  renderElems: [hRe],
  elemsToHtml: [{
    type: "todo",
    elemToHtml: function(e, t) {
      return '<div data-w-e-type="todo"><input type="checkbox" disabled ' + (e.checked ? "checked" : "") + ">" + t + "</div>"
    }
  }],
  preParseHtml: [{
    selector: "ul.w-e-todo",
    preParseHtml: function(e) {
      var t = Qre(e).find("li")
        , n = Qre('<div data-w-e-type="todo"></div>')
        , r = t.find("input[type]");
      return n.append(r),
        t.children()[0].remove(),
        n[0].innerHTML = n[0].innerHTML + t[0].innerHTML,
        n[0]
    }
  }],
  parseElemsHtml: [gRe],
  menus: [{
    key: "todo",
    factory: function() {
      return new vRe
    }
  }],
  editorPlugin: function(e) {
    var t = e.deleteBackward
      , n = e;
    return n.deleteBackward = function(n) {
      var r = e.selection;
      if (r && fne.isCollapsed(r)) {
        var o = qme.getSelectedNodeByType(e, "todo");
        if (o && 0 === ene.string(o).length)
          return void Nne.setNodes(e, {
            type: "paragraph"
          }, {
            mode: "highest"
          })
      }
      t(n)
    }
      ,
      n
  }
}
  , yRe = {
  type: "blockquote",
  renderElem: function(e, t, n) {
    return $ae("blockquote", null, t)
  }
}
  , bRe = {
  selector: "blockquote:not([data-w-e-type])",
  parseElemHtml: function(e, t, n) {
    var r = Qre(e);
    return 0 === (t = t.filter((function(e) {
        return !!bne.isText(e) || !!n.isInline(e)
      }
    ))).length && (t = [{
      text: r.text().replace(/\s+/gm, " ")
    }]),
      {
        type: "blockquote",
        children: t
      }
  }
}
  , wRe = function() {
  function e() {
    this.title = SEe("blockQuote.title"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M894.6 907.1H605.4c-32.6 0-59-26.4-59-59V608.2l-4-14.9c0-315.9 125.5-485.1 376.5-507.5v59.8C752.7 180.4 711.3 315.8 711.3 442.4v41.2l31.5 12.3h151.8c32.6 0 59 26.4 59 59v293.2c0 32.5-26.4 59-59 59z m-472 0H133.4c-32.6 0-59-26.4-59-59V608.2l-4-14.9c0-315.9 125.5-485.1 376.5-507.5v59.8C280.7 180.4 239.3 315.8 239.3 442.4v41.2l31.5 12.3h151.8c32.6 0 59 26.4 59 59v293.2c0 32.5-26.4 59-59 59z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !!qme.getSelectedNodeByType(e, "blockquote")
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || !VDe(Yte.nodes(e, {
        match: function(e) {
          var t = qme.getNodeType(e);
          return "paragraph" === t || "blockquote" === t
        },
        universal: !0,
        mode: "highest"
      }), 1)[0]
    }
    ,
    e.prototype.exec = function(e, t) {
      if (!this.isDisabled(e)) {
        var n = this.isActive(e) ? "paragraph" : "blockquote";
        Nne.setNodes(e, {
          type: n
        }, {
          mode: "highest"
        })
      }
    }
    ,
    e
}()
  , xRe = {
  key: "blockquote",
  factory: function() {
    return new wRe
  }
}
  , SRe = uAe([].slice)
  , ERe = Vke("slice")
  , ARe = tCe("species")
  , CRe = YEe.Array
  , kRe = Math.max;
gke({
  target: "Array",
  proto: !0,
  forced: !ERe
}, {
  slice: function(e, t) {
    var n, r, o, a = yAe(this), i = YCe(a), s = WCe(e, i), l = WCe(void 0 === t ? i : t, i);
    if (yke(a) && (n = a.constructor,
    (Lke(n) && (n === CRe || yke(n.prototype)) || wAe(n) && null === (n = n[ARe])) && (n = void 0),
    n === CRe || void 0 === n))
      return SRe(a, s, l);
    for (r = new (void 0 === n ? CRe : n)(kRe(l - s, 0)),
           o = 0; s < l; s++,
           o++)
      s in a && cDe(r, o, a[s]);
    return r.length = o,
      r
  }
});
var TRe = {
  renderElems: [yRe],
  elemsToHtml: [{
    type: "blockquote",
    elemToHtml: function(e, t) {
      return "<blockquote>" + t + "</blockquote>"
    }
  }],
  parseElemsHtml: [bRe],
  menus: [xRe],
  editorPlugin: function(e) {
    var t = e.insertBreak
      , n = e.insertText
      , r = e;
    return r.insertBreak = function() {
      var o = r.selection;
      if (null == o)
        return t();
      var a = VDe(Yte.nodes(e, {
        match: function(e) {
          return qme.checkNodeType(e, "blockquote")
        },
        universal: !0
      }), 1)[0];
      if (!a)
        return t();
      var i = a[0]
        , s = qme.findPath(e, i)
        , l = Yte.end(e, s);
      if (lne.equals(l, o.focus)) {
        var u = ene.string(i);
        if (u && "\n" === u.slice(-1))
          return e.deleteBackward("character"),
            void Nne.insertNodes(r, {
              type: "paragraph",
              children: [{
                text: ""
              }]
            }, {
              mode: "highest"
            })
      }
      n("\n")
    }
      ,
      r
  }
}
  , DRe = function() {
  function e() {
    this.title = SEe("emotion.title"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M512 1024C230.4 1024 0 793.6 0 512S230.4 0 512 0s512 230.4 512 512-230.4 512-512 512z m0-102.4c226.742857 0 409.6-182.857143 409.6-409.6S738.742857 102.4 512 102.4 102.4 285.257143 102.4 512s182.857143 409.6 409.6 409.6z m-204.8-358.4h409.6c0 113.371429-91.428571 204.8-204.8 204.8s-204.8-91.428571-204.8-204.8z m0-102.4c-43.885714 0-76.8-32.914286-76.8-76.8s32.914286-76.8 76.8-76.8 76.8 32.914286 76.8 76.8-32.914286 76.8-76.8 76.8z m409.6 0c-43.885714 0-76.8-32.914286-76.8-76.8s32.914286-76.8 76.8-76.8c43.885714 0 76.8 32.914286 76.8 76.8s-32.914286 76.8-76.8 76.8z"></path></svg>',
      this.tag = "button",
      this.showDropPanel = !0,
      this.$content = null
  }
  return e.prototype.exec = function(e, t) {}
    ,
    e.prototype.getValue = function(e) {
      return ""
    }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || !!VDe(Yte.nodes(e, {
        match: function(t) {
          return "pre" === qme.getNodeType(t) || !!Yte.isVoid(e, t)
        },
        universal: !0
      }), 1)[0]
    }
    ,
    e.prototype.getPanelContentElem = function(e) {
      if (null == this.$content) {
        var t = Qre('<ul class="w-e-panel-content-emotion"></ul>');
        t.on("click", "li", (function(t) {
            var n = t.target;
            if (null != n) {
              t.preventDefault();
              var r = Qre(n).text();
              e.insertText(r)
            }
          }
        )),
          this.$content = t
      }
      var n = this.$content;
      if (null == n)
        return document.createElement("ul");
      n.empty();
      var r = e.getMenuConfig("emotion").emotions;
      return (void 0 === r ? [] : r).forEach((function(e) {
          var t = Qre("<li>" + e + "</li>");
          n.append(t)
        }
      )),
        n[0]
    }
    ,
    e
}()
  , ORe = {
  menus: [{
    key: "emotion",
    factory: function() {
      return new DRe
    },
    config: {
      emotions: "😀 😃 😄 😁 😆 😅 😂 🤣 😊 😇 🙂 🙃 😉 😌 😍 😘 😗 😙 😚 😋 😛 😝 😜 🤓 😎 😏 😒 😞 😔 😟 😕 🙁 😣 😖 😫 😩 😢 😭 😤 😠 😡 😳 😱 😨 🤗 🤔 😶 😑 😬 🙄 😯 😴 😷 🤑 😈 🤡 💩 👻 💀 👀 👣 👐 🙌 👏 🤝 👍 👎 👊 ✊ 🤛 🤜 🤞 ✌️ 🤘 👌 👈 👉 👆 👇 ☝️ ✋ 🤚 🖐 🖖 👋 🤙 💪 🖕 ✍️ 🙏".split(" ")
    }
  }]
}
  , _Re = {
  1: "12px",
  2: "14px",
  3: "16px",
  4: "19px",
  5: "24px",
  6: "32px",
  7: "48px"
}
  , RRe = {
  selector: "font",
  preParseHtml: function(e) {
    var t = Qre(e);
    if ("font" !== RDe(t))
      return e;
    var n = t.attr("size") || "";
    n && (t.removeAttr("size"),
      t.css("font-size", _Re[n]));
    var r = t.attr("face") || "";
    return r && (t.removeAttr("face"),
      t.css("font-family", r)),
      t[0]
  }
}
  , LRe = uAe("".indexOf);
gke({
  target: "String",
  proto: !0,
  forced: !POe("includes")
}, {
  includes: function(e) {
    return !!~LRe(Kke(mAe(this)), Kke(LOe(e)), arguments.length > 1 ? arguments[1] : void 0)
  }
});
var IRe, PRe, FRe = function(e) {
  return e && e.Math == Math && e
}, BRe = FRe("object" == typeof globalThis && globalThis) || FRe("object" == typeof window && window) || FRe("object" == typeof self && self) || FRe("object" == typeof zEe && zEe) || function() {
  return this
}() || Function("return this")(), NRe = Function.prototype, MRe = NRe.apply, jRe = NRe.bind, VRe = NRe.call, URe = "object" == typeof Reflect && Reflect.apply || (jRe ? VRe.bind(MRe) : function() {
    return VRe.apply(MRe, arguments)
  }
), $Re = Function.prototype, HRe = $Re.bind, zRe = $Re.call, KRe = HRe && HRe.bind(zRe), WRe = HRe ? function(e) {
    return e && KRe(zRe, e)
  }
  : function(e) {
    return e && function() {
      return zRe.apply(e, arguments)
    }
  }
  , GRe = function(e) {
  return "function" == typeof e
}, qRe = function(e) {
  try {
    return !!e()
  } catch (t) {
    return !0
  }
}, YRe = !qRe((function() {
    return 7 != Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1]
  }
)), XRe = Function.prototype.call, QRe = XRe.bind ? XRe.bind(XRe) : function() {
  return XRe.apply(XRe, arguments)
}
  , JRe = {}.propertyIsEnumerable, ZRe = Object.getOwnPropertyDescriptor, eLe = ZRe && !JRe.call({
  1: 2
}, 1) ? function(e) {
    var t = ZRe(this, e);
    return !!t && t.enumerable
  }
  : JRe, tLe = {
  f: eLe
}, nLe = function(e, t) {
  return {
    enumerable: !(1 & e),
    configurable: !(2 & e),
    writable: !(4 & e),
    value: t
  }
}, rLe = WRe({}.toString), oLe = WRe("".slice), aLe = function(e) {
  return oLe(rLe(e), 8, -1)
}, iLe = BRe.Object, sLe = WRe("".split), lLe = qRe((function() {
    return !iLe("z").propertyIsEnumerable(0)
  }
)) ? function(e) {
    return "String" == aLe(e) ? sLe(e, "") : iLe(e)
  }
  : iLe, uLe = BRe.TypeError, cLe = function(e) {
  if (null == e)
    throw uLe("Can't call method on " + e);
  return e
}, dLe = function(e) {
  return lLe(cLe(e))
}, fLe = function(e) {
  return "object" == typeof e ? null !== e : GRe(e)
}, pLe = {}, hLe = function(e) {
  return GRe(e) ? e : void 0
}, vLe = function(e, t) {
  return arguments.length < 2 ? hLe(pLe[e]) || hLe(BRe[e]) : pLe[e] && pLe[e][t] || BRe[e] && BRe[e][t]
}, gLe = WRe({}.isPrototypeOf), mLe = vLe("navigator", "userAgent") || "", yLe = BRe.process, bLe = BRe.Deno, wLe = yLe && yLe.versions || bLe && bLe.version, xLe = wLe && wLe.v8;
xLe && (PRe = (IRe = xLe.split("."))[0] > 0 && IRe[0] < 4 ? 1 : +(IRe[0] + IRe[1])),
!PRe && mLe && (!(IRe = mLe.match(/Edge\/(\d+)/)) || IRe[1] >= 74) && (IRe = mLe.match(/Chrome\/(\d+)/)) && (PRe = +IRe[1]);
var SLe = PRe
  , ELe = !!Object.getOwnPropertySymbols && !qRe((function() {
    var e = Symbol();
    return !String(e) || !(Object(e)instanceof Symbol) || !Symbol.sham && SLe && SLe < 41
  }
))
  , ALe = ELe && !Symbol.sham && "symbol" == typeof Symbol.iterator
  , CLe = BRe.Object
  , kLe = ALe ? function(e) {
    return "symbol" == typeof e
  }
  : function(e) {
    var t = vLe("Symbol");
    return GRe(t) && gLe(t.prototype, CLe(e))
  }
  , TLe = BRe.String
  , DLe = BRe.TypeError
  , OLe = function(e) {
  if (GRe(e))
    return e;
  throw DLe(function(e) {
    try {
      return TLe(e)
    } catch (t) {
      return "Object"
    }
  }(e) + " is not a function")
}
  , _Le = BRe.TypeError
  , RLe = Object.defineProperty
  , LLe = BRe["__core-js_shared__"] || function(e, t) {
  try {
    RLe(BRe, e, {
      value: t,
      configurable: !0,
      writable: !0
    })
  } catch (AEe) {
    BRe[e] = t
  }
  return t
}("__core-js_shared__", {})
  , ILe = KEe((function(e) {
    (e.exports = function(e, t) {
        return LLe[e] || (LLe[e] = void 0 !== t ? t : {})
      }
    )("versions", []).push({
      version: "3.19.3",
      mode: "pure",
      copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
    })
  }
))
  , PLe = BRe.Object
  , FLe = function(e) {
  return PLe(cLe(e))
}
  , BLe = WRe({}.hasOwnProperty)
  , NLe = Object.hasOwn || function(e, t) {
  return BLe(FLe(e), t)
}
  , MLe = 0
  , jLe = Math.random()
  , VLe = WRe(1..toString)
  , ULe = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + VLe(++MLe + jLe, 36)
}
  , $Le = ILe("wks")
  , HLe = BRe.Symbol
  , zLe = HLe && HLe.for
  , KLe = ALe ? HLe : HLe && HLe.withoutSetter || ULe
  , WLe = function(e) {
  if (!NLe($Le, e) || !ELe && "string" != typeof $Le[e]) {
    var t = "Symbol." + e;
    ELe && NLe(HLe, e) ? $Le[e] = HLe[e] : $Le[e] = ALe && zLe ? zLe(t) : KLe(t)
  }
  return $Le[e]
}
  , GLe = BRe.TypeError
  , qLe = WLe("toPrimitive")
  , YLe = function(e) {
  var t = function(e, t) {
    if (!fLe(e) || kLe(e))
      return e;
    var n, r, o = null == (n = e[qLe]) ? void 0 : OLe(n);
    if (o) {
      if (void 0 === t && (t = "default"),
        r = QRe(o, e, t),
      !fLe(r) || kLe(r))
        return r;
      throw GLe("Can't convert object to primitive value")
    }
    return void 0 === t && (t = "number"),
      function(e, t) {
        var n, r;
        if ("string" === t && GRe(n = e.toString) && !fLe(r = QRe(n, e)))
          return r;
        if (GRe(n = e.valueOf) && !fLe(r = QRe(n, e)))
          return r;
        if ("string" !== t && GRe(n = e.toString) && !fLe(r = QRe(n, e)))
          return r;
        throw _Le("Can't convert object to primitive value")
      }(e, t)
  }(e, "string");
  return kLe(t) ? t : t + ""
}
  , XLe = BRe.document
  , QLe = fLe(XLe) && fLe(XLe.createElement)
  , JLe = function(e) {
  return QLe ? XLe.createElement(e) : {}
}
  , ZLe = !YRe && !qRe((function() {
    return 7 != Object.defineProperty(JLe("div"), "a", {
      get: function() {
        return 7
      }
    }).a
  }
))
  , eIe = Object.getOwnPropertyDescriptor
  , tIe = {
  f: YRe ? eIe : function(e, t) {
    if (e = dLe(e),
      t = YLe(t),
      ZLe)
      try {
        return eIe(e, t)
      } catch (n) {}
    if (NLe(e, t))
      return nLe(!QRe(tLe.f, e, t), e[t])
  }
}
  , nIe = /#|\.prototype\./
  , rIe = function(e, t) {
  var n = aIe[oIe(e)];
  return n == sIe || n != iIe && (GRe(t) ? qRe(t) : !!t)
}
  , oIe = rIe.normalize = function(e) {
  return String(e).replace(nIe, ".").toLowerCase()
}
  , aIe = rIe.data = {}
  , iIe = rIe.NATIVE = "N"
  , sIe = rIe.POLYFILL = "P"
  , lIe = rIe
  , uIe = WRe(WRe.bind)
  , cIe = function(e, t) {
  return OLe(e),
    void 0 === t ? e : uIe ? uIe(e, t) : function() {
      return e.apply(t, arguments)
    }
}
  , dIe = BRe.String
  , fIe = BRe.TypeError
  , pIe = function(e) {
  if (fLe(e))
    return e;
  throw fIe(dIe(e) + " is not an object")
}
  , hIe = BRe.TypeError
  , vIe = Object.defineProperty
  , gIe = {
  f: YRe ? vIe : function(e, t, n) {
    if (pIe(e),
      t = YLe(t),
      pIe(n),
      ZLe)
      try {
        return vIe(e, t, n)
      } catch (r) {}
    if ("get"in n || "set"in n)
      throw hIe("Accessors not supported");
    return "value"in n && (e[t] = n.value),
      e
  }
}
  , mIe = YRe ? function(e, t, n) {
    return gIe.f(e, t, nLe(1, n))
  }
  : function(e, t, n) {
    return e[t] = n,
      e
  }
  , yIe = tIe.f
  , bIe = function(e) {
  var t = function(n, r, o) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new e;
        case 1:
          return new e(n);
        case 2:
          return new e(n,r)
      }
      return new e(n,r,o)
    }
    return URe(e, this, arguments)
  };
  return t.prototype = e.prototype,
    t
}
  , wIe = function(e, t) {
  var n, r, o, a, i, s, l, u, c = e.target, d = e.global, f = e.stat, p = e.proto, h = d ? BRe : f ? BRe[c] : (BRe[c] || {}).prototype, v = d ? pLe : pLe[c] || mIe(pLe, c, {})[c], g = v.prototype;
  for (o in t)
    n = !lIe(d ? o : c + (f ? "." : "#") + o, e.forced) && h && NLe(h, o),
      i = v[o],
    n && (s = e.noTargetGet ? (u = yIe(h, o)) && u.value : h[o]),
      a = n && s ? s : t[o],
    n && typeof i == typeof a || (l = e.bind && n ? cIe(a, BRe) : e.wrap && n ? bIe(a) : p && GRe(a) ? WRe(a) : a,
    (e.sham || a && a.sham || i && i.sham) && mIe(l, "sham", !0),
      mIe(v, o, l),
    p && (NLe(pLe, r = c + "Prototype") || mIe(pLe, r, {}),
      mIe(pLe[r], o, a),
    e.real && g && !g[o] && mIe(g, o, a)))
}
  , xIe = Array.isArray || function(e) {
  return "Array" == aLe(e)
}
  , SIe = Math.ceil
  , EIe = Math.floor
  , AIe = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : (t > 0 ? EIe : SIe)(t)
}
  , CIe = Math.min
  , kIe = function(e) {
  return (t = e.length) > 0 ? CIe(AIe(t), 9007199254740991) : 0;
  var t
}
  , TIe = function(e, t, n) {
  var r = YLe(t);
  r in e ? gIe.f(e, r, nLe(0, n)) : e[r] = n
}
  , DIe = {};
DIe[WLe("toStringTag")] = "z";
var OIe = "[object z]" === String(DIe)
  , _Ie = WLe("toStringTag")
  , RIe = BRe.Object
  , LIe = "Arguments" == aLe(function() {
  return arguments
}())
  , IIe = OIe ? aLe : function(e) {
  var t, n, r;
  return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
    try {
      return e[t]
    } catch (n) {}
  }(t = RIe(e), _Ie)) ? n : LIe ? aLe(t) : "Object" == (r = aLe(t)) && GRe(t.callee) ? "Arguments" : r
}
  , PIe = WRe(Function.toString);
GRe(LLe.inspectSource) || (LLe.inspectSource = function(e) {
    return PIe(e)
  }
);
var FIe = LLe.inspectSource
  , BIe = function() {}
  , NIe = []
  , MIe = vLe("Reflect", "construct")
  , jIe = /^\s*(?:class|function)\b/
  , VIe = WRe(jIe.exec)
  , UIe = !jIe.exec(BIe)
  , $Ie = function(e) {
  if (!GRe(e))
    return !1;
  try {
    return MIe(BIe, NIe, e),
      !0
  } catch (t) {
    return !1
  }
}
  , HIe = !MIe || qRe((function() {
    var e;
    return $Ie($Ie.call) || !$Ie(Object) || !$Ie((function() {
        e = !0
      }
    )) || e
  }
)) ? function(e) {
    if (!GRe(e))
      return !1;
    switch (IIe(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    return UIe || !!VIe(jIe, FIe(e))
  }
  : $Ie
  , zIe = WLe("species")
  , KIe = BRe.Array
  , WIe = function(e, t) {
  return new (xIe(n = e) && (r = n.constructor,
  (HIe(r) && (r === KIe || xIe(r.prototype)) || fLe(r) && null === (r = r[zIe])) && (r = void 0)),
    void 0 === r ? KIe : r)(0 === t ? 0 : t);
  var n, r
}
  , GIe = WLe("species")
  , qIe = WLe("isConcatSpreadable")
  , YIe = BRe.TypeError
  , XIe = SLe >= 51 || !qRe((function() {
    var e = [];
    return e[qIe] = !1,
    e.concat()[0] !== e
  }
))
  , QIe = SLe >= 51 || !qRe((function() {
    var e = [];
    return (e.constructor = {})[GIe] = function() {
      return {
        foo: 1
      }
    }
      ,
    1 !== e.concat(Boolean).foo
  }
))
  , JIe = function(e) {
  if (!fLe(e))
    return !1;
  var t = e[qIe];
  return void 0 !== t ? !!t : xIe(e)
};
wIe({
  target: "Array",
  proto: !0,
  forced: !XIe || !QIe
}, {
  concat: function(e) {
    var t, n, r, o, a, i = FLe(this), s = WIe(i, 0), l = 0;
    for (t = -1,
           r = arguments.length; t < r; t++)
      if (JIe(a = -1 === t ? i : arguments[t])) {
        if (l + (o = kIe(a)) > 9007199254740991)
          throw YIe("Maximum allowed index exceeded");
        for (n = 0; n < o; n++,
          l++)
          n in a && TIe(s, l, a[n])
      } else {
        if (l >= 9007199254740991)
          throw YIe("Maximum allowed index exceeded");
        TIe(s, l++, a)
      }
    return s.length = l,
      s
  }
});
var ZIe, ePe = BRe.String, tPe = function(e) {
  if ("Symbol" === IIe(e))
    throw TypeError("Cannot convert a Symbol value to a string");
  return ePe(e)
}, nPe = Math.max, rPe = Math.min, oPe = function(e, t) {
  var n = AIe(e);
  return n < 0 ? nPe(n + t, 0) : rPe(n, t)
}, aPe = function(e) {
  return function(t, n, r) {
    var o, a = dLe(t), i = kIe(a), s = oPe(r, i);
    if (e && n != n) {
      for (; i > s; )
        if ((o = a[s++]) != o)
          return !0
    } else
      for (; i > s; s++)
        if ((e || s in a) && a[s] === n)
          return e || s || 0;
    return !e && -1
  }
}, iPe = {
  includes: aPe(!0),
  indexOf: aPe(!1)
}, sPe = {}, lPe = iPe.indexOf, uPe = WRe([].push), cPe = function(e, t) {
  var n, r = dLe(e), o = 0, a = [];
  for (n in r)
    !NLe(sPe, n) && NLe(r, n) && uPe(a, n);
  for (; t.length > o; )
    NLe(r, n = t[o++]) && (~lPe(a, n) || uPe(a, n));
  return a
}, dPe = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], fPe = Object.keys || function(e) {
  return cPe(e, dPe)
}
  , pPe = YRe ? Object.defineProperties : function(e, t) {
  pIe(e);
  for (var n, r = dLe(t), o = fPe(t), a = o.length, i = 0; a > i; )
    gIe.f(e, n = o[i++], r[n]);
  return e
}
  , hPe = vLe("document", "documentElement"), vPe = ILe("keys"), gPe = function(e) {
  return vPe[e] || (vPe[e] = ULe(e))
}, mPe = gPe("IE_PROTO"), yPe = function() {}, bPe = function(e) {
  return "<script>" + e + "<\/script>"
}, wPe = function(e) {
  e.write(bPe("")),
    e.close();
  var t = e.parentWindow.Object;
  return e = null,
    t
}, xPe = function() {
  try {
    ZIe = new ActiveXObject("htmlfile")
  } catch (r) {}
  var e, t;
  xPe = "undefined" != typeof document ? document.domain && ZIe ? wPe(ZIe) : ((t = JLe("iframe")).style.display = "none",
    hPe.appendChild(t),
    t.src = String("javascript:"),
    (e = t.contentWindow.document).open(),
    e.write(bPe("document.F=Object")),
    e.close(),
    e.F) : wPe(ZIe);
  for (var n = dPe.length; n--; )
    delete xPe.prototype[dPe[n]];
  return xPe()
};
sPe[mPe] = !0;
var SPe, EPe, APe, CPe = Object.create || function(e, t) {
  var n;
  return null !== e ? (yPe.prototype = pIe(e),
    n = new yPe,
    yPe.prototype = null,
    n[mPe] = e) : n = xPe(),
    void 0 === t ? n : pPe(n, t)
}
  , kPe = dPe.concat("length", "prototype"), TPe = {
  f: Object.getOwnPropertyNames || function(e) {
    return cPe(e, kPe)
  }
}, DPe = BRe.Array, OPe = Math.max, _Pe = TPe.f, RPe = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], LPe = {
  f: function(e) {
    return RPe && "Window" == aLe(e) ? function(e) {
      try {
        return _Pe(e)
      } catch (t) {
        return function(e, t, n) {
          for (var r = kIe(e), o = oPe(void 0, r), a = oPe(r, r), i = DPe(OPe(a - o, 0)), s = 0; o < a; o++,
            s++)
            TIe(i, s, e[o]);
          return i.length = s,
            i
        }(RPe)
      }
    }(e) : _Pe(dLe(e))
  }
}, IPe = {
  f: Object.getOwnPropertySymbols
}, PPe = WRe([].slice), FPe = function(e, t, n, r) {
  r && r.enumerable ? e[t] = n : mIe(e, t, n)
}, BPe = {
  f: WLe
}, NPe = gIe.f, MPe = function(e) {
  var t = pLe.Symbol || (pLe.Symbol = {});
  NLe(t, e) || NPe(t, e, {
    value: BPe.f(e)
  })
}, jPe = OIe ? {}.toString : function() {
  return "[object " + IIe(this) + "]"
}
  , VPe = gIe.f, UPe = WLe("toStringTag"), $Pe = function(e, t, n, r) {
  if (e) {
    var o = n ? e : e.prototype;
    NLe(o, UPe) || VPe(o, UPe, {
      configurable: !0,
      value: t
    }),
    r && !OIe && mIe(o, "toString", jPe)
  }
}, HPe = BRe.WeakMap, zPe = GRe(HPe) && /native code/.test(FIe(HPe)), KPe = BRe.TypeError, WPe = BRe.WeakMap;
if (zPe || LLe.state) {
  var GPe = LLe.state || (LLe.state = new WPe)
    , qPe = WRe(GPe.get)
    , YPe = WRe(GPe.has)
    , XPe = WRe(GPe.set);
  SPe = function(e, t) {
    if (YPe(GPe, e))
      throw new KPe("Object already initialized");
    return t.facade = e,
      XPe(GPe, e, t),
      t
  }
    ,
    EPe = function(e) {
      return qPe(GPe, e) || {}
    }
    ,
    APe = function(e) {
      return YPe(GPe, e)
    }
} else {
  var QPe = gPe("state");
  sPe[QPe] = !0,
    SPe = function(e, t) {
      if (NLe(e, QPe))
        throw new KPe("Object already initialized");
      return t.facade = e,
        mIe(e, QPe, t),
        t
    }
    ,
    EPe = function(e) {
      return NLe(e, QPe) ? e[QPe] : {}
    }
    ,
    APe = function(e) {
      return NLe(e, QPe)
    }
}
var JPe = {
  set: SPe,
  get: EPe,
  has: APe,
  enforce: function(e) {
    return APe(e) ? EPe(e) : SPe(e, {})
  },
  getterFor: function(e) {
    return function(t) {
      var n;
      if (!fLe(t) || (n = EPe(t)).type !== e)
        throw KPe("Incompatible receiver, " + e + " required");
      return n
    }
  }
}
  , ZPe = WRe([].push)
  , eFe = function(e) {
  var t = 1 == e
    , n = 2 == e
    , r = 3 == e
    , o = 4 == e
    , a = 6 == e
    , i = 7 == e
    , s = 5 == e || a;
  return function(l, u, c, d) {
    for (var f, p, h = FLe(l), v = lLe(h), g = cIe(u, c), m = kIe(v), y = 0, b = d || WIe, w = t ? b(l, m) : n || i ? b(l, 0) : void 0; m > y; y++)
      if ((s || y in v) && (p = g(f = v[y], y, h),
        e))
        if (t)
          w[y] = p;
        else if (p)
          switch (e) {
            case 3:
              return !0;
            case 5:
              return f;
            case 6:
              return y;
            case 2:
              ZPe(w, f)
          }
        else
          switch (e) {
            case 4:
              return !1;
            case 7:
              ZPe(w, f)
          }
    return a ? -1 : r || o ? o : w
  }
}
  , tFe = [eFe(0), eFe(1), eFe(2), eFe(3), eFe(4), eFe(5), eFe(6), eFe(7)][0]
  , nFe = gPe("hidden")
  , rFe = WLe("toPrimitive")
  , oFe = JPe.set
  , aFe = JPe.getterFor("Symbol")
  , iFe = Object.prototype
  , sFe = BRe.Symbol
  , lFe = sFe && sFe.prototype
  , uFe = BRe.TypeError
  , cFe = BRe.QObject
  , dFe = vLe("JSON", "stringify")
  , fFe = tIe.f
  , pFe = gIe.f
  , hFe = LPe.f
  , vFe = tLe.f
  , gFe = WRe([].push)
  , mFe = ILe("symbols")
  , yFe = ILe("op-symbols")
  , bFe = ILe("string-to-symbol-registry")
  , wFe = ILe("symbol-to-string-registry")
  , xFe = ILe("wks")
  , SFe = !cFe || !cFe.prototype || !cFe.prototype.findChild
  , EFe = YRe && qRe((function() {
    return 7 != CPe(pFe({}, "a", {
      get: function() {
        return pFe(this, "a", {
          value: 7
        }).a
      }
    })).a
  }
)) ? function(e, t, n) {
    var r = fFe(iFe, t);
    r && delete iFe[t],
      pFe(e, t, n),
    r && e !== iFe && pFe(iFe, t, r)
  }
  : pFe
  , AFe = function(e, t) {
  var n = mFe[e] = CPe(lFe);
  return oFe(n, {
    type: "Symbol",
    tag: e,
    description: t
  }),
  YRe || (n.description = t),
    n
}
  , CFe = function(e, t, n) {
  e === iFe && CFe(yFe, t, n),
    pIe(e);
  var r = YLe(t);
  return pIe(n),
    NLe(mFe, r) ? (n.enumerable ? (NLe(e, nFe) && e[nFe][r] && (e[nFe][r] = !1),
      n = CPe(n, {
        enumerable: nLe(0, !1)
      })) : (NLe(e, nFe) || pFe(e, nFe, nLe(1, {})),
      e[nFe][r] = !0),
      EFe(e, r, n)) : pFe(e, r, n)
}
  , kFe = function(e, t) {
  pIe(e);
  var n = dLe(t)
    , r = fPe(n).concat(_Fe(n));
  return tFe(r, (function(t) {
      YRe && !QRe(TFe, n, t) || CFe(e, t, n[t])
    }
  )),
    e
}
  , TFe = function(e) {
  var t = YLe(e)
    , n = QRe(vFe, this, t);
  return !(this === iFe && NLe(mFe, t) && !NLe(yFe, t)) && (!(n || !NLe(this, t) || !NLe(mFe, t) || NLe(this, nFe) && this[nFe][t]) || n)
}
  , DFe = function(e, t) {
  var n = dLe(e)
    , r = YLe(t);
  if (n !== iFe || !NLe(mFe, r) || NLe(yFe, r)) {
    var o = fFe(n, r);
    return !o || !NLe(mFe, r) || NLe(n, nFe) && n[nFe][r] || (o.enumerable = !0),
      o
  }
}
  , OFe = function(e) {
  var t = hFe(dLe(e))
    , n = [];
  return tFe(t, (function(e) {
      NLe(mFe, e) || NLe(sPe, e) || gFe(n, e)
    }
  )),
    n
}
  , _Fe = function(e) {
  var t = e === iFe
    , n = hFe(t ? yFe : dLe(e))
    , r = [];
  return tFe(n, (function(e) {
      !NLe(mFe, e) || t && !NLe(iFe, e) || gFe(r, mFe[e])
    }
  )),
    r
};
if (ELe || (lFe = (sFe = function() {
    if (gLe(lFe, this))
      throw uFe("Symbol is not a constructor");
    var e = arguments.length && void 0 !== arguments[0] ? tPe(arguments[0]) : void 0
      , t = ULe(e)
      , n = function(e) {
      this === iFe && QRe(n, yFe, e),
      NLe(this, nFe) && NLe(this[nFe], t) && (this[nFe][t] = !1),
        EFe(this, t, nLe(1, e))
    };
    return YRe && SFe && EFe(iFe, t, {
      configurable: !0,
      set: n
    }),
      AFe(t, e)
  }
).prototype,
  FPe(lFe, "toString", (function() {
      return aFe(this).tag
    }
  )),
  FPe(sFe, "withoutSetter", (function(e) {
      return AFe(ULe(e), e)
    }
  )),
  tLe.f = TFe,
  gIe.f = CFe,
  tIe.f = DFe,
  TPe.f = LPe.f = OFe,
  IPe.f = _Fe,
  BPe.f = function(e) {
    return AFe(WLe(e), e)
  }
  ,
YRe && pFe(lFe, "description", {
  configurable: !0,
  get: function() {
    return aFe(this).description
  }
})),
  wIe({
    global: !0,
    wrap: !0,
    forced: !ELe,
    sham: !ELe
  }, {
    Symbol: sFe
  }),
  tFe(fPe(xFe), (function(e) {
      MPe(e)
    }
  )),
  wIe({
    target: "Symbol",
    stat: !0,
    forced: !ELe
  }, {
    for: function(e) {
      var t = tPe(e);
      if (NLe(bFe, t))
        return bFe[t];
      var n = sFe(t);
      return bFe[t] = n,
        wFe[n] = t,
        n
    },
    keyFor: function(e) {
      if (!kLe(e))
        throw uFe(e + " is not a symbol");
      if (NLe(wFe, e))
        return wFe[e]
    },
    useSetter: function() {
      SFe = !0
    },
    useSimple: function() {
      SFe = !1
    }
  }),
  wIe({
    target: "Object",
    stat: !0,
    forced: !ELe,
    sham: !YRe
  }, {
    create: function(e, t) {
      return void 0 === t ? CPe(e) : kFe(CPe(e), t)
    },
    defineProperty: CFe,
    defineProperties: kFe,
    getOwnPropertyDescriptor: DFe
  }),
  wIe({
    target: "Object",
    stat: !0,
    forced: !ELe
  }, {
    getOwnPropertyNames: OFe,
    getOwnPropertySymbols: _Fe
  }),
  wIe({
    target: "Object",
    stat: !0,
    forced: qRe((function() {
        IPe.f(1)
      }
    ))
  }, {
    getOwnPropertySymbols: function(e) {
      return IPe.f(FLe(e))
    }
  }),
  dFe) {
  var RFe = !ELe || qRe((function() {
      var e = sFe();
      return "[null]" != dFe([e]) || "{}" != dFe({
        a: e
      }) || "{}" != dFe(Object(e))
    }
  ));
  wIe({
    target: "JSON",
    stat: !0,
    forced: RFe
  }, {
    stringify: function(e, t, n) {
      var r = PPe(arguments)
        , o = t;
      if ((fLe(t) || void 0 !== e) && !kLe(e))
        return xIe(t) || (t = function(e, t) {
            if (GRe(o) && (t = QRe(o, this, e, t)),
              !kLe(t))
              return t
          }
        ),
          r[1] = t,
          URe(dFe, null, r)
    }
  })
}
if (!lFe[rFe]) {
  var LFe = lFe.valueOf;
  FPe(lFe, rFe, (function(e) {
      return QRe(LFe, this)
    }
  ))
}
$Pe(sFe, "Symbol"),
  sPe[nFe] = !0,
  MPe("asyncIterator"),
  MPe("hasInstance"),
  MPe("isConcatSpreadable"),
  MPe("iterator"),
  MPe("match"),
  MPe("matchAll"),
  MPe("replace"),
  MPe("search"),
  MPe("species"),
  MPe("split"),
  MPe("toPrimitive"),
  MPe("toStringTag"),
  MPe("unscopables"),
  $Pe(BRe.JSON, "JSON", !0);
var IFe, PFe, FFe, BFe = pLe.Symbol, NFe = {}, MFe = Function.prototype, jFe = YRe && Object.getOwnPropertyDescriptor, VFe = NLe(MFe, "name"), UFe = {
  EXISTS: VFe,
  PROPER: VFe && "something" === function() {}
    .name,
  CONFIGURABLE: VFe && (!YRe || YRe && jFe(MFe, "name").configurable)
}, $Fe = !qRe((function() {
    function e() {}
    return e.prototype.constructor = null,
    Object.getPrototypeOf(new e) !== e.prototype
  }
)), HFe = gPe("IE_PROTO"), zFe = BRe.Object, KFe = zFe.prototype, WFe = $Fe ? zFe.getPrototypeOf : function(e) {
  var t = FLe(e);
  if (NLe(t, HFe))
    return t[HFe];
  var n = t.constructor;
  return GRe(n) && t instanceof n ? n.prototype : t instanceof zFe ? KFe : null
}
  , GFe = WLe("iterator"), qFe = !1;
[].keys && ("next"in (FFe = [].keys()) ? (PFe = WFe(WFe(FFe))) !== Object.prototype && (IFe = PFe) : qFe = !0);
var YFe = null == IFe || qRe((function() {
    var e = {};
    return IFe[GFe].call(e) !== e
  }
));
IFe = YFe ? {} : CPe(IFe),
GRe(IFe[GFe]) || FPe(IFe, GFe, (function() {
    return this
  }
));
var XFe = {
  IteratorPrototype: IFe,
  BUGGY_SAFARI_ITERATORS: qFe
}
  , QFe = XFe.IteratorPrototype
  , JFe = function() {
  return this
};
BRe.String,
  BRe.TypeError,
Object.setPrototypeOf || "__proto__"in {} && function() {
  var e = {};
  try {
    WRe(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set)(e, [])
  } catch (t) {}
}();
var ZFe = UFe.PROPER
  , eBe = XFe.BUGGY_SAFARI_ITERATORS
  , tBe = WLe("iterator")
  , nBe = function() {
  return this
}
  , rBe = function(e, t, n, r, o, a, i) {
  var s, l, u;
  l = r,
    u = t + " Iterator",
    (s = n).prototype = CPe(QFe, {
      next: nLe(1, l)
    }),
    $Pe(s, u, !1, !0),
    NFe[u] = JFe;
  var c, d, f, p = function(e) {
    if (e === o && y)
      return y;
    if (!eBe && e in g)
      return g[e];
    switch (e) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n(this,e)
        }
    }
    return function() {
      return new n(this)
    }
  }, h = t + " Iterator", v = !1, g = e.prototype, m = g[tBe] || g["@@iterator"] || o && g[o], y = !eBe && m || p(o), b = "Array" == t && g.entries || m;
  if (b && (c = WFe(b.call(new e))) !== Object.prototype && c.next && ($Pe(c, h, !0, !0),
    NFe[h] = nBe),
  ZFe && "values" == o && m && "values" !== m.name && (v = !0,
      y = function() {
        return QRe(m, this)
      }
  ),
    o)
    if (d = {
      values: p("values"),
      keys: a ? y : p("keys"),
      entries: p("entries")
    },
      i)
      for (f in d)
        (eBe || v || !(f in g)) && FPe(g, f, d[f]);
    else
      wIe({
        target: t,
        proto: !0,
        forced: eBe || v
      }, d);
  return i && g[tBe] !== y && FPe(g, tBe, y, {
    name: o
  }),
    NFe[t] = y,
    d
}
  , oBe = JPe.set
  , aBe = JPe.getterFor("Array Iterator");
rBe(Array, "Array", (function(e, t) {
    oBe(this, {
      type: "Array Iterator",
      target: dLe(e),
      index: 0,
      kind: t
    })
  }
), (function() {
    var e = aBe(this)
      , t = e.target
      , n = e.kind
      , r = e.index++;
    return !t || r >= t.length ? (e.target = void 0,
      {
        value: void 0,
        done: !0
      }) : "keys" == n ? {
      value: r,
      done: !1
    } : "values" == n ? {
      value: t[r],
      done: !1
    } : {
      value: [r, t[r]],
      done: !1
    }
  }
), "values"),
  NFe.Arguments = NFe.Array;
var iBe = WLe("toStringTag");
for (var sBe in {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}) {
  var lBe = BRe[sBe]
    , uBe = lBe && lBe.prototype;
  uBe && IIe(uBe) !== iBe && mIe(uBe, iBe, sBe),
    NFe[sBe] = NFe.Array
}
var cBe = BFe;
MPe("asyncDispose"),
  MPe("dispose"),
  MPe("matcher"),
  MPe("metadata"),
  MPe("observable"),
  MPe("patternMatch"),
  MPe("replaceAll");
var dBe = cBe
  , fBe = WRe("".charAt)
  , pBe = WRe("".charCodeAt)
  , hBe = WRe("".slice)
  , vBe = function(e) {
  return function(t, n) {
    var r, o, a = tPe(cLe(t)), i = AIe(n), s = a.length;
    return i < 0 || i >= s ? e ? "" : void 0 : (r = pBe(a, i)) < 55296 || r > 56319 || i + 1 === s || (o = pBe(a, i + 1)) < 56320 || o > 57343 ? e ? fBe(a, i) : r : e ? hBe(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536
  }
}(!0)
  , gBe = JPe.set
  , mBe = JPe.getterFor("String Iterator");
rBe(String, "String", (function(e) {
    gBe(this, {
      type: "String Iterator",
      string: tPe(e),
      index: 0
    })
  }
), (function() {
    var e, t = mBe(this), n = t.string, r = t.index;
    return r >= n.length ? {
      value: void 0,
      done: !0
    } : (e = vBe(n, r),
      t.index += e.length,
      {
        value: e,
        done: !1
      })
  }
));
var yBe = BPe.f("iterator")
  , bBe = KEe((function(e) {
    function t(n) {
      return "function" == typeof dBe && "symbol" == typeof yBe ? (e.exports = t = function(e) {
        return typeof e
      }
        ,
        e.exports.default = e.exports,
        e.exports.__esModule = !0) : (e.exports = t = function(e) {
        return e && "function" == typeof dBe && e.constructor === dBe && e !== dBe.prototype ? "symbol" : typeof e
      }
        ,
        e.exports.default = e.exports,
        e.exports.__esModule = !0),
        t(n)
    }
    e.exports = t,
      e.exports.default = e.exports,
      e.exports.__esModule = !0
  }
))
  , wBe = function(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}(bBe)
  , xBe = jCe.EXISTS
  , SBe = gCe.f
  , EBe = Function.prototype
  , ABe = uAe(EBe.toString)
  , CBe = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/
  , kBe = uAe(CBe.exec);
QEe && !xBe && SBe(EBe, "name", {
  configurable: !0,
  get: function() {
    try {
      return kBe(CBe, ABe(this))[1]
    } catch (Y_) {
      return ""
    }
  }
});
var TBe = function() {
  function e() {
    this.tag = "select",
      this.width = 80
  }
  return e.prototype.isActive = function(e) {
    return !1
  }
    ,
    e.prototype.getValue = function(e) {
      var t = this.mark
        , n = Yte.marks(e);
      return n && n[t] ? n[t] : ""
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || (this.mark,
        !!VDe(Yte.nodes(e, {
          match: function(t) {
            return "pre" === qme.getNodeType(t) || !!Yte.isVoid(e, t)
          },
          universal: !0
        }), 1)[0])
    }
    ,
    e.prototype.exec = function(e, t) {
      var n = this.mark;
      t ? e.addMark(n, t) : e.removeMark(n)
    }
    ,
    e
}()
  , DBe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = SEe("fontSize.title"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M64 512h384v128h-128V1024h-128V640h-128z m896-256H708.2496v768h-136.4992V256H320V128h640z"></path></svg>',
      t.mark = "fontSize",
      t
  }
  return FDe(t, e),
    t.prototype.getOptions = function(e) {
      var t = []
        , n = e.getMenuConfig(this.mark).fontSizeList
        , r = void 0 === n ? [] : n;
      t.push({
        text: SEe("fontSize.default"),
        value: ""
      }),
        r.forEach((function(e) {
            if ("string" == typeof e)
              t.push({
                text: e,
                value: e
              });
            else if ("object" === wBe(e)) {
              var n = e.name
                , r = e.value;
              t.push({
                text: n,
                value: r
              })
            }
          }
        ));
      var o = this.getValue(e);
      return t.forEach((function(e) {
          e.value === o ? e.selected = !0 : delete e.selected
        }
      )),
        t
    }
    ,
    t
}(TBe)
  , OBe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = SEe("fontFamily.title"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M956.788364 152.110545h-24.110546l23.924364 9.029819 0.186182 121.018181h-65.070546l-86.574545-130.048H566.551273v650.14691l130.048 64.977454v65.163636h-390.050909v-65.163636l129.954909-64.977454V152.110545H198.283636L111.429818 282.065455H46.545455V69.259636C46.545455 33.792 82.664727 22.062545 98.955636 22.062545h812.683637c23.738182 0 45.056 15.173818 45.056 41.053091V169.425455v-17.221819z"></path></svg>',
      t.mark = "fontFamily",
      t.selectPanelWidth = 150,
      t
  }
  return FDe(t, e),
    t.prototype.getOptions = function(e) {
      var t = []
        , n = e.getMenuConfig(this.mark).fontFamilyList
        , r = void 0 === n ? [] : n;
      t.push({
        text: SEe("fontFamily.default"),
        value: ""
      }),
        r.forEach((function(e) {
            if ("string" == typeof e)
              t.push({
                text: e,
                value: e,
                styleForRenderMenuList: {
                  "font-family": e
                }
              });
            else if ("object" === wBe(e)) {
              var n = e.name
                , r = e.value;
              t.push({
                text: n,
                value: r,
                styleForRenderMenuList: {
                  "font-family": r
                }
              })
            }
          }
        ));
      var o = this.getValue(e);
      return t.forEach((function(e) {
          e.value === o ? e.selected = !0 : delete e.selected
        }
      )),
        t
    }
    ,
    t
}(TBe)
  , _Be = {
  renderStyle: function(e, t) {
    var n = e
      , r = n.fontSize
      , o = n.fontFamily
      , a = t;
    return r && u_e(a, {
      fontSize: r
    }),
    o && u_e(a, {
      fontFamily: o
    }),
      a
  },
  styleToHtml: function(e, t) {
    if (!bne.isText(e))
      return t;
    var n, r = e, o = r.fontSize, a = r.fontFamily;
    return o || a ? ((ODe(t) || "span" !== RDe(n = Qre(t))) && (n = Qre("<span>" + t + "</span>")),
    o && n.css("font-size", o),
    a && n.css("font-family", a),
      _De(n)) : t
  },
  preParseHtml: [RRe],
  parseStyleHtml: function(e, t, n) {
    var r = Qre(e);
    if (!bne.isText(t))
      return t;
    var o = t
      , a = n.getMenuConfig("fontSize").fontSizeList
      , i = void 0 === a ? [] : a
      , s = LDe(r, "font-size")
      , l = i.find((function(e) {
        return e.value && e.value === s
      }
    )) || i.includes(s);
    s && l && (o.fontSize = s);
    var u = n.getMenuConfig("fontFamily").fontFamilyList
      , c = void 0 === u ? [] : u
      , d = LDe(r, "font-family").replace(/"/g, "")
      , f = c.find((function(e) {
        return e.value && e.value === d
      }
    )) || c.includes(d);
    return d && f && (o.fontFamily = d),
      o
  },
  menus: [{
    key: "fontSize",
    factory: function() {
      return new DBe
    },
    config: {
      fontSizeList: ["12px", {
        name: "13px",
        value: "13px"
      }, "14px", "15px", "16px", "19px", {
        name: "22px",
        value: "22px"
      }, "24px", "29px", "32px", "40px", "48px"]
    }
  }, {
    key: "fontFamily",
    factory: function() {
      return new OBe
    },
    config: {
      fontFamilyList: ["黑体", {
        name: "仿宋",
        value: "仿宋"
      }, "楷体", "标楷体", "华文仿宋", "华文楷体", {
        name: "宋体",
        value: "宋体"
      }, "微软雅黑", "Arial", "Tahoma", "Verdana", "Times New Roman", "Courier New"]
    }
  }]
}
  , RBe = {
  selector: "p,h1,h2,h3,h4,h5",
  preParseHtml: function(e) {
    var t = Qre(e)
      , n = LDe(t, "padding-left");
    return /\dem/.test(n) && t.css("text-indent", "2em"),
    /\dpx/.test(n) && parseInt(n, 10) % 32 == 0 && t.css("text-indent", "2em"),
      t[0]
  }
}
  , LBe = function() {
  function e() {
    this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    var t = VDe(Yte.nodes(e, {
      match: function(e) {
        return !!e.indent
      },
      universal: !0
    }), 1)[0];
    return null == t ? "" : VDe(t, 1)[0].indent || ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.getMatchNode = function(e) {
      var t = VDe(Yte.nodes(e, {
        match: function(e) {
          var t = qme.getNodeType(e);
          return "paragraph" === t || !!t.startsWith("header")
        },
        universal: !0,
        mode: "highest"
      }), 1)[0];
      return null == t ? null : t[0]
    }
    ,
    e
}()
  , IBe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = SEe("indent.decrease"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m256-512v384l-256-192z"></path></svg>',
      t
  }
  return FDe(t, e),
    t.prototype.isDisabled = function(e) {
      var t = this.getMatchNode(e);
      return null == t || !t.indent
    }
    ,
    t.prototype.exec = function(e, t) {
      Nne.setNodes(e, {
        indent: null
      }, {
        match: function(e) {
          return Hte.isElement(e)
        }
      })
    }
    ,
    t
}(LBe)
  , PBe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = SEe("indent.increase"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m0-128V320l256 192z"></path></svg>',
      t
  }
  return FDe(t, e),
    t.prototype.isDisabled = function(e) {
      var t = this.getMatchNode(e);
      return null == t || !!t.indent
    }
    ,
    t.prototype.exec = function(e, t) {
      Nne.setNodes(e, {
        indent: "2em"
      }, {
        match: function(e) {
          return Hte.isElement(e)
        },
        mode: "highest"
      })
    }
    ,
    t
}(LBe)
  , FBe = {
  renderStyle: function(e, t) {
    if (!Hte.isElement(e))
      return t;
    var n = e.indent
      , r = t;
    return n && u_e(r, {
      textIndent: n
    }),
      r
  },
  styleToHtml: function(e, t) {
    if (!Hte.isElement(e))
      return t;
    var n = e.indent;
    if (!n)
      return t;
    var r = Qre(t);
    return r.css("text-indent", n),
      _De(r)
  },
  preParseHtml: [RBe],
  parseStyleHtml: function(e, t, n) {
    var r = Qre(e);
    if (!Hte.isElement(t))
      return t;
    var o = t
      , a = LDe(r, "text-indent")
      , i = parseInt(a, 10);
    return a && i > 0 && (o.indent = a),
      o
  },
  menus: [{
    key: "indent",
    factory: function() {
      return new PBe
    }
  }, {
    key: "delIndent",
    factory: function() {
      return new IBe
    }
  }]
}
  , BBe = function() {
  function e() {
    this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.getMatchNode = function(e) {
      var t = VDe(Yte.nodes(e, {
        match: function(e) {
          var t = qme.getNodeType(e);
          return "paragraph" === t || "blockquote" === t || !!t.startsWith("header")
        },
        universal: !0,
        mode: "highest"
      }), 1)[0];
      return null == t ? null : t[0]
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || !!qme.getSelectedElems(e).some((function(t) {
          if (Yte.isVoid(e, t) && Yte.isBlock(e, t))
            return !0;
          var n = t.type;
          return !!["pre", "code"].includes(n) || void 0
        }
      ))
    }
    ,
    e
}()
  , NBe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = SEe("justify.left"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M768 793.6v102.4H51.2v-102.4h716.8z m204.8-230.4v102.4H51.2v-102.4h921.6z m-204.8-230.4v102.4H51.2v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>',
      t
  }
  return FDe(t, e),
    t.prototype.exec = function(e, t) {
      Nne.setNodes(e, {
        textAlign: "left"
      }, {
        match: function(t) {
          return Hte.isElement(t) && !e.isInline(t)
        }
      })
    }
    ,
    t
}(BBe)
  , MBe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = SEe("justify.right"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M972.8 793.6v102.4H256v-102.4h716.8z m0-230.4v102.4H51.2v-102.4h921.6z m0-230.4v102.4H256v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>',
      t
  }
  return FDe(t, e),
    t.prototype.exec = function(e, t) {
      Nne.setNodes(e, {
        textAlign: "right"
      }, {
        match: function(t) {
          return Hte.isElement(t) && !e.isInline(t)
        }
      })
    }
    ,
    t
}(BBe)
  , jBe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = SEe("justify.center"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M870.4 793.6v102.4H153.6v-102.4h716.8z m102.4-230.4v102.4H51.2v-102.4h921.6z m-102.4-230.4v102.4H153.6v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>',
      t
  }
  return FDe(t, e),
    t.prototype.exec = function(e, t) {
      Nne.setNodes(e, {
        textAlign: "center"
      }, {
        match: function(t) {
          return Hte.isElement(t) && !e.isInline(t)
        }
      })
    }
    ,
    t
}(BBe)
  , VBe = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.title = SEe("justify.justify"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m0 192h1024v128H0z m0 192h1024v128H0z m0 192h1024v128H0z m0 192h1024v128H0z"></path></svg>',
      t
  }
  return FDe(t, e),
    t.prototype.exec = function(e, t) {
      Nne.setNodes(e, {
        textAlign: "justify"
      }, {
        match: function(t) {
          return Hte.isElement(t) && !e.isInline(t)
        }
      })
    }
    ,
    t
}(BBe)
  , UBe = {
  renderStyle: function(e, t) {
    if (!Hte.isElement(e))
      return t;
    var n = e.textAlign
      , r = t;
    return n && u_e(r, {
      textAlign: n
    }),
      r
  },
  styleToHtml: function(e, t) {
    if (!Hte.isElement(e))
      return t;
    var n = e.textAlign;
    if (!n)
      return t;
    var r = Qre(t);
    return r.css("text-align", n),
      _De(r)
  },
  parseStyleHtml: function(e, t, n) {
    var r = Qre(e);
    if (!Hte.isElement(t))
      return t;
    var o = t
      , a = LDe(r, "text-align");
    return a && (o.textAlign = a),
      o
  },
  menus: [{
    key: "justifyLeft",
    factory: function() {
      return new NBe
    }
  }, {
    key: "justifyRight",
    factory: function() {
      return new MBe
    }
  }, {
    key: "justifyCenter",
    factory: function() {
      return new jBe
    }
  }, {
    key: "justifyJustify",
    factory: function() {
      return new VBe
    }
  }]
}
  , $Be = function() {
  function e() {
    this.title = SEe("lineHeight.title"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M964 788a8 8 0 0 1 8 8v98a8 8 0 0 1-8 8H438a8 8 0 0 1-8-8v-98a8 8 0 0 1 8-8h526zM198.93 144.306c6.668-5.798 16.774-5.094 22.573 1.574l122.26 140.582a16 16 0 0 1 3.927 10.5c0 8.836-7.164 16-16 16h-61.8a8 8 0 0 0-8 8v390.077h69.819a16 16 0 0 1 10.502 3.928c6.666 5.8 7.37 15.906 1.57 22.573L221.476 878.123a16 16 0 0 1-1.57 1.57c-6.668 5.8-16.774 5.097-22.574-1.57L75.051 737.538a16 16 0 0 1-3.928-10.5c0-8.837 7.163-16 16-16h69.822V312.96H87.127a16 16 0 0 1-10.502-3.928c-6.666-5.8-7.37-15.906-1.57-22.573l122.303-140.582a16 16 0 0 1 1.572-1.572zM964 465a8 8 0 0 1 8 8v98a8 8 0 0 1-8 8H438a8 8 0 0 1-8-8v-98a8 8 0 0 1 8-8h526z m0-323a8 8 0 0 1 8 8v98a8 8 0 0 1-8 8H438a8 8 0 0 1-8-8v-98a8 8 0 0 1 8-8h526z"></path></svg>',
      this.tag = "select",
      this.width = 80
  }
  return e.prototype.getOptions = function(e) {
    var t = []
      , n = e.getMenuConfig("lineHeight").lineHeightList
      , r = void 0 === n ? [] : n;
    t.push({
      text: SEe("lineHeight.default"),
      value: ""
    }),
      r.forEach((function(e) {
          t.push({
            text: e,
            value: e
          })
        }
      ));
    var o = this.getValue(e);
    return t.forEach((function(e) {
        e.value === o ? e.selected = !0 : delete e.selected
      }
    )),
      t
  }
    ,
    e.prototype.getMatchNode = function(e) {
      var t = VDe(Yte.nodes(e, {
        match: function(e) {
          var t = qme.getNodeType(e);
          return !!t.startsWith("header") || !!["paragraph", "blockquote", "list-item"].includes(t)
        },
        universal: !0,
        mode: "highest"
      }), 1)[0];
      return null == t ? null : t[0]
    }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.getValue = function(e) {
      var t = this.getMatchNode(e);
      return null == t ? "" : Hte.isElement(t) && t.lineHeight || ""
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || null == this.getMatchNode(e)
    }
    ,
    e.prototype.exec = function(e, t) {
      Nne.setNodes(e, {
        lineHeight: t.toString()
      }, {
        mode: "highest"
      })
    }
    ,
    e
}()
  , HBe = {
  renderStyle: function(e, t) {
    if (!Hte.isElement(e))
      return t;
    var n = e.lineHeight
      , r = t;
    return n && u_e(r, {
      lineHeight: n
    }),
      r
  },
  styleToHtml: function(e, t) {
    if (!Hte.isElement(e))
      return t;
    var n = e.lineHeight;
    if (!n)
      return t;
    var r = Qre(t);
    return r.css("line-height", n),
      _De(r)
  },
  parseStyleHtml: function(e, t, n) {
    var r = Qre(e);
    if (!Hte.isElement(t))
      return t;
    var o = t
      , a = n.getMenuConfig("lineHeight").lineHeightList
      , i = void 0 === a ? [] : a
      , s = LDe(r, "line-height");
    return s && i.includes(s) && (o.lineHeight = s),
      o
  },
  menus: [{
    key: "lineHeight",
    factory: function() {
      return new $Be
    },
    config: {
      lineHeightList: ["1", "1.15", "1.5", "2", "2.5", "3"]
    }
  }]
}
  , zBe = function() {
  function e() {
    this.title = SEe("undo.redo"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M0.00032 576a510.72 510.72 0 0 0 173.344 384l84.672-96A383.136 383.136 0 0 1 128.00032 576C128.00032 363.936 299.93632 192 512.00032 192c106.048 0 202.048 42.976 271.52 112.48L640.00032 448h384V64l-149.984 149.984A510.272 510.272 0 0 0 512.00032 64C229.21632 64 0.00032 293.216 0.00032 576z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection
    }
    ,
    e.prototype.exec = function(e, t) {
      "function" == typeof e.redo && e.redo()
    }
    ,
    e
}()
  , KBe = function() {
  function e() {
    this.title = SEe("undo.undo"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M512 64A510.272 510.272 0 0 0 149.984 213.984L0.032 64v384h384L240.512 304.48A382.784 382.784 0 0 1 512.032 192c212.064 0 384 171.936 384 384 0 114.688-50.304 217.632-130.016 288l84.672 96a510.72 510.72 0 0 0 173.344-384c0-282.784-229.216-512-512-512z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection
    }
    ,
    e.prototype.exec = function(e, t) {
      "function" == typeof e.undo && e.undo()
    }
    ,
    e
}()
  , WBe = {
  menus: [{
    key: "redo",
    factory: function() {
      return new zBe
    }
  }, {
    key: "undo",
    factory: function() {
      return new KBe
    }
  }]
}
  , GBe = {
  type: "divider",
  renderElem: function(e, t, n) {
    return Sae("div", {
      props: {
        contentEditable: !1,
        className: "w-e-textarea-divider"
      },
      dataset: {
        selected: qme.isNodeSelected(n, e) ? "true" : ""
      },
      style: {},
      on: {
        mousedown: function(e) {
          return e.preventDefault()
        }
      }
    }, [Sae("hr")])
  }
}
  , qBe = function() {
  function e() {
    this.title = SEe("divider.title"),
      this.iconSvg = '<svg viewBox="0 0 1092 1024"><path d="M0 51.2m51.2 0l989.866667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-989.866667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M0 460.8m51.2 0l170.666667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-170.666667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M819.2 460.8m51.2 0l170.666667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-170.666667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M409.6 460.8m51.2 0l170.666667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-170.666667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M0 870.4m51.2 0l989.866667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-989.866667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || !!qme.getSelectedElems(e).some((function(t) {
          if (e.isVoid(t))
            return !0;
          var n = qme.getNodeType(t);
          return "table" === n || "pre" === n || void 0
        }
      ))
    }
    ,
    e.prototype.exec = function(e, t) {
      Nne.insertNodes(e, {
        type: "divider",
        children: [{
          text: ""
        }]
      }, {
        mode: "highest"
      })
    }
    ,
    e
}()
  , YBe = {
  renderElems: [GBe],
  elemsToHtml: [{
    type: "divider",
    elemToHtml: function(e, t) {
      return "<hr/>"
    }
  }],
  parseElemsHtml: [{
    selector: "hr:not([data-w-e-type])",
    parseElemHtml: function(e, t, n) {
      return {
        type: "divider",
        children: [{
          text: ""
        }]
      }
    }
  }],
  menus: [{
    key: "divider",
    factory: function() {
      return new qBe
    }
  }],
  editorPlugin: function(e) {
    var t = e.isVoid
      , n = e.normalizeNode
      , r = e;
    return r.isVoid = function(e) {
      return "divider" === e.type || t(e)
    }
      ,
      r.normalizeNode = function(e) {
        var t = VDe(e, 2)
          , o = t[0]
          , a = t[1];
        if ("divider" !== qme.getNodeType(o))
          return n([o, a]);
        qme.isLastNode(r, o) && Nne.insertNodes(r, qme.genEmptyParagraph(), {
          at: [a[0] + 1]
        })
      }
      ,
      r
  }
}
  , XBe = Mke.map;
gke({
  target: "Array",
  proto: !0,
  forced: !Vke("map")
}, {
  map: function(e) {
    return XBe(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var QBe = uAe([].join)
  , JBe = vAe != Object
  , ZBe = ZDe("join", ",");
gke({
  target: "Array",
  proto: !0,
  forced: JBe || !ZBe
}, {
  join: function(e) {
    return QBe(yAe(this), void 0 === e ? "," : e)
  }
});
var eNe = function() {
  function e() {
    this.title = SEe("codeBlock.title"),
      this.iconSvg = '<svg viewBox="0 0 1280 1024"><path d="M832 736l96 96 320-320L928 192l-96 96 224 224zM448 288l-96-96L32 512l320 320 96-96-224-224zM701.312 150.528l69.472 18.944-192 704.032-69.472-18.944 192-704.032z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getSelectCodeElem = function(e) {
    var t = qme.getSelectedNodeByType(e, "code");
    if (null == t)
      return null;
    var n = qme.getParentNode(e, t);
    return null == n || "pre" !== qme.getNodeType(n) ? null : t
  }
    ,
    e.prototype.getValue = function(e) {
      var t = this.getSelectCodeElem(e);
      return null == t ? "" : t.language || ""
    }
    ,
    e.prototype.isActive = function(e) {
      return !!this.getSelectCodeElem(e)
    }
    ,
    e.prototype.isDisabled = function(e) {
      if (null == e.selection)
        return !0;
      var t = qme.getSelectedElems(e);
      return !!t.some((function(t) {
          return e.isVoid(t)
        }
      )) || !t.some((function(e) {
          var t = qme.getNodeType(e);
          if ("pre" === t || "paragraph" === t)
            return !0
        }
      ))
    }
    ,
    e.prototype.exec = function(e, t) {
      this.isActive(e) ? this.changeToPlainText(e) : this.changeToCodeBlock(e, t.toString())
    }
    ,
    e.prototype.changeToPlainText = function(e) {
      var t = this.getSelectCodeElem(e);
      if (null != t) {
        var n = ene.string(t);
        Nne.removeNodes(e, {
          mode: "highest"
        });
        var r = n.split("\n").map((function(e) {
            return {
              type: "paragraph",
              children: [{
                text: e
              }]
            }
          }
        ));
        Nne.insertNodes(e, r, {
          mode: "highest"
        })
      }
    }
    ,
    e.prototype.changeToCodeBlock = function(e, t) {
      var n, r, o = [], a = Yte.nodes(e, {
        match: function(t) {
          return e.children.includes(t)
        },
        universal: !0
      });
      try {
        for (var i = jDe(a), s = i.next(); !s.done; s = i.next()) {
          var l = VDe(s.value, 1)[0];
          l && o.push(ene.string(l))
        }
      } catch (c) {
        n = {
          error: c
        }
      } finally {
        try {
          s && !s.done && (r = i.return) && r.call(i)
        } finally {
          if (n)
            throw n.error
        }
      }
      Nne.removeNodes(e, {
        mode: "highest"
      });
      var u = {
        type: "pre",
        children: [{
          type: "code",
          language: t,
          children: [{
            text: o.join("\n")
          }]
        }]
      };
      Nne.insertNodes(e, u, {
        mode: "highest"
      })
    }
    ,
    e
}()
  , tNe = {
  key: "codeBlock",
  factory: function() {
    return new eNe
  }
};
gke({
  target: "String",
  proto: !0,
  forced: WDe("anchor")
}, {
  anchor: function(e) {
    return KDe(this, "a", "name", e)
  }
}),
  RTe("match", (function(e, t, n) {
      return [function(t) {
        var n = mAe(this)
          , r = null == t ? void 0 : NAe(t, e);
        return r ? ZEe(r, t, n) : new RegExp(t)[e](Kke(n))
      }
        , function(e) {
          var r = pCe(this)
            , o = Kke(e)
            , a = n(t, r, o);
          if (a.done)
            return a.value;
          if (!r.global)
            return KTe(r, o);
          var i = r.unicode;
          r.lastIndex = 0;
          for (var s, l = [], u = 0; null !== (s = KTe(r, o)); ) {
            var c = Kke(s[0]);
            l[u] = c,
            "" === c && (r.lastIndex = BTe(o, qCe(r.lastIndex), i)),
              u++
          }
          return 0 === u ? null : l
        }
      ]
    }
  ));
var nNe = {
  type: "pre",
  renderElem: function(e, t, n) {
    return $ae("pre", null, t)
  }
}
  , rNe = {
  type: "code",
  renderElem: function(e, t, n) {
    return $ae("code", null, t)
  }
}
  , oNe = {
  selector: "pre:not([data-w-e-type])",
  parseElemHtml: function(e, t, n) {
    var r = Qre(e);
    return 0 === (t = t.filter((function(e) {
        return "code" === qme.getNodeType(e)
      }
    ))).length && (t = [{
      type: "code",
      language: "",
      children: [{
        text: r[0].textContent || ""
      }]
    }]),
      {
        type: "pre",
        children: t.filter((function(e) {
            return "code" === qme.getNodeType(e)
          }
        ))
      }
  }
}
  , aNe = {
  menus: [tNe],
  editorPlugin: function(e) {
    var t = e.insertBreak
      , n = e.normalizeNode
      , r = e.insertData;
    e.insertNode;
    var o = e;
    return o.insertBreak = function() {
      var e = qme.getSelectedNodeByType(o, "code");
      if (null != e) {
        var n = function(e, t) {
          var n = t.selection;
          if (null == n)
            return "";
          var r = ene.string(e)
            , o = n.anchor.offset
            , a = r.slice(0, o).split("\n")
            , i = a.length;
          return 0 === i ? "" : a[i - 1]
        }(e, o);
        if (n) {
          var r = n.match(/^\s+/);
          if (null != r && null != r[0]) {
            var a = r[0];
            return void o.insertText("\n" + a)
          }
        }
        o.insertText("\n")
      } else
        t()
    }
      ,
      o.normalizeNode = function(e) {
        var t = VDe(e, 2)
          , r = t[0]
          , a = t[1]
          , i = qme.getNodeType(r);
        return "code" === i && a.length <= 1 && Nne.setNodes(o, {
          type: "paragraph"
        }, {
          at: a
        }),
        "pre" === i && (qme.isLastNode(o, r) && Nne.insertNodes(o, qme.genEmptyParagraph(), {
          at: [a[0] + 1]
        }),
        "code" !== qme.getNodeType(r.children[0]) && (Nne.unwrapNodes(o),
          Nne.setNodes(o, {
            type: "paragraph"
          }, {
            mode: "highest"
          }))),
          n([r, a])
      }
      ,
      o.insertData = function(e) {
        if (null != qme.getSelectedNodeByType(o, "code")) {
          var t = e.getData("text/plain");
          Yte.insertText(o, t)
        } else
          r(e)
      }
      ,
      o
  },
  renderElems: [nNe, rNe],
  elemsToHtml: [{
    type: "code",
    elemToHtml: function(e, t) {
      return "<code>" + t + "</code>"
    }
  }, {
    type: "pre",
    elemToHtml: function(e, t) {
      return "<pre>" + t + "</pre>"
    }
  }],
  preParseHtml: [{
    selector: "pre>code",
    preParseHtml: function(e) {
      var t = Qre(e);
      if ("code" !== RDe(t))
        return e;
      var n = t.find("xmp");
      if (0 === n.length)
        return e;
      var r = n.text();
      return n.remove(),
        t.text(r),
        t[0]
    }
  }],
  parseElemsHtml: [{
    selector: "pre:not([data-w-e-type])>code",
    parseElemHtml: function(e, t, n) {
      return {
        type: "code",
        language: "",
        children: [{
          text: Qre(e)[0].textContent || ""
        }]
      }
    }
  }, oNe]
}
  , iNe = function() {
  function e() {
    this.title = SEe("fullScreen.title"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M133.705143 335.433143V133.851429h201.581714a29.622857 29.622857 0 0 0 29.622857-29.549715V68.754286a29.622857 29.622857 0 0 0-29.622857-29.622857H61.732571A22.893714 22.893714 0 0 0 38.765714 62.025143V335.725714c0 16.310857 13.238857 29.622857 29.622857 29.622857h35.547429a29.842286 29.842286 0 0 0 29.696-29.842285zM690.980571 133.851429h201.581715v201.654857c0 16.310857 13.238857 29.549714 29.622857 29.549714h35.547428a29.622857 29.622857 0 0 0 29.549715-29.549714V61.952a22.893714 22.893714 0 0 0-22.820572-22.893714h-273.554285a29.622857 29.622857 0 0 0-29.549715 29.622857v35.547428c0 16.310857 13.238857 29.696 29.622857 29.696zM335.286857 892.781714H133.705143V691.2a29.622857 29.622857 0 0 0-29.622857-29.622857H68.534857a29.622857 29.622857 0 0 0-29.549714 29.622857v273.554286c0 12.653714 10.24 22.893714 22.820571 22.893714h273.554286a29.622857 29.622857 0 0 0 29.696-29.622857v-35.547429a29.769143 29.769143 0 0 0-29.769143-29.696z m557.348572-201.581714v201.581714H690.907429a29.622857 29.622857 0 0 0-29.622858 29.622857v35.547429c0 16.310857 13.238857 29.622857 29.622858 29.622857h273.554285c12.580571 0 22.893714-10.313143 22.893715-22.893714V691.2a29.622857 29.622857 0 0 0-29.622858-29.622857h-35.547428a29.622857 29.622857 0 0 0-29.696 29.622857z"></path></svg>',
      this.tag = "button",
      this.alwaysEnable = !0
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return e.isFullScreen
    }
    ,
    e.prototype.isDisabled = function(e) {
      return !1
    }
    ,
    e.prototype.exec = function(e, t) {
      e.isFullScreen ? e.unFullScreen() : e.fullScreen()
    }
    ,
    e
}()
  , sNe = {
  menus: [{
    key: "fullScreen",
    factory: function() {
      return new iNe
    }
  }]
}
  , lNe = function() {
  function e() {
    this.title = SEe("common.enter"),
      this.iconSvg = '<svg viewBox="0 0 1255 1024"><path d="M1095.111111 731.477333h-625.777778V1024L0 658.318222 469.333333 292.408889v292.636444h625.777778V0h156.444445v731.477333z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !!fne.isExpanded(t)
    }
    ,
    e.prototype.exec = function(e, t) {
      var n = e.selection;
      if (null != n) {
        var r = [n.anchor.path[0]];
        Nne.insertNodes(e, {
          type: "paragraph",
          children: [{
            text: ""
          }]
        }, {
          at: r
        }),
          e.select(Yte.start(e, r))
      }
    }
    ,
    e
}()
  , uNe = [mOe, v_e, _Be, FBe, UBe, HBe, pRe, YBe, ORe, B_e, aNe, TRe, o_e, $De, mRe, WBe, sNe, {
  menus: [{
    key: "enter",
    factory: function() {
      return new lNe
    }
  }]
}];
xEe("en", {
  listModule: {
    unOrderedList: "Unordered list",
    orderedList: "Ordered list"
  }
}),
  xEe("zh-CN", {
    listModule: {
      unOrderedList: "无序列表",
      orderedList: "有序列表"
    }
  });
var cNe = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function dNe(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports),
    t.exports
}
var fNe, pNe, hNe = function(e) {
  return e && e.Math == Math && e
}, vNe = hNe("object" == typeof globalThis && globalThis) || hNe("object" == typeof window && window) || hNe("object" == typeof self && self) || hNe("object" == typeof cNe && cNe) || function() {
  return this
}() || Function("return this")(), gNe = Function.prototype, mNe = gNe.bind, yNe = gNe.call, bNe = mNe && mNe.bind(yNe), wNe = mNe ? function(e) {
    return e && bNe(yNe, e)
  }
  : function(e) {
    return e && function() {
      return yNe.apply(e, arguments)
    }
  }
  , xNe = function(e) {
  try {
    return !!e()
  } catch (t) {
    return !0
  }
}, SNe = wNe({}.toString), ENe = wNe("".slice), ANe = function(e) {
  return ENe(SNe(e), 8, -1)
}, CNe = vNe.Object, kNe = wNe("".split), TNe = xNe((function() {
    return !CNe("z").propertyIsEnumerable(0)
  }
)) ? function(e) {
    return "String" == ANe(e) ? kNe(e, "") : CNe(e)
  }
  : CNe, DNe = vNe.TypeError, ONe = function(e) {
  if (null == e)
    throw DNe("Can't call method on " + e);
  return e
}, _Ne = function(e) {
  return TNe(ONe(e))
}, RNe = Object.defineProperty, LNe = function(e, t) {
  try {
    RNe(vNe, e, {
      value: t,
      configurable: !0,
      writable: !0
    })
  } catch (AEe) {
    vNe[e] = t
  }
  return t
}, INe = vNe["__core-js_shared__"] || LNe("__core-js_shared__", {}), PNe = dNe((function(e) {
    (e.exports = function(e, t) {
        return INe[e] || (INe[e] = void 0 !== t ? t : {})
      }
    )("versions", []).push({
      version: "3.19.3",
      mode: "global",
      copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
    })
  }
)), FNe = vNe.Object, BNe = function(e) {
  return FNe(ONe(e))
}, NNe = wNe({}.hasOwnProperty), MNe = Object.hasOwn || function(e, t) {
  return NNe(BNe(e), t)
}
  , jNe = 0, VNe = Math.random(), UNe = wNe(1..toString), $Ne = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + UNe(++jNe + VNe, 36)
}, HNe = function(e) {
  return "function" == typeof e
}, zNe = function(e, t) {
  return arguments.length < 2 ? function(e) {
    return HNe(e) ? e : void 0
  }(vNe[e]) : vNe[e] && vNe[e][t]
}, KNe = zNe("navigator", "userAgent") || "", WNe = vNe.process, GNe = vNe.Deno, qNe = WNe && WNe.versions || GNe && GNe.version, YNe = qNe && qNe.v8;
YNe && (pNe = (fNe = YNe.split("."))[0] > 0 && fNe[0] < 4 ? 1 : +(fNe[0] + fNe[1])),
!pNe && KNe && (!(fNe = KNe.match(/Edge\/(\d+)/)) || fNe[1] >= 74) && (fNe = KNe.match(/Chrome\/(\d+)/)) && (pNe = +fNe[1]);
var XNe, QNe = pNe, JNe = !!Object.getOwnPropertySymbols && !xNe((function() {
    var e = Symbol();
    return !String(e) || !(Object(e)instanceof Symbol) || !Symbol.sham && QNe && QNe < 41
  }
)), ZNe = JNe && !Symbol.sham && "symbol" == typeof Symbol.iterator, eMe = PNe("wks"), tMe = vNe.Symbol, nMe = tMe && tMe.for, rMe = ZNe ? tMe : tMe && tMe.withoutSetter || $Ne, oMe = function(e) {
  if (!MNe(eMe, e) || !JNe && "string" != typeof eMe[e]) {
    var t = "Symbol." + e;
    JNe && MNe(tMe, e) ? eMe[e] = tMe[e] : eMe[e] = ZNe && nMe ? nMe(t) : rMe(t)
  }
  return eMe[e]
}, aMe = function(e) {
  return "object" == typeof e ? null !== e : HNe(e)
}, iMe = vNe.String, sMe = vNe.TypeError, lMe = function(e) {
  if (aMe(e))
    return e;
  throw sMe(iMe(e) + " is not an object")
}, uMe = !xNe((function() {
    return 7 != Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1]
  }
)), cMe = vNe.document, dMe = aMe(cMe) && aMe(cMe.createElement), fMe = function(e) {
  return dMe ? cMe.createElement(e) : {}
}, pMe = !uMe && !xNe((function() {
    return 7 != Object.defineProperty(fMe("div"), "a", {
      get: function() {
        return 7
      }
    }).a
  }
)), hMe = Function.prototype.call, vMe = hMe.bind ? hMe.bind(hMe) : function() {
  return hMe.apply(hMe, arguments)
}
  , gMe = wNe({}.isPrototypeOf), mMe = vNe.Object, yMe = ZNe ? function(e) {
    return "symbol" == typeof e
  }
  : function(e) {
    var t = zNe("Symbol");
    return HNe(t) && gMe(t.prototype, mMe(e))
  }
  , bMe = vNe.String, wMe = function(e) {
  try {
    return bMe(e)
  } catch (t) {
    return "Object"
  }
}, xMe = vNe.TypeError, SMe = function(e) {
  if (HNe(e))
    return e;
  throw xMe(wMe(e) + " is not a function")
}, EMe = function(e, t) {
  var n = e[t];
  return null == n ? void 0 : SMe(n)
}, AMe = vNe.TypeError, CMe = vNe.TypeError, kMe = oMe("toPrimitive"), TMe = function(e) {
  var t = function(e, t) {
    if (!aMe(e) || yMe(e))
      return e;
    var n, r = EMe(e, kMe);
    if (r) {
      if (void 0 === t && (t = "default"),
        n = vMe(r, e, t),
      !aMe(n) || yMe(n))
        return n;
      throw CMe("Can't convert object to primitive value")
    }
    return void 0 === t && (t = "number"),
      function(e, t) {
        var n, r;
        if ("string" === t && HNe(n = e.toString) && !aMe(r = vMe(n, e)))
          return r;
        if (HNe(n = e.valueOf) && !aMe(r = vMe(n, e)))
          return r;
        if ("string" !== t && HNe(n = e.toString) && !aMe(r = vMe(n, e)))
          return r;
        throw AMe("Can't convert object to primitive value")
      }(e, t)
  }(e, "string");
  return yMe(t) ? t : t + ""
}, DMe = vNe.TypeError, OMe = Object.defineProperty, _Me = {
  f: uMe ? OMe : function(e, t, n) {
    if (lMe(e),
      t = TMe(t),
      lMe(n),
      pMe)
      try {
        return OMe(e, t, n)
      } catch (r) {}
    if ("get"in n || "set"in n)
      throw DMe("Accessors not supported");
    return "value"in n && (e[t] = n.value),
      e
  }
}, RMe = Math.ceil, LMe = Math.floor, IMe = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : (t > 0 ? LMe : RMe)(t)
}, PMe = Math.max, FMe = Math.min, BMe = function(e, t) {
  var n = IMe(e);
  return n < 0 ? PMe(n + t, 0) : FMe(n, t)
}, NMe = Math.min, MMe = function(e) {
  return e > 0 ? NMe(IMe(e), 9007199254740991) : 0
}, jMe = function(e) {
  return MMe(e.length)
}, VMe = function(e) {
  return function(t, n, r) {
    var o, a = _Ne(t), i = jMe(a), s = BMe(r, i);
    if (e && n != n) {
      for (; i > s; )
        if ((o = a[s++]) != o)
          return !0
    } else
      for (; i > s; s++)
        if ((e || s in a) && a[s] === n)
          return e || s || 0;
    return !e && -1
  }
}, UMe = {
  includes: VMe(!0),
  indexOf: VMe(!1)
}, $Me = {}, HMe = UMe.indexOf, zMe = wNe([].push), KMe = function(e, t) {
  var n, r = _Ne(e), o = 0, a = [];
  for (n in r)
    !MNe($Me, n) && MNe(r, n) && zMe(a, n);
  for (; t.length > o; )
    MNe(r, n = t[o++]) && (~HMe(a, n) || zMe(a, n));
  return a
}, WMe = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], GMe = Object.keys || function(e) {
  return KMe(e, WMe)
}
  , qMe = uMe ? Object.defineProperties : function(e, t) {
  lMe(e);
  for (var n, r = _Ne(t), o = GMe(t), a = o.length, i = 0; a > i; )
    _Me.f(e, n = o[i++], r[n]);
  return e
}
  , YMe = zNe("document", "documentElement"), XMe = PNe("keys"), QMe = function(e) {
  return XMe[e] || (XMe[e] = $Ne(e))
}, JMe = QMe("IE_PROTO"), ZMe = function() {}, eje = function(e) {
  return "<script>" + e + "<\/script>"
}, tje = function(e) {
  e.write(eje("")),
    e.close();
  var t = e.parentWindow.Object;
  return e = null,
    t
}, nje = function() {
  try {
    XNe = new ActiveXObject("htmlfile")
  } catch (r) {}
  var e, t;
  nje = "undefined" != typeof document ? document.domain && XNe ? tje(XNe) : ((t = fMe("iframe")).style.display = "none",
    YMe.appendChild(t),
    t.src = String("javascript:"),
    (e = t.contentWindow.document).open(),
    e.write(eje("document.F=Object")),
    e.close(),
    e.F) : tje(XNe);
  for (var n = WMe.length; n--; )
    delete nje.prototype[WMe[n]];
  return nje()
};
$Me[JMe] = !0;
var rje = Object.create || function(e, t) {
  var n;
  return null !== e ? (ZMe.prototype = lMe(e),
    n = new ZMe,
    ZMe.prototype = null,
    n[JMe] = e) : n = nje(),
    void 0 === t ? n : qMe(n, t)
}
  , oje = oMe("unscopables")
  , aje = Array.prototype;
null == aje[oje] && _Me.f(aje, oje, {
  configurable: !0,
  value: rje(null)
});
var ije = function(e) {
  aje[oje][e] = !0
}
  , sje = {}
  , lje = wNe(Function.toString);
HNe(INe.inspectSource) || (INe.inspectSource = function(e) {
    return lje(e)
  }
);
var uje, cje, dje, fje = INe.inspectSource, pje = vNe.WeakMap, hje = HNe(pje) && /native code/.test(fje(pje)), vje = function(e, t) {
  return {
    enumerable: !(1 & e),
    configurable: !(2 & e),
    writable: !(4 & e),
    value: t
  }
}, gje = uMe ? function(e, t, n) {
    return _Me.f(e, t, vje(1, n))
  }
  : function(e, t, n) {
    return e[t] = n,
      e
  }
  , mje = vNe.TypeError, yje = vNe.WeakMap;
if (hje || INe.state) {
  var bje = INe.state || (INe.state = new yje)
    , wje = wNe(bje.get)
    , xje = wNe(bje.has)
    , Sje = wNe(bje.set);
  uje = function(e, t) {
    if (xje(bje, e))
      throw new mje("Object already initialized");
    return t.facade = e,
      Sje(bje, e, t),
      t
  }
    ,
    cje = function(e) {
      return wje(bje, e) || {}
    }
    ,
    dje = function(e) {
      return xje(bje, e)
    }
} else {
  var Eje = QMe("state");
  $Me[Eje] = !0,
    uje = function(e, t) {
      if (MNe(e, Eje))
        throw new mje("Object already initialized");
      return t.facade = e,
        gje(e, Eje, t),
        t
    }
    ,
    cje = function(e) {
      return MNe(e, Eje) ? e[Eje] : {}
    }
    ,
    dje = function(e) {
      return MNe(e, Eje)
    }
}
var Aje, Cje, kje, Tje = {
  set: uje,
  get: cje,
  has: dje,
  enforce: function(e) {
    return dje(e) ? cje(e) : uje(e, {})
  },
  getterFor: function(e) {
    return function(t) {
      var n;
      if (!aMe(t) || (n = cje(t)).type !== e)
        throw mje("Incompatible receiver, " + e + " required");
      return n
    }
  }
}, Dje = {}.propertyIsEnumerable, Oje = Object.getOwnPropertyDescriptor, _je = {
  f: Oje && !Dje.call({
    1: 2
  }, 1) ? function(e) {
      var t = Oje(this, e);
      return !!t && t.enumerable
    }
    : Dje
}, Rje = Object.getOwnPropertyDescriptor, Lje = {
  f: uMe ? Rje : function(e, t) {
    if (e = _Ne(e),
      t = TMe(t),
      pMe)
      try {
        return Rje(e, t)
      } catch (n) {}
    if (MNe(e, t))
      return vje(!vMe(_je.f, e, t), e[t])
  }
}, Ije = Function.prototype, Pje = uMe && Object.getOwnPropertyDescriptor, Fje = MNe(Ije, "name"), Bje = {
  EXISTS: Fje,
  PROPER: Fje && "something" === function() {}
    .name,
  CONFIGURABLE: Fje && (!uMe || uMe && Pje(Ije, "name").configurable)
}, Nje = dNe((function(e) {
    var t = Bje.CONFIGURABLE
      , n = Tje.get
      , r = Tje.enforce
      , o = String(String).split("String");
    (e.exports = function(e, n, a, i) {
        var s, l = !!i && !!i.unsafe, u = !!i && !!i.enumerable, c = !!i && !!i.noTargetGet, d = i && void 0 !== i.name ? i.name : n;
        HNe(a) && ("Symbol(" === String(d).slice(0, 7) && (d = "[" + String(d).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
        (!MNe(a, "name") || t && a.name !== d) && gje(a, "name", d),
        (s = r(a)).source || (s.source = o.join("string" == typeof d ? d : ""))),
          e !== vNe ? (l ? !c && e[n] && (u = !0) : delete e[n],
            u ? e[n] = a : gje(e, n, a)) : u ? e[n] = a : LNe(n, a)
      }
    )(Function.prototype, "toString", (function() {
        return HNe(this) && n(this).source || fje(this)
      }
    ))
  }
)), Mje = WMe.concat("length", "prototype"), jje = {
  f: Object.getOwnPropertyNames || function(e) {
    return KMe(e, Mje)
  }
}, Vje = {
  f: Object.getOwnPropertySymbols
}, Uje = wNe([].concat), $je = zNe("Reflect", "ownKeys") || function(e) {
  var t = jje.f(lMe(e))
    , n = Vje.f;
  return n ? Uje(t, n(e)) : t
}
  , Hje = function(e, t) {
  for (var n = $je(t), r = _Me.f, o = Lje.f, a = 0; a < n.length; a++) {
    var i = n[a];
    MNe(e, i) || r(e, i, o(t, i))
  }
}, zje = /#|\.prototype\./, Kje = function(e, t) {
  var n = Gje[Wje(e)];
  return n == Yje || n != qje && (HNe(t) ? xNe(t) : !!t)
}, Wje = Kje.normalize = function(e) {
  return String(e).replace(zje, ".").toLowerCase()
}
  , Gje = Kje.data = {}, qje = Kje.NATIVE = "N", Yje = Kje.POLYFILL = "P", Xje = Kje, Qje = Lje.f, Jje = function(e, t) {
  var n, r, o, a, i, s = e.target, l = e.global, u = e.stat;
  if (n = l ? vNe : u ? vNe[s] || LNe(s, {}) : (vNe[s] || {}).prototype)
    for (r in t) {
      if (a = t[r],
        o = e.noTargetGet ? (i = Qje(n, r)) && i.value : n[r],
      !Xje(l ? r : s + (u ? "." : "#") + r, e.forced) && void 0 !== o) {
        if (typeof a == typeof o)
          continue;
        Hje(a, o)
      }
      (e.sham || o && o.sham) && gje(a, "sham", !0),
        Nje(n, r, a, e)
    }
}, Zje = !xNe((function() {
    function e() {}
    return e.prototype.constructor = null,
    Object.getPrototypeOf(new e) !== e.prototype
  }
)), eVe = QMe("IE_PROTO"), tVe = vNe.Object, nVe = tVe.prototype, rVe = Zje ? tVe.getPrototypeOf : function(e) {
  var t = BNe(e);
  if (MNe(t, eVe))
    return t[eVe];
  var n = t.constructor;
  return HNe(n) && t instanceof n ? n.prototype : t instanceof tVe ? nVe : null
}
  , oVe = oMe("iterator"), aVe = !1;
[].keys && ("next"in (kje = [].keys()) ? (Cje = rVe(rVe(kje))) !== Object.prototype && (Aje = Cje) : aVe = !0);
var iVe = null == Aje || xNe((function() {
    var e = {};
    return Aje[oVe].call(e) !== e
  }
));
iVe && (Aje = {}),
HNe(Aje[oVe]) || Nje(Aje, oVe, (function() {
    return this
  }
));
var sVe = {
  IteratorPrototype: Aje,
  BUGGY_SAFARI_ITERATORS: aVe
}
  , lVe = _Me.f
  , uVe = oMe("toStringTag")
  , cVe = function(e, t, n) {
  e && !MNe(e = n ? e : e.prototype, uVe) && lVe(e, uVe, {
    configurable: !0,
    value: t
  })
}
  , dVe = sVe.IteratorPrototype
  , fVe = function() {
  return this
}
  , pVe = vNe.String
  , hVe = vNe.TypeError
  , vVe = Object.setPrototypeOf || ("__proto__"in {} ? function() {
  var e, t = !1, n = {};
  try {
    (e = wNe(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n, []),
      t = n instanceof Array
  } catch (r) {}
  return function(n, r) {
    return lMe(n),
      function(e) {
        if ("object" == typeof e || HNe(e))
          return e;
        throw hVe("Can't set " + pVe(e) + " as a prototype")
      }(r),
      t ? e(n, r) : n.__proto__ = r,
      n
  }
}() : void 0)
  , gVe = Bje.PROPER
  , mVe = Bje.CONFIGURABLE
  , yVe = sVe.IteratorPrototype
  , bVe = sVe.BUGGY_SAFARI_ITERATORS
  , wVe = oMe("iterator")
  , xVe = function() {
  return this
}
  , SVe = function(e, t, n, r, o, a, i) {
  var s, l, u;
  l = r,
    u = t + " Iterator",
    (s = n).prototype = rje(dVe, {
      next: vje(1, l)
    }),
    cVe(s, u, !1),
    sje[u] = fVe;
  var c, d, f, p = function(e) {
    if (e === o && y)
      return y;
    if (!bVe && e in g)
      return g[e];
    switch (e) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n(this,e)
        }
    }
    return function() {
      return new n(this)
    }
  }, h = t + " Iterator", v = !1, g = e.prototype, m = g[wVe] || g["@@iterator"] || o && g[o], y = !bVe && m || p(o), b = "Array" == t && g.entries || m;
  if (b && (c = rVe(b.call(new e))) !== Object.prototype && c.next && (rVe(c) !== yVe && (vVe ? vVe(c, yVe) : HNe(c[wVe]) || Nje(c, wVe, xVe)),
    cVe(c, h, !0)),
  gVe && "values" == o && m && "values" !== m.name && (mVe ? gje(g, "name", "values") : (v = !0,
      y = function() {
        return vMe(m, this)
      }
  )),
    o)
    if (d = {
      values: p("values"),
      keys: a ? y : p("keys"),
      entries: p("entries")
    },
      i)
      for (f in d)
        (bVe || v || !(f in g)) && Nje(g, f, d[f]);
    else
      Jje({
        target: t,
        proto: !0,
        forced: bVe || v
      }, d);
  return g[wVe] !== y && Nje(g, wVe, y, {
    name: o
  }),
    sje[t] = y,
    d
}
  , EVe = Tje.set
  , AVe = Tje.getterFor("Array Iterator")
  , CVe = SVe(Array, "Array", (function(e, t) {
    EVe(this, {
      type: "Array Iterator",
      target: _Ne(e),
      index: 0,
      kind: t
    })
  }
), (function() {
    var e = AVe(this)
      , t = e.target
      , n = e.kind
      , r = e.index++;
    return !t || r >= t.length ? (e.target = void 0,
      {
        value: void 0,
        done: !0
      }) : "keys" == n ? {
      value: r,
      done: !1
    } : "values" == n ? {
      value: t[r],
      done: !1
    } : {
      value: [r, t[r]],
      done: !1
    }
  }
), "values");
sje.Arguments = sje.Array,
  ije("keys"),
  ije("values"),
  ije("entries");
var kVe = {};
kVe[oMe("toStringTag")] = "z";
var TVe = "[object z]" === String(kVe)
  , DVe = oMe("toStringTag")
  , OVe = vNe.Object
  , _Ve = "Arguments" == ANe(function() {
    return arguments
  }())
  , RVe = TVe ? ANe : function(e) {
    var t, n, r;
    return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
      try {
        return e[t]
      } catch (n) {}
    }(t = OVe(e), DVe)) ? n : _Ve ? ANe(t) : "Object" == (r = ANe(t)) && HNe(t.callee) ? "Arguments" : r
  }
  , LVe = TVe ? {}.toString : function() {
    return "[object " + RVe(this) + "]"
  }
;
TVe || Nje(Object.prototype, "toString", LVe, {
  unsafe: !0
});
var IVe = vNe.String
  , PVe = function(e) {
  if ("Symbol" === RVe(e))
    throw TypeError("Cannot convert a Symbol value to a string");
  return IVe(e)
}
  , FVe = wNe("".charAt)
  , BVe = wNe("".charCodeAt)
  , NVe = wNe("".slice)
  , MVe = function(e) {
  return function(t, n) {
    var r, o, a = PVe(ONe(t)), i = IMe(n), s = a.length;
    return i < 0 || i >= s ? e ? "" : void 0 : (r = BVe(a, i)) < 55296 || r > 56319 || i + 1 === s || (o = BVe(a, i + 1)) < 56320 || o > 57343 ? e ? FVe(a, i) : r : e ? NVe(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536
  }
}
  , jVe = {
  codeAt: MVe(!1),
  charAt: MVe(!0)
}
  , VVe = jVe.charAt
  , UVe = Tje.set
  , $Ve = Tje.getterFor("String Iterator");
SVe(String, "String", (function(e) {
    UVe(this, {
      type: "String Iterator",
      string: PVe(e),
      index: 0
    })
  }
), (function() {
    var e, t = $Ve(this), n = t.string, r = t.index;
    return r >= n.length ? {
      value: void 0,
      done: !0
    } : (e = VVe(n, r),
      t.index += e.length,
      {
        value: e,
        done: !1
      })
  }
));
var HVe = function(e, t, n) {
  for (var r in t)
    Nje(e, r, t[r], n);
  return e
}
  , zVe = vNe.Array
  , KVe = Math.max
  , WVe = jje.f
  , GVe = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []
  , qVe = {
  f: function(e) {
    return GVe && "Window" == ANe(e) ? function(e) {
      try {
        return WVe(e)
      } catch (t) {
        return function(e, t, n) {
          for (var r, o, a, i, s = jMe(e), l = BMe(void 0, s), u = BMe(s, s), c = zVe(KVe(u - l, 0)), d = 0; l < u; l++,
            d++)
            r = c,
              o = d,
              a = e[l],
              (i = TMe(o))in r ? _Me.f(r, i, vje(0, a)) : r[i] = a;
          return c.length = d,
            c
        }(GVe)
      }
    }(e) : WVe(_Ne(e))
  }
}
  , YVe = xNe((function() {
    if ("function" == typeof ArrayBuffer) {
      var e = new ArrayBuffer(8);
      Object.isExtensible(e) && Object.defineProperty(e, "a", {
        value: 8
      })
    }
  }
))
  , XVe = Object.isExtensible
  , QVe = xNe((function() {
    XVe(1)
  }
)) || YVe ? function(e) {
    return !!aMe(e) && (!YVe || "ArrayBuffer" != ANe(e)) && (!XVe || XVe(e))
  }
  : XVe
  , JVe = !xNe((function() {
    return Object.isExtensible(Object.preventExtensions({}))
  }
))
  , ZVe = dNe((function(e) {
    var t = _Me.f
      , n = !1
      , r = $Ne("meta")
      , o = 0
      , a = function(e) {
      t(e, r, {
        value: {
          objectID: "O" + o++,
          weakData: {}
        }
      })
    }
      , i = e.exports = {
      enable: function() {
        i.enable = function() {}
          ,
          n = !0;
        var e = jje.f
          , t = wNe([].splice)
          , o = {};
        o[r] = 1,
        e(o).length && (jje.f = function(n) {
          for (var o = e(n), a = 0, i = o.length; a < i; a++)
            if (o[a] === r) {
              t(o, a, 1);
              break
            }
          return o
        }
          ,
          Jje({
            target: "Object",
            stat: !0,
            forced: !0
          }, {
            getOwnPropertyNames: qVe.f
          }))
      },
      fastKey: function(e, t) {
        if (!aMe(e))
          return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
        if (!MNe(e, r)) {
          if (!QVe(e))
            return "F";
          if (!t)
            return "E";
          a(e)
        }
        return e[r].objectID
      },
      getWeakData: function(e, t) {
        if (!MNe(e, r)) {
          if (!QVe(e))
            return !0;
          if (!t)
            return !1;
          a(e)
        }
        return e[r].weakData
      },
      onFreeze: function(e) {
        return JVe && n && QVe(e) && !MNe(e, r) && a(e),
          e
      }
    };
    $Me[r] = !0
  }
))
  , eUe = wNe(wNe.bind)
  , tUe = function(e, t) {
  return SMe(e),
    void 0 === t ? e : eUe ? eUe(e, t) : function() {
      return e.apply(t, arguments)
    }
}
  , nUe = oMe("iterator")
  , rUe = Array.prototype
  , oUe = oMe("iterator")
  , aUe = function(e) {
  if (null != e)
    return EMe(e, oUe) || EMe(e, "@@iterator") || sje[RVe(e)]
}
  , iUe = vNe.TypeError
  , sUe = function(e, t, n) {
  var r, o;
  lMe(e);
  try {
    if (!(r = EMe(e, "return"))) {
      if ("throw" === t)
        throw n;
      return n
    }
    r = vMe(r, e)
  } catch (a) {
    o = !0,
      r = a
  }
  if ("throw" === t)
    throw n;
  if (o)
    throw r;
  return lMe(r),
    n
}
  , lUe = vNe.TypeError
  , uUe = function(e, t) {
  this.stopped = e,
    this.result = t
}
  , cUe = uUe.prototype
  , dUe = function(e, t, n) {
  var r, o, a, i, s, l, u, c, d = n && n.that, f = !(!n || !n.AS_ENTRIES), p = !(!n || !n.IS_ITERATOR), h = !(!n || !n.INTERRUPTED), v = tUe(t, d), g = function(e) {
    return r && sUe(r, "normal", e),
      new uUe(!0,e)
  }, m = function(e) {
    return f ? (lMe(e),
      h ? v(e[0], e[1], g) : v(e[0], e[1])) : h ? v(e, g) : v(e)
  };
  if (p)
    r = e;
  else {
    if (!(o = aUe(e)))
      throw lUe(wMe(e) + " is not iterable");
    if (void 0 !== (c = o) && (sje.Array === c || rUe[nUe] === c)) {
      for (a = 0,
             i = jMe(e); i > a; a++)
        if ((s = m(e[a])) && gMe(cUe, s))
          return s;
      return new uUe(!1)
    }
    r = function(e, t) {
      var n = arguments.length < 2 ? aUe(e) : t;
      if (SMe(n))
        return lMe(vMe(n, e));
      throw iUe(wMe(e) + " is not iterable")
    }(e, o)
  }
  for (l = r.next; !(u = vMe(l, r)).done; ) {
    try {
      s = m(u.value)
    } catch (y) {
      sUe(r, "throw", y)
    }
    if ("object" == typeof s && s && gMe(cUe, s))
      return s
  }
  return new uUe(!1)
}
  , fUe = vNe.TypeError
  , pUe = function(e, t) {
  if (gMe(t, e))
    return e;
  throw fUe("Incorrect invocation")
}
  , hUe = oMe("iterator")
  , vUe = !1;
try {
  var gUe = 0
    , mUe = {
    next: function() {
      return {
        done: !!gUe++
      }
    },
    return: function() {
      vUe = !0
    }
  };
  mUe[hUe] = function() {
    return this
  }
    ,
    Array.from(mUe, (function() {
        throw 2
      }
    ))
} catch (lbt) {}
var yUe = Array.isArray || function(e) {
  return "Array" == ANe(e)
}
  , bUe = function() {}
  , wUe = []
  , xUe = zNe("Reflect", "construct")
  , SUe = /^\s*(?:class|function)\b/
  , EUe = wNe(SUe.exec)
  , AUe = !SUe.exec(bUe)
  , CUe = function(e) {
  if (!HNe(e))
    return !1;
  try {
    return xUe(bUe, wUe, e),
      !0
  } catch (t) {
    return !1
  }
}
  , kUe = !xUe || xNe((function() {
    var e;
    return CUe(CUe.call) || !CUe(Object) || !CUe((function() {
        e = !0
      }
    )) || e
  }
)) ? function(e) {
    if (!HNe(e))
      return !1;
    switch (RVe(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    return AUe || !!EUe(SUe, fje(e))
  }
  : CUe
  , TUe = oMe("species")
  , DUe = vNe.Array
  , OUe = function(e, t) {
  return new (yUe(n = e) && (r = n.constructor,
  (kUe(r) && (r === DUe || yUe(r.prototype)) || aMe(r) && null === (r = r[TUe])) && (r = void 0)),
    void 0 === r ? DUe : r)(0 === t ? 0 : t);
  var n, r
}
  , _Ue = wNe([].push)
  , RUe = function(e) {
  var t = 1 == e
    , n = 2 == e
    , r = 3 == e
    , o = 4 == e
    , a = 6 == e
    , i = 7 == e
    , s = 5 == e || a;
  return function(l, u, c, d) {
    for (var f, p, h = BNe(l), v = TNe(h), g = tUe(u, c), m = jMe(v), y = 0, b = d || OUe, w = t ? b(l, m) : n || i ? b(l, 0) : void 0; m > y; y++)
      if ((s || y in v) && (p = g(f = v[y], y, h),
        e))
        if (t)
          w[y] = p;
        else if (p)
          switch (e) {
            case 3:
              return !0;
            case 5:
              return f;
            case 6:
              return y;
            case 2:
              _Ue(w, f)
          }
        else
          switch (e) {
            case 4:
              return !1;
            case 7:
              _Ue(w, f)
          }
    return a ? -1 : r || o ? o : w
  }
}
  , LUe = {
  forEach: RUe(0),
  map: RUe(1),
  filter: RUe(2),
  some: RUe(3),
  every: RUe(4),
  find: RUe(5),
  findIndex: RUe(6),
  filterReject: RUe(7)
}
  , IUe = ZVe.getWeakData
  , PUe = Tje.set
  , FUe = Tje.getterFor
  , BUe = LUe.find
  , NUe = LUe.findIndex
  , MUe = wNe([].splice)
  , jUe = 0
  , VUe = function(e) {
  return e.frozen || (e.frozen = new UUe)
}
  , UUe = function() {
  this.entries = []
}
  , $Ue = function(e, t) {
  return BUe(e.entries, (function(e) {
      return e[0] === t
    }
  ))
};
UUe.prototype = {
  get: function(e) {
    var t = $Ue(this, e);
    if (t)
      return t[1]
  },
  has: function(e) {
    return !!$Ue(this, e)
  },
  set: function(e, t) {
    var n = $Ue(this, e);
    n ? n[1] = t : this.entries.push([e, t])
  },
  delete: function(e) {
    var t = NUe(this.entries, (function(t) {
        return t[0] === e
      }
    ));
    return ~t && MUe(this.entries, t, 1),
      !!~t
  }
};
var HUe, zUe = {
  getConstructor: function(e, t, n, r) {
    var o = e((function(e, o) {
        pUe(e, a),
          PUe(e, {
            type: t,
            id: jUe++,
            frozen: void 0
          }),
        null != o && dUe(o, e[r], {
          that: e,
          AS_ENTRIES: n
        })
      }
    ))
      , a = o.prototype
      , i = FUe(t)
      , s = function(e, t, n) {
      var r = i(e)
        , o = IUe(lMe(t), !0);
      return !0 === o ? VUe(r).set(t, n) : o[r.id] = n,
        e
    };
    return HVe(a, {
      delete: function(e) {
        var t = i(this);
        if (!aMe(e))
          return !1;
        var n = IUe(e);
        return !0 === n ? VUe(t).delete(e) : n && MNe(n, t.id) && delete n[t.id]
      },
      has: function(e) {
        var t = i(this);
        if (!aMe(e))
          return !1;
        var n = IUe(e);
        return !0 === n ? VUe(t).has(e) : n && MNe(n, t.id)
      }
    }),
      HVe(a, n ? {
        get: function(e) {
          var t = i(this);
          if (aMe(e)) {
            var n = IUe(e);
            return !0 === n ? VUe(t).get(e) : n ? n[t.id] : void 0
          }
        },
        set: function(e, t) {
          return s(this, e, t)
        }
      } : {
        add: function(e) {
          return s(this, e, !0)
        }
      }),
      o
  }
}, KUe = Tje.enforce, WUe = !vNe.ActiveXObject && "ActiveXObject"in vNe, GUe = function(e) {
  return function() {
    return e(this, arguments.length ? arguments[0] : void 0)
  }
}, qUe = function(e, t, n) {
  var r = -1 !== e.indexOf("Map")
    , o = -1 !== e.indexOf("Weak")
    , a = r ? "set" : "add"
    , i = vNe[e]
    , s = i && i.prototype
    , l = i
    , u = {}
    , c = function(e) {
    var t = wNe(s[e]);
    Nje(s, e, "add" == e ? function(e) {
          return t(this, 0 === e ? 0 : e),
            this
        }
        : "delete" == e ? function(e) {
            return !(o && !aMe(e)) && t(this, 0 === e ? 0 : e)
          }
          : "get" == e ? function(e) {
              return o && !aMe(e) ? void 0 : t(this, 0 === e ? 0 : e)
            }
            : "has" == e ? function(e) {
                return !(o && !aMe(e)) && t(this, 0 === e ? 0 : e)
              }
              : function(e, n) {
                return t(this, 0 === e ? 0 : e, n),
                  this
              }
    )
  };
  if (Xje(e, !HNe(i) || !(o || s.forEach && !xNe((function() {
      (new i).entries().next()
    }
  )))))
    l = n.getConstructor(t, e, r, a),
      ZVe.enable();
  else if (Xje(e, !0)) {
    var d = new l
      , f = d[a](o ? {} : -0, 1) != d
      , p = xNe((function() {
        d.has(1)
      }
    ))
      , h = function(e, t) {
      if (!vUe)
        return !1;
      var n = !1;
      try {
        var r = {};
        r[hUe] = function() {
          return {
            next: function() {
              return {
                done: n = !0
              }
            }
          }
        }
          ,
          new i(r)
      } catch (o) {}
      return n
    }()
      , v = !o && xNe((function() {
        for (var e = new i, t = 5; t--; )
          e[a](t, t);
        return !e.has(-0)
      }
    ));
    h || ((l = t((function(e, t) {
        pUe(e, s);
        var n, o, u, c, d, f = (n = new i,
          o = e,
          u = l,
        vVe && HNe(c = o.constructor) && c !== u && aMe(d = c.prototype) && d !== u.prototype && vVe(n, d),
          n);
        return null != t && dUe(t, f[a], {
          that: f,
          AS_ENTRIES: r
        }),
          f
      }
    ))).prototype = s,
      s.constructor = l),
    (p || v) && (c("delete"),
      c("has"),
    r && c("get")),
    (v || f) && c(a),
    o && s.clear && delete s.clear
  }
  return u[e] = l,
    Jje({
      global: !0,
      forced: l != i
    }, u),
    cVe(l, e),
  o || n.setStrong(l, e, r),
    l
}("WeakMap", GUe, zUe);
if (hje && WUe) {
  HUe = zUe.getConstructor(GUe, "WeakMap", !0),
    ZVe.enable();
  var YUe = qUe.prototype
    , XUe = wNe(YUe.delete)
    , QUe = wNe(YUe.has)
    , JUe = wNe(YUe.get)
    , ZUe = wNe(YUe.set);
  HVe(YUe, {
    delete: function(e) {
      if (aMe(e) && !QVe(e)) {
        var t = KUe(this);
        return t.frozen || (t.frozen = new HUe),
        XUe(this, e) || t.frozen.delete(e)
      }
      return XUe(this, e)
    },
    has: function(e) {
      if (aMe(e) && !QVe(e)) {
        var t = KUe(this);
        return t.frozen || (t.frozen = new HUe),
        QUe(this, e) || t.frozen.has(e)
      }
      return QUe(this, e)
    },
    get: function(e) {
      if (aMe(e) && !QVe(e)) {
        var t = KUe(this);
        return t.frozen || (t.frozen = new HUe),
          QUe(this, e) ? JUe(this, e) : t.frozen.get(e)
      }
      return JUe(this, e)
    },
    set: function(e, t) {
      if (aMe(e) && !QVe(e)) {
        var n = KUe(this);
        n.frozen || (n.frozen = new HUe),
          QUe(this, e) ? ZUe(this, e, t) : n.frozen.set(e, t)
      } else
        ZUe(this, e, t);
      return this
    }
  })
}
var e$e = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}
  , t$e = fMe("span").classList
  , n$e = t$e && t$e.constructor && t$e.constructor.prototype
  , r$e = n$e === Object.prototype ? void 0 : n$e
  , o$e = oMe("iterator")
  , a$e = oMe("toStringTag")
  , i$e = CVe.values
  , s$e = function(e, t) {
  if (e) {
    if (e[o$e] !== i$e)
      try {
        gje(e, o$e, i$e)
      } catch (r) {
        e[o$e] = i$e
      }
    if (e[a$e] || gje(e, a$e, t),
      e$e[t])
      for (var n in CVe)
        if (e[n] !== CVe[n])
          try {
            gje(e, n, CVe[n])
          } catch (r) {
            e[n] = CVe[n]
          }
  }
};
for (var l$e in e$e)
  s$e(vNe[l$e] && vNe[l$e].prototype, l$e);
s$e(r$e, "DOMTokenList");
var u$e = new WeakMap
  , c$e = {
  type: "list-item",
  renderElem: function(e, t, n) {
    u$e.set(e, n);
    var r = e
      , o = r.level
      , a = void 0 === o ? 0 : o
      , i = r.ordered
      , s = {
      margin: "5px 0 5px " + 20 * a + "px"
    }
      , l = "";
    void 0 !== i && i ? l = function(e, t) {
      var n = t
        , r = n.type
        , o = n.level
        , a = void 0 === o ? 0 : o
        , i = n.ordered
        , s = void 0 !== i && i;
      if (!s)
        return -1;
      var l = 1
        , u = t
        , c = qme.findPath(e, u);
      if (0 === c[0])
        return 1;
      for (; c[0] > 0; ) {
        var d = one.previous(c)
          , f = Yte.node(e, d);
        if (null == f)
          break;
        var p = f[0]
          , h = p.level
          , v = void 0 === h ? 0 : h
          , g = p.type
          , m = p.ordered;
        if (g !== r)
          break;
        if (v < a)
          break;
        if (v === a) {
          if (m !== s)
            break;
          l++
        }
        u = p,
          c = d
      }
      return l
    }(n, e) + "." : l = function(e) {
      void 0 === e && (e = 0);
      var t = "";
      switch (e) {
        case 0:
          t = "•";
          break;
        case 1:
          t = "◦";
          break;
        default:
          t = "▪"
      }
      return t
    }(a);
    return $ae("div", {
      style: s
    }, $ae("span", {
      contentEditable: !1,
      style: {
        marginRight: "0.5em",
        color: function(e) {
          var t, n = e.children || [], r = n.length;
          if (0 === r)
            return "";
          for (var o = 0; o < r && !t; o++) {
            var a = n[o];
            bne.isText(a) && (t = a)
          }
          return null == t ? "" : t.color || ""
        }(e)
      },
      "data-w-e-reserve": !0
    }, l), $ae("span", null, t))
  }
}
  , d$e = function(e, t) {
  return d$e = Object.setPrototypeOf || {
      __proto__: []
    }instanceof Array && function(e, t) {
      e.__proto__ = t
    }
    || function(e, t) {
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
    }
    ,
    d$e(e, t);
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
};
function f$e(e, t) {
  if ("function" != typeof t && null !== t)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function n() {
    this.constructor = e
  }
  d$e(e, t),
    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype,
      new n)
}
function p$e(e) {
  var t = "function" == typeof Symbol && Symbol.iterator
    , n = t && e[t]
    , r = 0;
  if (n)
    return n.call(e);
  if (e && "number" == typeof e.length)
    return {
      next: function() {
        return e && r >= e.length && (e = void 0),
          {
            value: e && e[r++],
            done: !e
          }
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function h$e(e, t) {
  var n = "function" == typeof Symbol && e[Symbol.iterator];
  if (!n)
    return e;
  var r, o, a = n.call(e), i = [];
  try {
    for (; (void 0 === t || t-- > 0) && !(r = a.next()).done; )
      i.push(r.value)
  } catch (s) {
    o = {
      error: s
    }
  } finally {
    try {
      r && !r.done && (n = a.return) && n.call(a)
    } finally {
      if (o)
        throw o.error
    }
  }
  return i
}
function v$e(e) {
  return Yte.nodes(e, {
    at: e.selection || void 0,
    match: function(t) {
      return 1 === qme.findPath(e, t).length
    }
  })
}
var g$e = UMe.includes;
Jje({
  target: "Array",
  proto: !0
}, {
  includes: function(e) {
    return g$e(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
}),
  ije("includes");
var m$e, y$e, b$e = function() {
  var e = lMe(this)
    , t = "";
  return e.global && (t += "g"),
  e.ignoreCase && (t += "i"),
  e.multiline && (t += "m"),
  e.dotAll && (t += "s"),
  e.unicode && (t += "u"),
  e.sticky && (t += "y"),
    t
}, w$e = vNe.RegExp, x$e = xNe((function() {
    var e = w$e("a", "y");
    return e.lastIndex = 2,
    null != e.exec("abcd")
  }
)), S$e = x$e || xNe((function() {
    return !w$e("a", "y").sticky
  }
)), E$e = {
  BROKEN_CARET: x$e || xNe((function() {
      var e = w$e("^r", "gy");
      return e.lastIndex = 2,
      null != e.exec("str")
    }
  )),
  MISSED_STICKY: S$e,
  UNSUPPORTED_Y: x$e
}, A$e = vNe.RegExp, C$e = xNe((function() {
    var e = A$e(".", "s");
    return !(e.dotAll && e.exec("\n") && "s" === e.flags)
  }
)), k$e = vNe.RegExp, T$e = xNe((function() {
    var e = k$e("(?<a>b)", "g");
    return "b" !== e.exec("b").groups.a || "bc" !== "b".replace(e, "$<a>c")
  }
)), D$e = Tje.get, O$e = PNe("native-string-replace", String.prototype.replace), _$e = RegExp.prototype.exec, R$e = _$e, L$e = wNe("".charAt), I$e = wNe("".indexOf), P$e = wNe("".replace), F$e = wNe("".slice), B$e = (y$e = /b*/g,
  vMe(_$e, m$e = /a/, "a"),
  vMe(_$e, y$e, "a"),
0 !== m$e.lastIndex || 0 !== y$e.lastIndex), N$e = E$e.BROKEN_CARET, M$e = void 0 !== /()??/.exec("")[1];
(B$e || M$e || N$e || C$e || T$e) && (R$e = function(e) {
    var t, n, r, o, a, i, s, l = this, u = D$e(l), c = PVe(e), d = u.raw;
    if (d)
      return d.lastIndex = l.lastIndex,
        t = vMe(R$e, d, c),
        l.lastIndex = d.lastIndex,
        t;
    var f = u.groups
      , p = N$e && l.sticky
      , h = vMe(b$e, l)
      , v = l.source
      , g = 0
      , m = c;
    if (p && (h = P$e(h, "y", ""),
    -1 === I$e(h, "g") && (h += "g"),
      m = F$e(c, l.lastIndex),
    l.lastIndex > 0 && (!l.multiline || l.multiline && "\n" !== L$e(c, l.lastIndex - 1)) && (v = "(?: " + v + ")",
      m = " " + m,
      g++),
      n = new RegExp("^(?:" + v + ")",h)),
    M$e && (n = new RegExp("^" + v + "$(?!\\s)",h)),
    B$e && (r = l.lastIndex),
      o = vMe(_$e, p ? n : l, m),
      p ? o ? (o.input = F$e(o.input, g),
        o[0] = F$e(o[0], g),
        o.index = l.lastIndex,
        l.lastIndex += o[0].length) : l.lastIndex = 0 : B$e && o && (l.lastIndex = l.global ? o.index + o[0].length : r),
    M$e && o && o.length > 1 && vMe(O$e, o[0], n, (function() {
        for (a = 1; a < arguments.length - 2; a++)
          void 0 === arguments[a] && (o[a] = void 0)
      }
    )),
    o && f)
      for (o.groups = i = rje(null),
             a = 0; a < f.length; a++)
        i[(s = f[a])[0]] = o[s[1]];
    return o
  }
);
var j$e = R$e;
Jje({
  target: "RegExp",
  proto: !0,
  forced: /./.exec !== j$e
}, {
  exec: j$e
});
var V$e = function() {
  function e() {
    this.type = "list-item",
      this.tag = "button"
  }
  return e.prototype.getListNode = function(e) {
    var t = this.type;
    return qme.getSelectedNodeByType(e, t)
  }
    ,
    e.prototype.getValue = function(e) {
      return ""
    }
    ,
    e.prototype.isActive = function(e) {
      var t = this.getListNode(e);
      if (null == t)
        return !1;
      var n = t.ordered;
      return (void 0 !== n && n) === this.ordered
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || !!qme.getSelectedElems(e).some((function(t) {
          if (Yte.isVoid(e, t) && Yte.isBlock(e, t))
            return !0;
          var n = t.type;
          return !!["pre", "code", "table"].includes(n) || void 0
        }
      ))
    }
    ,
    e.prototype.exec = function(e, t) {
      this.isActive(e) ? Nne.setNodes(e, {
        type: "paragraph",
        ordered: void 0,
        level: void 0
      }) : Nne.setNodes(e, {
        type: "list-item",
        ordered: this.ordered,
        indent: void 0
      })
    }
    ,
    e
}()
  , U$e = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.ordered = !1,
      t.title = SEe("listModule.unOrderedList"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M384 64h640v128H384V64z m0 384h640v128H384v-128z m0 384h640v128H384v-128zM0 128a128 128 0 1 1 256 0 128 128 0 0 1-256 0z m0 384a128 128 0 1 1 256 0 128 128 0 0 1-256 0z m0 384a128 128 0 1 1 256 0 128 128 0 0 1-256 0z"></path></svg>',
      t
  }
  return f$e(t, e),
    t
}(V$e)
  , $$e = function(e) {
  function t() {
    var t = null !== e && e.apply(this, arguments) || this;
    return t.ordered = !0,
      t.title = SEe("listModule.orderedList"),
      t.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M384 832h640v128H384z m0-384h640v128H384z m0-384h640v128H384zM192 0v256H128V64H64V0zM128 526.016v50.016h128v64H64v-146.016l128-60V384H64v-64h192v146.016zM256 704v320H64v-64h128v-64H64v-64h128v-64H64v-64z"></path></svg>',
      t
  }
  return f$e(t, e),
    t
}(V$e)
  , H$e = {
  key: "bulletedList",
  factory: function() {
    return new U$e
  }
}
  , z$e = {
  key: "numberedList",
  factory: function() {
    return new $$e
  }
}
  , K$e = []
  , W$e = {
  type: "list-item",
  elemToHtml: function(e, t) {
    var n = ""
      , r = ""
      , o = e.ordered
      , a = void 0 !== o && o ? "ol" : "ul"
      , i = function(e) {
      var t = u$e.get(e);
      if (null == t)
        return 0;
      var n = e
        , r = n.type
        , o = n.ordered
        , a = void 0 !== o && o
        , i = n.level
        , s = void 0 === i ? 0 : i
        , l = qme.findPath(t, e);
      if (0 === l[0])
        return s + 1;
      var u = one.previous(l)
        , c = Yte.node(t, u);
      if (!c)
        return 0;
      var d = h$e(c, 1)[0];
      if (qme.getNodeType(d) !== r)
        return s + 1;
      var f = d
        , p = f.ordered
        , h = void 0 !== p && p
        , v = f.level
        , g = void 0 === v ? 0 : v;
      return g < s ? s - g : g > s ? 0 : g === s ? h === a ? 0 : 1 : 0
    }(e);
    if (i > 0)
      for (var s = 0; s < i; s++)
        n += "<" + a + ">",
          K$e.push(a);
    var l = function(e) {
      var t = u$e.get(e);
      if (null == t)
        return 0;
      var n = e
        , r = n.type
        , o = n.ordered
        , a = void 0 !== o && o
        , i = n.level
        , s = void 0 === i ? 0 : i
        , l = qme.findPath(t, e);
      if (l[0] === t.children.length - 1)
        return s + 1;
      var u = one.next(l)
        , c = Yte.node(t, u);
      if (!c)
        return 0;
      var d = h$e(c, 1)[0];
      if (qme.getNodeType(d) !== r)
        return s + 1;
      var f = d
        , p = f.ordered
        , h = void 0 !== p && p
        , v = f.level
        , g = void 0 === v ? 0 : v;
      return g < s ? s - g : g > s ? 0 : g === s ? h === a ? 0 : 1 : 0
    }(e);
    if (l > 0)
      for (s = 0; s < l; s++)
        r += "</" + K$e.pop() + ">";
    return {
      html: "<li>" + t + "</li>",
      prefix: n,
      suffix: r
    }
  }
}
  , G$e = oMe("species")
  , q$e = LUe.filter
  , Y$e = QNe >= 51 || !xNe((function() {
    var e = [];
    return (e.constructor = {})[G$e] = function() {
      return {
        foo: 1
      }
    }
      ,
    1 !== e.filter(Boolean).foo
  }
));
Jje({
  target: "Array",
  proto: !0,
  forced: !Y$e
}, {
  filter: function(e) {
    return q$e(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var X$e = Function.prototype
  , Q$e = X$e.apply
  , J$e = X$e.bind
  , Z$e = X$e.call
  , eHe = "object" == typeof Reflect && Reflect.apply || (J$e ? Z$e.bind(Q$e) : function() {
    return Z$e.apply(Q$e, arguments)
  }
)
  , tHe = (oMe("species"),
  RegExp.prototype)
  , nHe = jVe.charAt
  , rHe = function(e, t, n) {
  return t + (n ? nHe(e, t).length : 1)
}
  , oHe = Math.floor
  , aHe = wNe("".charAt)
  , iHe = wNe("".replace)
  , sHe = wNe("".slice)
  , lHe = /\$([$&'`]|\d{1,2}|<[^>]*>)/g
  , uHe = /\$([$&'`]|\d{1,2})/g
  , cHe = function(e, t, n, r, o, a) {
  var i = n + e.length
    , s = r.length
    , l = uHe;
  return void 0 !== o && (o = BNe(o),
    l = lHe),
    iHe(a, l, (function(a, l) {
        var u;
        switch (aHe(l, 0)) {
          case "$":
            return "$";
          case "&":
            return e;
          case "`":
            return sHe(t, 0, n);
          case "'":
            return sHe(t, i);
          case "<":
            u = o[sHe(l, 1, -1)];
            break;
          default:
            var c = +l;
            if (0 === c)
              return a;
            if (c > s) {
              var d = oHe(c / 10);
              return 0 === d ? a : d <= s ? void 0 === r[d - 1] ? aHe(l, 1) : r[d - 1] + aHe(l, 1) : a
            }
            u = r[c - 1]
        }
        return void 0 === u ? "" : u
      }
    ))
}
  , dHe = vNe.TypeError
  , fHe = function(e, t) {
  var n = e.exec;
  if (HNe(n)) {
    var r = vMe(n, e, t);
    return null !== r && lMe(r),
      r
  }
  if ("RegExp" === ANe(e))
    return vMe(j$e, e, t);
  throw dHe("RegExp#exec called on incompatible receiver")
}
  , pHe = oMe("replace")
  , hHe = Math.max
  , vHe = Math.min
  , gHe = wNe([].concat)
  , mHe = wNe([].push)
  , yHe = wNe("".indexOf)
  , bHe = wNe("".slice)
  , wHe = "$0" === "a".replace(/./, "$0")
  , xHe = !!/./[pHe] && "" === /./[pHe]("a", "$0");
!function(e, t, n, r) {
  var o, a, i = oMe(e), s = !xNe((function() {
      var t = {};
      return t[i] = function() {
        return 7
      }
        ,
      7 != ""[e](t)
    }
  )), l = s && !xNe((function() {
      var e = !1
        , t = /a/;
      return t.exec = function() {
        return e = !0,
          null
      }
        ,
        t[i](""),
        !e
    }
  ));
  if (!s || !l || n) {
    var u = wNe(/./[i])
      , c = (o = ""[e],
      a = xHe ? "$" : "$0",
      [function(e, t) {
        var n = ONe(this)
          , r = null == e ? void 0 : EMe(e, pHe);
        return r ? vMe(r, e, n, t) : vMe(o, PVe(n), e, t)
      }
        , function(e, t) {
        var n = lMe(this)
          , r = PVe(e);
        if ("string" == typeof t && -1 === yHe(t, a) && -1 === yHe(t, "$<")) {
          var i = function(e, t, n, r, o) {
            var a = wNe(e)
              , i = t.exec;
            return i === j$e || i === tHe.exec ? s && !o ? {
              done: !0,
              value: u(t, n, r)
            } : {
              done: !0,
              value: a(n, t, r)
            } : {
              done: !1
            }
          }(o, n, r, t);
          if (i.done)
            return i.value
        }
        var l = HNe(t);
        l || (t = PVe(t));
        var c = n.global;
        if (c) {
          var d = n.unicode;
          n.lastIndex = 0
        }
        for (var f = []; ; ) {
          var p = fHe(n, r);
          if (null === p)
            break;
          if (mHe(f, p),
            !c)
            break;
          "" === PVe(p[0]) && (n.lastIndex = rHe(r, MMe(n.lastIndex), d))
        }
        for (var h, v = "", g = 0, m = 0; m < f.length; m++) {
          for (var y = PVe((p = f[m])[0]), b = hHe(vHe(IMe(p.index), r.length), 0), w = [], x = 1; x < p.length; x++)
            mHe(w, void 0 === (h = p[x]) ? h : String(h));
          var S = p.groups;
          if (l) {
            var E = gHe([y], w, b, r);
            void 0 !== S && mHe(E, S);
            var A = PVe(eHe(t, void 0, E))
          } else
            A = cHe(y, r, b, w, S, t);
          b >= g && (v += bHe(r, g, b) + A,
            g = b + y.length)
        }
        return v + bHe(r, g)
      }
      ]);
    Nje(String.prototype, e, c[0]),
      Nje(tHe, i, c[1])
  }
}("replace", 0, !!xNe((function() {
    var e = /./;
    return e.exec = function() {
      var e = [];
      return e.groups = {
        a: "7"
      },
        e
    }
      ,
    "7" !== "".replace(e, "$<a>")
  }
)) || !wHe || xHe);
var SHe = vNe.TypeError
  , EHe = function(e, t, n, r, o, a, i, s) {
  for (var l, u, c = o, d = 0, f = !!i && tUe(i, s); d < r; ) {
    if (d in n) {
      if (l = f ? f(n[d], d, t) : n[d],
      a > 0 && yUe(l))
        u = jMe(l),
          c = EHe(e, t, l, u, c, a - 1) - 1;
      else {
        if (c >= 9007199254740991)
          throw SHe("Exceed the acceptable array length");
        e[c] = l
      }
      c++
    }
    d++
  }
  return c
}
  , AHe = EHe;
function CHe(e) {
  return e.length ? e[0].tagName.toLowerCase() : ""
}
Jje({
  target: "Array",
  proto: !0
}, {
  flat: function() {
    var e = arguments.length ? arguments[0] : void 0
      , t = BNe(this)
      , n = jMe(t)
      , r = OUe(t, 0);
    return r.length = AHe(r, t, t, n, 0, void 0 === e ? 1 : IMe(e)),
      r
  }
}),
  ije("flat"),
  Jje({
    global: !0
  }, {
    globalThis: vNe
  }),
yoe && (Qre.fn.append = yoe),
toe && (Qre.fn.attr = toe),
woe && (Qre.fn.parent = woe);
var kHe = {
  renderElems: [c$e],
  editorPlugin: function(e) {
    var t = e.deleteBackward
      , n = e.handleTab
      , r = e.normalizeNode
      , o = e;
    return o.deleteBackward = function(e) {
      var n = o.selection;
      if (null != n)
        if (fne.isExpanded(n))
          t(e);
        else {
          var r = qme.getSelectedNodeByType(o, "list-item");
          if (null != r)
            if (0 !== n.focus.offset)
              t(e);
            else {
              var a = r.level
                , i = void 0 === a ? 0 : a;
              i > 0 ? Nne.setNodes(o, {
                level: i - 1
              }) : Nne.setNodes(o, {
                type: "paragraph",
                ordered: void 0,
                level: void 0
              })
            }
          else
            t(e)
        }
      else
        t(e)
    }
      ,
      o.handleTab = function() {
        var e, t, r, a, i = o.selection;
        if (null != i) {
          if (fne.isCollapsed(i)) {
            var s = qme.getSelectedNodeByType(o, "list-item");
            if (null == s)
              return void n();
            if (0 === i.focus.offset) {
              var l = s.level
                , u = void 0 === l ? 0 : l;
              return void Nne.setNodes(o, {
                level: u + 1
              })
            }
          }
          if (fne.isExpanded(i)) {
            var c = 0
              , d = !1;
            try {
              for (var f = p$e(v$e(o)), p = f.next(); !p.done; p = f.next()) {
                var h = h$e(p.value, 1)[0];
                "list-item" === qme.getNodeType(h) ? c++ : d = !0
              }
            } catch (w) {
              e = {
                error: w
              }
            } finally {
              try {
                p && !p.done && (t = f.return) && t.call(f)
              } finally {
                if (e)
                  throw e.error
              }
            }
            if (d || c <= 1)
              return void n();
            try {
              for (var v = p$e(v$e(o)), g = v.next(); !g.done; g = v.next()) {
                var m = h$e(g.value, 2)
                  , y = (h = m[0],
                  m[1])
                  , b = h.level;
                u = void 0 === b ? 0 : b,
                  Nne.setNodes(o, {
                    level: u + 1
                  }, {
                    at: y
                  })
              }
            } catch (x) {
              r = {
                error: x
              }
            } finally {
              try {
                g && !g.done && (a = v.return) && a.call(v)
              } finally {
                if (r)
                  throw r.error
              }
            }
          } else
            n()
        } else
          n()
      }
      ,
      o.normalizeNode = function(e) {
        var t = h$e(e, 2)
          , n = t[0]
          , a = t[1]
          , i = qme.getNodeType(n);
        return "bulleted-list" !== i && "numbered-list" !== i || Nne.unwrapNodes(o, {
          at: a
        }),
          r([n, a])
      }
      ,
      o
  },
  menus: [H$e, z$e],
  elemsToHtml: [W$e],
  parseElemsHtml: [{
    selector: "ul:not([data-w-e-type]),ol:not([data-w-e-type])",
    parseElemHtml: function(e, t, n) {
      return t.flat(1 / 0)
    }
  }, {
    selector: "li:not([data-w-e-type])",
    parseElemHtml: function(e, t, n) {
      var r = Qre(e);
      0 === (t = t.filter((function(e) {
          return !!bne.isText(e) || !!n.isInline(e)
        }
      ))).length && (t = [{
        text: r.text().replace(/\s+/gm, " ")
      }]);
      var o = "ol" === CHe(r.parent())
        , a = function(e) {
        for (var t = 0, n = e.parent(), r = CHe(n); "ul" === r || "ol" === r; )
          r = CHe(n = n.parent()),
            t++;
        return t - 1
      }(r);
      return {
        type: "list-item",
        ordered: o,
        level: a,
        children: t
      }
    }
  }]
}
  , THe = jZ((function(e, t) {
    var n = "__lodash_hash_undefined__"
      , r = 9007199254740991
      , o = "[object Arguments]"
      , a = "[object Array]"
      , i = "[object Boolean]"
      , s = "[object Date]"
      , l = "[object Error]"
      , u = "[object Function]"
      , c = "[object Map]"
      , d = "[object Number]"
      , f = "[object Object]"
      , p = "[object Promise]"
      , h = "[object RegExp]"
      , v = "[object Set]"
      , g = "[object String]"
      , m = "[object WeakMap]"
      , y = "[object ArrayBuffer]"
      , b = "[object DataView]"
      , w = /^\[object .+?Constructor\]$/
      , x = /^(?:0|[1-9]\d*)$/
      , S = {};
    S["[object Float32Array]"] = S["[object Float64Array]"] = S["[object Int8Array]"] = S["[object Int16Array]"] = S["[object Int32Array]"] = S["[object Uint8Array]"] = S["[object Uint8ClampedArray]"] = S["[object Uint16Array]"] = S["[object Uint32Array]"] = !0,
      S[o] = S[a] = S[y] = S[i] = S[b] = S[s] = S[l] = S[u] = S[c] = S[d] = S[f] = S[h] = S[v] = S[g] = S[m] = !1;
    var E = "object" == typeof MZ && MZ && MZ.Object === Object && MZ
      , A = "object" == typeof self && self && self.Object === Object && self
      , C = E || A || Function("return this")()
      , k = t && !t.nodeType && t
      , T = k && e && !e.nodeType && e
      , D = T && T.exports === k
      , O = D && E.process
      , _ = function() {
      try {
        return O && O.binding && O.binding("util")
      } catch (Y_) {}
    }()
      , R = _ && _.isTypedArray;
    function L(e, t) {
      for (var n = -1, r = null == e ? 0 : e.length; ++n < r; )
        if (t(e[n], n, e))
          return !0;
      return !1
    }
    function I(e) {
      var t = -1
        , n = Array(e.size);
      return e.forEach((function(e, r) {
          n[++t] = [r, e]
        }
      )),
        n
    }
    function P(e) {
      var t = -1
        , n = Array(e.size);
      return e.forEach((function(e) {
          n[++t] = e
        }
      )),
        n
    }
    var F = Array.prototype
      , B = Function.prototype
      , N = Object.prototype
      , M = C["__core-js_shared__"]
      , j = B.toString
      , V = N.hasOwnProperty
      , U = function() {
      var e = /[^.]+$/.exec(M && M.keys && M.keys.IE_PROTO || "");
      return e ? "Symbol(src)_1." + e : ""
    }()
      , $ = N.toString
      , H = RegExp("^" + j.call(V).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$")
      , z = D ? C.Buffer : void 0
      , K = C.Symbol
      , W = C.Uint8Array
      , G = N.propertyIsEnumerable
      , q = F.splice
      , Y = K ? K.toStringTag : void 0
      , X = Object.getOwnPropertySymbols
      , Q = z ? z.isBuffer : void 0
      , J = function(e, t) {
      return function(n) {
        return e(t(n))
      }
    }(Object.keys, Object)
      , Z = Ae(C, "DataView")
      , ee = Ae(C, "Map")
      , te = Ae(C, "Promise")
      , ne = Ae(C, "Set")
      , re = Ae(C, "WeakMap")
      , oe = Ae(Object, "create")
      , ae = De(Z)
      , ie = De(ee)
      , se = De(te)
      , le = De(ne)
      , ue = De(re)
      , ce = K ? K.prototype : void 0
      , de = ce ? ce.valueOf : void 0;
    function fe(e) {
      var t = -1
        , n = null == e ? 0 : e.length;
      for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
      }
    }
    function pe(e) {
      var t = -1
        , n = null == e ? 0 : e.length;
      for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
      }
    }
    function he(e) {
      var t = -1
        , n = null == e ? 0 : e.length;
      for (this.clear(); ++t < n; ) {
        var r = e[t];
        this.set(r[0], r[1])
      }
    }
    function ve(e) {
      var t = -1
        , n = null == e ? 0 : e.length;
      for (this.__data__ = new he; ++t < n; )
        this.add(e[t])
    }
    function ge(e) {
      var t = this.__data__ = new pe(e);
      this.size = t.size
    }
    function me(e, t) {
      for (var n = e.length; n--; )
        if (Oe(e[n][0], t))
          return n;
      return -1
    }
    function ye(e) {
      return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Y && Y in Object(e) ? function(e) {
        var t = V.call(e, Y)
          , n = e[Y];
        try {
          e[Y] = void 0;
          var r = !0
        } catch (a) {}
        var o = $.call(e);
        return r && (t ? e[Y] = n : delete e[Y]),
          o
      }(e) : (t = e,
        $.call(t));
      var t
    }
    function be(e) {
      return Be(e) && ye(e) == o
    }
    function we(e, t, n, r, u) {
      return e === t || (null == e || null == t || !Be(e) && !Be(t) ? e != e && t != t : function(e, t, n, r, u, p) {
        var m = Re(e)
          , w = Re(t)
          , x = m ? a : ke(e)
          , S = w ? a : ke(t)
          , E = (x = x == o ? f : x) == f
          , A = (S = S == o ? f : S) == f
          , C = x == S;
        if (C && Le(e)) {
          if (!Le(t))
            return !1;
          m = !0,
            E = !1
        }
        if (C && !E)
          return p || (p = new ge),
            m || Ne(e) ? xe(e, t, n, r, u, p) : function(e, t, n, r, o, a, u) {
              switch (n) {
                case b:
                  if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
                    return !1;
                  e = e.buffer,
                    t = t.buffer;
                case y:
                  return !(e.byteLength != t.byteLength || !a(new W(e), new W(t)));
                case i:
                case s:
                case d:
                  return Oe(+e, +t);
                case l:
                  return e.name == t.name && e.message == t.message;
                case h:
                case g:
                  return e == t + "";
                case c:
                  var f = I;
                case v:
                  var p = 1 & r;
                  if (f || (f = P),
                  e.size != t.size && !p)
                    return !1;
                  var m = u.get(e);
                  if (m)
                    return m == t;
                  r |= 2,
                    u.set(e, t);
                  var w = xe(f(e), f(t), r, o, a, u);
                  return u.delete(e),
                    w;
                case "[object Symbol]":
                  if (de)
                    return de.call(e) == de.call(t)
              }
              return !1
            }(e, t, x, n, r, u, p);
        if (!(1 & n)) {
          var k = E && V.call(e, "__wrapped__")
            , T = A && V.call(t, "__wrapped__");
          if (k || T) {
            var D = k ? e.value() : e
              , O = T ? t.value() : t;
            return p || (p = new ge),
              u(D, O, n, r, p)
          }
        }
        return !!C && (p || (p = new ge),
          function(e, t, n, r, o, a) {
            var i = 1 & n
              , s = Se(e)
              , l = s.length;
            if (l != Se(t).length && !i)
              return !1;
            for (var u = l; u--; ) {
              var c = s[u];
              if (!(i ? c in t : V.call(t, c)))
                return !1
            }
            var d = a.get(e);
            if (d && a.get(t))
              return d == t;
            var f = !0;
            a.set(e, t),
              a.set(t, e);
            for (var p = i; ++u < l; ) {
              var h = e[c = s[u]]
                , v = t[c];
              if (r)
                var g = i ? r(v, h, c, t, e, a) : r(h, v, c, e, t, a);
              if (!(void 0 === g ? h === v || o(h, v, n, r, a) : g)) {
                f = !1;
                break
              }
              p || (p = "constructor" == c)
            }
            if (f && !p) {
              var m = e.constructor
                , y = t.constructor;
              m == y || !("constructor"in e) || !("constructor"in t) || "function" == typeof m && m instanceof m && "function" == typeof y && y instanceof y || (f = !1)
            }
            return a.delete(e),
              a.delete(t),
              f
          }(e, t, n, r, u, p))
      }(e, t, n, r, we, u))
    }
    function xe(e, t, n, r, o, a) {
      var i = 1 & n
        , s = e.length
        , l = t.length;
      if (s != l && !(i && l > s))
        return !1;
      var u = a.get(e);
      if (u && a.get(t))
        return u == t;
      var c = -1
        , d = !0
        , f = 2 & n ? new ve : void 0;
      for (a.set(e, t),
             a.set(t, e); ++c < s; ) {
        var p = e[c]
          , h = t[c];
        if (r)
          var v = i ? r(h, p, c, t, e, a) : r(p, h, c, e, t, a);
        if (void 0 !== v) {
          if (v)
            continue;
          d = !1;
          break
        }
        if (f) {
          if (!L(t, (function(e, t) {
              if (i = t,
              !f.has(i) && (p === e || o(p, e, n, r, a)))
                return f.push(t);
              var i
            }
          ))) {
            d = !1;
            break
          }
        } else if (p !== h && !o(p, h, n, r, a)) {
          d = !1;
          break
        }
      }
      return a.delete(e),
        a.delete(t),
        d
    }
    function Se(e) {
      return n = Ce,
        r = Me(t = e),
        Re(t) ? r : function(e, t) {
          for (var n = -1, r = t.length, o = e.length; ++n < r; )
            e[o + n] = t[n];
          return e
        }(r, n(t));
      var t, n, r
    }
    function Ee(e, t) {
      var n, r, o = e.__data__;
      return ("string" == (r = typeof (n = t)) || "number" == r || "symbol" == r || "boolean" == r ? "__proto__" !== n : null === n) ? o["string" == typeof t ? "string" : "hash"] : o.map
    }
    function Ae(e, t) {
      var n, r, o = (r = t,
        null == (n = e) ? void 0 : n[r]);
      return function(e) {
        return !(!Fe(e) || (t = e,
        U && U in t)) && (Ie(e) ? H : w).test(De(e));
        var t
      }(o) ? o : void 0
    }
    fe.prototype.clear = function() {
      this.__data__ = oe ? oe(null) : {},
        this.size = 0
    }
      ,
      fe.prototype.delete = function(e) {
        var t = this.has(e) && delete this.__data__[e];
        return this.size -= t ? 1 : 0,
          t
      }
      ,
      fe.prototype.get = function(e) {
        var t = this.__data__;
        if (oe) {
          var r = t[e];
          return r === n ? void 0 : r
        }
        return V.call(t, e) ? t[e] : void 0
      }
      ,
      fe.prototype.has = function(e) {
        var t = this.__data__;
        return oe ? void 0 !== t[e] : V.call(t, e)
      }
      ,
      fe.prototype.set = function(e, t) {
        var r = this.__data__;
        return this.size += this.has(e) ? 0 : 1,
          r[e] = oe && void 0 === t ? n : t,
          this
      }
      ,
      pe.prototype.clear = function() {
        this.__data__ = [],
          this.size = 0
      }
      ,
      pe.prototype.delete = function(e) {
        var t = this.__data__
          , n = me(t, e);
        return !(n < 0 || (n == t.length - 1 ? t.pop() : q.call(t, n, 1),
          --this.size,
          0))
      }
      ,
      pe.prototype.get = function(e) {
        var t = this.__data__
          , n = me(t, e);
        return n < 0 ? void 0 : t[n][1]
      }
      ,
      pe.prototype.has = function(e) {
        return me(this.__data__, e) > -1
      }
      ,
      pe.prototype.set = function(e, t) {
        var n = this.__data__
          , r = me(n, e);
        return r < 0 ? (++this.size,
          n.push([e, t])) : n[r][1] = t,
          this
      }
      ,
      he.prototype.clear = function() {
        this.size = 0,
          this.__data__ = {
            hash: new fe,
            map: new (ee || pe),
            string: new fe
          }
      }
      ,
      he.prototype.delete = function(e) {
        var t = Ee(this, e).delete(e);
        return this.size -= t ? 1 : 0,
          t
      }
      ,
      he.prototype.get = function(e) {
        return Ee(this, e).get(e)
      }
      ,
      he.prototype.has = function(e) {
        return Ee(this, e).has(e)
      }
      ,
      he.prototype.set = function(e, t) {
        var n = Ee(this, e)
          , r = n.size;
        return n.set(e, t),
          this.size += n.size == r ? 0 : 1,
          this
      }
      ,
      ve.prototype.add = ve.prototype.push = function(e) {
        return this.__data__.set(e, n),
          this
      }
      ,
      ve.prototype.has = function(e) {
        return this.__data__.has(e)
      }
      ,
      ge.prototype.clear = function() {
        this.__data__ = new pe,
          this.size = 0
      }
      ,
      ge.prototype.delete = function(e) {
        var t = this.__data__
          , n = t.delete(e);
        return this.size = t.size,
          n
      }
      ,
      ge.prototype.get = function(e) {
        return this.__data__.get(e)
      }
      ,
      ge.prototype.has = function(e) {
        return this.__data__.has(e)
      }
      ,
      ge.prototype.set = function(e, t) {
        var n = this.__data__;
        if (n instanceof pe) {
          var r = n.__data__;
          if (!ee || r.length < 199)
            return r.push([e, t]),
              this.size = ++n.size,
              this;
          n = this.__data__ = new he(r)
        }
        return n.set(e, t),
          this.size = n.size,
          this
      }
    ;
    var Ce = X ? function(e) {
        return null == e ? [] : (e = Object(e),
          function(e, t) {
            for (var n = -1, r = null == e ? 0 : e.length, o = 0, a = []; ++n < r; ) {
              var i = e[n];
              t(i) && (a[o++] = i)
            }
            return a
          }(X(e), (function(t) {
              return G.call(e, t)
            }
          )))
      }
      : function() {
        return []
      }
      , ke = ye;
    function Te(e, t) {
      return !!(t = null == t ? r : t) && ("number" == typeof e || x.test(e)) && e > -1 && e % 1 == 0 && e < t
    }
    function De(e) {
      if (null != e) {
        try {
          return j.call(e)
        } catch (t) {}
        try {
          return e + ""
        } catch (t) {}
      }
      return ""
    }
    function Oe(e, t) {
      return e === t || e != e && t != t
    }
    (Z && ke(new Z(new ArrayBuffer(1))) != b || ee && ke(new ee) != c || te && ke(te.resolve()) != p || ne && ke(new ne) != v || re && ke(new re) != m) && (ke = function(e) {
        var t = ye(e)
          , n = t == f ? e.constructor : void 0
          , r = n ? De(n) : "";
        if (r)
          switch (r) {
            case ae:
              return b;
            case ie:
              return c;
            case se:
              return p;
            case le:
              return v;
            case ue:
              return m
          }
        return t
      }
    );
    var _e = be(function() {
        return arguments
      }()) ? be : function(e) {
        return Be(e) && V.call(e, "callee") && !G.call(e, "callee")
      }
      , Re = Array.isArray
      , Le = Q || function() {
        return !1
      }
    ;
    function Ie(e) {
      if (!Fe(e))
        return !1;
      var t = ye(e);
      return t == u || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t
    }
    function Pe(e) {
      return "number" == typeof e && e > -1 && e % 1 == 0 && e <= r
    }
    function Fe(e) {
      var t = typeof e;
      return null != e && ("object" == t || "function" == t)
    }
    function Be(e) {
      return null != e && "object" == typeof e
    }
    var Ne = R ? function(e) {
        return function(t) {
          return e(t)
        }
      }(R) : function(e) {
        return Be(e) && Pe(e.length) && !!S[ye(e)]
      }
    ;
    function Me(e) {
      return null != (t = e) && Pe(t.length) && !Ie(t) ? function(e, t) {
        var n = Re(e)
          , r = !n && _e(e)
          , o = !n && !r && Le(e)
          , a = !n && !r && !o && Ne(e)
          , i = n || r || o || a
          , s = i ? function(e, t) {
          for (var n = -1, r = Array(e); ++n < e; )
            r[n] = t(n);
          return r
        }(e.length, String) : []
          , l = s.length;
        for (var u in e)
          !t && !V.call(e, u) || i && ("length" == u || o && ("offset" == u || "parent" == u) || a && ("buffer" == u || "byteLength" == u || "byteOffset" == u) || Te(u, l)) || s.push(u);
        return s
      }(e) : function(e) {
        if (n = (t = e) && t.constructor,
        t !== ("function" == typeof n && n.prototype || N))
          return J(e);
        var t, n, r = [];
        for (var o in Object(e))
          V.call(e, o) && "constructor" != o && r.push(o);
        return r
      }(e);
      var t
    }
    e.exports = function(e, t) {
      return we(e, t)
    }
  }
));
xEe("en", {
  tableModule: {
    deleteCol: "Delete column",
    deleteRow: "Delete row",
    deleteTable: "Delete table",
    widthAuto: "Width auto",
    insertCol: "Insert column",
    insertRow: "Insert row",
    insertTable: "Insert table",
    header: "Header"
  }
}),
  xEe("zh-CN", {
    tableModule: {
      deleteCol: "删除列",
      deleteRow: "删除行",
      deleteTable: "删除表格",
      widthAuto: "宽度自适应",
      insertCol: "插入列",
      insertRow: "插入行",
      insertTable: "插入表格",
      header: "表头"
    }
  });
var DHe = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function OHe(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports),
    t.exports
}
var _He, RHe, LHe = function(e) {
  return e && e.Math == Math && e
}, IHe = LHe("object" == typeof globalThis && globalThis) || LHe("object" == typeof window && window) || LHe("object" == typeof self && self) || LHe("object" == typeof DHe && DHe) || function() {
  return this
}() || Function("return this")(), PHe = function(e) {
  try {
    return !!e()
  } catch (t) {
    return !0
  }
}, FHe = !PHe((function() {
    return 7 != Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1]
  }
)), BHe = Function.prototype.call, NHe = BHe.bind ? BHe.bind(BHe) : function() {
  return BHe.apply(BHe, arguments)
}
  , MHe = {}.propertyIsEnumerable, jHe = Object.getOwnPropertyDescriptor, VHe = {
  f: jHe && !MHe.call({
    1: 2
  }, 1) ? function(e) {
      var t = jHe(this, e);
      return !!t && t.enumerable
    }
    : MHe
}, UHe = function(e, t) {
  return {
    enumerable: !(1 & e),
    configurable: !(2 & e),
    writable: !(4 & e),
    value: t
  }
}, $He = Function.prototype, HHe = $He.bind, zHe = $He.call, KHe = HHe && HHe.bind(zHe), WHe = HHe ? function(e) {
    return e && KHe(zHe, e)
  }
  : function(e) {
    return e && function() {
      return zHe.apply(e, arguments)
    }
  }
  , GHe = WHe({}.toString), qHe = WHe("".slice), YHe = function(e) {
  return qHe(GHe(e), 8, -1)
}, XHe = IHe.Object, QHe = WHe("".split), JHe = PHe((function() {
    return !XHe("z").propertyIsEnumerable(0)
  }
)) ? function(e) {
    return "String" == YHe(e) ? QHe(e, "") : XHe(e)
  }
  : XHe, ZHe = IHe.TypeError, eze = function(e) {
  if (null == e)
    throw ZHe("Can't call method on " + e);
  return e
}, tze = function(e) {
  return JHe(eze(e))
}, nze = function(e) {
  return "function" == typeof e
}, rze = function(e) {
  return "object" == typeof e ? null !== e : nze(e)
}, oze = function(e, t) {
  return arguments.length < 2 ? function(e) {
    return nze(e) ? e : void 0
  }(IHe[e]) : IHe[e] && IHe[e][t]
}, aze = WHe({}.isPrototypeOf), ize = oze("navigator", "userAgent") || "", sze = IHe.process, lze = IHe.Deno, uze = sze && sze.versions || lze && lze.version, cze = uze && uze.v8;
cze && (RHe = (_He = cze.split("."))[0] > 0 && _He[0] < 4 ? 1 : +(_He[0] + _He[1])),
!RHe && ize && (!(_He = ize.match(/Edge\/(\d+)/)) || _He[1] >= 74) && (_He = ize.match(/Chrome\/(\d+)/)) && (RHe = +_He[1]);
var dze = RHe
  , fze = !!Object.getOwnPropertySymbols && !PHe((function() {
    var e = Symbol();
    return !String(e) || !(Object(e)instanceof Symbol) || !Symbol.sham && dze && dze < 41
  }
))
  , pze = fze && !Symbol.sham && "symbol" == typeof Symbol.iterator
  , hze = IHe.Object
  , vze = pze ? function(e) {
    return "symbol" == typeof e
  }
  : function(e) {
    var t = oze("Symbol");
    return nze(t) && aze(t.prototype, hze(e))
  }
  , gze = IHe.String
  , mze = function(e) {
  try {
    return gze(e)
  } catch (t) {
    return "Object"
  }
}
  , yze = IHe.TypeError
  , bze = function(e) {
  if (nze(e))
    return e;
  throw yze(mze(e) + " is not a function")
}
  , wze = function(e, t) {
  var n = e[t];
  return null == n ? void 0 : bze(n)
}
  , xze = IHe.TypeError
  , Sze = Object.defineProperty
  , Eze = function(e, t) {
  try {
    Sze(IHe, e, {
      value: t,
      configurable: !0,
      writable: !0
    })
  } catch (AEe) {
    IHe[e] = t
  }
  return t
}
  , Aze = IHe["__core-js_shared__"] || Eze("__core-js_shared__", {})
  , Cze = OHe((function(e) {
    (e.exports = function(e, t) {
        return Aze[e] || (Aze[e] = void 0 !== t ? t : {})
      }
    )("versions", []).push({
      version: "3.19.3",
      mode: "global",
      copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
    })
  }
))
  , kze = IHe.Object
  , Tze = function(e) {
  return kze(eze(e))
}
  , Dze = WHe({}.hasOwnProperty)
  , Oze = Object.hasOwn || function(e, t) {
  return Dze(Tze(e), t)
}
  , _ze = 0
  , Rze = Math.random()
  , Lze = WHe(1..toString)
  , Ize = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + Lze(++_ze + Rze, 36)
}
  , Pze = Cze("wks")
  , Fze = IHe.Symbol
  , Bze = Fze && Fze.for
  , Nze = pze ? Fze : Fze && Fze.withoutSetter || Ize
  , Mze = function(e) {
  if (!Oze(Pze, e) || !fze && "string" != typeof Pze[e]) {
    var t = "Symbol." + e;
    fze && Oze(Fze, e) ? Pze[e] = Fze[e] : Pze[e] = pze && Bze ? Bze(t) : Nze(t)
  }
  return Pze[e]
}
  , jze = IHe.TypeError
  , Vze = Mze("toPrimitive")
  , Uze = function(e) {
  var t = function(e, t) {
    if (!rze(e) || vze(e))
      return e;
    var n, r = wze(e, Vze);
    if (r) {
      if (void 0 === t && (t = "default"),
        n = NHe(r, e, t),
      !rze(n) || vze(n))
        return n;
      throw jze("Can't convert object to primitive value")
    }
    return void 0 === t && (t = "number"),
      function(e, t) {
        var n, r;
        if ("string" === t && nze(n = e.toString) && !rze(r = NHe(n, e)))
          return r;
        if (nze(n = e.valueOf) && !rze(r = NHe(n, e)))
          return r;
        if ("string" !== t && nze(n = e.toString) && !rze(r = NHe(n, e)))
          return r;
        throw xze("Can't convert object to primitive value")
      }(e, t)
  }(e, "string");
  return vze(t) ? t : t + ""
}
  , $ze = IHe.document
  , Hze = rze($ze) && rze($ze.createElement)
  , zze = function(e) {
  return Hze ? $ze.createElement(e) : {}
}
  , Kze = !FHe && !PHe((function() {
    return 7 != Object.defineProperty(zze("div"), "a", {
      get: function() {
        return 7
      }
    }).a
  }
))
  , Wze = Object.getOwnPropertyDescriptor
  , Gze = {
  f: FHe ? Wze : function(e, t) {
    if (e = tze(e),
      t = Uze(t),
      Kze)
      try {
        return Wze(e, t)
      } catch (n) {}
    if (Oze(e, t))
      return UHe(!NHe(VHe.f, e, t), e[t])
  }
}
  , qze = IHe.String
  , Yze = IHe.TypeError
  , Xze = function(e) {
  if (rze(e))
    return e;
  throw Yze(qze(e) + " is not an object")
}
  , Qze = IHe.TypeError
  , Jze = Object.defineProperty
  , Zze = {
  f: FHe ? Jze : function(e, t, n) {
    if (Xze(e),
      t = Uze(t),
      Xze(n),
      Kze)
      try {
        return Jze(e, t, n)
      } catch (r) {}
    if ("get"in n || "set"in n)
      throw Qze("Accessors not supported");
    return "value"in n && (e[t] = n.value),
      e
  }
}
  , eKe = FHe ? function(e, t, n) {
    return Zze.f(e, t, UHe(1, n))
  }
  : function(e, t, n) {
    return e[t] = n,
      e
  }
  , tKe = WHe(Function.toString);
nze(Aze.inspectSource) || (Aze.inspectSource = function(e) {
    return tKe(e)
  }
);
var nKe, rKe, oKe, aKe = Aze.inspectSource, iKe = IHe.WeakMap, sKe = nze(iKe) && /native code/.test(aKe(iKe)), lKe = Cze("keys"), uKe = function(e) {
  return lKe[e] || (lKe[e] = Ize(e))
}, cKe = {}, dKe = IHe.TypeError, fKe = IHe.WeakMap;
if (sKe || Aze.state) {
  var pKe = Aze.state || (Aze.state = new fKe)
    , hKe = WHe(pKe.get)
    , vKe = WHe(pKe.has)
    , gKe = WHe(pKe.set);
  nKe = function(e, t) {
    if (vKe(pKe, e))
      throw new dKe("Object already initialized");
    return t.facade = e,
      gKe(pKe, e, t),
      t
  }
    ,
    rKe = function(e) {
      return hKe(pKe, e) || {}
    }
    ,
    oKe = function(e) {
      return vKe(pKe, e)
    }
} else {
  var mKe = uKe("state");
  cKe[mKe] = !0,
    nKe = function(e, t) {
      if (Oze(e, mKe))
        throw new dKe("Object already initialized");
      return t.facade = e,
        eKe(e, mKe, t),
        t
    }
    ,
    rKe = function(e) {
      return Oze(e, mKe) ? e[mKe] : {}
    }
    ,
    oKe = function(e) {
      return Oze(e, mKe)
    }
}
var yKe = {
  set: nKe,
  get: rKe,
  has: oKe,
  enforce: function(e) {
    return oKe(e) ? rKe(e) : nKe(e, {})
  },
  getterFor: function(e) {
    return function(t) {
      var n;
      if (!rze(t) || (n = rKe(t)).type !== e)
        throw dKe("Incompatible receiver, " + e + " required");
      return n
    }
  }
}
  , bKe = Function.prototype
  , wKe = FHe && Object.getOwnPropertyDescriptor
  , xKe = Oze(bKe, "name")
  , SKe = {
  EXISTS: xKe,
  PROPER: xKe && "something" === function() {}
    .name,
  CONFIGURABLE: xKe && (!FHe || FHe && wKe(bKe, "name").configurable)
}
  , EKe = OHe((function(e) {
    var t = SKe.CONFIGURABLE
      , n = yKe.get
      , r = yKe.enforce
      , o = String(String).split("String");
    (e.exports = function(e, n, a, i) {
        var s, l = !!i && !!i.unsafe, u = !!i && !!i.enumerable, c = !!i && !!i.noTargetGet, d = i && void 0 !== i.name ? i.name : n;
        nze(a) && ("Symbol(" === String(d).slice(0, 7) && (d = "[" + String(d).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
        (!Oze(a, "name") || t && a.name !== d) && eKe(a, "name", d),
        (s = r(a)).source || (s.source = o.join("string" == typeof d ? d : ""))),
          e !== IHe ? (l ? !c && e[n] && (u = !0) : delete e[n],
            u ? e[n] = a : eKe(e, n, a)) : u ? e[n] = a : Eze(n, a)
      }
    )(Function.prototype, "toString", (function() {
        return nze(this) && n(this).source || aKe(this)
      }
    ))
  }
))
  , AKe = Math.ceil
  , CKe = Math.floor
  , kKe = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : (t > 0 ? CKe : AKe)(t)
}
  , TKe = Math.max
  , DKe = Math.min
  , OKe = function(e, t) {
  var n = kKe(e);
  return n < 0 ? TKe(n + t, 0) : DKe(n, t)
}
  , _Ke = Math.min
  , RKe = function(e) {
  return e > 0 ? _Ke(kKe(e), 9007199254740991) : 0
}
  , LKe = function(e) {
  return RKe(e.length)
}
  , IKe = function(e) {
  return function(t, n, r) {
    var o, a = tze(t), i = LKe(a), s = OKe(r, i);
    if (e && n != n) {
      for (; i > s; )
        if ((o = a[s++]) != o)
          return !0
    } else
      for (; i > s; s++)
        if ((e || s in a) && a[s] === n)
          return e || s || 0;
    return !e && -1
  }
}(!1)
  , PKe = WHe([].push)
  , FKe = function(e, t) {
  var n, r = tze(e), o = 0, a = [];
  for (n in r)
    !Oze(cKe, n) && Oze(r, n) && PKe(a, n);
  for (; t.length > o; )
    Oze(r, n = t[o++]) && (~IKe(a, n) || PKe(a, n));
  return a
}
  , BKe = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
  , NKe = BKe.concat("length", "prototype")
  , MKe = {
  f: Object.getOwnPropertyNames || function(e) {
    return FKe(e, NKe)
  }
}
  , jKe = {
  f: Object.getOwnPropertySymbols
}
  , VKe = WHe([].concat)
  , UKe = oze("Reflect", "ownKeys") || function(e) {
  var t = MKe.f(Xze(e))
    , n = jKe.f;
  return n ? VKe(t, n(e)) : t
}
  , $Ke = function(e, t) {
  for (var n = UKe(t), r = Zze.f, o = Gze.f, a = 0; a < n.length; a++) {
    var i = n[a];
    Oze(e, i) || r(e, i, o(t, i))
  }
}
  , HKe = /#|\.prototype\./
  , zKe = function(e, t) {
  var n = WKe[KKe(e)];
  return n == qKe || n != GKe && (nze(t) ? PHe(t) : !!t)
}
  , KKe = zKe.normalize = function(e) {
  return String(e).replace(HKe, ".").toLowerCase()
}
  , WKe = zKe.data = {}
  , GKe = zKe.NATIVE = "N"
  , qKe = zKe.POLYFILL = "P"
  , YKe = zKe
  , XKe = Gze.f
  , QKe = function(e, t) {
  var n, r, o, a, i, s = e.target, l = e.global, u = e.stat;
  if (n = l ? IHe : u ? IHe[s] || Eze(s, {}) : (IHe[s] || {}).prototype)
    for (r in t) {
      if (a = t[r],
        o = e.noTargetGet ? (i = XKe(n, r)) && i.value : n[r],
      !YKe(l ? r : s + (u ? "." : "#") + r, e.forced) && void 0 !== o) {
        if (typeof a == typeof o)
          continue;
        $Ke(a, o)
      }
      (e.sham || o && o.sham) && eKe(a, "sham", !0),
        EKe(n, r, a, e)
    }
}
  , JKe = {};
JKe[Mze("toStringTag")] = "z";
var ZKe = "[object z]" === String(JKe)
  , eWe = Mze("toStringTag")
  , tWe = IHe.Object
  , nWe = "Arguments" == YHe(function() {
  return arguments
}())
  , rWe = ZKe ? YHe : function(e) {
  var t, n, r;
  return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
    try {
      return e[t]
    } catch (n) {}
  }(t = tWe(e), eWe)) ? n : nWe ? YHe(t) : "Object" == (r = YHe(t)) && nze(t.callee) ? "Arguments" : r
}
  , oWe = IHe.String
  , aWe = function(e) {
  if ("Symbol" === rWe(e))
    throw TypeError("Cannot convert a Symbol value to a string");
  return oWe(e)
}
  , iWe = /"/g
  , sWe = WHe("".replace);
QKe({
  target: "String",
  proto: !0,
  forced: PHe((function() {
      var e = "".anchor('"');
      return e !== e.toLowerCase() || e.split('"').length > 3
    }
  ))
}, {
  anchor: function(e) {
    return t = e,
      n = aWe(eze(this)),
      r = "<a",
    (r += ' name="' + sWe(aWe(t), iWe, "&quot;") + '"') + ">" + n + "</a>";
    var t, n, r
  }
});
var lWe, uWe = function() {
  var e = Xze(this)
    , t = "";
  return e.global && (t += "g"),
  e.ignoreCase && (t += "i"),
  e.multiline && (t += "m"),
  e.dotAll && (t += "s"),
  e.unicode && (t += "u"),
  e.sticky && (t += "y"),
    t
}, cWe = IHe.RegExp, dWe = PHe((function() {
    var e = cWe("a", "y");
    return e.lastIndex = 2,
    null != e.exec("abcd")
  }
)), fWe = dWe || PHe((function() {
    return !cWe("a", "y").sticky
  }
)), pWe = {
  BROKEN_CARET: dWe || PHe((function() {
      var e = cWe("^r", "gy");
      return e.lastIndex = 2,
      null != e.exec("str")
    }
  )),
  MISSED_STICKY: fWe,
  UNSUPPORTED_Y: dWe
}, hWe = Object.keys || function(e) {
  return FKe(e, BKe)
}
  , vWe = FHe ? Object.defineProperties : function(e, t) {
  Xze(e);
  for (var n, r = tze(t), o = hWe(t), a = o.length, i = 0; a > i; )
    Zze.f(e, n = o[i++], r[n]);
  return e
}
  , gWe = oze("document", "documentElement"), mWe = uKe("IE_PROTO"), yWe = function() {}, bWe = function(e) {
  return "<script>" + e + "<\/script>"
}, wWe = function(e) {
  e.write(bWe("")),
    e.close();
  var t = e.parentWindow.Object;
  return e = null,
    t
}, xWe = function() {
  try {
    lWe = new ActiveXObject("htmlfile")
  } catch (r) {}
  var e, t;
  xWe = "undefined" != typeof document ? document.domain && lWe ? wWe(lWe) : ((t = zze("iframe")).style.display = "none",
    gWe.appendChild(t),
    t.src = String("javascript:"),
    (e = t.contentWindow.document).open(),
    e.write(bWe("document.F=Object")),
    e.close(),
    e.F) : wWe(lWe);
  for (var n = BKe.length; n--; )
    delete xWe.prototype[BKe[n]];
  return xWe()
};
cKe[mWe] = !0;
var SWe, EWe, AWe = Object.create || function(e, t) {
  var n;
  return null !== e ? (yWe.prototype = Xze(e),
    n = new yWe,
    yWe.prototype = null,
    n[mWe] = e) : n = xWe(),
    void 0 === t ? n : vWe(n, t)
}
  , CWe = IHe.RegExp, kWe = PHe((function() {
    var e = CWe(".", "s");
    return !(e.dotAll && e.exec("\n") && "s" === e.flags)
  }
)), TWe = IHe.RegExp, DWe = PHe((function() {
    var e = TWe("(?<a>b)", "g");
    return "b" !== e.exec("b").groups.a || "bc" !== "b".replace(e, "$<a>c")
  }
)), OWe = yKe.get, _We = Cze("native-string-replace", String.prototype.replace), RWe = RegExp.prototype.exec, LWe = RWe, IWe = WHe("".charAt), PWe = WHe("".indexOf), FWe = WHe("".replace), BWe = WHe("".slice), NWe = (EWe = /b*/g,
  NHe(RWe, SWe = /a/, "a"),
  NHe(RWe, EWe, "a"),
0 !== SWe.lastIndex || 0 !== EWe.lastIndex), MWe = pWe.BROKEN_CARET, jWe = void 0 !== /()??/.exec("")[1];
(NWe || jWe || MWe || kWe || DWe) && (LWe = function(e) {
    var t, n, r, o, a, i, s, l = this, u = OWe(l), c = aWe(e), d = u.raw;
    if (d)
      return d.lastIndex = l.lastIndex,
        t = NHe(LWe, d, c),
        l.lastIndex = d.lastIndex,
        t;
    var f = u.groups
      , p = MWe && l.sticky
      , h = NHe(uWe, l)
      , v = l.source
      , g = 0
      , m = c;
    if (p && (h = FWe(h, "y", ""),
    -1 === PWe(h, "g") && (h += "g"),
      m = BWe(c, l.lastIndex),
    l.lastIndex > 0 && (!l.multiline || l.multiline && "\n" !== IWe(c, l.lastIndex - 1)) && (v = "(?: " + v + ")",
      m = " " + m,
      g++),
      n = new RegExp("^(?:" + v + ")",h)),
    jWe && (n = new RegExp("^" + v + "$(?!\\s)",h)),
    NWe && (r = l.lastIndex),
      o = NHe(RWe, p ? n : l, m),
      p ? o ? (o.input = BWe(o.input, g),
        o[0] = BWe(o[0], g),
        o.index = l.lastIndex,
        l.lastIndex += o[0].length) : l.lastIndex = 0 : NWe && o && (l.lastIndex = l.global ? o.index + o[0].length : r),
    jWe && o && o.length > 1 && NHe(_We, o[0], n, (function() {
        for (a = 1; a < arguments.length - 2; a++)
          void 0 === arguments[a] && (o[a] = void 0)
      }
    )),
    o && f)
      for (o.groups = i = AWe(null),
             a = 0; a < f.length; a++)
        i[(s = f[a])[0]] = o[s[1]];
    return o
  }
);
var VWe = LWe;
QKe({
  target: "RegExp",
  proto: !0,
  forced: /./.exec !== VWe
}, {
  exec: VWe
});
var UWe = Array.isArray || function(e) {
  return "Array" == YHe(e)
}
  , $We = function() {}
  , HWe = []
  , zWe = oze("Reflect", "construct")
  , KWe = /^\s*(?:class|function)\b/
  , WWe = WHe(KWe.exec)
  , GWe = !KWe.exec($We)
  , qWe = function(e) {
  if (!nze(e))
    return !1;
  try {
    return zWe($We, HWe, e),
      !0
  } catch (t) {
    return !1
  }
}
  , YWe = !zWe || PHe((function() {
    var e;
    return qWe(qWe.call) || !qWe(Object) || !qWe((function() {
        e = !0
      }
    )) || e
  }
)) ? function(e) {
    if (!nze(e))
      return !1;
    switch (rWe(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    return GWe || !!WWe(KWe, aKe(e))
  }
  : qWe
  , XWe = function(e, t, n) {
  var r = Uze(t);
  r in e ? Zze.f(e, r, UHe(0, n)) : e[r] = n
}
  , QWe = Mze("species")
  , JWe = function(e) {
  return dze >= 51 || !PHe((function() {
      var t = [];
      return (t.constructor = {})[QWe] = function() {
        return {
          foo: 1
        }
      }
        ,
      1 !== t[e](Boolean).foo
    }
  ))
}
  , ZWe = WHe([].slice)
  , eGe = JWe("slice")
  , tGe = Mze("species")
  , nGe = IHe.Array
  , rGe = Math.max;
function oGe(e, t) {
  var n = "function" == typeof Symbol && e[Symbol.iterator];
  if (!n)
    return e;
  var r, o, a = n.call(e), i = [];
  try {
    for (; (void 0 === t || t-- > 0) && !(r = a.next()).done; )
      i.push(r.value)
  } catch (s) {
    o = {
      error: s
    }
  } finally {
    try {
      r && !r.done && (n = a.return) && n.call(a)
    } finally {
      if (o)
        throw o.error
    }
  }
  return i
}
function aGe(e) {
  var t = e.selection;
  if (null == t)
    return !1;
  var n = oGe(Yte.nodes(e, {
    match: function(e) {
      return qme.checkNodeType(e, "table-cell")
    }
  }), 1)[0];
  if (n) {
    var r = oGe(n, 2)[1]
      , o = Yte.start(e, r);
    if (lne.equals(t.anchor, o))
      return !0
  }
  return !1
}
function iGe(e, t) {
  var n, r, o = Yte.nodes(e, {
    at: t,
    match: function(e) {
      return "table" === qme.getNodeType(e)
    }
  }), a = !1;
  try {
    for (var i = /*! *****************************************************************************
      Copyright (c) Microsoft Corporation.

      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.

      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** */
      function(e) {
        var t = "function" == typeof Symbol && Symbol.iterator
          , n = t && e[t]
          , r = 0;
        if (n)
          return n.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function() {
              return e && r >= e.length && (e = void 0),
                {
                  value: e && e[r++],
                  done: !e
                }
            }
          };
        throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
      }(o), s = i.next(); !s.done; s = i.next())
      s.value,
        a = !0
  } catch (l) {
    n = {
      error: l
    }
  } finally {
    try {
      s && !s.done && (r = i.return) && r.call(i)
    } finally {
      if (n)
        throw n.error
    }
  }
  return a
}
QKe({
  target: "Array",
  proto: !0,
  forced: !eGe
}, {
  slice: function(e, t) {
    var n, r, o, a = tze(this), i = LKe(a), s = OKe(e, i), l = OKe(void 0 === t ? i : t, i);
    if (UWe(a) && (n = a.constructor,
    (YWe(n) && (n === nGe || UWe(n.prototype)) || rze(n) && null === (n = n[tGe])) && (n = void 0),
    n === nGe || void 0 === n))
      return ZWe(a, s, l);
    for (r = new (void 0 === n ? nGe : n)(rGe(l - s, 0)),
           o = 0; s < l; s++,
           o++)
      s in a && XWe(r, o, a[s]);
    return r.length = o,
      r
  }
});
var sGe = WHe(WHe.bind)
  , lGe = Mze("species")
  , uGe = IHe.Array
  , cGe = function(e, t) {
  return new (UWe(n = e) && (r = n.constructor,
  (YWe(r) && (r === uGe || UWe(r.prototype)) || rze(r) && null === (r = r[lGe])) && (r = void 0)),
    void 0 === r ? uGe : r)(0 === t ? 0 : t);
  var n, r
}
  , dGe = WHe([].push)
  , fGe = function(e) {
  var t = 1 == e
    , n = 2 == e
    , r = 3 == e
    , o = 4 == e
    , a = 6 == e
    , i = 7 == e
    , s = 5 == e || a;
  return function(l, u, c, d) {
    for (var f, p, h = Tze(l), v = JHe(h), g = function(e, t) {
      return bze(e),
        void 0 === t ? e : sGe ? sGe(e, t) : function() {
          return e.apply(t, arguments)
        }
    }(u, c), m = LKe(v), y = 0, b = d || cGe, w = t ? b(l, m) : n || i ? b(l, 0) : void 0; m > y; y++)
      if ((s || y in v) && (p = g(f = v[y], y, h),
        e))
        if (t)
          w[y] = p;
        else if (p)
          switch (e) {
            case 3:
              return !0;
            case 5:
              return f;
            case 6:
              return y;
            case 2:
              dGe(w, f)
          }
        else
          switch (e) {
            case 4:
              return !1;
            case 7:
              dGe(w, f)
          }
    return a ? -1 : r || o ? o : w
  }
}
  , pGe = {
  forEach: fGe(0),
  map: fGe(1),
  filter: fGe(2),
  some: fGe(3),
  every: fGe(4),
  find: fGe(5),
  findIndex: fGe(6),
  filterReject: fGe(7)
}
  , hGe = pGe.map;
QKe({
  target: "Array",
  proto: !0,
  forced: !JWe("map")
}, {
  map: function(e) {
    return hGe(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var vGe = ZKe ? {}.toString : function() {
    return "[object " + rWe(this) + "]"
  }
;
function gGe(e) {
  var t = e.children || [];
  return 0 === t.length ? [] : (t[0] || {}).children || []
}
function mGe(e) {
  return gGe(e).every((function(e) {
      return !!e.isHeader
    }
  ))
}
ZKe || EKe(Object.prototype, "toString", vGe, {
  unsafe: !0
});
var yGe = SKe.PROPER
  , bGe = RegExp.prototype
  , wGe = bGe.toString
  , xGe = WHe(uWe)
  , SGe = PHe((function() {
    return "/a/b" != wGe.call({
      source: "a",
      flags: "b"
    })
  }
))
  , EGe = yGe && "toString" != wGe.name;
(SGe || EGe) && EKe(RegExp.prototype, "toString", (function() {
    var e = Xze(this)
      , t = aWe(e.source)
      , n = e.flags;
    return "/" + t + "/" + aWe(void 0 === n && aze(bGe, e) && !("flags"in bGe) ? xGe(e) : n)
  }
), {
  unsafe: !0
});
var AGe = Mze("unscopables")
  , CGe = Array.prototype;
null == CGe[AGe] && Zze.f(CGe, AGe, {
  configurable: !0,
  value: AWe(null)
});
var kGe = pGe.find
  , TGe = !0;
"find"in [] && Array(1).find((function() {
    TGe = !1
  }
)),
  QKe({
    target: "Array",
    proto: !0,
    forced: TGe
  }, {
    find: function(e) {
      return kGe(this, e, arguments.length > 1 ? arguments[1] : void 0)
    }
  }),
  CGe[AGe].find = !0;
var DGe = Function.prototype
  , OGe = DGe.apply
  , _Ge = DGe.bind
  , RGe = DGe.call
  , LGe = "object" == typeof Reflect && Reflect.apply || (_Ge ? RGe.bind(OGe) : function() {
    return RGe.apply(OGe, arguments)
  }
)
  , IGe = Mze("species")
  , PGe = RegExp.prototype
  , FGe = function(e, t, n, r) {
  var o = Mze(e)
    , a = !PHe((function() {
      var t = {};
      return t[o] = function() {
        return 7
      }
        ,
      7 != ""[e](t)
    }
  ))
    , i = a && !PHe((function() {
      var t = !1
        , n = /a/;
      return "split" === e && ((n = {}).constructor = {},
        n.constructor[IGe] = function() {
          return n
        }
        ,
        n.flags = "",
        n[o] = /./[o]),
        n.exec = function() {
          return t = !0,
            null
        }
        ,
        n[o](""),
        !t
    }
  ));
  if (!a || !i || n) {
    var s = WHe(/./[o])
      , l = t(o, ""[e], (function(e, t, n, r, o) {
        var i = WHe(e)
          , l = t.exec;
        return l === VWe || l === PGe.exec ? a && !o ? {
          done: !0,
          value: s(t, n, r)
        } : {
          done: !0,
          value: i(n, t, r)
        } : {
          done: !1
        }
      }
    ));
    EKe(String.prototype, e, l[0]),
      EKe(PGe, o, l[1])
  }
  r && eKe(PGe[o], "sham", !0)
}
  , BGe = Mze("match")
  , NGe = IHe.TypeError
  , MGe = Mze("species")
  , jGe = WHe("".charAt)
  , VGe = WHe("".charCodeAt)
  , UGe = WHe("".slice)
  , $Ge = function(e) {
  return function(t, n) {
    var r, o, a = aWe(eze(t)), i = kKe(n), s = a.length;
    return i < 0 || i >= s ? e ? "" : void 0 : (r = VGe(a, i)) < 55296 || r > 56319 || i + 1 === s || (o = VGe(a, i + 1)) < 56320 || o > 57343 ? e ? jGe(a, i) : r : e ? UGe(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536
  }
}(!0)
  , HGe = function(e, t, n) {
  return t + (n ? $Ge(e, t).length : 1)
}
  , zGe = IHe.Array
  , KGe = Math.max
  , WGe = function(e, t, n) {
  for (var r = LKe(e), o = OKe(t, r), a = OKe(void 0 === n ? r : n, r), i = zGe(KGe(a - o, 0)), s = 0; o < a; o++,
    s++)
    XWe(i, s, e[o]);
  return i.length = s,
    i
}
  , GGe = IHe.TypeError
  , qGe = function(e, t) {
  var n = e.exec;
  if (nze(n)) {
    var r = NHe(n, e, t);
    return null !== r && Xze(r),
      r
  }
  if ("RegExp" === YHe(e))
    return NHe(VWe, e, t);
  throw GGe("RegExp#exec called on incompatible receiver")
}
  , YGe = pWe.UNSUPPORTED_Y
  , XGe = Math.min
  , QGe = [].push
  , JGe = WHe(/./.exec)
  , ZGe = WHe(QGe)
  , eqe = WHe("".slice);
FGe("split", (function(e, t, n) {
    var r;
    return r = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e, n) {
        var r, o, a = aWe(eze(this)), i = void 0 === n ? 4294967295 : n >>> 0;
        if (0 === i)
          return [];
        if (void 0 === e)
          return [a];
        if (!rze(r = e) || !(void 0 !== (o = r[BGe]) ? o : "RegExp" == YHe(r)))
          return NHe(t, a, e, i);
        for (var s, l, u, c = [], d = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), f = 0, p = new RegExp(e.source,d + "g"); (s = NHe(VWe, p, a)) && !((l = p.lastIndex) > f && (ZGe(c, eqe(a, f, s.index)),
        s.length > 1 && s.index < a.length && LGe(QGe, c, WGe(s, 1)),
          u = s[0].length,
          f = l,
        c.length >= i)); )
          p.lastIndex === s.index && p.lastIndex++;
        return f === a.length ? !u && JGe(p, "") || ZGe(c, "") : ZGe(c, eqe(a, f)),
          c.length > i ? WGe(c, 0, i) : c
      }
      : "0".split(void 0, 0).length ? function(e, n) {
          return void 0 === e && 0 === n ? [] : NHe(t, this, e, n)
        }
        : t,
      [function(t, n) {
        var o = eze(this)
          , a = null == t ? void 0 : wze(t, e);
        return a ? NHe(a, t, o, n) : NHe(r, aWe(o), t, n)
      }
        , function(e, o) {
        var a = Xze(this)
          , i = aWe(e)
          , s = n(r, a, i, o, r !== t);
        if (s.done)
          return s.value;
        var l, u, c, d = (l = RegExp,
          void 0 === (c = Xze(a).constructor) || null == (u = Xze(c)[MGe]) ? l : function(e) {
            if (YWe(e))
              return e;
            throw NGe(mze(e) + " is not a constructor")
          }(u)), f = a.unicode, p = (a.ignoreCase ? "i" : "") + (a.multiline ? "m" : "") + (a.unicode ? "u" : "") + (YGe ? "g" : "y"), h = new d(YGe ? "^(?:" + a.source + ")" : a,p), v = void 0 === o ? 4294967295 : o >>> 0;
        if (0 === v)
          return [];
        if (0 === i.length)
          return null === qGe(h, i) ? [i] : [];
        for (var g = 0, m = 0, y = []; m < i.length; ) {
          h.lastIndex = YGe ? 0 : m;
          var b, w = qGe(h, YGe ? eqe(i, m) : i);
          if (null === w || (b = XGe(RKe(h.lastIndex + (YGe ? m : 0)), i.length)) === g)
            m = HGe(i, m, f);
          else {
            if (ZGe(y, eqe(i, g, m)),
            y.length === v)
              return y;
            for (var x = 1; x <= w.length - 1; x++)
              if (ZGe(y, w[x]),
              y.length === v)
                return y;
            m = g = b
          }
        }
        return ZGe(y, eqe(i, g)),
          y
      }
      ]
  }
), !!PHe((function() {
    var e = /(?:)/
      , t = e.exec;
    e.exec = function() {
      return t.apply(this, arguments)
    }
    ;
    var n = "ab".split(e);
    return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
  }
)), YGe);
var tqe = "\t\n\v\f\r                　\u2028\u2029\ufeff"
  , nqe = WHe("".replace)
  , rqe = "[" + tqe + "]"
  , oqe = RegExp("^" + rqe + rqe + "*")
  , aqe = RegExp(rqe + rqe + "*$")
  , iqe = function(e) {
  return function(t) {
    var n = aWe(eze(t));
    return 1 & e && (n = nqe(n, oqe, "")),
    2 & e && (n = nqe(n, aqe, "")),
      n
  }
}
  , sqe = {
  start: iqe(1),
  end: iqe(2),
  trim: iqe(3)
}
  , lqe = SKe.PROPER
  , uqe = sqe.trim;
function cqe(e) {
  return e.length ? e[0].tagName.toLowerCase() : ""
}
QKe({
  target: "String",
  proto: !0,
  forced: function(e) {
    return PHe((function() {
        return !!tqe[e]() || "​᠎" !== "​᠎"[e]() || lqe && tqe[e].name !== e
      }
    ))
  }("trim")
}, {
  trim: function() {
    return uqe(this)
  }
}),
  QKe({
    global: !0
  }, {
    globalThis: IHe
  }),
yoe && (Qre.fn.append = yoe),
aoe && (Qre.fn.on = aoe),
Ooe && (Qre.fn.focus = Ooe),
toe && (Qre.fn.attr = toe),
ooe && (Qre.fn.val = ooe),
voe && (Qre.fn.html = voe),
roe && (Qre.fn.dataset = roe),
Jre && (Qre.fn.addClass = Jre),
Zre && (Qre.fn.removeClass = Zre),
Eoe && (Qre.fn.children = Eoe),
poe && (Qre.fn.each = poe),
Soe && (Qre.fn.find = Soe);
var dqe = !1
  , fqe = 0
  , pqe = 0
  , hqe = null
  , vqe = null
  , gqe = Qre("body");
function mqe(e) {
  dqe = !1,
    vqe = null,
    hqe = null,
    gqe.off("mousemove", yqe),
    gqe.off("mouseup", mqe)
}
gqe.on("mousedown", (function(e) {
    var t = e.target;
    if (("TH" === t.tagName || "TD" === t.tagName) && "col-resize" === t.style.cursor) {
      t.style.cursor = "auto",
        e.preventDefault(),
        dqe = !0;
      var n = e.clientX;
      fqe = n;
      var r = t.getBoundingClientRect().width;
      pqe = r,
        gqe.on("mousemove", yqe),
        gqe.on("mouseup", mqe)
    }
  }
));
var yqe = uae((function(e) {
    if (dqe && null != vqe && null != hqe) {
      e.preventDefault();
      var t = e.clientX
        , n = pqe + (t - fqe);
      (n = Math.floor(100 * n) / 100) < 30 && (n = 30),
        Nne.setNodes(vqe, {
          width: n.toString()
        }, {
          at: hqe
        })
    }
  }
), 100)
  , bqe = {
  type: "table",
  renderElem: function(e, t, n) {
    var r = function(e, t) {
      if (e.isDisabled())
        return !1;
      var n = e.selection;
      if (null == n)
        return !0;
      if (fne.isCollapsed(n))
        return !0;
      var r = n.anchor
        , o = n.focus
        , a = qme.findPath(e, t)
        , i = Yte.start(e, a)
        , s = Yte.end(e, a)
        , l = lne.compare(r, s) <= 0 && lne.compare(r, i) >= 0
        , u = lne.compare(o, s) <= 0 && lne.compare(o, i) >= 0;
      return !!(l && u && one.equals(r.path.slice(0, 3), o.path.slice(0, 3)))
    }(n, e)
      , o = e.width
      , a = void 0 === o ? "auto" : o;
    return $ae("div", {
      className: "table-container",
      "data-selected": qme.isNodeSelected(n, e),
      on: {
        mousedown: function(t) {
          if ("DIV" === t.target.tagName && t.preventDefault(),
            !n.isDisabled()) {
            var r = qme.findPath(n, e)
              , o = Yte.start(n, r)
              , a = n.selection;
            null != a ? a.anchor.path[0] !== r[0] && n.select(o) : n.select(o)
          }
        }
      }
    }, $ae("table", {
      width: a,
      contentEditable: r
    }, $ae("colgroup", null, gGe(e).map((function(e) {
        var t = e.width;
        return $ae("col", {
          width: void 0 === t ? "auto" : t
        })
      }
    ))), $ae("tbody", null, t)))
  }
}
  , wqe = {
  type: "table-row",
  renderElem: function(e, t, n) {
    return $ae("tr", null, t)
  }
}
  , xqe = {
  type: "table-cell",
  renderElem: function(e, t, n) {
    var r = function(e, t) {
      var n = qme.getParentNode(e, t);
      if (null == n)
        return !1;
      var r = qme.getParentNode(e, n);
      return null != r && gGe(r).some((function(e) {
          return e === t
        }
      ))
    }(n, e)
      , o = e
      , a = o.colSpan
      , i = void 0 === a ? 1 : a
      , s = o.rowSpan
      , l = void 0 === s ? 1 : s
      , u = o.isHeader;
    return r ? $ae(void 0 !== u && u ? "th" : "td", {
      colSpan: i,
      rowSpan: l,
      style: {
        borderRightWidth: "3px"
      },
      on: {
        mousemove: uae((function(t) {
            var r = this.elm;
            if (null != r) {
              var o = r.getBoundingClientRect()
                , a = o.left
                , i = o.width
                , s = o.top
                , l = o.height
                , u = t.clientX
                , c = t.clientY;
              dqe || (u > a + i - 5 && u < a + i && c > s && c < s + l ? (r.style.cursor = "col-resize",
                vqe = n,
                hqe = qme.findPath(n, e)) : dqe || (r.style.cursor = "auto",
                vqe = null,
                hqe = null))
            }
          }
        ), 100)
      }
    }, t) : $ae("td", {
      colSpan: i,
      rowSpan: l
    }, t)
  }
}
  , Sqe = {
  selector: "table",
  preParseHtml: function(e) {
    var t = Qre(e);
    if ("table" !== cqe(t))
      return e;
    var n = t.find("tbody");
    if (0 === n.length)
      return e;
    var r = t.find("tr");
    return t.append(r),
      n.remove(),
      t[0]
  }
}
  , Eqe = pGe.filter;
QKe({
  target: "Array",
  proto: !0,
  forced: !JWe("filter")
}, {
  filter: function(e) {
    return Eqe(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
});
var Aqe = Math.floor
  , Cqe = WHe("".charAt)
  , kqe = WHe("".replace)
  , Tqe = WHe("".slice)
  , Dqe = /\$([$&'`]|\d{1,2}|<[^>]*>)/g
  , Oqe = /\$([$&'`]|\d{1,2})/g
  , _qe = function(e, t, n, r, o, a) {
  var i = n + e.length
    , s = r.length
    , l = Oqe;
  return void 0 !== o && (o = Tze(o),
    l = Dqe),
    kqe(a, l, (function(a, l) {
        var u;
        switch (Cqe(l, 0)) {
          case "$":
            return "$";
          case "&":
            return e;
          case "`":
            return Tqe(t, 0, n);
          case "'":
            return Tqe(t, i);
          case "<":
            u = o[Tqe(l, 1, -1)];
            break;
          default:
            var c = +l;
            if (0 === c)
              return a;
            if (c > s) {
              var d = Aqe(c / 10);
              return 0 === d ? a : d <= s ? void 0 === r[d - 1] ? Cqe(l, 1) : r[d - 1] + Cqe(l, 1) : a
            }
            u = r[c - 1]
        }
        return void 0 === u ? "" : u
      }
    ))
}
  , Rqe = Mze("replace")
  , Lqe = Math.max
  , Iqe = Math.min
  , Pqe = WHe([].concat)
  , Fqe = WHe([].push)
  , Bqe = WHe("".indexOf)
  , Nqe = WHe("".slice)
  , Mqe = "$0" === "a".replace(/./, "$0")
  , jqe = !!/./[Rqe] && "" === /./[Rqe]("a", "$0");
FGe("replace", (function(e, t, n) {
    var r = jqe ? "$" : "$0";
    return [function(e, n) {
      var r = eze(this)
        , o = null == e ? void 0 : wze(e, Rqe);
      return o ? NHe(o, e, r, n) : NHe(t, aWe(r), e, n)
    }
      , function(e, o) {
        var a = Xze(this)
          , i = aWe(e);
        if ("string" == typeof o && -1 === Bqe(o, r) && -1 === Bqe(o, "$<")) {
          var s = n(t, a, i, o);
          if (s.done)
            return s.value
        }
        var l = nze(o);
        l || (o = aWe(o));
        var u = a.global;
        if (u) {
          var c = a.unicode;
          a.lastIndex = 0
        }
        for (var d = []; ; ) {
          var f = qGe(a, i);
          if (null === f)
            break;
          if (Fqe(d, f),
            !u)
            break;
          "" === aWe(f[0]) && (a.lastIndex = HGe(i, RKe(a.lastIndex), c))
        }
        for (var p, h = "", v = 0, g = 0; g < d.length; g++) {
          for (var m = aWe((f = d[g])[0]), y = Lqe(Iqe(kKe(f.index), i.length), 0), b = [], w = 1; w < f.length; w++)
            Fqe(b, void 0 === (p = f[w]) ? p : String(p));
          var x = f.groups;
          if (l) {
            var S = Pqe([m], b, y, i);
            void 0 !== x && Fqe(S, x);
            var E = aWe(LGe(o, void 0, S))
          } else
            E = _qe(m, i, y, b, x, o);
          y >= v && (h += Nqe(i, v, y) + E,
            v = y + m.length)
        }
        return h + Nqe(i, v)
      }
    ]
  }
), !!PHe((function() {
    var e = /./;
    return e.exec = function() {
      var e = [];
      return e.groups = {
        a: "7"
      },
        e
    }
      ,
    "7" !== "".replace(e, "$<a>")
  }
)) || !Mqe || jqe);
var Vqe = {
  selector: "td:not([data-w-e-type]),th:not([data-w-e-type])",
  parseElemHtml: function(e, t, n) {
    var r = Qre(e);
    0 === (t = t.filter((function(e) {
        return !!bne.isText(e) || !!n.isInline(e)
      }
    ))).length && (t = [{
      text: r.text().replace(/\s+/gm, " ")
    }]);
    var o = parseInt(r.attr("colSpan") || "1")
      , a = parseInt(r.attr("rowSpan") || "1")
      , i = r.attr("width") || "auto";
    return {
      type: "table-cell",
      isHeader: "th" === cqe(r),
      colSpan: o,
      rowSpan: a,
      width: i,
      children: t
    }
  }
}
  , Uqe = {
  selector: "tr:not([data-w-e-type])",
  parseElemHtml: function(e, t, n) {
    return {
      type: "table-row",
      children: t.filter((function(e) {
          return "table-cell" === qme.getNodeType(e)
        }
      ))
    }
  }
}
  , $qe = {
  selector: "table:not([data-w-e-type])",
  parseElemHtml: function(e, t, n) {
    var r = Qre(e)
      , o = "auto";
    return "100%" === function(e, t) {
      for (var n = "", r = (e.attr("style") || "").split(";"), o = r.length, a = 0; a < o; a++) {
        var i = r[a];
        if (i) {
          var s = i.split(":");
          "width" === s[0].trim() && (n = s[1].trim())
        }
      }
      return n
    }(r) && (o = "100%"),
    "100%" === r.attr("width") && (o = "100%"),
      {
        type: "table",
        width: o,
        children: t.filter((function(e) {
            return "table-row" === qme.getNodeType(e)
          }
        ))
      }
  }
}
  , Hqe = function() {
  function e() {
    this.title = SEe("tableModule.insertTable"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M0 64v896h1024V64H0z m384 576v-192h256v192h-256z m256 64v192h-256v-192h256z m0-512v192h-256V192h256zM320 192v192H64V192h256z m-256 256h256v192H64v-192z m640 0h256v192h-256v-192z m0-64V192h256v192h-256zM64 704h256v192H64v-192z m640 192v-192h256v192h-256z"></path></svg>',
      this.tag = "button",
      this.showDropPanel = !0,
      this.$content = null
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.exec = function(e, t) {}
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !fne.isCollapsed(t) || !!qme.getSelectedElems(e).some((function(t) {
          var n = qme.getNodeType(t);
          return "pre" === n || "table" === n || "list-item" === n || !!e.isVoid(t)
        }
      ))
    }
    ,
    e.prototype.getPanelContentElem = function(e) {
      var t = this;
      if (this.$content)
        return this.$content[0];
      for (var n = Qre('<div class="w-e-panel-content-table"></div>'), r = Qre("<span>0 &times; 0</span>"), o = Qre("<table></table>"), a = 0; a < 10; a++) {
        for (var i = Qre("<tr></tr>"), s = 0; s < 10; s++) {
          var l = Qre("<td></td>");
          l.attr("data-x", s.toString()),
            l.attr("data-y", a.toString()),
            i.append(l),
            l.on("mouseenter", (function(e) {
                var t = e.target;
                if (null != t) {
                  var n = Qre(t).dataset()
                    , a = n.x
                    , i = n.y;
                  r[0].innerHTML = a + 1 + " &times; " + (i + 1),
                    o.children().each((function(e) {
                        Qre(e).children().each((function(e) {
                            var t = Qre(e)
                              , n = t.dataset()
                              , r = n.x
                              , o = n.y;
                            r <= a && o <= i ? t.addClass("active") : t.removeClass("active")
                          }
                        ))
                      }
                    ))
                }
              }
            )),
            l.on("click", (function(n) {
                n.preventDefault();
                var r = n.target;
                if (null != r) {
                  var o = Qre(r).dataset()
                    , a = o.x
                    , i = o.y;
                  t.insertTable(e, i + 1, a + 1)
                }
              }
            ))
        }
        o.append(i)
      }
      return n.append(o),
        n.append(r),
        this.$content = n,
        n[0]
    }
    ,
    e.prototype.insertTable = function(e, t, n) {
      var r = parseInt(t, 10)
        , o = parseInt(n, 10);
      if (r && o && !(r <= 0 || o <= 0)) {
        qme.isSelectedEmptyParagraph(e) && Nne.removeNodes(e, {
          mode: "highest"
        });
        var a = function(e, t) {
          for (var n = [], r = 0; r < e; r++) {
            for (var o = [], a = 0; a < t; a++) {
              var i = {
                type: "table-cell",
                children: [{
                  text: ""
                }]
              };
              0 === r && (i.isHeader = !0),
                o.push(i)
            }
            n.push({
              type: "table-row",
              children: o
            })
          }
          return {
            type: "table",
            width: "auto",
            children: n
          }
        }(r, o);
        Nne.insertNodes(e, a, {
          mode: "highest"
        })
      }
    }
    ,
    e
}()
  , zqe = function() {
  function e() {
    this.title = SEe("tableModule.deleteTable"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M826.8032 356.5312c-19.328 0-36.3776 15.6928-36.3776 35.0464v524.2624c0 19.328-16 34.56-35.328 34.56H264.9344c-19.328 0-35.5072-15.3088-35.5072-34.56V390.0416c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.6928-33.5104 35.0464V915.712c0 57.9328 44.6208 108.288 102.528 108.288H755.2c57.9328 0 108.0832-50.4576 108.0832-108.288V391.4752c-0.1024-19.2512-17.1264-34.944-36.48-34.944z" p-id="9577"></path><path d="M437.1712 775.7568V390.6048c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.616-33.5104 35.0464v385.152c0 19.328 14.1568 35.0464 33.5104 35.0464s33.5104-15.7184 33.5104-35.0464zM649.7024 775.7568V390.6048c0-19.328-17.0496-35.0464-36.3776-35.0464s-36.3776 15.616-36.3776 35.0464v385.152c0 19.328 17.0496 35.0464 36.3776 35.0464s36.3776-15.7184 36.3776-35.0464zM965.0432 217.0368h-174.6176V145.5104c0-57.9328-47.2064-101.76-104.6528-101.76h-350.976c-57.8304 0-105.3952 43.8528-105.3952 101.76v71.5264H54.784c-19.4304 0-35.0464 14.1568-35.0464 33.5104 0 19.328 15.616 33.5104 35.0464 33.5104h910.3616c19.328 0 35.0464-14.1568 35.0464-33.5104 0-19.3536-15.6928-33.5104-35.1488-33.5104z m-247.3728 0H297.3952V145.5104c0-19.328 18.2016-34.7648 37.4272-34.7648h350.976c19.1488 0 31.872 15.1296 31.872 34.7648v71.5264z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || null == qme.getSelectedNodeByType(e, "table")
    }
    ,
    e.prototype.exec = function(e, t) {
      this.isDisabled(e) || Nne.removeNodes(e, {
        mode: "highest"
      })
    }
    ,
    e
}()
  , Kqe = function() {
  function e() {
    this.title = SEe("tableModule.insertRow"),
      this.iconSvg = '<svg viewBox="0 0 1048 1024"><path d="M707.7888 521.0112h-147.456v-147.456H488.2432v147.456h-147.456v68.8128h147.456v147.456h72.0896v-147.456h147.456zM0 917.504V0h1048.576v917.504H0zM327.68 65.536H65.536v196.608H327.68V65.536z m327.68 0H393.216v196.608h262.144V65.536z m327.68 0h-262.144v196.608h262.144V65.536z m0 258.8672H65.536v462.0288H983.04V324.4032z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !fne.isCollapsed(t) || null == qme.getSelectedNodeByType(e, "table")
    }
    ,
    e.prototype.exec = function(e, t) {
      if (!this.isDisabled(e)) {
        var n = oGe(Yte.nodes(e, {
          match: function(e) {
            return qme.checkNodeType(e, "table-cell")
          },
          universal: !0
        }), 1)
          , r = oGe(n[0], 2)
          , o = r[0]
          , a = r[1]
          , i = qme.getParentNode(e, o)
          , s = (null == i ? void 0 : i.children.length) || 0;
        if (0 !== s) {
          for (var l = {
            type: "table-row",
            children: []
          }, u = 0; u < s; u++)
            l.children.push({
              type: "table-cell",
              children: [{
                text: ""
              }]
            });
          var c = one.parent(a)
            , d = one.next(c);
          Nne.insertNodes(e, l, {
            at: d
          })
        }
      }
    }
    ,
    e
}()
  , Wqe = function() {
  function e() {
    this.title = SEe("tableModule.deleteRow"),
      this.iconSvg = '<svg viewBox="0 0 1048 1024"><path d="M907.6736 586.5472L747.1104 425.984l163.84-163.84-78.6432-78.6432-163.84 163.84L507.904 186.7776 429.2608 262.144l163.84 163.84-167.1168 167.1168 78.6432 78.6432 167.1168-167.1168 160.5632 160.5632 75.3664-78.6432zM0 917.504V0h1048.576v917.504H0z m983.04-327.68h-22.9376l-65.536-65.536H983.04V327.68h-91.7504l65.536-65.536h26.2144V65.536H65.536v196.608h317.8496l65.536 65.536H65.536v196.608h380.1088l-65.536 65.536H65.536v196.608H983.04v-196.608z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !fne.isCollapsed(t) || null == qme.getSelectedNodeByType(e, "table-row")
    }
    ,
    e.prototype.exec = function(e, t) {
      if (!this.isDisabled(e)) {
        var n = oGe(Yte.nodes(e, {
          match: function(e) {
            return qme.checkNodeType(e, "table-row")
          },
          universal: !0
        }), 1)
          , r = oGe(n[0], 2)
          , o = r[0]
          , a = r[1]
          , i = qme.getParentNode(e, o);
        ((null == i ? void 0 : i.children.length) || 0) <= 1 ? Nne.removeNodes(e, {
          mode: "highest"
        }) : Nne.removeNodes(e, {
          at: a
        })
      }
    }
    ,
    e
}()
  , Gqe = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}
  , qqe = zze("span").classList
  , Yqe = qqe && qqe.constructor && qqe.constructor.prototype
  , Xqe = Yqe === Object.prototype ? void 0 : Yqe
  , Qqe = pGe.forEach
  , Jqe = function(e, t) {
  var n = [].forEach;
  return !!n && PHe((function() {
      n.call(null, (function() {
          throw 1
        }
      ), 1)
    }
  ))
}()
  , Zqe = Jqe ? [].forEach : function(e) {
  return Qqe(this, e, arguments.length > 1 ? arguments[1] : void 0)
}
  , eYe = function(e) {
  if (e && e.forEach !== Zqe)
    try {
      eKe(e, "forEach", Zqe)
    } catch (X_) {
      e.forEach = Zqe
    }
};
for (var tYe in Gqe)
  Gqe[tYe] && eYe(IHe[tYe] && IHe[tYe].prototype);
eYe(Xqe);
var nYe = function() {
  function e() {
    this.title = SEe("tableModule.insertCol"),
      this.iconSvg = '<svg viewBox="0 0 1048 1024"><path d="M327.68 193.3312v186.7776H140.9024v91.7504H327.68v186.7776h88.4736V471.8592h190.0544V380.1088H416.1536V193.3312zM0 917.504V0h1048.576v917.504H0zM655.36 65.536H65.536v720.896H655.36V65.536z m327.68 0h-262.144v196.608h262.144V65.536z m0 262.144h-262.144v196.608h262.144V327.68z m0 262.144h-262.144v196.608h262.144v-196.608z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !fne.isCollapsed(t) || null == qme.getSelectedNodeByType(e, "table")
    }
    ,
    e.prototype.exec = function(e, t) {
      if (!this.isDisabled(e)) {
        var n = oGe(Yte.nodes(e, {
          match: function(e) {
            return qme.checkNodeType(e, "table-cell")
          },
          universal: !0
        }), 1)
          , r = oGe(n[0], 2)
          , o = r[0]
          , a = r[1]
          , i = qme.getParentNode(e, o);
        if (null != i) {
          var s = qme.getParentNode(e, i);
          null != s && (s.children || []).forEach((function(t, n) {
              Hte.isElement(t) && (t.children || []).forEach((function(t) {
                  var r = qme.findPath(e, t);
                  if (r.length === a.length && THe(r.slice(-1), a.slice(-1))) {
                    var o = {
                      type: "table-cell",
                      children: [{
                        text: ""
                      }]
                    };
                    0 === n && mGe(s) && (o.isHeader = !0),
                      Nne.insertNodes(e, o, {
                        at: r
                      })
                  }
                }
              ))
            }
          ))
        }
      }
    }
    ,
    e
}()
  , rYe = function() {
  function e() {
    this.title = SEe("tableModule.deleteCol"),
      this.iconSvg = '<svg viewBox="0 0 1048 1024"><path d="M327.68 510.976L393.216 445.44v-13.1072L327.68 366.7968V510.976z m327.68-78.4384l65.536-65.536V507.904L655.36 442.368v-9.8304z m393.216 484.9664V0H0v917.504h1048.576z m-65.536-131.072h-262.144v-52.4288l-13.1072 13.1072-52.4288-52.4288v91.7504H393.216v-91.7504l-52.4288 52.4288-13.1072-13.1072v52.4288H65.536V65.536H327.68v121.2416l36.0448-36.0448 29.4912 29.4912V62.2592h262.144V180.224l49.152-49.152 16.384 16.384V62.2592h262.144V786.432z m-294.912-108.1344l-160.5632-160.5632-167.1168 167.1168-78.6432-78.6432 167.1168-167.1168L288.3584 278.528l78.6432-78.6432 160.5632 160.5632 163.84-163.84 78.6432 78.6432-163.84 163.84 160.5632 160.5632-78.6432 78.6432z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !fne.isCollapsed(t) || null == qme.getSelectedNodeByType(e, "table-cell")
    }
    ,
    e.prototype.exec = function(e, t) {
      if (!this.isDisabled(e)) {
        var n = oGe(Yte.nodes(e, {
          match: function(e) {
            return qme.checkNodeType(e, "table-cell")
          },
          universal: !0
        }), 1)
          , r = oGe(n[0], 2)
          , o = r[0]
          , a = r[1]
          , i = qme.getParentNode(e, o)
          , s = (null == i ? void 0 : i.children.length) || 0;
        if (!i || s <= 1)
          Nne.removeNodes(e, {
            mode: "highest"
          });
        else {
          var l = qme.getParentNode(e, i);
          null != l && (l.children || []).forEach((function(t) {
              Hte.isElement(t) && (t.children || []).forEach((function(t) {
                  var n = qme.findPath(e, t);
                  n.length === a.length && THe(n.slice(-1), a.slice(-1)) && Nne.removeNodes(e, {
                    at: n
                  })
                }
              ))
            }
          ))
        }
      }
    }
    ,
    e
}()
  , oYe = function() {
  function e() {
    this.title = SEe("tableModule.header"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M704 128l-64 0L384 128 320 128 0 128l0 256 0 64 0 192 0 64 0 256 320 0 64 0 256 0 64 0 320 0 0-256 0-64L1024 448 1024 384 1024 128 704 128zM640 640 384 640 384 448l256 0L640 640zM64 448l256 0 0 192L64 640 64 448zM320 896 64 896l0-192 256 0L320 896zM640 896 384 896l0-192 256 0L640 896zM960 896l-256 0 0-192 256 0L960 896zM960 640l-256 0L704 448l256 0L960 640z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    var t = qme.getSelectedNodeByType(e, "table");
    return null != t && mGe(t)
  }
    ,
    e.prototype.isActive = function(e) {
      return !!this.getValue(e)
    }
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !fne.isCollapsed(t) || null == qme.getSelectedNodeByType(e, "table")
    }
    ,
    e.prototype.exec = function(e, t) {
      if (!this.isDisabled(e)) {
        var n = !t
          , r = qme.getSelectedNodeByType(e, "table");
        null != r && gGe(r).forEach((function(t) {
            return Nne.setNodes(e, {
              isHeader: n
            }, {
              at: qme.findPath(e, t)
            })
          }
        ))
      }
    }
    ,
    e
}()
  , aYe = function() {
  function e() {
    this.title = SEe("tableModule.widthAuto"),
      this.iconSvg = '<svg viewBox="0 0 1228 1024"><path d="M862.514337 563.200461H404.581995v121.753478a13.311987 13.311987 0 0 1-6.655993 11.468789 10.23999 10.23999 0 0 1-12.083188-1.433599l-204.799795-179.199821a13.721586 13.721586 0 0 1 0-20.479979l204.799795-179.302221a10.23999 10.23999 0 0 1 12.185588-1.535998 13.209587 13.209587 0 0 1 6.553593 11.673588v115.097485h457.932342V319.693504a11.571188 11.571188 0 0 1 18.841582-10.239989l204.799795 179.19982a13.721586 13.721586 0 0 1 0 20.47998l-204.799795 179.199821a10.23999 10.23999 0 0 1-12.185588 1.535998 13.311987 13.311987 0 0 1-6.655994-11.571188V563.200461zM136.499064 14.951409v993.893406a15.257585 15.257585 0 0 1-15.155185 15.052785H15.155185A15.155185 15.155185 0 0 1 0 1008.844815V14.951409a15.257585 15.257585 0 0 1 15.155185-15.052785h106.086294a15.155185 15.155185 0 0 1 15.257585 15.155185zM1228.798771 14.951409v993.893406a15.257585 15.257585 0 0 1-15.155185 15.052785h-106.188693a15.155185 15.155185 0 0 1-15.155185-15.052785V14.951409a15.257585 15.257585 0 0 1 15.155185-15.052785h106.086293A15.155185 15.155185 0 0 1 1228.798771 15.053809z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    var t = qme.getSelectedNodeByType(e, "table");
    return null != t && "100%" === t.width
  }
    ,
    e.prototype.isActive = function(e) {
      return !!this.getValue(e)
    }
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !fne.isCollapsed(t) || null == qme.getSelectedNodeByType(e, "table")
    }
    ,
    e.prototype.exec = function(e, t) {
      if (!this.isDisabled(e)) {
        var n = {
          width: t ? "auto" : "100%"
        };
        Nne.setNodes(e, n, {
          mode: "highest"
        })
      }
    }
    ,
    e
}()
  , iYe = {
  renderElems: [bqe, wqe, xqe],
  elemsToHtml: [{
    type: "table",
    elemToHtml: function(e, t) {
      var n = e.width;
      return '<table style="width: ' + (void 0 === n ? "auto" : n) + ';"><tbody>' + t + "</tbody></table>"
    }
  }, {
    type: "table-row",
    elemToHtml: function(e, t) {
      return "<tr>" + t + "</tr>"
    }
  }, {
    type: "table-cell",
    elemToHtml: function(e, t) {
      var n = e
        , r = n.colSpan
        , o = void 0 === r ? 1 : r
        , a = n.rowSpan
        , i = void 0 === a ? 1 : a
        , s = n.isHeader
        , l = void 0 !== s && s
        , u = n.width
        , c = l ? "th" : "td";
      return "<" + c + ' colSpan="' + o + '" rowSpan="' + i + '" width="' + (void 0 === u ? "auto" : u) + '">' + t + "</" + c + ">"
    }
  }],
  preParseHtml: [Sqe],
  parseElemsHtml: [Vqe, Uqe, $qe],
  menus: [{
    key: "insertTable",
    factory: function() {
      return new Hqe
    }
  }, {
    key: "deleteTable",
    factory: function() {
      return new zqe
    }
  }, {
    key: "insertTableRow",
    factory: function() {
      return new Kqe
    }
  }, {
    key: "deleteTableRow",
    factory: function() {
      return new Wqe
    }
  }, {
    key: "insertTableCol",
    factory: function() {
      return new nYe
    }
  }, {
    key: "deleteTableCol",
    factory: function() {
      return new rYe
    }
  }, {
    key: "tableHeader",
    factory: function() {
      return new oYe
    }
  }, {
    key: "tableFullWidth",
    factory: function() {
      return new aYe
    }
  }],
  editorPlugin: function(e) {
    var t = e.insertBreak
      , n = e.deleteBackward
      , r = e.deleteForward
      , o = e.normalizeNode
      , a = e.insertData
      , i = e.handleTab
      , s = e.selectAll
      , l = e;
    return l.insertBreak = function() {
      null == qme.getSelectedNodeByType(l, "table") ? t() : l.insertText("\n")
    }
      ,
      l.deleteBackward = function(e) {
        if (!aGe(l)) {
          var t = l.selection;
          if (t) {
            var r = Yte.before(l, t);
            if (r) {
              var o = iGe(l, r)
                , a = iGe(l, t);
              if (o && !a)
                return
            }
          }
          n(e)
        }
      }
      ,
      l.handleTab = function() {
        var t;
        if (qme.getSelectedNodeByType(l, "table")) {
          var n = Yte.above(e);
          qme.checkNodeType(n[0], "table-cell") && Nne.select(e, n[1]);
          var r = Yte.next(e);
          if (r)
            r[0] && r[0].text && (r = null !== (t = Yte.above(e, {
              at: r[1]
            })) && void 0 !== t ? t : r),
              Nne.select(e, r[1]);
          else {
            var o = l.children || []
              , a = o.length;
            if (qme.checkNodeType(o[a - 1], "table")) {
              var s = qme.genEmptyParagraph();
              Nne.insertNodes(l, s, {
                at: [a]
              }),
                l.handleTab()
            }
          }
        } else
          i()
      }
      ,
      l.deleteForward = function(e) {
        aGe(l) || r(e)
      }
      ,
      l.normalizeNode = function(e) {
        var t = oGe(e, 2)
          , n = t[0]
          , r = t[1];
        if ("table" !== qme.getNodeType(n))
          return o([n, r]);
        if (qme.isLastNode(l, n)) {
          var a = qme.genEmptyParagraph();
          Nne.insertNodes(l, a, {
            at: [r[0] + 1]
          })
        }
      }
      ,
      l.insertData = function(e) {
        if (null != qme.getSelectedNodeByType(l, "table")) {
          var t = e.getData("text/plain");
          "\n" === t || /<img[^>]+>/.test(e.getData("text/html")) ? a(e) : Yte.insertText(l, t)
        } else
          a(e)
      }
      ,
      l.selectAll = function() {
        var e = l.selection;
        if (null != e) {
          var t = qme.getSelectedNodeByType(l, "table-cell");
          if (null != t) {
            var n = e.anchor
              , r = e.focus;
            if (one.equals(n.path.slice(0, 3), r.path.slice(0, 3)))
              if (0 !== ene.string(t).length) {
                var o = qme.findPath(l, t)
                  , a = {
                  anchor: Yte.start(l, o),
                  focus: Yte.end(l, o)
                };
                l.select(a)
              } else
                s();
            else
              s()
          } else
            s()
        } else
          s()
      }
      ,
      l
  }
};
xEe("en", {
  videoModule: {
    delete: "Delete",
    uploadVideo: "Upload video",
    insertVideo: "Insert video",
    videoSrc: "Video source",
    videoSrcPlaceHolder: "Video file url, or third-party <iframe>",
    videoPoster: "Video poster",
    videoPosterPlaceHolder: "Poster image url",
    ok: "Ok",
    editSize: "Edit size",
    width: "Width",
    height: "Height"
  }
}),
  xEe("zh-CN", {
    videoModule: {
      delete: "删除视频",
      uploadVideo: "上传视频",
      insertVideo: "插入视频",
      videoSrc: "视频地址",
      videoSrcPlaceHolder: "视频文件 url 或第三方 <iframe>",
      videoPoster: "视频封面",
      videoPosterPlaceHolder: "封面图片 url",
      ok: "确定",
      editSize: "修改尺寸",
      width: "宽度",
      height: "高度"
    }
  });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var sYe = function() {
  return sYe = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++)
      for (var o in t = arguments[n])
        Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    return e
  }
    ,
    sYe.apply(this, arguments)
};
function lYe(e, t, n, r) {
  return new (n || (n = Promise))((function(o, a) {
      function i(e) {
        try {
          l(r.next(e))
        } catch (t) {
          a(t)
        }
      }
      function s(e) {
        try {
          l(r.throw(e))
        } catch (t) {
          a(t)
        }
      }
      function l(e) {
        var t;
        e.done ? o(e.value) : (t = e.value,
          t instanceof n ? t : new n((function(e) {
              e(t)
            }
          ))).then(i, s)
      }
      l((r = r.apply(e, t || [])).next())
    }
  ))
}
function uYe(e, t) {
  var n, r, o, a, i = {
    label: 0,
    sent: function() {
      if (1 & o[0])
        throw o[1];
      return o[1]
    },
    trys: [],
    ops: []
  };
  return a = {
    next: s(0),
    throw: s(1),
    return: s(2)
  },
  "function" == typeof Symbol && (a[Symbol.iterator] = function() {
      return this
    }
  ),
    a;
  function s(a) {
    return function(s) {
      return function(a) {
        if (n)
          throw new TypeError("Generator is already executing.");
        for (; i; )
          try {
            if (n = 1,
            r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r),
              0) : r.next) && !(o = o.call(r, a[1])).done)
              return o;
            switch (r = 0,
            o && (a = [2 & a[0], o.value]),
              a[0]) {
              case 0:
              case 1:
                o = a;
                break;
              case 4:
                return i.label++,
                  {
                    value: a[1],
                    done: !1
                  };
              case 5:
                i.label++,
                  r = a[1],
                  a = [0];
                continue;
              case 7:
                a = i.ops.pop(),
                  i.trys.pop();
                continue;
              default:
                if (!((o = (o = i.trys).length > 0 && o[o.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                  i = 0;
                  continue
                }
                if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {
                  i.label = a[1];
                  break
                }
                if (6 === a[0] && i.label < o[1]) {
                  i.label = o[1],
                    o = a;
                  break
                }
                if (o && i.label < o[2]) {
                  i.label = o[2],
                    i.ops.push(a);
                  break
                }
                o[2] && i.ops.pop(),
                  i.trys.pop();
                continue
            }
            a = t.call(e, i)
          } catch (s) {
            a = [6, s],
              r = 0
          } finally {
            n = o = 0
          }
        if (5 & a[0])
          throw a[1];
        return {
          value: a[0] ? a[1] : void 0,
          done: !0
        }
      }([a, s])
    }
  }
}
function cYe(e, t) {
  var n = "function" == typeof Symbol && e[Symbol.iterator];
  if (!n)
    return e;
  var r, o, a = n.call(e), i = [];
  try {
    for (; (void 0 === t || t-- > 0) && !(r = a.next()).done; )
      i.push(r.value)
  } catch (s) {
    o = {
      error: s
    }
  } finally {
    try {
      r && !r.done && (n = a.return) && n.call(a)
    } finally {
      if (o)
        throw o.error
    }
  }
  return i
}
var dYe = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function fYe(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports),
    t.exports
}
var pYe, hYe, vYe = function(e) {
  return e && e.Math == Math && e
}, gYe = vYe("object" == typeof globalThis && globalThis) || vYe("object" == typeof window && window) || vYe("object" == typeof self && self) || vYe("object" == typeof dYe && dYe) || function() {
  return this
}() || Function("return this")(), mYe = function(e) {
  try {
    return !!e()
  } catch (t) {
    return !0
  }
}, yYe = !mYe((function() {
    return 7 != Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1]
  }
)), bYe = Function.prototype.call, wYe = bYe.bind ? bYe.bind(bYe) : function() {
  return bYe.apply(bYe, arguments)
}
  , xYe = {}.propertyIsEnumerable, SYe = Object.getOwnPropertyDescriptor, EYe = {
  f: SYe && !xYe.call({
    1: 2
  }, 1) ? function(e) {
      var t = SYe(this, e);
      return !!t && t.enumerable
    }
    : xYe
}, AYe = function(e, t) {
  return {
    enumerable: !(1 & e),
    configurable: !(2 & e),
    writable: !(4 & e),
    value: t
  }
}, CYe = Function.prototype, kYe = CYe.bind, TYe = CYe.call, DYe = kYe && kYe.bind(TYe), OYe = kYe ? function(e) {
    return e && DYe(TYe, e)
  }
  : function(e) {
    return e && function() {
      return TYe.apply(e, arguments)
    }
  }
  , _Ye = OYe({}.toString), RYe = OYe("".slice), LYe = function(e) {
  return RYe(_Ye(e), 8, -1)
}, IYe = gYe.Object, PYe = OYe("".split), FYe = mYe((function() {
    return !IYe("z").propertyIsEnumerable(0)
  }
)) ? function(e) {
    return "String" == LYe(e) ? PYe(e, "") : IYe(e)
  }
  : IYe, BYe = gYe.TypeError, NYe = function(e) {
  if (null == e)
    throw BYe("Can't call method on " + e);
  return e
}, MYe = function(e) {
  return FYe(NYe(e))
}, jYe = function(e) {
  return "function" == typeof e
}, VYe = function(e) {
  return "object" == typeof e ? null !== e : jYe(e)
}, UYe = function(e, t) {
  return arguments.length < 2 ? function(e) {
    return jYe(e) ? e : void 0
  }(gYe[e]) : gYe[e] && gYe[e][t]
}, $Ye = OYe({}.isPrototypeOf), HYe = UYe("navigator", "userAgent") || "", zYe = gYe.process, KYe = gYe.Deno, WYe = zYe && zYe.versions || KYe && KYe.version, GYe = WYe && WYe.v8;
GYe && (hYe = (pYe = GYe.split("."))[0] > 0 && pYe[0] < 4 ? 1 : +(pYe[0] + pYe[1])),
!hYe && HYe && (!(pYe = HYe.match(/Edge\/(\d+)/)) || pYe[1] >= 74) && (pYe = HYe.match(/Chrome\/(\d+)/)) && (hYe = +pYe[1]);
var qYe = hYe
  , YYe = !!Object.getOwnPropertySymbols && !mYe((function() {
    var e = Symbol();
    return !String(e) || !(Object(e)instanceof Symbol) || !Symbol.sham && qYe && qYe < 41
  }
))
  , XYe = YYe && !Symbol.sham && "symbol" == typeof Symbol.iterator
  , QYe = gYe.Object
  , JYe = XYe ? function(e) {
    return "symbol" == typeof e
  }
  : function(e) {
    var t = UYe("Symbol");
    return jYe(t) && $Ye(t.prototype, QYe(e))
  }
  , ZYe = gYe.String
  , eXe = function(e) {
  try {
    return ZYe(e)
  } catch (t) {
    return "Object"
  }
}
  , tXe = gYe.TypeError
  , nXe = function(e) {
  if (jYe(e))
    return e;
  throw tXe(eXe(e) + " is not a function")
}
  , rXe = function(e, t) {
  var n = e[t];
  return null == n ? void 0 : nXe(n)
}
  , oXe = gYe.TypeError
  , aXe = Object.defineProperty
  , iXe = function(e, t) {
  try {
    aXe(gYe, e, {
      value: t,
      configurable: !0,
      writable: !0
    })
  } catch (AEe) {
    gYe[e] = t
  }
  return t
}
  , sXe = gYe["__core-js_shared__"] || iXe("__core-js_shared__", {})
  , lXe = fYe((function(e) {
    (e.exports = function(e, t) {
        return sXe[e] || (sXe[e] = void 0 !== t ? t : {})
      }
    )("versions", []).push({
      version: "3.19.3",
      mode: "global",
      copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
    })
  }
))
  , uXe = gYe.Object
  , cXe = function(e) {
  return uXe(NYe(e))
}
  , dXe = OYe({}.hasOwnProperty)
  , fXe = Object.hasOwn || function(e, t) {
  return dXe(cXe(e), t)
}
  , pXe = 0
  , hXe = Math.random()
  , vXe = OYe(1..toString)
  , gXe = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + vXe(++pXe + hXe, 36)
}
  , mXe = lXe("wks")
  , yXe = gYe.Symbol
  , bXe = yXe && yXe.for
  , wXe = XYe ? yXe : yXe && yXe.withoutSetter || gXe
  , xXe = function(e) {
  if (!fXe(mXe, e) || !YYe && "string" != typeof mXe[e]) {
    var t = "Symbol." + e;
    YYe && fXe(yXe, e) ? mXe[e] = yXe[e] : mXe[e] = XYe && bXe ? bXe(t) : wXe(t)
  }
  return mXe[e]
}
  , SXe = gYe.TypeError
  , EXe = xXe("toPrimitive")
  , AXe = function(e) {
  var t = function(e, t) {
    if (!VYe(e) || JYe(e))
      return e;
    var n, r = rXe(e, EXe);
    if (r) {
      if (void 0 === t && (t = "default"),
        n = wYe(r, e, t),
      !VYe(n) || JYe(n))
        return n;
      throw SXe("Can't convert object to primitive value")
    }
    return void 0 === t && (t = "number"),
      function(e, t) {
        var n, r;
        if ("string" === t && jYe(n = e.toString) && !VYe(r = wYe(n, e)))
          return r;
        if (jYe(n = e.valueOf) && !VYe(r = wYe(n, e)))
          return r;
        if ("string" !== t && jYe(n = e.toString) && !VYe(r = wYe(n, e)))
          return r;
        throw oXe("Can't convert object to primitive value")
      }(e, t)
  }(e, "string");
  return JYe(t) ? t : t + ""
}
  , CXe = gYe.document
  , kXe = VYe(CXe) && VYe(CXe.createElement)
  , TXe = function(e) {
  return kXe ? CXe.createElement(e) : {}
}
  , DXe = !yYe && !mYe((function() {
    return 7 != Object.defineProperty(TXe("div"), "a", {
      get: function() {
        return 7
      }
    }).a
  }
))
  , OXe = Object.getOwnPropertyDescriptor
  , _Xe = {
  f: yYe ? OXe : function(e, t) {
    if (e = MYe(e),
      t = AXe(t),
      DXe)
      try {
        return OXe(e, t)
      } catch (n) {}
    if (fXe(e, t))
      return AYe(!wYe(EYe.f, e, t), e[t])
  }
}
  , RXe = gYe.String
  , LXe = gYe.TypeError
  , IXe = function(e) {
  if (VYe(e))
    return e;
  throw LXe(RXe(e) + " is not an object")
}
  , PXe = gYe.TypeError
  , FXe = Object.defineProperty
  , BXe = {
  f: yYe ? FXe : function(e, t, n) {
    if (IXe(e),
      t = AXe(t),
      IXe(n),
      DXe)
      try {
        return FXe(e, t, n)
      } catch (r) {}
    if ("get"in n || "set"in n)
      throw PXe("Accessors not supported");
    return "value"in n && (e[t] = n.value),
      e
  }
}
  , NXe = yYe ? function(e, t, n) {
    return BXe.f(e, t, AYe(1, n))
  }
  : function(e, t, n) {
    return e[t] = n,
      e
  }
  , MXe = OYe(Function.toString);
jYe(sXe.inspectSource) || (sXe.inspectSource = function(e) {
    return MXe(e)
  }
);
var jXe, VXe, UXe, $Xe = sXe.inspectSource, HXe = gYe.WeakMap, zXe = jYe(HXe) && /native code/.test($Xe(HXe)), KXe = lXe("keys"), WXe = function(e) {
  return KXe[e] || (KXe[e] = gXe(e))
}, GXe = {}, qXe = gYe.TypeError, YXe = gYe.WeakMap;
if (zXe || sXe.state) {
  var XXe = sXe.state || (sXe.state = new YXe)
    , QXe = OYe(XXe.get)
    , JXe = OYe(XXe.has)
    , ZXe = OYe(XXe.set);
  jXe = function(e, t) {
    if (JXe(XXe, e))
      throw new qXe("Object already initialized");
    return t.facade = e,
      ZXe(XXe, e, t),
      t
  }
    ,
    VXe = function(e) {
      return QXe(XXe, e) || {}
    }
    ,
    UXe = function(e) {
      return JXe(XXe, e)
    }
} else {
  var eQe = WXe("state");
  GXe[eQe] = !0,
    jXe = function(e, t) {
      if (fXe(e, eQe))
        throw new qXe("Object already initialized");
      return t.facade = e,
        NXe(e, eQe, t),
        t
    }
    ,
    VXe = function(e) {
      return fXe(e, eQe) ? e[eQe] : {}
    }
    ,
    UXe = function(e) {
      return fXe(e, eQe)
    }
}
var tQe = {
  set: jXe,
  get: VXe,
  has: UXe,
  enforce: function(e) {
    return UXe(e) ? VXe(e) : jXe(e, {})
  },
  getterFor: function(e) {
    return function(t) {
      var n;
      if (!VYe(t) || (n = VXe(t)).type !== e)
        throw qXe("Incompatible receiver, " + e + " required");
      return n
    }
  }
}
  , nQe = Function.prototype
  , rQe = yYe && Object.getOwnPropertyDescriptor
  , oQe = fXe(nQe, "name")
  , aQe = {
  EXISTS: oQe,
  PROPER: oQe && "something" === function() {}
    .name,
  CONFIGURABLE: oQe && (!yYe || yYe && rQe(nQe, "name").configurable)
}
  , iQe = fYe((function(e) {
    var t = aQe.CONFIGURABLE
      , n = tQe.get
      , r = tQe.enforce
      , o = String(String).split("String");
    (e.exports = function(e, n, a, i) {
        var s, l = !!i && !!i.unsafe, u = !!i && !!i.enumerable, c = !!i && !!i.noTargetGet, d = i && void 0 !== i.name ? i.name : n;
        jYe(a) && ("Symbol(" === String(d).slice(0, 7) && (d = "[" + String(d).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
        (!fXe(a, "name") || t && a.name !== d) && NXe(a, "name", d),
        (s = r(a)).source || (s.source = o.join("string" == typeof d ? d : ""))),
          e !== gYe ? (l ? !c && e[n] && (u = !0) : delete e[n],
            u ? e[n] = a : NXe(e, n, a)) : u ? e[n] = a : iXe(n, a)
      }
    )(Function.prototype, "toString", (function() {
        return jYe(this) && n(this).source || $Xe(this)
      }
    ))
  }
))
  , sQe = Math.ceil
  , lQe = Math.floor
  , uQe = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : (t > 0 ? lQe : sQe)(t)
}
  , cQe = Math.max
  , dQe = Math.min
  , fQe = function(e, t) {
  var n = uQe(e);
  return n < 0 ? cQe(n + t, 0) : dQe(n, t)
}
  , pQe = Math.min
  , hQe = function(e) {
  return e > 0 ? pQe(uQe(e), 9007199254740991) : 0
}
  , vQe = function(e) {
  return hQe(e.length)
}
  , gQe = function(e) {
  return function(t, n, r) {
    var o, a = MYe(t), i = vQe(a), s = fQe(r, i);
    if (e && n != n) {
      for (; i > s; )
        if ((o = a[s++]) != o)
          return !0
    } else
      for (; i > s; s++)
        if ((e || s in a) && a[s] === n)
          return e || s || 0;
    return !e && -1
  }
}
  , mQe = {
  includes: gQe(!0),
  indexOf: gQe(!1)
}
  , yQe = mQe.indexOf
  , bQe = OYe([].push)
  , wQe = function(e, t) {
  var n, r = MYe(e), o = 0, a = [];
  for (n in r)
    !fXe(GXe, n) && fXe(r, n) && bQe(a, n);
  for (; t.length > o; )
    fXe(r, n = t[o++]) && (~yQe(a, n) || bQe(a, n));
  return a
}
  , xQe = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
  , SQe = xQe.concat("length", "prototype")
  , EQe = {
  f: Object.getOwnPropertyNames || function(e) {
    return wQe(e, SQe)
  }
}
  , AQe = {
  f: Object.getOwnPropertySymbols
}
  , CQe = OYe([].concat)
  , kQe = UYe("Reflect", "ownKeys") || function(e) {
  var t = EQe.f(IXe(e))
    , n = AQe.f;
  return n ? CQe(t, n(e)) : t
}
  , TQe = function(e, t) {
  for (var n = kQe(t), r = BXe.f, o = _Xe.f, a = 0; a < n.length; a++) {
    var i = n[a];
    fXe(e, i) || r(e, i, o(t, i))
  }
}
  , DQe = /#|\.prototype\./
  , OQe = function(e, t) {
  var n = RQe[_Qe(e)];
  return n == IQe || n != LQe && (jYe(t) ? mYe(t) : !!t)
}
  , _Qe = OQe.normalize = function(e) {
  return String(e).replace(DQe, ".").toLowerCase()
}
  , RQe = OQe.data = {}
  , LQe = OQe.NATIVE = "N"
  , IQe = OQe.POLYFILL = "P"
  , PQe = OQe
  , FQe = _Xe.f
  , BQe = function(e, t) {
  var n, r, o, a, i, s = e.target, l = e.global, u = e.stat;
  if (n = l ? gYe : u ? gYe[s] || iXe(s, {}) : (gYe[s] || {}).prototype)
    for (r in t) {
      if (a = t[r],
        o = e.noTargetGet ? (i = FQe(n, r)) && i.value : n[r],
      !PQe(l ? r : s + (u ? "." : "#") + r, e.forced) && void 0 !== o) {
        if (typeof a == typeof o)
          continue;
        TQe(a, o)
      }
      (e.sham || o && o.sham) && NXe(a, "sham", !0),
        iQe(n, r, a, e)
    }
}
  , NQe = {};
NQe[xXe("toStringTag")] = "z";
var MQe = "[object z]" === String(NQe)
  , jQe = xXe("toStringTag")
  , VQe = gYe.Object
  , UQe = "Arguments" == LYe(function() {
  return arguments
}())
  , $Qe = MQe ? LYe : function(e) {
  var t, n, r;
  return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
    try {
      return e[t]
    } catch (n) {}
  }(t = VQe(e), jQe)) ? n : UQe ? LYe(t) : "Object" == (r = LYe(t)) && jYe(t.callee) ? "Arguments" : r
}
  , HQe = gYe.String
  , zQe = function(e) {
  if ("Symbol" === $Qe(e))
    throw TypeError("Cannot convert a Symbol value to a string");
  return HQe(e)
}
  , KQe = "\t\n\v\f\r                　\u2028\u2029\ufeff"
  , WQe = OYe("".replace)
  , GQe = "[" + KQe + "]"
  , qQe = RegExp("^" + GQe + GQe + "*")
  , YQe = RegExp(GQe + GQe + "*$")
  , XQe = function(e) {
  return function(t) {
    var n = zQe(NYe(t));
    return 1 & e && (n = WQe(n, qQe, "")),
    2 & e && (n = WQe(n, YQe, "")),
      n
  }
}
  , QQe = {
  start: XQe(1),
  end: XQe(2),
  trim: XQe(3)
}
  , JQe = aQe.PROPER
  , ZQe = QQe.trim;
function eJe(e) {
  return e.length ? e[0].tagName.toLowerCase() : ""
}
function tJe(e, t, n) {
  void 0 === t && (t = "auto"),
  void 0 === n && (n = "auto");
  var r = Qre(e);
  return r.attr("width", t),
    r.attr("height", n),
    r[0].outerHTML
}
BQe({
  target: "String",
  proto: !0,
  forced: mYe((function() {
      return !!KQe.trim() || "​᠎" !== "​᠎".trim() || JQe && "trim" !== KQe.trim.name
    }
  ))
}, {
  trim: function() {
    return ZQe(this)
  }
}),
  BQe({
    global: !0
  }, {
    globalThis: gYe
  }),
yoe && (Qre.fn.append = yoe),
aoe && (Qre.fn.on = aoe),
Ooe && (Qre.fn.focus = Ooe),
toe && (Qre.fn.attr = toe),
ooe && (Qre.fn.val = ooe),
voe && (Qre.fn.html = voe),
woe && (Qre.fn.parent = woe),
eoe && (Qre.fn.hasClass = eoe),
Coe && (Qre.fn.empty = Coe);
var nJe, rJe = {
  type: "video",
  renderElem: function(e, t, n) {
    var r, o = e, a = o.src, i = void 0 === a ? "" : a, s = o.poster, l = void 0 === s ? "" : s, u = o.width, c = void 0 === u ? "auto" : u, d = o.height, f = void 0 === d ? "auto" : d, p = qme.isNodeSelected(n, e);
    if (0 === i.trim().indexOf("<iframe "))
      r = $ae("div", {
        className: "w-e-textarea-video-container",
        "data-selected": p ? "true" : "",
        innerHTML: tJe(i, c, f)
      });
    else {
      var h = $ae("video", {
        poster: l,
        controls: !0
      }, $ae("source", {
        src: i,
        type: "video/mp4"
      }), "Sorry, your browser doesn't support embedded videos.\n 抱歉，浏览器不支持 video 视频");
      "auto" !== c && (h.data.width = c),
      "auto" !== f && (h.data.height = f),
        r = $ae("div", {
          className: "w-e-textarea-video-container",
          "data-selected": p ? "true" : ""
        }, h)
    }
    return Sae("div", {
      props: {
        contentEditable: !1
      },
      on: {
        mousedown: function(e) {
          return e.preventDefault()
        }
      }
    }, r)
  }
}, oJe = {
  type: "video",
  elemToHtml: function(e, t) {
    var n = e
      , r = n.src
      , o = void 0 === r ? "" : r
      , a = n.poster
      , i = void 0 === a ? "" : a
      , s = n.width
      , l = void 0 === s ? "auto" : s
      , u = n.height
      , c = void 0 === u ? "auto" : u
      , d = '<div data-w-e-type="video" data-w-e-is-void>\n';
    return 0 === o.trim().indexOf("<iframe ") ? d += tJe(o, l, c) : d += '<video poster="' + i + '" controls="true" width="' + l + '" height="' + c + '"><source src="' + o + '" type="video/mp4"/></video>',
    d + "\n</div>"
  }
}, aJe = Object.keys || function(e) {
  return wQe(e, xQe)
}
  , iJe = yYe ? Object.defineProperties : function(e, t) {
  IXe(e);
  for (var n, r = MYe(t), o = aJe(t), a = o.length, i = 0; a > i; )
    BXe.f(e, n = o[i++], r[n]);
  return e
}
  , sJe = UYe("document", "documentElement"), lJe = WXe("IE_PROTO"), uJe = function() {}, cJe = function(e) {
  return "<script>" + e + "<\/script>"
}, dJe = function(e) {
  e.write(cJe("")),
    e.close();
  var t = e.parentWindow.Object;
  return e = null,
    t
}, fJe = function() {
  try {
    nJe = new ActiveXObject("htmlfile")
  } catch (r) {}
  var e, t;
  fJe = "undefined" != typeof document ? document.domain && nJe ? dJe(nJe) : ((t = TXe("iframe")).style.display = "none",
    sJe.appendChild(t),
    t.src = String("javascript:"),
    (e = t.contentWindow.document).open(),
    e.write(cJe("document.F=Object")),
    e.close(),
    e.F) : dJe(nJe);
  for (var n = xQe.length; n--; )
    delete fJe.prototype[xQe[n]];
  return fJe()
};
GXe[lJe] = !0;
var pJe = Object.create || function(e, t) {
  var n;
  return null !== e ? (uJe.prototype = IXe(e),
    n = new uJe,
    uJe.prototype = null,
    n[lJe] = e) : n = fJe(),
    void 0 === t ? n : iJe(n, t)
}
  , hJe = xXe("unscopables")
  , vJe = Array.prototype;
null == vJe[hJe] && BXe.f(vJe, hJe, {
  configurable: !0,
  value: pJe(null)
});
var gJe = function(e) {
  vJe[hJe][e] = !0
}
  , mJe = mQe.includes;
BQe({
  target: "Array",
  proto: !0
}, {
  includes: function(e) {
    return mJe(this, e, arguments.length > 1 ? arguments[1] : void 0)
  }
}),
  gJe("includes");
var yJe = {
  selector: "iframe,video,p",
  preParseHtml: function(e) {
    var t = Qre(e)
      , n = t;
    if ("p" === eJe(t)) {
      var r = t.children();
      if (1 === r.length) {
        var o = r[0]
          , a = o.tagName.toLowerCase();
        ["iframe", "video"].includes(a) && (n = Qre(o))
      }
    }
    var i = eJe(n);
    if ("iframe" !== i && "video" !== i)
      return n[0];
    if ("video" === n.parent().attr("data-w-e-type"))
      return n[0];
    var s = Qre('<div data-w-e-type="video" data-w-e-is-void></div>');
    return s.append(n),
      s[0]
  }
}
  , bJe = OYe(OYe.bind)
  , wJe = function(e, t) {
  return nXe(e),
    void 0 === t ? e : bJe ? bJe(e, t) : function() {
      return e.apply(t, arguments)
    }
}
  , xJe = Array.isArray || function(e) {
  return "Array" == LYe(e)
}
  , SJe = function() {}
  , EJe = []
  , AJe = UYe("Reflect", "construct")
  , CJe = /^\s*(?:class|function)\b/
  , kJe = OYe(CJe.exec)
  , TJe = !CJe.exec(SJe)
  , DJe = function(e) {
  if (!jYe(e))
    return !1;
  try {
    return AJe(SJe, EJe, e),
      !0
  } catch (t) {
    return !1
  }
}
  , OJe = !AJe || mYe((function() {
    var e;
    return DJe(DJe.call) || !DJe(Object) || !DJe((function() {
        e = !0
      }
    )) || e
  }
)) ? function(e) {
    if (!jYe(e))
      return !1;
    switch ($Qe(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    return TJe || !!kJe(CJe, $Xe(e))
  }
  : DJe
  , _Je = xXe("species")
  , RJe = gYe.Array
  , LJe = function(e, t) {
  return new (xJe(n = e) && (r = n.constructor,
  (OJe(r) && (r === RJe || xJe(r.prototype)) || VYe(r) && null === (r = r[_Je])) && (r = void 0)),
    void 0 === r ? RJe : r)(0 === t ? 0 : t);
  var n, r
}
  , IJe = OYe([].push)
  , PJe = function(e) {
  var t = 1 == e
    , n = 2 == e
    , r = 3 == e
    , o = 4 == e
    , a = 6 == e
    , i = 7 == e
    , s = 5 == e || a;
  return function(l, u, c, d) {
    for (var f, p, h = cXe(l), v = FYe(h), g = wJe(u, c), m = vQe(v), y = 0, b = d || LJe, w = t ? b(l, m) : n || i ? b(l, 0) : void 0; m > y; y++)
      if ((s || y in v) && (p = g(f = v[y], y, h),
        e))
        if (t)
          w[y] = p;
        else if (p)
          switch (e) {
            case 3:
              return !0;
            case 5:
              return f;
            case 6:
              return y;
            case 2:
              IJe(w, f)
          }
        else
          switch (e) {
            case 4:
              return !1;
            case 7:
              IJe(w, f)
          }
    return a ? -1 : r || o ? o : w
  }
}
  , FJe = {
  forEach: PJe(0),
  map: PJe(1),
  filter: PJe(2),
  some: PJe(3),
  every: PJe(4),
  find: PJe(5),
  findIndex: PJe(6),
  filterReject: PJe(7)
}
  , BJe = FJe.find
  , NJe = !0;
"find"in [] && Array(1).find((function() {
    NJe = !1
  }
)),
  BQe({
    target: "Array",
    proto: !0,
    forced: NJe
  }, {
    find: function(e) {
      return BJe(this, e, arguments.length > 1 ? arguments[1] : void 0)
    }
  }),
  gJe("find");
var MJe = MQe ? {}.toString : function() {
    return "[object " + $Qe(this) + "]"
  }
;
function jJe(e, t, n, r) {
  return void 0 === t && (t = ""),
  void 0 === n && (n = "auto"),
  void 0 === r && (r = "auto"),
    {
      type: "video",
      src: e,
      poster: t,
      width: n,
      height: r,
      children: [{
        text: ""
      }]
    }
}
MQe || iQe(Object.prototype, "toString", MJe, {
  unsafe: !0
});
var VJe, UJe, $Je = {
  selector: 'div[data-w-e-type="video"]',
  parseElemHtml: function(e, t, n) {
    var r = Qre(e)
      , o = ""
      , a = ""
      , i = "auto"
      , s = "auto"
      , l = r.find("iframe");
    if (l.length > 0)
      return i = l.attr("width") || "auto",
        s = l.attr("height") || "auto",
        jJe(o = l[0].outerHTML, a, i, s);
    var u = r.find("video");
    return (o = u.attr("src") || "") || u.length > 0 && (o = u.find("source").attr("src") || ""),
      i = u.attr("width") || "auto",
      s = u.attr("height") || "auto",
      jJe(o, a = u.attr("poster") || "", i, s)
  }
}, HJe = function() {
  var e = IXe(this)
    , t = "";
  return e.global && (t += "g"),
  e.ignoreCase && (t += "i"),
  e.multiline && (t += "m"),
  e.dotAll && (t += "s"),
  e.unicode && (t += "u"),
  e.sticky && (t += "y"),
    t
}, zJe = gYe.RegExp, KJe = mYe((function() {
    var e = zJe("a", "y");
    return e.lastIndex = 2,
    null != e.exec("abcd")
  }
)), WJe = KJe || mYe((function() {
    return !zJe("a", "y").sticky
  }
)), GJe = {
  BROKEN_CARET: KJe || mYe((function() {
      var e = zJe("^r", "gy");
      return e.lastIndex = 2,
      null != e.exec("str")
    }
  )),
  MISSED_STICKY: WJe,
  UNSUPPORTED_Y: KJe
}, qJe = gYe.RegExp, YJe = mYe((function() {
    var e = qJe(".", "s");
    return !(e.dotAll && e.exec("\n") && "s" === e.flags)
  }
)), XJe = gYe.RegExp, QJe = mYe((function() {
    var e = XJe("(?<a>b)", "g");
    return "b" !== e.exec("b").groups.a || "bc" !== "b".replace(e, "$<a>c")
  }
)), JJe = tQe.get, ZJe = lXe("native-string-replace", String.prototype.replace), eZe = RegExp.prototype.exec, tZe = eZe, nZe = OYe("".charAt), rZe = OYe("".indexOf), oZe = OYe("".replace), aZe = OYe("".slice), iZe = (UJe = /b*/g,
  wYe(eZe, VJe = /a/, "a"),
  wYe(eZe, UJe, "a"),
0 !== VJe.lastIndex || 0 !== UJe.lastIndex), sZe = GJe.BROKEN_CARET, lZe = void 0 !== /()??/.exec("")[1];
(iZe || lZe || sZe || YJe || QJe) && (tZe = function(e) {
    var t, n, r, o, a, i, s, l = this, u = JJe(l), c = zQe(e), d = u.raw;
    if (d)
      return d.lastIndex = l.lastIndex,
        t = wYe(tZe, d, c),
        l.lastIndex = d.lastIndex,
        t;
    var f = u.groups
      , p = sZe && l.sticky
      , h = wYe(HJe, l)
      , v = l.source
      , g = 0
      , m = c;
    if (p && (h = oZe(h, "y", ""),
    -1 === rZe(h, "g") && (h += "g"),
      m = aZe(c, l.lastIndex),
    l.lastIndex > 0 && (!l.multiline || l.multiline && "\n" !== nZe(c, l.lastIndex - 1)) && (v = "(?: " + v + ")",
      m = " " + m,
      g++),
      n = new RegExp("^(?:" + v + ")",h)),
    lZe && (n = new RegExp("^" + v + "$(?!\\s)",h)),
    iZe && (r = l.lastIndex),
      o = wYe(eZe, p ? n : l, m),
      p ? o ? (o.input = aZe(o.input, g),
        o[0] = aZe(o[0], g),
        o.index = l.lastIndex,
        l.lastIndex += o[0].length) : l.lastIndex = 0 : iZe && o && (l.lastIndex = l.global ? o.index + o[0].length : r),
    lZe && o && o.length > 1 && wYe(ZJe, o[0], n, (function() {
        for (a = 1; a < arguments.length - 2; a++)
          void 0 === arguments[a] && (o[a] = void 0)
      }
    )),
    o && f)
      for (o.groups = i = pJe(null),
             a = 0; a < f.length; a++)
        i[(s = f[a])[0]] = o[s[1]];
    return o
  }
);
var uZe = tZe;
BQe({
  target: "RegExp",
  proto: !0,
  forced: /./.exec !== uZe
}, {
  exec: uZe
});
var cZe = Function.prototype
  , dZe = cZe.apply
  , fZe = cZe.bind
  , pZe = cZe.call
  , hZe = "object" == typeof Reflect && Reflect.apply || (fZe ? pZe.bind(dZe) : function() {
    return pZe.apply(dZe, arguments)
  }
)
  , vZe = (xXe("species"),
  RegExp.prototype)
  , gZe = OYe("".charAt)
  , mZe = OYe("".charCodeAt)
  , yZe = OYe("".slice)
  , bZe = function(e) {
  return function(t, n) {
    var r, o, a = zQe(NYe(t)), i = uQe(n), s = a.length;
    return i < 0 || i >= s ? e ? "" : void 0 : (r = mZe(a, i)) < 55296 || r > 56319 || i + 1 === s || (o = mZe(a, i + 1)) < 56320 || o > 57343 ? e ? gZe(a, i) : r : e ? yZe(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536
  }
}
  , wZe = {
  codeAt: bZe(!1),
  charAt: bZe(!0)
}
  , xZe = wZe.charAt
  , SZe = function(e, t, n) {
  return t + (n ? xZe(e, t).length : 1)
}
  , EZe = Math.floor
  , AZe = OYe("".charAt)
  , CZe = OYe("".replace)
  , kZe = OYe("".slice)
  , TZe = /\$([$&'`]|\d{1,2}|<[^>]*>)/g
  , DZe = /\$([$&'`]|\d{1,2})/g
  , OZe = function(e, t, n, r, o, a) {
  var i = n + e.length
    , s = r.length
    , l = DZe;
  return void 0 !== o && (o = cXe(o),
    l = TZe),
    CZe(a, l, (function(a, l) {
        var u;
        switch (AZe(l, 0)) {
          case "$":
            return "$";
          case "&":
            return e;
          case "`":
            return kZe(t, 0, n);
          case "'":
            return kZe(t, i);
          case "<":
            u = o[kZe(l, 1, -1)];
            break;
          default:
            var c = +l;
            if (0 === c)
              return a;
            if (c > s) {
              var d = EZe(c / 10);
              return 0 === d ? a : d <= s ? void 0 === r[d - 1] ? AZe(l, 1) : r[d - 1] + AZe(l, 1) : a
            }
            u = r[c - 1]
        }
        return void 0 === u ? "" : u
      }
    ))
}
  , _Ze = gYe.TypeError
  , RZe = function(e, t) {
  var n = e.exec;
  if (jYe(n)) {
    var r = wYe(n, e, t);
    return null !== r && IXe(r),
      r
  }
  if ("RegExp" === LYe(e))
    return wYe(uZe, e, t);
  throw _Ze("RegExp#exec called on incompatible receiver")
}
  , LZe = xXe("replace")
  , IZe = Math.max
  , PZe = Math.min
  , FZe = OYe([].concat)
  , BZe = OYe([].push)
  , NZe = OYe("".indexOf)
  , MZe = OYe("".slice)
  , jZe = "$0" === "a".replace(/./, "$0")
  , VZe = !!/./[LZe] && "" === /./[LZe]("a", "$0");
function UZe(e) {
  return void 0 === e && (e = "r"),
  e + "-" + Goe()
}
!function(e, t, n, r) {
  var o, a, i = xXe(e), s = !mYe((function() {
      var t = {};
      return t[i] = function() {
        return 7
      }
        ,
      7 != ""[e](t)
    }
  )), l = s && !mYe((function() {
      var e = !1
        , t = /a/;
      return t.exec = function() {
        return e = !0,
          null
      }
        ,
        t[i](""),
        !e
    }
  ));
  if (!s || !l || n) {
    var u = OYe(/./[i])
      , c = (o = ""[e],
      a = VZe ? "$" : "$0",
      [function(e, t) {
        var n = NYe(this)
          , r = null == e ? void 0 : rXe(e, LZe);
        return r ? wYe(r, e, n, t) : wYe(o, zQe(n), e, t)
      }
        , function(e, t) {
        var n = IXe(this)
          , r = zQe(e);
        if ("string" == typeof t && -1 === NZe(t, a) && -1 === NZe(t, "$<")) {
          var i = function(e, t, n, r, o) {
            var a = OYe(e)
              , i = t.exec;
            return i === uZe || i === vZe.exec ? s && !o ? {
              done: !0,
              value: u(t, n, r)
            } : {
              done: !0,
              value: a(n, t, r)
            } : {
              done: !1
            }
          }(o, n, r, t);
          if (i.done)
            return i.value
        }
        var l = jYe(t);
        l || (t = zQe(t));
        var c = n.global;
        if (c) {
          var d = n.unicode;
          n.lastIndex = 0
        }
        for (var f = []; ; ) {
          var p = RZe(n, r);
          if (null === p)
            break;
          if (BZe(f, p),
            !c)
            break;
          "" === zQe(p[0]) && (n.lastIndex = SZe(r, hQe(n.lastIndex), d))
        }
        for (var h, v = "", g = 0, m = 0; m < f.length; m++) {
          for (var y = zQe((p = f[m])[0]), b = IZe(PZe(uQe(p.index), r.length), 0), w = [], x = 1; x < p.length; x++)
            BZe(w, void 0 === (h = p[x]) ? h : String(h));
          var S = p.groups;
          if (l) {
            var E = FZe([y], w, b, r);
            void 0 !== S && BZe(E, S);
            var A = zQe(hZe(t, void 0, E))
          } else
            A = OZe(y, r, b, w, S, t);
          b >= g && (v += MZe(r, g, b) + A,
            g = b + y.length)
        }
        return v + MZe(r, g)
      }
      ]);
    iQe(String.prototype, e, c[0]),
      iQe(vZe, i, c[1])
  }
}("replace", 0, !!mYe((function() {
    var e = /./;
    return e.exec = function() {
      var e = [];
      return e.groups = {
        a: "7"
      },
        e
    }
      ,
    "7" !== "".replace(e, "$<a>")
  }
)) || !jZe || VZe);
var $Ze = gYe.Promise
  , HZe = function(e, t, n) {
  for (var r in t)
    iQe(e, r, t[r], n);
  return e
}
  , zZe = gYe.String
  , KZe = gYe.TypeError
  , WZe = Object.setPrototypeOf || ("__proto__"in {} ? function() {
  var e, t = !1, n = {};
  try {
    (e = OYe(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n, []),
      t = n instanceof Array
  } catch (r) {}
  return function(n, r) {
    return IXe(n),
      function(e) {
        if ("object" == typeof e || jYe(e))
          return e;
        throw KZe("Can't set " + zZe(e) + " as a prototype")
      }(r),
      t ? e(n, r) : n.__proto__ = r,
      n
  }
}() : void 0)
  , GZe = BXe.f
  , qZe = xXe("toStringTag")
  , YZe = function(e, t, n) {
  e && !fXe(e = n ? e : e.prototype, qZe) && GZe(e, qZe, {
    configurable: !0,
    value: t
  })
}
  , XZe = xXe("species")
  , QZe = gYe.TypeError
  , JZe = function(e, t) {
  if ($Ye(t, e))
    return e;
  throw QZe("Incorrect invocation")
}
  , ZZe = {}
  , e0e = xXe("iterator")
  , t0e = Array.prototype
  , n0e = xXe("iterator")
  , r0e = function(e) {
  if (null != e)
    return rXe(e, n0e) || rXe(e, "@@iterator") || ZZe[$Qe(e)]
}
  , o0e = gYe.TypeError
  , a0e = function(e, t, n) {
  var r, o;
  IXe(e);
  try {
    if (!(r = rXe(e, "return"))) {
      if ("throw" === t)
        throw n;
      return n
    }
    r = wYe(r, e)
  } catch (a) {
    o = !0,
      r = a
  }
  if ("throw" === t)
    throw n;
  if (o)
    throw r;
  return IXe(r),
    n
}
  , i0e = gYe.TypeError
  , s0e = function(e, t) {
  this.stopped = e,
    this.result = t
}
  , l0e = s0e.prototype
  , u0e = function(e, t, n) {
  var r, o, a, i, s, l, u, c, d = n && n.that, f = !(!n || !n.AS_ENTRIES), p = !(!n || !n.IS_ITERATOR), h = !(!n || !n.INTERRUPTED), v = wJe(t, d), g = function(e) {
    return r && a0e(r, "normal", e),
      new s0e(!0,e)
  }, m = function(e) {
    return f ? (IXe(e),
      h ? v(e[0], e[1], g) : v(e[0], e[1])) : h ? v(e, g) : v(e)
  };
  if (p)
    r = e;
  else {
    if (!(o = r0e(e)))
      throw i0e(eXe(e) + " is not iterable");
    if (void 0 !== (c = o) && (ZZe.Array === c || t0e[e0e] === c)) {
      for (a = 0,
             i = vQe(e); i > a; a++)
        if ((s = m(e[a])) && $Ye(l0e, s))
          return s;
      return new s0e(!1)
    }
    r = function(e, t) {
      var n = arguments.length < 2 ? r0e(e) : t;
      if (nXe(n))
        return IXe(wYe(n, e));
      throw o0e(eXe(e) + " is not iterable")
    }(e, o)
  }
  for (l = r.next; !(u = wYe(l, r)).done; ) {
    try {
      s = m(u.value)
    } catch (y) {
      a0e(r, "throw", y)
    }
    if ("object" == typeof s && s && $Ye(l0e, s))
      return s
  }
  return new s0e(!1)
}
  , c0e = xXe("iterator")
  , d0e = !1;
try {
  var f0e = 0
    , p0e = {
    next: function() {
      return {
        done: !!f0e++
      }
    },
    return: function() {
      d0e = !0
    }
  };
  p0e[c0e] = function() {
    return this
  }
    ,
    Array.from(p0e, (function() {
        throw 2
      }
    ))
} catch (lbt) {}
var h0e, v0e, g0e, m0e, y0e = function(e, t) {
  if (!t && !d0e)
    return !1;
  var n = !1;
  try {
    var r = {};
    r[c0e] = function() {
      return {
        next: function() {
          return {
            done: n = !0
          }
        }
      }
    }
      ,
      e(r)
  } catch (o) {}
  return n
}, b0e = gYe.TypeError, w0e = xXe("species"), x0e = OYe([].slice), S0e = /(?:ipad|iphone|ipod).*applewebkit/i.test(HYe), E0e = "process" == LYe(gYe.process), A0e = gYe.setImmediate, C0e = gYe.clearImmediate, k0e = gYe.process, T0e = gYe.Dispatch, D0e = gYe.Function, O0e = gYe.MessageChannel, _0e = gYe.String, R0e = 0, L0e = {};
try {
  h0e = gYe.location
} catch (lbt) {}
var I0e = function(e) {
  if (fXe(L0e, e)) {
    var t = L0e[e];
    delete L0e[e],
      t()
  }
}
  , P0e = function(e) {
  return function() {
    I0e(e)
  }
}
  , F0e = function(e) {
  I0e(e.data)
}
  , B0e = function(e) {
  gYe.postMessage(_0e(e), h0e.protocol + "//" + h0e.host)
};
A0e && C0e || (A0e = function(e) {
    var t = x0e(arguments, 1);
    return L0e[++R0e] = function() {
      hZe(jYe(e) ? e : D0e(e), void 0, t)
    }
      ,
      v0e(R0e),
      R0e
  }
    ,
    C0e = function(e) {
      delete L0e[e]
    }
    ,
    E0e ? v0e = function(e) {
        k0e.nextTick(P0e(e))
      }
      : T0e && T0e.now ? v0e = function(e) {
          T0e.now(P0e(e))
        }
        : O0e && !S0e ? (m0e = (g0e = new O0e).port2,
          g0e.port1.onmessage = F0e,
          v0e = wJe(m0e.postMessage, m0e)) : gYe.addEventListener && jYe(gYe.postMessage) && !gYe.importScripts && h0e && "file:" !== h0e.protocol && !mYe(B0e) ? (v0e = B0e,
          gYe.addEventListener("message", F0e, !1)) : v0e = "onreadystatechange"in TXe("script") ? function(e) {
            sJe.appendChild(TXe("script")).onreadystatechange = function() {
              sJe.removeChild(this),
                I0e(e)
            }
          }
          : function(e) {
            setTimeout(P0e(e), 0)
          }
);
var N0e, M0e, j0e, V0e, U0e, $0e, H0e, z0e, K0e = {
  set: A0e,
  clear: C0e
}, W0e = /ipad|iphone|ipod/i.test(HYe) && void 0 !== gYe.Pebble, G0e = /web0s(?!.*chrome)/i.test(HYe), q0e = _Xe.f, Y0e = K0e.set, X0e = gYe.MutationObserver || gYe.WebKitMutationObserver, Q0e = gYe.document, J0e = gYe.process, Z0e = gYe.Promise, e1e = q0e(gYe, "queueMicrotask"), t1e = e1e && e1e.value;
t1e || (N0e = function() {
  var e, t;
  for (E0e && (e = J0e.domain) && e.exit(); M0e; ) {
    t = M0e.fn,
      M0e = M0e.next;
    try {
      t()
    } catch (n) {
      throw M0e ? V0e() : j0e = void 0,
        n
    }
  }
  j0e = void 0,
  e && e.enter()
}
  ,
  S0e || E0e || G0e || !X0e || !Q0e ? !W0e && Z0e && Z0e.resolve ? ((H0e = Z0e.resolve(void 0)).constructor = Z0e,
      z0e = wJe(H0e.then, H0e),
      V0e = function() {
        z0e(N0e)
      }
  ) : E0e ? V0e = function() {
      J0e.nextTick(N0e)
    }
    : (Y0e = wJe(Y0e, gYe),
        V0e = function() {
          Y0e(N0e)
        }
    ) : (U0e = !0,
      $0e = Q0e.createTextNode(""),
      new X0e(N0e).observe($0e, {
        characterData: !0
      }),
      V0e = function() {
        $0e.data = U0e = !U0e
      }
  ));
var n1e, r1e, o1e, a1e, i1e = t1e || function(e) {
  var t = {
    fn: e,
    next: void 0
  };
  j0e && (j0e.next = t),
  M0e || (M0e = t,
    V0e()),
    j0e = t
}
  , s1e = function(e) {
  var t, n;
  this.promise = new e((function(e, r) {
      if (void 0 !== t || void 0 !== n)
        throw TypeError("Bad Promise constructor");
      t = e,
        n = r
    }
  )),
    this.resolve = nXe(t),
    this.reject = nXe(n)
}, l1e = {
  f: function(e) {
    return new s1e(e)
  }
}, u1e = function(e) {
  try {
    return {
      error: !1,
      value: e()
    }
  } catch (t) {
    return {
      error: !0,
      value: t
    }
  }
}, c1e = "object" == typeof window, d1e = K0e.set, f1e = xXe("species"), p1e = "Promise", h1e = tQe.getterFor(p1e), v1e = tQe.set, g1e = tQe.getterFor(p1e), m1e = $Ze && $Ze.prototype, y1e = $Ze, b1e = m1e, w1e = gYe.TypeError, x1e = gYe.document, S1e = gYe.process, E1e = l1e.f, A1e = E1e, C1e = !!(x1e && x1e.createEvent && gYe.dispatchEvent), k1e = jYe(gYe.PromiseRejectionEvent), T1e = !1, D1e = PQe(p1e, (function() {
    var e = $Xe(y1e)
      , t = e !== String(y1e);
    if (!t && 66 === qYe)
      return !0;
    if (qYe >= 51 && /native code/.test(e))
      return !1;
    var n = new y1e((function(e) {
        e(1)
      }
    ))
      , r = function(e) {
      e((function() {}
      ), (function() {}
      ))
    };
    return (n.constructor = {})[f1e] = r,
    !(T1e = n.then((function() {}
    ))instanceof r) || !t && c1e && !k1e
  }
)), O1e = D1e || !y0e((function(e) {
    y1e.all(e).catch((function() {}
    ))
  }
)), _1e = function(e) {
  var t;
  return !(!VYe(e) || !jYe(t = e.then)) && t
}, R1e = function(e, t) {
  if (!e.notified) {
    e.notified = !0;
    var n = e.reactions;
    i1e((function() {
        for (var r = e.value, o = 1 == e.state, a = 0; n.length > a; ) {
          var i, s, l, u = n[a++], c = o ? u.ok : u.fail, d = u.resolve, f = u.reject, p = u.domain;
          try {
            c ? (o || (2 === e.rejection && F1e(e),
              e.rejection = 1),
              !0 === c ? i = r : (p && p.enter(),
                i = c(r),
              p && (p.exit(),
                l = !0)),
              i === u.promise ? f(w1e("Promise-chain cycle")) : (s = _1e(i)) ? wYe(s, i, d, f) : d(i)) : f(r)
          } catch (h) {
            p && !l && p.exit(),
              f(h)
          }
        }
        e.reactions = [],
          e.notified = !1,
        t && !e.rejection && I1e(e)
      }
    ))
  }
}, L1e = function(e, t, n) {
  var r, o;
  C1e ? ((r = x1e.createEvent("Event")).promise = t,
    r.reason = n,
    r.initEvent(e, !1, !0),
    gYe.dispatchEvent(r)) : r = {
    promise: t,
    reason: n
  },
    !k1e && (o = gYe["on" + e]) ? o(r) : "unhandledrejection" === e && function(e, t) {
      var n = gYe.console;
      n && n.error && (1 == arguments.length ? n.error(e) : n.error(e, t))
    }("Unhandled promise rejection", n)
}, I1e = function(e) {
  wYe(d1e, gYe, (function() {
      var t, n = e.facade, r = e.value;
      if (P1e(e) && (t = u1e((function() {
          E0e ? S1e.emit("unhandledRejection", r, n) : L1e("unhandledrejection", n, r)
        }
      )),
        e.rejection = E0e || P1e(e) ? 2 : 1,
        t.error))
        throw t.value
    }
  ))
}, P1e = function(e) {
  return 1 !== e.rejection && !e.parent
}, F1e = function(e) {
  wYe(d1e, gYe, (function() {
      var t = e.facade;
      E0e ? S1e.emit("rejectionHandled", t) : L1e("rejectionhandled", t, e.value)
    }
  ))
}, B1e = function(e, t, n) {
  return function(r) {
    e(t, r, n)
  }
}, N1e = function(e, t, n) {
  e.done || (e.done = !0,
  n && (e = n),
    e.value = t,
    e.state = 2,
    R1e(e, !0))
}, M1e = function(e, t, n) {
  if (!e.done) {
    e.done = !0,
    n && (e = n);
    try {
      if (e.facade === t)
        throw w1e("Promise can't be resolved itself");
      var r = _1e(t);
      r ? i1e((function() {
          var n = {
            done: !1
          };
          try {
            wYe(r, t, B1e(M1e, n, e), B1e(N1e, n, e))
          } catch (o) {
            N1e(n, o, e)
          }
        }
      )) : (e.value = t,
        e.state = 1,
        R1e(e, !1))
    } catch (o) {
      N1e({
        done: !1
      }, o, e)
    }
  }
};
if (D1e && (b1e = (y1e = function(e) {
    JZe(this, b1e),
      nXe(e),
      wYe(n1e, this);
    var t = h1e(this);
    try {
      e(B1e(M1e, t), B1e(N1e, t))
    } catch (n) {
      N1e(t, n)
    }
  }
).prototype,
  (n1e = function(e) {
      v1e(this, {
        type: p1e,
        done: !1,
        notified: !1,
        parent: !1,
        reactions: [],
        rejection: !1,
        state: 0,
        value: void 0
      })
    }
  ).prototype = HZe(b1e, {
    then: function(e, t) {
      var n, r, o, a = g1e(this), i = a.reactions, s = E1e((n = y1e,
        void 0 === (o = IXe(this).constructor) || null == (r = IXe(o)[w0e]) ? n : function(e) {
          if (OJe(e))
            return e;
          throw b0e(eXe(e) + " is not a constructor")
        }(r)));
      return s.ok = !jYe(e) || e,
        s.fail = jYe(t) && t,
        s.domain = E0e ? S1e.domain : void 0,
        a.parent = !0,
        i[i.length] = s,
      0 != a.state && R1e(a, !1),
        s.promise
    },
    catch: function(e) {
      return this.then(void 0, e)
    }
  }),
  r1e = function() {
    var e = new n1e
      , t = h1e(e);
    this.promise = e,
      this.resolve = B1e(M1e, t),
      this.reject = B1e(N1e, t)
  }
  ,
  l1e.f = E1e = function(e) {
    return e === y1e || e === o1e ? new r1e(e) : A1e(e)
  }
  ,
jYe($Ze) && m1e !== Object.prototype)) {
  a1e = m1e.then,
  T1e || (iQe(m1e, "then", (function(e, t) {
      var n = this;
      return new y1e((function(e, t) {
          wYe(a1e, n, e, t)
        }
      )).then(e, t)
    }
  ), {
    unsafe: !0
  }),
    iQe(m1e, "catch", b1e.catch, {
      unsafe: !0
    }));
  try {
    delete m1e.constructor
  } catch (lbt) {}
  WZe && WZe(m1e, b1e)
}
function j1e(e, t, n) {
  return void 0 === n && (n = ""),
    lYe(this, void 0, void 0, (function() {
        var r, o, a, i, s, l, u;
        return uYe(this, (function(c) {
            switch (c.label) {
              case 0:
                return t ? (e.restoreSelection(),
                  r = e.getMenuConfig("insertVideo"),
                  o = r.onInsertedVideo,
                  a = r.checkVideo,
                  i = r.parseVideoSrc,
                  [4, a(t, n)]) : [2];
              case 1:
                return "string" == typeof (s = c.sent()) ? (e.alert(s, "error"),
                  [2]) : null == s ? [2] : [4, i(t)];
              case 2:
                return 0 !== (l = c.sent()).trim().indexOf("<iframe ") && (l = l.replace(/</g, "&lt;").replace(/>/g, "&gt;")),
                  u = {
                    type: "video",
                    src: l,
                    poster: n,
                    children: [{
                      text: ""
                    }]
                  },
                  Promise.resolve().then((function() {
                      Nne.insertNodes(e, u)
                    }
                  )),
                  o(u),
                  [2]
            }
          }
        ))
      }
    ))
}
function V1e() {
  return UZe("w-e-insert-video")
}
BQe({
  global: !0,
  wrap: !0,
  forced: D1e
}, {
  Promise: y1e
}),
  YZe(y1e, p1e, !1),
  function(e) {
    var t = UYe("Promise")
      , n = BXe.f;
    yYe && t && !t[XZe] && n(t, XZe, {
      configurable: !0,
      get: function() {
        return this
      }
    })
  }(),
  o1e = UYe(p1e),
  BQe({
    target: p1e,
    stat: !0,
    forced: D1e
  }, {
    reject: function(e) {
      var t = E1e(this);
      return wYe(t.reject, void 0, e),
        t.promise
    }
  }),
  BQe({
    target: p1e,
    stat: !0,
    forced: D1e
  }, {
    resolve: function(e) {
      return function(e, t) {
        if (IXe(e),
        VYe(t) && t.constructor === e)
          return t;
        var n = l1e.f(e);
        return (0,
          n.resolve)(t),
          n.promise
      }(this, e)
    }
  }),
  BQe({
    target: p1e,
    stat: !0,
    forced: O1e
  }, {
    all: function(e) {
      var t = this
        , n = E1e(t)
        , r = n.resolve
        , o = n.reject
        , a = u1e((function() {
          var n = nXe(t.resolve)
            , a = []
            , i = 0
            , s = 1;
          u0e(e, (function(e) {
              var l = i++
                , u = !1;
              s++,
                wYe(n, t, e).then((function(e) {
                    u || (u = !0,
                      a[l] = e,
                    --s || r(a))
                  }
                ), o)
            }
          )),
          --s || r(a)
        }
      ));
      return a.error && o(a.value),
        n.promise
    },
    race: function(e) {
      var t = this
        , n = E1e(t)
        , r = n.reject
        , o = u1e((function() {
          var o = nXe(t.resolve);
          u0e(e, (function(e) {
              wYe(o, t, e).then(n.resolve, r)
            }
          ))
        }
      ));
      return o.error && r(o.value),
        n.promise
    }
  });
var U1e = function() {
  function e() {
    this.title = SEe("videoModule.insertVideo"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M981.184 160.096C837.568 139.456 678.848 128 512 128S186.432 139.456 42.816 160.096C15.296 267.808 0 386.848 0 512s15.264 244.16 42.816 351.904C186.464 884.544 345.152 896 512 896s325.568-11.456 469.184-32.096C1008.704 756.192 1024 637.152 1024 512s-15.264-244.16-42.816-351.904zM384 704V320l320 192-320 192z"></path></svg>',
      this.tag = "button",
      this.showModal = !0,
      this.modalWidth = 320,
      this.$content = null,
      this.srcInputId = V1e(),
      this.posterInputId = V1e(),
      this.buttonId = V1e()
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.exec = function(e, t) {}
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !fne.isCollapsed(t) || !!qme.getSelectedElems(e).some((function(t) {
          var n = qme.getNodeType(t);
          return "pre" === n || "list-item" === n || !!e.isVoid(t)
        }
      ))
    }
    ,
    e.prototype.getModalPositionNode = function(e) {
      return null
    }
    ,
    e.prototype.getModalContentElem = function(e) {
      var t = this
        , n = this
        , r = n.srcInputId
        , o = n.posterInputId
        , a = n.buttonId
        , i = cYe(fSe(SEe("videoModule.videoSrc"), r, SEe("videoModule.videoSrcPlaceHolder")), 2)
        , s = i[0]
        , l = i[1]
        , u = cYe(fSe(SEe("videoModule.videoPoster"), o, SEe("videoModule.videoPosterPlaceHolder")), 2)
        , c = u[0]
        , d = u[1]
        , f = Qre(l)
        , p = Qre(d)
        , h = cYe(pSe(a, SEe("videoModule.ok")), 1)[0];
      if (null == this.$content) {
        var v = Qre("<div></div>");
        v.on("click", "#" + a, (function(n) {
            return lYe(t, void 0, void 0, (function() {
                var t, a;
                return uYe(this, (function(i) {
                    switch (i.label) {
                      case 0:
                        return n.preventDefault(),
                          t = v.find("#" + r).val().trim(),
                          a = v.find("#" + o).val().trim(),
                          [4, j1e(e, t, a)];
                      case 1:
                        return i.sent(),
                          e.hidePanelOrModal(),
                          [2]
                    }
                  }
                ))
              }
            ))
          }
        )),
          this.$content = v
      }
      var g = this.$content;
      return g.empty(),
        g.append(s),
        g.append(c),
        g.append(h),
        f.val(""),
        p.val(""),
        setTimeout((function() {
            f.focus()
          }
        )),
        g[0]
    }
    ,
    e
}()
  , $1e = OYe([].join)
  , H1e = FYe != Object
  , z1e = function(e, t) {
  var n = [].join;
  return !!n && mYe((function() {
      n.call(null, ",", 1)
    }
  ))
}();
BQe({
  target: "Array",
  proto: !0,
  forced: H1e || !z1e
}, {
  join: function(e) {
    return $1e(MYe(this), void 0 === e ? "," : e)
  }
});
var K1e, W1e, G1e, q1e = !mYe((function() {
    function e() {}
    return e.prototype.constructor = null,
    Object.getPrototypeOf(new e) !== e.prototype
  }
)), Y1e = WXe("IE_PROTO"), X1e = gYe.Object, Q1e = X1e.prototype, J1e = q1e ? X1e.getPrototypeOf : function(e) {
  var t = cXe(e);
  if (fXe(t, Y1e))
    return t[Y1e];
  var n = t.constructor;
  return jYe(n) && t instanceof n ? n.prototype : t instanceof X1e ? Q1e : null
}
  , Z1e = xXe("iterator"), e2e = !1;
[].keys && ("next"in (G1e = [].keys()) ? (W1e = J1e(J1e(G1e))) !== Object.prototype && (K1e = W1e) : e2e = !0);
var t2e = null == K1e || mYe((function() {
    var e = {};
    return K1e[Z1e].call(e) !== e
  }
));
t2e && (K1e = {}),
jYe(K1e[Z1e]) || iQe(K1e, Z1e, (function() {
    return this
  }
));
var n2e = {
  IteratorPrototype: K1e,
  BUGGY_SAFARI_ITERATORS: e2e
}
  , r2e = n2e.IteratorPrototype
  , o2e = function() {
  return this
}
  , a2e = aQe.PROPER
  , i2e = aQe.CONFIGURABLE
  , s2e = n2e.IteratorPrototype
  , l2e = n2e.BUGGY_SAFARI_ITERATORS
  , u2e = xXe("iterator")
  , c2e = function() {
  return this
}
  , d2e = function(e, t, n, r, o, a, i) {
  var s, l, u;
  l = r,
    u = t + " Iterator",
    (s = n).prototype = pJe(r2e, {
      next: AYe(1, l)
    }),
    YZe(s, u, !1),
    ZZe[u] = o2e;
  var c, d, f, p = function(e) {
    if (e === o && y)
      return y;
    if (!l2e && e in g)
      return g[e];
    switch (e) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n(this,e)
        }
    }
    return function() {
      return new n(this)
    }
  }, h = t + " Iterator", v = !1, g = e.prototype, m = g[u2e] || g["@@iterator"] || o && g[o], y = !l2e && m || p(o), b = "Array" == t && g.entries || m;
  if (b && (c = J1e(b.call(new e))) !== Object.prototype && c.next && (J1e(c) !== s2e && (WZe ? WZe(c, s2e) : jYe(c[u2e]) || iQe(c, u2e, c2e)),
    YZe(c, h, !0)),
  a2e && "values" == o && m && "values" !== m.name && (i2e ? NXe(g, "name", "values") : (v = !0,
      y = function() {
        return wYe(m, this)
      }
  )),
    o)
    if (d = {
      values: p("values"),
      keys: a ? y : p("keys"),
      entries: p("entries")
    },
      i)
      for (f in d)
        (l2e || v || !(f in g)) && iQe(g, f, d[f]);
    else
      BQe({
        target: t,
        proto: !0,
        forced: l2e || v
      }, d);
  return g[u2e] !== y && iQe(g, u2e, y, {
    name: o
  }),
    ZZe[t] = y,
    d
}
  , f2e = tQe.set
  , p2e = tQe.getterFor("Array Iterator")
  , h2e = d2e(Array, "Array", (function(e, t) {
    f2e(this, {
      type: "Array Iterator",
      target: MYe(e),
      index: 0,
      kind: t
    })
  }
), (function() {
    var e = p2e(this)
      , t = e.target
      , n = e.kind
      , r = e.index++;
    return !t || r >= t.length ? (e.target = void 0,
      {
        value: void 0,
        done: !0
      }) : "keys" == n ? {
      value: r,
      done: !1
    } : "values" == n ? {
      value: t[r],
      done: !1
    } : {
      value: [r, t[r]],
      done: !1
    }
  }
), "values");
ZZe.Arguments = ZZe.Array,
  gJe("keys"),
  gJe("values"),
  gJe("entries");
var v2e = wZe.charAt
  , g2e = tQe.set
  , m2e = tQe.getterFor("String Iterator");
d2e(String, "String", (function(e) {
    g2e(this, {
      type: "String Iterator",
      string: zQe(e),
      index: 0
    })
  }
), (function() {
    var e, t = m2e(this), n = t.string, r = t.index;
    return r >= n.length ? {
      value: void 0,
      done: !0
    } : (e = v2e(n, r),
      t.index += e.length,
      {
        value: e,
        done: !1
      })
  }
));
var y2e = function(e, t, n) {
  var r = AXe(t);
  r in e ? BXe.f(e, r, AYe(0, n)) : e[r] = n
}
  , b2e = gYe.Array
  , w2e = Math.max
  , x2e = EQe.f
  , S2e = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []
  , E2e = {
  f: function(e) {
    return S2e && "Window" == LYe(e) ? function(e) {
      try {
        return x2e(e)
      } catch (t) {
        return function(e, t, n) {
          for (var r = vQe(e), o = fQe(void 0, r), a = fQe(r, r), i = b2e(w2e(a - o, 0)), s = 0; o < a; o++,
            s++)
            y2e(i, s, e[o]);
          return i.length = s,
            i
        }(S2e)
      }
    }(e) : x2e(MYe(e))
  }
}
  , A2e = mYe((function() {
    if ("function" == typeof ArrayBuffer) {
      var e = new ArrayBuffer(8);
      Object.isExtensible(e) && Object.defineProperty(e, "a", {
        value: 8
      })
    }
  }
))
  , C2e = Object.isExtensible
  , k2e = mYe((function() {
    C2e(1)
  }
)) || A2e ? function(e) {
    return !!VYe(e) && (!A2e || "ArrayBuffer" != LYe(e)) && (!C2e || C2e(e))
  }
  : C2e
  , T2e = !mYe((function() {
    return Object.isExtensible(Object.preventExtensions({}))
  }
))
  , D2e = fYe((function(e) {
    var t = BXe.f
      , n = !1
      , r = gXe("meta")
      , o = 0
      , a = function(e) {
      t(e, r, {
        value: {
          objectID: "O" + o++,
          weakData: {}
        }
      })
    }
      , i = e.exports = {
      enable: function() {
        i.enable = function() {}
          ,
          n = !0;
        var e = EQe.f
          , t = OYe([].splice)
          , o = {};
        o[r] = 1,
        e(o).length && (EQe.f = function(n) {
          for (var o = e(n), a = 0, i = o.length; a < i; a++)
            if (o[a] === r) {
              t(o, a, 1);
              break
            }
          return o
        }
          ,
          BQe({
            target: "Object",
            stat: !0,
            forced: !0
          }, {
            getOwnPropertyNames: E2e.f
          }))
      },
      fastKey: function(e, t) {
        if (!VYe(e))
          return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
        if (!fXe(e, r)) {
          if (!k2e(e))
            return "F";
          if (!t)
            return "E";
          a(e)
        }
        return e[r].objectID
      },
      getWeakData: function(e, t) {
        if (!fXe(e, r)) {
          if (!k2e(e))
            return !0;
          if (!t)
            return !1;
          a(e)
        }
        return e[r].weakData
      },
      onFreeze: function(e) {
        return T2e && n && k2e(e) && !fXe(e, r) && a(e),
          e
      }
    };
    GXe[r] = !0
  }
))
  , O2e = D2e.getWeakData
  , _2e = tQe.set
  , R2e = tQe.getterFor
  , L2e = FJe.find
  , I2e = FJe.findIndex
  , P2e = OYe([].splice)
  , F2e = 0
  , B2e = function(e) {
  return e.frozen || (e.frozen = new N2e)
}
  , N2e = function() {
  this.entries = []
}
  , M2e = function(e, t) {
  return L2e(e.entries, (function(e) {
      return e[0] === t
    }
  ))
};
N2e.prototype = {
  get: function(e) {
    var t = M2e(this, e);
    if (t)
      return t[1]
  },
  has: function(e) {
    return !!M2e(this, e)
  },
  set: function(e, t) {
    var n = M2e(this, e);
    n ? n[1] = t : this.entries.push([e, t])
  },
  delete: function(e) {
    var t = I2e(this.entries, (function(t) {
        return t[0] === e
      }
    ));
    return ~t && P2e(this.entries, t, 1),
      !!~t
  }
};
var j2e, V2e = {
  getConstructor: function(e, t, n, r) {
    var o = e((function(e, o) {
        JZe(e, a),
          _2e(e, {
            type: t,
            id: F2e++,
            frozen: void 0
          }),
        null != o && u0e(o, e[r], {
          that: e,
          AS_ENTRIES: n
        })
      }
    ))
      , a = o.prototype
      , i = R2e(t)
      , s = function(e, t, n) {
      var r = i(e)
        , o = O2e(IXe(t), !0);
      return !0 === o ? B2e(r).set(t, n) : o[r.id] = n,
        e
    };
    return HZe(a, {
      delete: function(e) {
        var t = i(this);
        if (!VYe(e))
          return !1;
        var n = O2e(e);
        return !0 === n ? B2e(t).delete(e) : n && fXe(n, t.id) && delete n[t.id]
      },
      has: function(e) {
        var t = i(this);
        if (!VYe(e))
          return !1;
        var n = O2e(e);
        return !0 === n ? B2e(t).has(e) : n && fXe(n, t.id)
      }
    }),
      HZe(a, n ? {
        get: function(e) {
          var t = i(this);
          if (VYe(e)) {
            var n = O2e(e);
            return !0 === n ? B2e(t).get(e) : n ? n[t.id] : void 0
          }
        },
        set: function(e, t) {
          return s(this, e, t)
        }
      } : {
        add: function(e) {
          return s(this, e, !0)
        }
      }),
      o
  }
}, U2e = tQe.enforce, $2e = !gYe.ActiveXObject && "ActiveXObject"in gYe, H2e = function(e) {
  return function() {
    return e(this, arguments.length ? arguments[0] : void 0)
  }
}, z2e = function(e, t, n) {
  var r = -1 !== e.indexOf("Map")
    , o = -1 !== e.indexOf("Weak")
    , a = r ? "set" : "add"
    , i = gYe[e]
    , s = i && i.prototype
    , l = i
    , u = {}
    , c = function(e) {
    var t = OYe(s[e]);
    iQe(s, e, "add" == e ? function(e) {
          return t(this, 0 === e ? 0 : e),
            this
        }
        : "delete" == e ? function(e) {
            return !(o && !VYe(e)) && t(this, 0 === e ? 0 : e)
          }
          : "get" == e ? function(e) {
              return o && !VYe(e) ? void 0 : t(this, 0 === e ? 0 : e)
            }
            : "has" == e ? function(e) {
                return !(o && !VYe(e)) && t(this, 0 === e ? 0 : e)
              }
              : function(e, n) {
                return t(this, 0 === e ? 0 : e, n),
                  this
              }
    )
  };
  if (PQe(e, !jYe(i) || !(o || s.forEach && !mYe((function() {
      (new i).entries().next()
    }
  )))))
    l = n.getConstructor(t, e, r, a),
      D2e.enable();
  else if (PQe(e, !0)) {
    var d = new l
      , f = d[a](o ? {} : -0, 1) != d
      , p = mYe((function() {
        d.has(1)
      }
    ))
      , h = y0e((function(e) {
        new i(e)
      }
    ))
      , v = !o && mYe((function() {
        for (var e = new i, t = 5; t--; )
          e[a](t, t);
        return !e.has(-0)
      }
    ));
    h || ((l = t((function(e, t) {
        JZe(e, s);
        var n, o, u, c, d, f = (n = new i,
          o = e,
          u = l,
        WZe && jYe(c = o.constructor) && c !== u && VYe(d = c.prototype) && d !== u.prototype && WZe(n, d),
          n);
        return null != t && u0e(t, f[a], {
          that: f,
          AS_ENTRIES: r
        }),
          f
      }
    ))).prototype = s,
      s.constructor = l),
    (p || v) && (c("delete"),
      c("has"),
    r && c("get")),
    (v || f) && c(a),
    o && s.clear && delete s.clear
  }
  return u[e] = l,
    BQe({
      global: !0,
      forced: l != i
    }, u),
    YZe(l, e),
  o || n.setStrong(l, e, r),
    l
}("WeakMap", H2e, V2e);
if (zXe && $2e) {
  j2e = V2e.getConstructor(H2e, "WeakMap", !0),
    D2e.enable();
  var K2e = z2e.prototype
    , W2e = OYe(K2e.delete)
    , G2e = OYe(K2e.has)
    , q2e = OYe(K2e.get)
    , Y2e = OYe(K2e.set);
  HZe(K2e, {
    delete: function(e) {
      if (VYe(e) && !k2e(e)) {
        var t = U2e(this);
        return t.frozen || (t.frozen = new j2e),
        W2e(this, e) || t.frozen.delete(e)
      }
      return W2e(this, e)
    },
    has: function(e) {
      if (VYe(e) && !k2e(e)) {
        var t = U2e(this);
        return t.frozen || (t.frozen = new j2e),
        G2e(this, e) || t.frozen.has(e)
      }
      return G2e(this, e)
    },
    get: function(e) {
      if (VYe(e) && !k2e(e)) {
        var t = U2e(this);
        return t.frozen || (t.frozen = new j2e),
          G2e(this, e) ? q2e(this, e) : t.frozen.get(e)
      }
      return q2e(this, e)
    },
    set: function(e, t) {
      if (VYe(e) && !k2e(e)) {
        var n = U2e(this);
        n.frozen || (n.frozen = new j2e),
          G2e(this, e) ? Y2e(this, e, t) : n.frozen.set(e, t)
      } else
        Y2e(this, e, t);
      return this
    }
  })
}
var X2e = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}
  , Q2e = TXe("span").classList
  , J2e = Q2e && Q2e.constructor && Q2e.constructor.prototype
  , Z2e = J2e === Object.prototype ? void 0 : J2e
  , e4e = xXe("iterator")
  , t4e = xXe("toStringTag")
  , n4e = h2e.values
  , r4e = function(e, t) {
  if (e) {
    if (e[e4e] !== n4e)
      try {
        NXe(e, e4e, n4e)
      } catch (r) {
        e[e4e] = n4e
      }
    if (e[t4e] || NXe(e, t4e, t),
      X2e[t])
      for (var n in h2e)
        if (e[n] !== h2e[n])
          try {
            NXe(e, n, h2e[n])
          } catch (r) {
            e[n] = h2e[n]
          }
  }
};
for (var o4e in X2e)
  r4e(gYe[o4e] && gYe[o4e].prototype, o4e);
r4e(Z2e, "DOMTokenList");
var a4e = aQe.EXISTS
  , i4e = BXe.f
  , s4e = Function.prototype
  , l4e = OYe(s4e.toString)
  , u4e = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/
  , c4e = OYe(u4e.exec);
yYe && !a4e && i4e(s4e, "name", {
  configurable: !0,
  get: function() {
    try {
      return c4e(u4e, l4e(this))[1]
    } catch (Y_) {
      return ""
    }
  }
});
var d4e = xXe("species")
  , f4e = qYe >= 51 || !mYe((function() {
    var e = [];
    return (e.constructor = {})[d4e] = function() {
      return {
        foo: 1
      }
    }
      ,
    1 !== e.slice(Boolean).foo
  }
))
  , p4e = xXe("species")
  , h4e = gYe.Array
  , v4e = Math.max;
function g4e(e) {
  return e.getMenuConfig("uploadVideo")
}
BQe({
  target: "Array",
  proto: !0,
  forced: !f4e
}, {
  slice: function(e, t) {
    var n, r, o, a = MYe(this), i = vQe(a), s = fQe(e, i), l = fQe(void 0 === t ? i : t, i);
    if (xJe(a) && (n = a.constructor,
    (OJe(n) && (n === h4e || xJe(n.prototype)) || VYe(n) && null === (n = n[p4e])) && (n = void 0),
    n === h4e || void 0 === n))
      return x0e(a, s, l);
    for (r = new (void 0 === n ? h4e : n)(v4e(l - s, 0)),
           o = 0; s < l; s++,
           o++)
      s in a && y2e(r, o, a[s]);
    return r.length = o,
      r
  }
});
var m4e = new WeakMap;
function y4e(e, t) {
  return lYe(this, void 0, void 0, (function() {
      var n, r, o, a;
      return uYe(this, (function(i) {
          switch (i.label) {
            case 0:
              return n = function(e) {
                var t = m4e.get(e);
                if (null != t)
                  return t;
                var n = g4e(e)
                  , r = n.onSuccess
                  , o = n.onProgress
                  , a = n.onFailed
                  , i = n.customInsert
                  , s = n.onError;
                return t = ISe(sYe(sYe({}, n), {
                  onProgress: function(t) {
                    e.showProgressBar(t),
                    o && o(t)
                  },
                  onSuccess: function(t, n) {
                    if (i)
                      return i(n, (function(t, n) {
                          return j1e(e, t, n)
                        }
                      )),
                        void r(t, n);
                    var o = n.errno
                      , s = void 0 === o ? 1 : o
                      , l = n.data
                      , u = void 0 === l ? {} : l;
                    if (0 === s) {
                      var c = u.url
                        , d = void 0 === c ? "" : c
                        , f = u.poster;
                      j1e(e, d, void 0 === f ? "" : f),
                        r(t, n)
                    } else
                      a(t, n)
                  },
                  onError: function(e, t, n) {
                    s(e, t, n)
                  }
                })),
                  m4e.set(e, t),
                  t
              }(e),
                r = t.name,
                o = t.type,
                a = t.size,
                n.addFile({
                  name: r,
                  type: o,
                  size: a,
                  data: t
                }),
                [4, n.upload()];
            case 1:
              return i.sent(),
                [2]
          }
        }
      ))
    }
  ))
}
var b4e = function() {
  function e() {
    this.title = SEe("videoModule.uploadVideo"),
      this.iconSvg = '<svg viewBox="0 0 1056 1024"><path d="M805.902261 521.819882a251.441452 251.441452 0 0 0-251.011972 246.600033 251.051015 251.051015 0 1 0 502.023944 8.823877 253.237463 253.237463 0 0 0-251.011972-255.42391z m59.463561 240.001647v129.898403h-116.701631v-129.898403h-44.041298l101.279368-103.504859 101.279368 103.504859z" p-id="6802"></path><path d="M788.254507 0.000781H99.094092A98.663439 98.663439 0 0 0 0.001171 99.093701v590.067495a98.663439 98.663439 0 0 0 99.092921 99.092921h411.7549a266.434235 266.434235 0 0 1-2.186448-41.815807 275.843767 275.843767 0 0 1 275.180024-270.729042 270.650955 270.650955 0 0 1 103.504859 19.834201V99.093701A101.51363 101.51363 0 0 0 788.254507 0.000781zM295.054441 640.747004V147.507894l394.146189 246.600033z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.exec = function(e, t) {
      var n = this.getMenuConfig(e)
        , r = n.allowedFileTypes
        , o = void 0 === r ? [] : r
        , a = n.customBrowseAndUpload;
      if (a)
        a((function(t, n) {
            return j1e(e, t, n)
          }
        ));
      else {
        var i = "";
        o.length > 0 && (i = 'accept="' + o.join(", ") + '"');
        var s = Qre("body")
          , l = Qre('<input type="file" ' + i + " multiple/>");
        l.hide(),
          s.append(l),
          l.click(),
          l.on("change", (function() {
              var t = l[0].files;
              !function(e, t) {
                var n, r;
                lYe(this, void 0, void 0, (function() {
                    var o, a, i, s, l, u;
                    return uYe(this, (function(c) {
                        switch (c.label) {
                          case 0:
                            if (null == t)
                              return [2];
                            o = Array.prototype.slice.call(t),
                              a = g4e(e).customUpload,
                              c.label = 1;
                          case 1:
                            c.trys.push([1, 9, 10, 15]),
                              i = function(e) {
                                if (!Symbol.asyncIterator)
                                  throw new TypeError("Symbol.asyncIterator is not defined.");
                                var t, n = e[Symbol.asyncIterator];
                                return n ? n.call(e) : (e = function(e) {
                                  var t = "function" == typeof Symbol && Symbol.iterator
                                    , n = t && e[t]
                                    , r = 0;
                                  if (n)
                                    return n.call(e);
                                  if (e && "number" == typeof e.length)
                                    return {
                                      next: function() {
                                        return e && r >= e.length && (e = void 0),
                                          {
                                            value: e && e[r++],
                                            done: !e
                                          }
                                      }
                                    };
                                  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
                                }(e),
                                  t = {},
                                  r("next"),
                                  r("throw"),
                                  r("return"),
                                  t[Symbol.asyncIterator] = function() {
                                    return this
                                  }
                                  ,
                                  t);
                                function r(n) {
                                  t[n] = e[n] && function(t) {
                                    return new Promise((function(r, o) {
                                        var a, i, s, l;
                                        a = r,
                                          i = o,
                                          s = (t = e[n](t)).done,
                                          l = t.value,
                                          Promise.resolve(l).then((function(e) {
                                              a({
                                                value: e,
                                                done: s
                                              })
                                            }
                                          ), i)
                                      }
                                    ))
                                  }
                                }
                              }(o),
                              c.label = 2;
                          case 2:
                            return [4, i.next()];
                          case 3:
                            return (s = c.sent()).done ? [3, 8] : (l = s.value,
                              a ? [4, a(l, (function(t, n) {
                                  return j1e(e, t, n)
                                }
                              ))] : [3, 5]);
                          case 4:
                            return c.sent(),
                              [3, 7];
                          case 5:
                            return [4, y4e(e, l)];
                          case 6:
                            c.sent(),
                              c.label = 7;
                          case 7:
                            return [3, 2];
                          case 8:
                            return [3, 15];
                          case 9:
                            return u = c.sent(),
                              n = {
                                error: u
                              },
                              [3, 15];
                          case 10:
                            return c.trys.push([10, , 13, 14]),
                              s && !s.done && (r = i.return) ? [4, r.call(i)] : [3, 12];
                          case 11:
                            c.sent(),
                              c.label = 12;
                          case 12:
                            return [3, 14];
                          case 13:
                            if (n)
                              throw n.error;
                            return [7];
                          case 14:
                            return [7];
                          case 15:
                            return [2]
                        }
                      }
                    ))
                  }
                ))
              }(e, t)
            }
          ))
      }
    }
    ,
    e.prototype.isDisabled = function(e) {
      var t = e.selection;
      return null == t || !fne.isCollapsed(t) || !!qme.getSelectedElems(e).some((function(t) {
          var n = qme.getNodeType(t);
          return "pre" === n || "list-item" === n || !!e.isVoid(t)
        }
      ))
    }
    ,
    e.prototype.getMenuConfig = function(e) {
      return e.getMenuConfig("uploadVideo")
    }
    ,
    e
}()
  , w4e = aQe.PROPER
  , x4e = RegExp.prototype
  , S4e = x4e.toString
  , E4e = OYe(HJe)
  , A4e = mYe((function() {
    return "/a/b" != S4e.call({
      source: "a",
      flags: "b"
    })
  }
))
  , C4e = w4e && "toString" != S4e.name;
function k4e() {
  return UZe("w-e-insert-video")
}
(A4e || C4e) && iQe(RegExp.prototype, "toString", (function() {
    var e = IXe(this)
      , t = zQe(e.source)
      , n = e.flags;
    return "/" + t + "/" + zQe(void 0 === n && $Ye(x4e, e) && !("flags"in x4e) ? E4e(e) : n)
  }
), {
  unsafe: !0
});
var T4e = function() {
  function e() {
    this.title = SEe("videoModule.editSize"),
      this.tag = "button",
      this.showModal = !0,
      this.modalWidth = 320,
      this.$content = null,
      this.widthInputId = k4e(),
      this.heightInputId = k4e(),
      this.buttonId = k4e()
  }
  return e.prototype.getSelectedVideoNode = function(e) {
    return qme.getSelectedNodeByType(e, "video")
  }
    ,
    e.prototype.getValue = function(e) {
      return ""
    }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.exec = function(e, t) {}
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || null == this.getSelectedVideoNode(e)
    }
    ,
    e.prototype.getModalPositionNode = function(e) {
      return this.getSelectedVideoNode(e)
    }
    ,
    e.prototype.getModalContentElem = function(e) {
      var t = this
        , n = t.widthInputId
        , r = t.heightInputId
        , o = t.buttonId
        , a = cYe(fSe(SEe("videoModule.width"), n, "auto"), 2)
        , i = a[0]
        , s = Qre(a[1])
        , l = cYe(fSe(SEe("videoModule.height"), r, "auto"), 2)
        , u = l[0]
        , c = Qre(l[1])
        , d = cYe(pSe(o, SEe("videoModule.ok")), 1)[0];
      if (null == this.$content) {
        var f = Qre("<div></div>");
        f.on("click", "#" + o, (function(t) {
            t.preventDefault();
            var o = f.find("#" + n).val().trim()
              , a = f.find("#" + r).val().trim()
              , i = parseInt(o)
              , s = parseInt(a)
              , l = i ? i.toString() : "auto"
              , u = s ? s.toString() : "auto";
            e.restoreSelection(),
              Nne.setNodes(e, {
                width: l,
                height: u
              }, {
                match: function(e) {
                  return qme.checkNodeType(e, "video")
                }
              }),
              e.hidePanelOrModal()
          }
        )),
          this.$content = f
      }
      var p = this.$content;
      p.empty(),
        p.append(i),
        p.append(u),
        p.append(d);
      var h = this.getSelectedVideoNode(e);
      if (null == h)
        return p[0];
      var v = h.width
        , g = void 0 === v ? "auto" : v
        , m = h.height
        , y = void 0 === m ? "auto" : m;
      return s.val(g),
        c.val(y),
        setTimeout((function() {
            s.focus()
          }
        )),
        p[0]
    }
    ,
    e
}()
  , D4e = {
  renderElems: [rJe],
  elemsToHtml: [oJe],
  preParseHtml: [yJe],
  parseElemsHtml: [$Je],
  menus: [{
    key: "insertVideo",
    factory: function() {
      return new U1e
    },
    config: {
      onInsertedVideo: function(e) {},
      checkVideo: function(e, t) {
        return !0
      },
      parseVideoSrc: function(e) {
        return e
      }
    }
  }, {
    key: "uploadVideo",
    factory: function() {
      return new b4e
    },
    config: {
      server: "",
      fieldName: "wangeditor-uploaded-video",
      maxFileSize: 10485760,
      maxNumberOfFiles: 5,
      allowedFileTypes: ["video/*"],
      meta: {},
      metaWithUrl: !1,
      withCredentials: !1,
      timeout: 3e4,
      onBeforeUpload: function(e) {
        return e
      },
      onProgress: function(e) {},
      onSuccess: function(e, t) {},
      onFailed: function(e, t) {
        console.error("'" + e.name + "' upload failed", t)
      },
      onError: function(e, t, n) {
        console.error("'" + e.name + " upload error", t, n)
      }
    }
  }, {
    key: "editVideoSize",
    factory: function() {
      return new T4e
    }
  }],
  editorPlugin: function(e) {
    var t = e.isVoid
      , n = e.normalizeNode
      , r = e;
    return r.isVoid = function(e) {
      return "video" === e.type || t(e)
    }
      ,
      r.normalizeNode = function(e) {
        var t = cYe(e, 2)
          , o = t[0]
          , a = t[1];
        return "video" === qme.getNodeType(o) && qme.isLastNode(r, o) && Nne.insertNodes(r, qme.genEmptyParagraph(), {
          at: [a[0] + 1]
        }),
          n([o, a])
      }
      ,
      r
  }
};
xEe("en", {
  uploadImgModule: {
    uploadImage: "Upload Image",
    uploadError: "{{fileName}} upload error"
  }
}),
  xEe("zh-CN", {
    uploadImgModule: {
      uploadImage: "上传图片",
      uploadError: "{{fileName}} 上传出错"
    }
  });
var O4e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function _4e(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports),
    t.exports
}
var R4e, L4e, I4e = function(e) {
  return e && e.Math == Math && e
}, P4e = I4e("object" == typeof globalThis && globalThis) || I4e("object" == typeof window && window) || I4e("object" == typeof self && self) || I4e("object" == typeof O4e && O4e) || function() {
  return this
}() || Function("return this")(), F4e = function(e) {
  try {
    return !!e()
  } catch (t) {
    return !0
  }
}, B4e = !F4e((function() {
    return 7 != Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1]
  }
)), N4e = Function.prototype.call, M4e = N4e.bind ? N4e.bind(N4e) : function() {
  return N4e.apply(N4e, arguments)
}
  , j4e = {}.propertyIsEnumerable, V4e = Object.getOwnPropertyDescriptor, U4e = {
  f: V4e && !j4e.call({
    1: 2
  }, 1) ? function(e) {
      var t = V4e(this, e);
      return !!t && t.enumerable
    }
    : j4e
}, $4e = function(e, t) {
  return {
    enumerable: !(1 & e),
    configurable: !(2 & e),
    writable: !(4 & e),
    value: t
  }
}, H4e = Function.prototype, z4e = H4e.bind, K4e = H4e.call, W4e = z4e && z4e.bind(K4e), G4e = z4e ? function(e) {
    return e && W4e(K4e, e)
  }
  : function(e) {
    return e && function() {
      return K4e.apply(e, arguments)
    }
  }
  , q4e = G4e({}.toString), Y4e = G4e("".slice), X4e = function(e) {
  return Y4e(q4e(e), 8, -1)
}, Q4e = P4e.Object, J4e = G4e("".split), Z4e = F4e((function() {
    return !Q4e("z").propertyIsEnumerable(0)
  }
)) ? function(e) {
    return "String" == X4e(e) ? J4e(e, "") : Q4e(e)
  }
  : Q4e, e3e = P4e.TypeError, t3e = function(e) {
  if (null == e)
    throw e3e("Can't call method on " + e);
  return e
}, n3e = function(e) {
  return Z4e(t3e(e))
}, r3e = function(e) {
  return "function" == typeof e
}, o3e = function(e) {
  return "object" == typeof e ? null !== e : r3e(e)
}, a3e = function(e, t) {
  return arguments.length < 2 ? function(e) {
    return r3e(e) ? e : void 0
  }(P4e[e]) : P4e[e] && P4e[e][t]
}, i3e = G4e({}.isPrototypeOf), s3e = a3e("navigator", "userAgent") || "", l3e = P4e.process, u3e = P4e.Deno, c3e = l3e && l3e.versions || u3e && u3e.version, d3e = c3e && c3e.v8;
d3e && (L4e = (R4e = d3e.split("."))[0] > 0 && R4e[0] < 4 ? 1 : +(R4e[0] + R4e[1])),
!L4e && s3e && (!(R4e = s3e.match(/Edge\/(\d+)/)) || R4e[1] >= 74) && (R4e = s3e.match(/Chrome\/(\d+)/)) && (L4e = +R4e[1]);
var f3e = L4e
  , p3e = !!Object.getOwnPropertySymbols && !F4e((function() {
    var e = Symbol();
    return !String(e) || !(Object(e)instanceof Symbol) || !Symbol.sham && f3e && f3e < 41
  }
))
  , h3e = p3e && !Symbol.sham && "symbol" == typeof Symbol.iterator
  , v3e = P4e.Object
  , g3e = h3e ? function(e) {
    return "symbol" == typeof e
  }
  : function(e) {
    var t = a3e("Symbol");
    return r3e(t) && i3e(t.prototype, v3e(e))
  }
  , m3e = P4e.String
  , y3e = function(e) {
  try {
    return m3e(e)
  } catch (t) {
    return "Object"
  }
}
  , b3e = P4e.TypeError
  , w3e = function(e) {
  if (r3e(e))
    return e;
  throw b3e(y3e(e) + " is not a function")
}
  , x3e = function(e, t) {
  var n = e[t];
  return null == n ? void 0 : w3e(n)
}
  , S3e = P4e.TypeError
  , E3e = Object.defineProperty
  , A3e = function(e, t) {
  try {
    E3e(P4e, e, {
      value: t,
      configurable: !0,
      writable: !0
    })
  } catch (AEe) {
    P4e[e] = t
  }
  return t
}
  , C3e = P4e["__core-js_shared__"] || A3e("__core-js_shared__", {})
  , k3e = _4e((function(e) {
    (e.exports = function(e, t) {
        return C3e[e] || (C3e[e] = void 0 !== t ? t : {})
      }
    )("versions", []).push({
      version: "3.19.3",
      mode: "global",
      copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
    })
  }
))
  , T3e = P4e.Object
  , D3e = function(e) {
  return T3e(t3e(e))
}
  , O3e = G4e({}.hasOwnProperty)
  , _3e = Object.hasOwn || function(e, t) {
  return O3e(D3e(e), t)
}
  , R3e = 0
  , L3e = Math.random()
  , I3e = G4e(1..toString)
  , P3e = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + I3e(++R3e + L3e, 36)
}
  , F3e = k3e("wks")
  , B3e = P4e.Symbol
  , N3e = B3e && B3e.for
  , M3e = h3e ? B3e : B3e && B3e.withoutSetter || P3e
  , j3e = function(e) {
  if (!_3e(F3e, e) || !p3e && "string" != typeof F3e[e]) {
    var t = "Symbol." + e;
    p3e && _3e(B3e, e) ? F3e[e] = B3e[e] : F3e[e] = h3e && N3e ? N3e(t) : M3e(t)
  }
  return F3e[e]
}
  , V3e = P4e.TypeError
  , U3e = j3e("toPrimitive")
  , $3e = function(e) {
  var t = function(e, t) {
    if (!o3e(e) || g3e(e))
      return e;
    var n, r = x3e(e, U3e);
    if (r) {
      if (void 0 === t && (t = "default"),
        n = M4e(r, e, t),
      !o3e(n) || g3e(n))
        return n;
      throw V3e("Can't convert object to primitive value")
    }
    return void 0 === t && (t = "number"),
      function(e, t) {
        var n, r;
        if ("string" === t && r3e(n = e.toString) && !o3e(r = M4e(n, e)))
          return r;
        if (r3e(n = e.valueOf) && !o3e(r = M4e(n, e)))
          return r;
        if ("string" !== t && r3e(n = e.toString) && !o3e(r = M4e(n, e)))
          return r;
        throw S3e("Can't convert object to primitive value")
      }(e, t)
  }(e, "string");
  return g3e(t) ? t : t + ""
}
  , H3e = P4e.document
  , z3e = o3e(H3e) && o3e(H3e.createElement)
  , K3e = function(e) {
  return z3e ? H3e.createElement(e) : {}
}
  , W3e = !B4e && !F4e((function() {
    return 7 != Object.defineProperty(K3e("div"), "a", {
      get: function() {
        return 7
      }
    }).a
  }
))
  , G3e = Object.getOwnPropertyDescriptor
  , q3e = {
  f: B4e ? G3e : function(e, t) {
    if (e = n3e(e),
      t = $3e(t),
      W3e)
      try {
        return G3e(e, t)
      } catch (n) {}
    if (_3e(e, t))
      return $4e(!M4e(U4e.f, e, t), e[t])
  }
}
  , Y3e = P4e.String
  , X3e = P4e.TypeError
  , Q3e = function(e) {
  if (o3e(e))
    return e;
  throw X3e(Y3e(e) + " is not an object")
}
  , J3e = P4e.TypeError
  , Z3e = Object.defineProperty
  , e8e = {
  f: B4e ? Z3e : function(e, t, n) {
    if (Q3e(e),
      t = $3e(t),
      Q3e(n),
      W3e)
      try {
        return Z3e(e, t, n)
      } catch (r) {}
    if ("get"in n || "set"in n)
      throw J3e("Accessors not supported");
    return "value"in n && (e[t] = n.value),
      e
  }
}
  , t8e = B4e ? function(e, t, n) {
    return e8e.f(e, t, $4e(1, n))
  }
  : function(e, t, n) {
    return e[t] = n,
      e
  }
  , n8e = G4e(Function.toString);
r3e(C3e.inspectSource) || (C3e.inspectSource = function(e) {
    return n8e(e)
  }
);
var r8e, o8e, a8e, i8e = C3e.inspectSource, s8e = P4e.WeakMap, l8e = r3e(s8e) && /native code/.test(i8e(s8e)), u8e = k3e("keys"), c8e = function(e) {
  return u8e[e] || (u8e[e] = P3e(e))
}, d8e = {}, f8e = P4e.TypeError, p8e = P4e.WeakMap;
if (l8e || C3e.state) {
  var h8e = C3e.state || (C3e.state = new p8e)
    , v8e = G4e(h8e.get)
    , g8e = G4e(h8e.has)
    , m8e = G4e(h8e.set);
  r8e = function(e, t) {
    if (g8e(h8e, e))
      throw new f8e("Object already initialized");
    return t.facade = e,
      m8e(h8e, e, t),
      t
  }
    ,
    o8e = function(e) {
      return v8e(h8e, e) || {}
    }
    ,
    a8e = function(e) {
      return g8e(h8e, e)
    }
} else {
  var y8e = c8e("state");
  d8e[y8e] = !0,
    r8e = function(e, t) {
      if (_3e(e, y8e))
        throw new f8e("Object already initialized");
      return t.facade = e,
        t8e(e, y8e, t),
        t
    }
    ,
    o8e = function(e) {
      return _3e(e, y8e) ? e[y8e] : {}
    }
    ,
    a8e = function(e) {
      return _3e(e, y8e)
    }
}
var b8e = {
  set: r8e,
  get: o8e,
  has: a8e,
  enforce: function(e) {
    return a8e(e) ? o8e(e) : r8e(e, {})
  },
  getterFor: function(e) {
    return function(t) {
      var n;
      if (!o3e(t) || (n = o8e(t)).type !== e)
        throw f8e("Incompatible receiver, " + e + " required");
      return n
    }
  }
}
  , w8e = Function.prototype
  , x8e = B4e && Object.getOwnPropertyDescriptor
  , S8e = _3e(w8e, "name")
  , E8e = {
  EXISTS: S8e,
  PROPER: S8e && "something" === function() {}
    .name,
  CONFIGURABLE: S8e && (!B4e || B4e && x8e(w8e, "name").configurable)
}
  , A8e = _4e((function(e) {
    var t = E8e.CONFIGURABLE
      , n = b8e.get
      , r = b8e.enforce
      , o = String(String).split("String");
    (e.exports = function(e, n, a, i) {
        var s, l = !!i && !!i.unsafe, u = !!i && !!i.enumerable, c = !!i && !!i.noTargetGet, d = i && void 0 !== i.name ? i.name : n;
        r3e(a) && ("Symbol(" === String(d).slice(0, 7) && (d = "[" + String(d).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
        (!_3e(a, "name") || t && a.name !== d) && t8e(a, "name", d),
        (s = r(a)).source || (s.source = o.join("string" == typeof d ? d : ""))),
          e !== P4e ? (l ? !c && e[n] && (u = !0) : delete e[n],
            u ? e[n] = a : t8e(e, n, a)) : u ? e[n] = a : A3e(n, a)
      }
    )(Function.prototype, "toString", (function() {
        return r3e(this) && n(this).source || i8e(this)
      }
    ))
  }
))
  , C8e = Math.ceil
  , k8e = Math.floor
  , T8e = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : (t > 0 ? k8e : C8e)(t)
}
  , D8e = Math.max
  , O8e = Math.min
  , _8e = function(e, t) {
  var n = T8e(e);
  return n < 0 ? D8e(n + t, 0) : O8e(n, t)
}
  , R8e = Math.min
  , L8e = function(e) {
  return e > 0 ? R8e(T8e(e), 9007199254740991) : 0
}
  , I8e = function(e) {
  return L8e(e.length)
}
  , P8e = function(e) {
  return function(t, n, r) {
    var o, a = n3e(t), i = I8e(a), s = _8e(r, i);
    if (e && n != n) {
      for (; i > s; )
        if ((o = a[s++]) != o)
          return !0
    } else
      for (; i > s; s++)
        if ((e || s in a) && a[s] === n)
          return e || s || 0;
    return !e && -1
  }
}(!1)
  , F8e = G4e([].push)
  , B8e = function(e, t) {
  var n, r = n3e(e), o = 0, a = [];
  for (n in r)
    !_3e(d8e, n) && _3e(r, n) && F8e(a, n);
  for (; t.length > o; )
    _3e(r, n = t[o++]) && (~P8e(a, n) || F8e(a, n));
  return a
}
  , N8e = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
  , M8e = N8e.concat("length", "prototype")
  , j8e = {
  f: Object.getOwnPropertyNames || function(e) {
    return B8e(e, M8e)
  }
}
  , V8e = {
  f: Object.getOwnPropertySymbols
}
  , U8e = G4e([].concat)
  , $8e = a3e("Reflect", "ownKeys") || function(e) {
  var t = j8e.f(Q3e(e))
    , n = V8e.f;
  return n ? U8e(t, n(e)) : t
}
  , H8e = function(e, t) {
  for (var n = $8e(t), r = e8e.f, o = q3e.f, a = 0; a < n.length; a++) {
    var i = n[a];
    _3e(e, i) || r(e, i, o(t, i))
  }
}
  , z8e = /#|\.prototype\./
  , K8e = function(e, t) {
  var n = G8e[W8e(e)];
  return n == Y8e || n != q8e && (r3e(t) ? F4e(t) : !!t)
}
  , W8e = K8e.normalize = function(e) {
  return String(e).replace(z8e, ".").toLowerCase()
}
  , G8e = K8e.data = {}
  , q8e = K8e.NATIVE = "N"
  , Y8e = K8e.POLYFILL = "P"
  , X8e = K8e
  , Q8e = q3e.f
  , J8e = function(e, t) {
  var n, r, o, a, i, s = e.target, l = e.global, u = e.stat;
  if (n = l ? P4e : u ? P4e[s] || A3e(s, {}) : (P4e[s] || {}).prototype)
    for (r in t) {
      if (a = t[r],
        o = e.noTargetGet ? (i = Q8e(n, r)) && i.value : n[r],
      !X8e(l ? r : s + (u ? "." : "#") + r, e.forced) && void 0 !== o) {
        if (typeof a == typeof o)
          continue;
        H8e(a, o)
      }
      (e.sham || o && o.sham) && t8e(a, "sham", !0),
        A8e(n, r, a, e)
    }
}
  , Z8e = Array.isArray || function(e) {
  return "Array" == X4e(e)
}
  , e6e = {};
e6e[j3e("toStringTag")] = "z";
var t6e = "[object z]" === String(e6e)
  , n6e = j3e("toStringTag")
  , r6e = P4e.Object
  , o6e = "Arguments" == X4e(function() {
  return arguments
}())
  , a6e = t6e ? X4e : function(e) {
  var t, n, r;
  return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
    try {
      return e[t]
    } catch (n) {}
  }(t = r6e(e), n6e)) ? n : o6e ? X4e(t) : "Object" == (r = X4e(t)) && r3e(t.callee) ? "Arguments" : r
}
  , i6e = function() {}
  , s6e = []
  , l6e = a3e("Reflect", "construct")
  , u6e = /^\s*(?:class|function)\b/
  , c6e = G4e(u6e.exec)
  , d6e = !u6e.exec(i6e)
  , f6e = function(e) {
  if (!r3e(e))
    return !1;
  try {
    return l6e(i6e, s6e, e),
      !0
  } catch (t) {
    return !1
  }
}
  , p6e = !l6e || F4e((function() {
    var e;
    return f6e(f6e.call) || !f6e(Object) || !f6e((function() {
        e = !0
      }
    )) || e
  }
)) ? function(e) {
    if (!r3e(e))
      return !1;
    switch (a6e(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    return d6e || !!c6e(u6e, i8e(e))
  }
  : f6e
  , h6e = function(e, t, n) {
  var r = $3e(t);
  r in e ? e8e.f(e, r, $4e(0, n)) : e[r] = n
}
  , v6e = j3e("species")
  , g6e = G4e([].slice)
  , m6e = f3e >= 51 || !F4e((function() {
    var e = [];
    return (e.constructor = {})[v6e] = function() {
      return {
        foo: 1
      }
    }
      ,
    1 !== e.slice(Boolean).foo
  }
))
  , y6e = j3e("species")
  , b6e = P4e.Array
  , w6e = Math.max;
J8e({
  target: "Array",
  proto: !0,
  forced: !m6e
}, {
  slice: function(e, t) {
    var n, r, o, a = n3e(this), i = I8e(a), s = _8e(e, i), l = _8e(void 0 === t ? i : t, i);
    if (Z8e(a) && (n = a.constructor,
    (p6e(n) && (n === b6e || Z8e(n.prototype)) || o3e(n) && null === (n = n[y6e])) && (n = void 0),
    n === b6e || void 0 === n))
      return g6e(a, s, l);
    for (r = new (void 0 === n ? b6e : n)(w6e(l - s, 0)),
           o = 0; s < l; s++,
           o++)
      s in a && h6e(r, o, a[s]);
    return r.length = o,
      r
  }
});
var x6e = t6e ? {}.toString : function() {
    return "[object " + a6e(this) + "]"
  }
;
t6e || A8e(Object.prototype, "toString", x6e, {
  unsafe: !0
});
var S6e, E6e = P4e.String, A6e = function(e) {
  if ("Symbol" === a6e(e))
    throw TypeError("Cannot convert a Symbol value to a string");
  return E6e(e)
}, C6e = function() {
  var e = Q3e(this)
    , t = "";
  return e.global && (t += "g"),
  e.ignoreCase && (t += "i"),
  e.multiline && (t += "m"),
  e.dotAll && (t += "s"),
  e.unicode && (t += "u"),
  e.sticky && (t += "y"),
    t
}, k6e = P4e.RegExp, T6e = F4e((function() {
    var e = k6e("a", "y");
    return e.lastIndex = 2,
    null != e.exec("abcd")
  }
)), D6e = T6e || F4e((function() {
    return !k6e("a", "y").sticky
  }
)), O6e = {
  BROKEN_CARET: T6e || F4e((function() {
      var e = k6e("^r", "gy");
      return e.lastIndex = 2,
      null != e.exec("str")
    }
  )),
  MISSED_STICKY: D6e,
  UNSUPPORTED_Y: T6e
}, _6e = Object.keys || function(e) {
  return B8e(e, N8e)
}
  , R6e = B4e ? Object.defineProperties : function(e, t) {
  Q3e(e);
  for (var n, r = n3e(t), o = _6e(t), a = o.length, i = 0; a > i; )
    e8e.f(e, n = o[i++], r[n]);
  return e
}
  , L6e = a3e("document", "documentElement"), I6e = c8e("IE_PROTO"), P6e = function() {}, F6e = function(e) {
  return "<script>" + e + "<\/script>"
}, B6e = function(e) {
  e.write(F6e("")),
    e.close();
  var t = e.parentWindow.Object;
  return e = null,
    t
}, N6e = function() {
  try {
    S6e = new ActiveXObject("htmlfile")
  } catch (r) {}
  var e, t;
  N6e = "undefined" != typeof document ? document.domain && S6e ? B6e(S6e) : ((t = K3e("iframe")).style.display = "none",
    L6e.appendChild(t),
    t.src = String("javascript:"),
    (e = t.contentWindow.document).open(),
    e.write(F6e("document.F=Object")),
    e.close(),
    e.F) : B6e(S6e);
  for (var n = N8e.length; n--; )
    delete N6e.prototype[N8e[n]];
  return N6e()
};
d8e[I6e] = !0;
var M6e, j6e, V6e = Object.create || function(e, t) {
  var n;
  return null !== e ? (P6e.prototype = Q3e(e),
    n = new P6e,
    P6e.prototype = null,
    n[I6e] = e) : n = N6e(),
    void 0 === t ? n : R6e(n, t)
}
  , U6e = P4e.RegExp, $6e = F4e((function() {
    var e = U6e(".", "s");
    return !(e.dotAll && e.exec("\n") && "s" === e.flags)
  }
)), H6e = P4e.RegExp, z6e = F4e((function() {
    var e = H6e("(?<a>b)", "g");
    return "b" !== e.exec("b").groups.a || "bc" !== "b".replace(e, "$<a>c")
  }
)), K6e = b8e.get, W6e = k3e("native-string-replace", String.prototype.replace), G6e = RegExp.prototype.exec, q6e = G6e, Y6e = G4e("".charAt), X6e = G4e("".indexOf), Q6e = G4e("".replace), J6e = G4e("".slice), Z6e = (j6e = /b*/g,
  M4e(G6e, M6e = /a/, "a"),
  M4e(G6e, j6e, "a"),
0 !== M6e.lastIndex || 0 !== j6e.lastIndex), e5e = O6e.BROKEN_CARET, t5e = void 0 !== /()??/.exec("")[1];
(Z6e || t5e || e5e || $6e || z6e) && (q6e = function(e) {
    var t, n, r, o, a, i, s, l = this, u = K6e(l), c = A6e(e), d = u.raw;
    if (d)
      return d.lastIndex = l.lastIndex,
        t = M4e(q6e, d, c),
        l.lastIndex = d.lastIndex,
        t;
    var f = u.groups
      , p = e5e && l.sticky
      , h = M4e(C6e, l)
      , v = l.source
      , g = 0
      , m = c;
    if (p && (h = Q6e(h, "y", ""),
    -1 === X6e(h, "g") && (h += "g"),
      m = J6e(c, l.lastIndex),
    l.lastIndex > 0 && (!l.multiline || l.multiline && "\n" !== Y6e(c, l.lastIndex - 1)) && (v = "(?: " + v + ")",
      m = " " + m,
      g++),
      n = new RegExp("^(?:" + v + ")",h)),
    t5e && (n = new RegExp("^" + v + "$(?!\\s)",h)),
    Z6e && (r = l.lastIndex),
      o = M4e(G6e, p ? n : l, m),
      p ? o ? (o.input = J6e(o.input, g),
        o[0] = J6e(o[0], g),
        o.index = l.lastIndex,
        l.lastIndex += o[0].length) : l.lastIndex = 0 : Z6e && o && (l.lastIndex = l.global ? o.index + o[0].length : r),
    t5e && o && o.length > 1 && M4e(W6e, o[0], n, (function() {
        for (a = 1; a < arguments.length - 2; a++)
          void 0 === arguments[a] && (o[a] = void 0)
      }
    )),
    o && f)
      for (o.groups = i = V6e(null),
             a = 0; a < f.length; a++)
        i[(s = f[a])[0]] = o[s[1]];
    return o
  }
);
var n5e = q6e;
J8e({
  target: "RegExp",
  proto: !0,
  forced: /./.exec !== n5e
}, {
  exec: n5e
});
var r5e = Function.prototype
  , o5e = r5e.apply
  , a5e = r5e.bind
  , i5e = r5e.call
  , s5e = "object" == typeof Reflect && Reflect.apply || (a5e ? i5e.bind(o5e) : function() {
    return i5e.apply(o5e, arguments)
  }
)
  , l5e = j3e("species")
  , u5e = RegExp.prototype
  , c5e = j3e("match")
  , d5e = P4e.TypeError
  , f5e = j3e("species")
  , p5e = function(e, t) {
  var n, r = Q3e(e).constructor;
  return void 0 === r || null == (n = Q3e(r)[f5e]) ? t : function(e) {
    if (p6e(e))
      return e;
    throw d5e(y3e(e) + " is not a constructor")
  }(n)
}
  , h5e = G4e("".charAt)
  , v5e = G4e("".charCodeAt)
  , g5e = G4e("".slice)
  , m5e = function(e) {
  return function(t, n) {
    var r, o, a = A6e(t3e(t)), i = T8e(n), s = a.length;
    return i < 0 || i >= s ? e ? "" : void 0 : (r = v5e(a, i)) < 55296 || r > 56319 || i + 1 === s || (o = v5e(a, i + 1)) < 56320 || o > 57343 ? e ? h5e(a, i) : r : e ? g5e(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536
  }
}
  , y5e = {
  codeAt: m5e(!1),
  charAt: m5e(!0)
}
  , b5e = y5e.charAt
  , w5e = function(e, t, n) {
  return t + (n ? b5e(e, t).length : 1)
}
  , x5e = P4e.Array
  , S5e = Math.max
  , E5e = function(e, t, n) {
  for (var r = I8e(e), o = _8e(t, r), a = _8e(void 0 === n ? r : n, r), i = x5e(S5e(a - o, 0)), s = 0; o < a; o++,
    s++)
    h6e(i, s, e[o]);
  return i.length = s,
    i
}
  , A5e = P4e.TypeError
  , C5e = function(e, t) {
  var n = e.exec;
  if (r3e(n)) {
    var r = M4e(n, e, t);
    return null !== r && Q3e(r),
      r
  }
  if ("RegExp" === X4e(e))
    return M4e(n5e, e, t);
  throw A5e("RegExp#exec called on incompatible receiver")
}
  , k5e = O6e.UNSUPPORTED_Y
  , T5e = Math.min
  , D5e = [].push
  , O5e = G4e(/./.exec)
  , _5e = G4e(D5e)
  , R5e = G4e("".slice);
!function(e, t, n, r) {
  var o, a, i, s = j3e(e), l = !F4e((function() {
      var t = {};
      return t[s] = function() {
        return 7
      }
        ,
      7 != ""[e](t)
    }
  )), u = l && !F4e((function() {
      var e = !1
        , t = /a/;
      return (t = {}).constructor = {},
        t.constructor[l5e] = function() {
          return t
        }
        ,
        t.flags = "",
        t[s] = /./[s],
        t.exec = function() {
          return e = !0,
            null
        }
        ,
        t[s](""),
        !e
    }
  ));
  if (!l || !u || n) {
    var c = G4e(/./[s])
      , d = (o = s,
      a = ""[e],
      i = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e, t) {
          var n, r, o = A6e(t3e(this)), i = void 0 === t ? 4294967295 : t >>> 0;
          if (0 === i)
            return [];
          if (void 0 === e)
            return [o];
          if (!o3e(n = e) || !(void 0 !== (r = n[c5e]) ? r : "RegExp" == X4e(n)))
            return M4e(a, o, e, i);
          for (var s, l, u, c = [], d = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), f = 0, p = new RegExp(e.source,d + "g"); (s = M4e(n5e, p, o)) && !((l = p.lastIndex) > f && (_5e(c, R5e(o, f, s.index)),
          s.length > 1 && s.index < o.length && s5e(D5e, c, E5e(s, 1)),
            u = s[0].length,
            f = l,
          c.length >= i)); )
            p.lastIndex === s.index && p.lastIndex++;
          return f === o.length ? !u && O5e(p, "") || _5e(c, "") : _5e(c, R5e(o, f)),
            c.length > i ? E5e(c, 0, i) : c
        }
        : "0".split(void 0, 0).length ? function(e, t) {
            return void 0 === e && 0 === t ? [] : M4e(a, this, e, t)
          }
          : a,
      [function(e, t) {
        var n = t3e(this)
          , r = null == e ? void 0 : x3e(e, o);
        return r ? M4e(r, e, n, t) : M4e(i, A6e(n), e, t)
      }
        , function(e, t) {
        var n = Q3e(this)
          , r = A6e(e)
          , o = function(e, t, n, r, o) {
          var a = G4e(e)
            , i = t.exec;
          return i === n5e || i === u5e.exec ? l && !o ? {
            done: !0,
            value: c(t, n, r)
          } : {
            done: !0,
            value: a(n, t, r)
          } : {
            done: !1
          }
        }(i, n, r, t, i !== a);
        if (o.done)
          return o.value;
        var s = p5e(n, RegExp)
          , u = n.unicode
          , d = (n.ignoreCase ? "i" : "") + (n.multiline ? "m" : "") + (n.unicode ? "u" : "") + (k5e ? "g" : "y")
          , f = new s(k5e ? "^(?:" + n.source + ")" : n,d)
          , p = void 0 === t ? 4294967295 : t >>> 0;
        if (0 === p)
          return [];
        if (0 === r.length)
          return null === C5e(f, r) ? [r] : [];
        for (var h = 0, v = 0, g = []; v < r.length; ) {
          f.lastIndex = k5e ? 0 : v;
          var m, y = C5e(f, k5e ? R5e(r, v) : r);
          if (null === y || (m = T5e(L8e(f.lastIndex + (k5e ? v : 0)), r.length)) === h)
            v = w5e(r, v, u);
          else {
            if (_5e(g, R5e(r, h, v)),
            g.length === p)
              return g;
            for (var b = 1; b <= y.length - 1; b++)
              if (_5e(g, y[b]),
              g.length === p)
                return g;
            v = h = m
          }
        }
        return _5e(g, R5e(r, h)),
          g
      }
      ]);
    A8e(String.prototype, e, d[0]),
      A8e(u5e, s, d[1])
  }
  r && t8e(u5e[s], "sham", !0)
}("split", 0, !!F4e((function() {
    var e = /(?:)/
      , t = e.exec;
    e.exec = function() {
      return t.apply(this, arguments)
    }
    ;
    var n = "ab".split(e);
    return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
  }
)), k5e);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var L5e = function() {
  return L5e = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++)
      for (var o in t = arguments[n])
        Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    return e
  }
    ,
    L5e.apply(this, arguments)
};
function I5e(e, t, n, r) {
  return new (n || (n = Promise))((function(o, a) {
      function i(e) {
        try {
          l(r.next(e))
        } catch (t) {
          a(t)
        }
      }
      function s(e) {
        try {
          l(r.throw(e))
        } catch (t) {
          a(t)
        }
      }
      function l(e) {
        var t;
        e.done ? o(e.value) : (t = e.value,
          t instanceof n ? t : new n((function(e) {
              e(t)
            }
          ))).then(i, s)
      }
      l((r = r.apply(e, t || [])).next())
    }
  ))
}
function P5e(e, t) {
  var n, r, o, a, i = {
    label: 0,
    sent: function() {
      if (1 & o[0])
        throw o[1];
      return o[1]
    },
    trys: [],
    ops: []
  };
  return a = {
    next: s(0),
    throw: s(1),
    return: s(2)
  },
  "function" == typeof Symbol && (a[Symbol.iterator] = function() {
      return this
    }
  ),
    a;
  function s(a) {
    return function(s) {
      return function(a) {
        if (n)
          throw new TypeError("Generator is already executing.");
        for (; i; )
          try {
            if (n = 1,
            r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r),
              0) : r.next) && !(o = o.call(r, a[1])).done)
              return o;
            switch (r = 0,
            o && (a = [2 & a[0], o.value]),
              a[0]) {
              case 0:
              case 1:
                o = a;
                break;
              case 4:
                return i.label++,
                  {
                    value: a[1],
                    done: !1
                  };
              case 5:
                i.label++,
                  r = a[1],
                  a = [0];
                continue;
              case 7:
                a = i.ops.pop(),
                  i.trys.pop();
                continue;
              default:
                if (!((o = (o = i.trys).length > 0 && o[o.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                  i = 0;
                  continue
                }
                if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {
                  i.label = a[1];
                  break
                }
                if (6 === a[0] && i.label < o[1]) {
                  i.label = o[1],
                    o = a;
                  break
                }
                if (o && i.label < o[2]) {
                  i.label = o[2],
                    i.ops.push(a);
                  break
                }
                o[2] && i.ops.pop(),
                  i.trys.pop();
                continue
            }
            a = t.call(e, i)
          } catch (s) {
            a = [6, s],
              r = 0
          } finally {
            n = o = 0
          }
        if (5 & a[0])
          throw a[1];
        return {
          value: a[0] ? a[1] : void 0,
          done: !0
        }
      }([a, s])
    }
  }
}
var F5e = j3e("unscopables")
  , B5e = Array.prototype;
null == B5e[F5e] && e8e.f(B5e, F5e, {
  configurable: !0,
  value: V6e(null)
});
var N5e, M5e, j5e, V5e = function(e) {
  B5e[F5e][e] = !0
}, U5e = {}, $5e = !F4e((function() {
    function e() {}
    return e.prototype.constructor = null,
    Object.getPrototypeOf(new e) !== e.prototype
  }
)), H5e = c8e("IE_PROTO"), z5e = P4e.Object, K5e = z5e.prototype, W5e = $5e ? z5e.getPrototypeOf : function(e) {
  var t = D3e(e);
  if (_3e(t, H5e))
    return t[H5e];
  var n = t.constructor;
  return r3e(n) && t instanceof n ? n.prototype : t instanceof z5e ? K5e : null
}
  , G5e = j3e("iterator"), q5e = !1;
[].keys && ("next"in (j5e = [].keys()) ? (M5e = W5e(W5e(j5e))) !== Object.prototype && (N5e = M5e) : q5e = !0);
var Y5e = null == N5e || F4e((function() {
    var e = {};
    return N5e[G5e].call(e) !== e
  }
));
Y5e && (N5e = {}),
r3e(N5e[G5e]) || A8e(N5e, G5e, (function() {
    return this
  }
));
var X5e = {
  IteratorPrototype: N5e,
  BUGGY_SAFARI_ITERATORS: q5e
}
  , Q5e = e8e.f
  , J5e = j3e("toStringTag")
  , Z5e = function(e, t, n) {
  e && !_3e(e = n ? e : e.prototype, J5e) && Q5e(e, J5e, {
    configurable: !0,
    value: t
  })
}
  , e9e = X5e.IteratorPrototype
  , t9e = function() {
  return this
}
  , n9e = P4e.String
  , r9e = P4e.TypeError
  , o9e = Object.setPrototypeOf || ("__proto__"in {} ? function() {
  var e, t = !1, n = {};
  try {
    (e = G4e(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n, []),
      t = n instanceof Array
  } catch (r) {}
  return function(n, r) {
    return Q3e(n),
      function(e) {
        if ("object" == typeof e || r3e(e))
          return e;
        throw r9e("Can't set " + n9e(e) + " as a prototype")
      }(r),
      t ? e(n, r) : n.__proto__ = r,
      n
  }
}() : void 0)
  , a9e = E8e.PROPER
  , i9e = E8e.CONFIGURABLE
  , s9e = X5e.IteratorPrototype
  , l9e = X5e.BUGGY_SAFARI_ITERATORS
  , u9e = j3e("iterator")
  , c9e = function() {
  return this
}
  , d9e = function(e, t, n, r, o, a, i) {
  var s, l, u;
  l = r,
    u = t + " Iterator",
    (s = n).prototype = V6e(e9e, {
      next: $4e(1, l)
    }),
    Z5e(s, u, !1),
    U5e[u] = t9e;
  var c, d, f, p = function(e) {
    if (e === o && y)
      return y;
    if (!l9e && e in g)
      return g[e];
    switch (e) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n(this,e)
        }
    }
    return function() {
      return new n(this)
    }
  }, h = t + " Iterator", v = !1, g = e.prototype, m = g[u9e] || g["@@iterator"] || o && g[o], y = !l9e && m || p(o), b = "Array" == t && g.entries || m;
  if (b && (c = W5e(b.call(new e))) !== Object.prototype && c.next && (W5e(c) !== s9e && (o9e ? o9e(c, s9e) : r3e(c[u9e]) || A8e(c, u9e, c9e)),
    Z5e(c, h, !0)),
  a9e && "values" == o && m && "values" !== m.name && (i9e ? t8e(g, "name", "values") : (v = !0,
      y = function() {
        return M4e(m, this)
      }
  )),
    o)
    if (d = {
      values: p("values"),
      keys: a ? y : p("keys"),
      entries: p("entries")
    },
      i)
      for (f in d)
        (l9e || v || !(f in g)) && A8e(g, f, d[f]);
    else
      J8e({
        target: t,
        proto: !0,
        forced: l9e || v
      }, d);
  return g[u9e] !== y && A8e(g, u9e, y, {
    name: o
  }),
    U5e[t] = y,
    d
}
  , f9e = b8e.set
  , p9e = b8e.getterFor("Array Iterator")
  , h9e = d9e(Array, "Array", (function(e, t) {
    f9e(this, {
      type: "Array Iterator",
      target: n3e(e),
      index: 0,
      kind: t
    })
  }
), (function() {
    var e = p9e(this)
      , t = e.target
      , n = e.kind
      , r = e.index++;
    return !t || r >= t.length ? (e.target = void 0,
      {
        value: void 0,
        done: !0
      }) : "keys" == n ? {
      value: r,
      done: !1
    } : "values" == n ? {
      value: t[r],
      done: !1
    } : {
      value: [r, t[r]],
      done: !1
    }
  }
), "values");
U5e.Arguments = U5e.Array,
  V5e("keys"),
  V5e("values"),
  V5e("entries");
var v9e = y5e.charAt
  , g9e = b8e.set
  , m9e = b8e.getterFor("String Iterator");
d9e(String, "String", (function(e) {
    g9e(this, {
      type: "String Iterator",
      string: A6e(e),
      index: 0
    })
  }
), (function() {
    var e, t = m9e(this), n = t.string, r = t.index;
    return r >= n.length ? {
      value: void 0,
      done: !0
    } : (e = v9e(n, r),
      t.index += e.length,
      {
        value: e,
        done: !1
      })
  }
));
var y9e = function(e, t, n) {
  for (var r in t)
    A8e(e, r, t[r], n);
  return e
}
  , b9e = j8e.f
  , w9e = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []
  , x9e = {
  f: function(e) {
    return w9e && "Window" == X4e(e) ? function(e) {
      try {
        return b9e(e)
      } catch (t) {
        return E5e(w9e)
      }
    }(e) : b9e(n3e(e))
  }
}
  , S9e = F4e((function() {
    if ("function" == typeof ArrayBuffer) {
      var e = new ArrayBuffer(8);
      Object.isExtensible(e) && Object.defineProperty(e, "a", {
        value: 8
      })
    }
  }
))
  , E9e = Object.isExtensible
  , A9e = F4e((function() {
    E9e(1)
  }
)) || S9e ? function(e) {
    return !!o3e(e) && (!S9e || "ArrayBuffer" != X4e(e)) && (!E9e || E9e(e))
  }
  : E9e
  , C9e = !F4e((function() {
    return Object.isExtensible(Object.preventExtensions({}))
  }
))
  , k9e = _4e((function(e) {
    var t = e8e.f
      , n = !1
      , r = P3e("meta")
      , o = 0
      , a = function(e) {
      t(e, r, {
        value: {
          objectID: "O" + o++,
          weakData: {}
        }
      })
    }
      , i = e.exports = {
      enable: function() {
        i.enable = function() {}
          ,
          n = !0;
        var e = j8e.f
          , t = G4e([].splice)
          , o = {};
        o[r] = 1,
        e(o).length && (j8e.f = function(n) {
          for (var o = e(n), a = 0, i = o.length; a < i; a++)
            if (o[a] === r) {
              t(o, a, 1);
              break
            }
          return o
        }
          ,
          J8e({
            target: "Object",
            stat: !0,
            forced: !0
          }, {
            getOwnPropertyNames: x9e.f
          }))
      },
      fastKey: function(e, t) {
        if (!o3e(e))
          return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
        if (!_3e(e, r)) {
          if (!A9e(e))
            return "F";
          if (!t)
            return "E";
          a(e)
        }
        return e[r].objectID
      },
      getWeakData: function(e, t) {
        if (!_3e(e, r)) {
          if (!A9e(e))
            return !0;
          if (!t)
            return !1;
          a(e)
        }
        return e[r].weakData
      },
      onFreeze: function(e) {
        return C9e && n && A9e(e) && !_3e(e, r) && a(e),
          e
      }
    };
    d8e[r] = !0
  }
))
  , T9e = G4e(G4e.bind)
  , D9e = function(e, t) {
  return w3e(e),
    void 0 === t ? e : T9e ? T9e(e, t) : function() {
      return e.apply(t, arguments)
    }
}
  , O9e = j3e("iterator")
  , _9e = Array.prototype
  , R9e = j3e("iterator")
  , L9e = function(e) {
  if (null != e)
    return x3e(e, R9e) || x3e(e, "@@iterator") || U5e[a6e(e)]
}
  , I9e = P4e.TypeError
  , P9e = function(e, t, n) {
  var r, o;
  Q3e(e);
  try {
    if (!(r = x3e(e, "return"))) {
      if ("throw" === t)
        throw n;
      return n
    }
    r = M4e(r, e)
  } catch (a) {
    o = !0,
      r = a
  }
  if ("throw" === t)
    throw n;
  if (o)
    throw r;
  return Q3e(r),
    n
}
  , F9e = P4e.TypeError
  , B9e = function(e, t) {
  this.stopped = e,
    this.result = t
}
  , N9e = B9e.prototype
  , M9e = function(e, t, n) {
  var r, o, a, i, s, l, u, c, d = n && n.that, f = !(!n || !n.AS_ENTRIES), p = !(!n || !n.IS_ITERATOR), h = !(!n || !n.INTERRUPTED), v = D9e(t, d), g = function(e) {
    return r && P9e(r, "normal", e),
      new B9e(!0,e)
  }, m = function(e) {
    return f ? (Q3e(e),
      h ? v(e[0], e[1], g) : v(e[0], e[1])) : h ? v(e, g) : v(e)
  };
  if (p)
    r = e;
  else {
    if (!(o = L9e(e)))
      throw F9e(y3e(e) + " is not iterable");
    if (void 0 !== (c = o) && (U5e.Array === c || _9e[O9e] === c)) {
      for (a = 0,
             i = I8e(e); i > a; a++)
        if ((s = m(e[a])) && i3e(N9e, s))
          return s;
      return new B9e(!1)
    }
    r = function(e, t) {
      var n = arguments.length < 2 ? L9e(e) : t;
      if (w3e(n))
        return Q3e(M4e(n, e));
      throw I9e(y3e(e) + " is not iterable")
    }(e, o)
  }
  for (l = r.next; !(u = M4e(l, r)).done; ) {
    try {
      s = m(u.value)
    } catch (y) {
      P9e(r, "throw", y)
    }
    if ("object" == typeof s && s && i3e(N9e, s))
      return s
  }
  return new B9e(!1)
}
  , j9e = P4e.TypeError
  , V9e = function(e, t) {
  if (i3e(t, e))
    return e;
  throw j9e("Incorrect invocation")
}
  , U9e = j3e("iterator")
  , $9e = !1;
try {
  var H9e = 0
    , z9e = {
    next: function() {
      return {
        done: !!H9e++
      }
    },
    return: function() {
      $9e = !0
    }
  };
  z9e[U9e] = function() {
    return this
  }
    ,
    Array.from(z9e, (function() {
        throw 2
      }
    ))
} catch (lbt) {}
var K9e = function(e, t) {
  if (!t && !$9e)
    return !1;
  var n = !1;
  try {
    var r = {};
    r[U9e] = function() {
      return {
        next: function() {
          return {
            done: n = !0
          }
        }
      }
    }
      ,
      e(r)
  } catch (o) {}
  return n
}
  , W9e = j3e("species")
  , G9e = P4e.Array
  , q9e = function(e, t) {
  return new (Z8e(n = e) && (r = n.constructor,
  (p6e(r) && (r === G9e || Z8e(r.prototype)) || o3e(r) && null === (r = r[W9e])) && (r = void 0)),
    void 0 === r ? G9e : r)(0 === t ? 0 : t);
  var n, r
}
  , Y9e = G4e([].push)
  , X9e = function(e) {
  var t = 1 == e
    , n = 2 == e
    , r = 3 == e
    , o = 4 == e
    , a = 6 == e
    , i = 7 == e
    , s = 5 == e || a;
  return function(l, u, c, d) {
    for (var f, p, h = D3e(l), v = Z4e(h), g = D9e(u, c), m = I8e(v), y = 0, b = d || q9e, w = t ? b(l, m) : n || i ? b(l, 0) : void 0; m > y; y++)
      if ((s || y in v) && (p = g(f = v[y], y, h),
        e))
        if (t)
          w[y] = p;
        else if (p)
          switch (e) {
            case 3:
              return !0;
            case 5:
              return f;
            case 6:
              return y;
            case 2:
              Y9e(w, f)
          }
        else
          switch (e) {
            case 4:
              return !1;
            case 7:
              Y9e(w, f)
          }
    return a ? -1 : r || o ? o : w
  }
}
  , Q9e = {
  forEach: X9e(0),
  map: X9e(1),
  filter: X9e(2),
  some: X9e(3),
  every: X9e(4),
  find: X9e(5),
  findIndex: X9e(6),
  filterReject: X9e(7)
}
  , J9e = k9e.getWeakData
  , Z9e = b8e.set
  , e7e = b8e.getterFor
  , t7e = Q9e.find
  , n7e = Q9e.findIndex
  , r7e = G4e([].splice)
  , o7e = 0
  , a7e = function(e) {
  return e.frozen || (e.frozen = new i7e)
}
  , i7e = function() {
  this.entries = []
}
  , s7e = function(e, t) {
  return t7e(e.entries, (function(e) {
      return e[0] === t
    }
  ))
};
i7e.prototype = {
  get: function(e) {
    var t = s7e(this, e);
    if (t)
      return t[1]
  },
  has: function(e) {
    return !!s7e(this, e)
  },
  set: function(e, t) {
    var n = s7e(this, e);
    n ? n[1] = t : this.entries.push([e, t])
  },
  delete: function(e) {
    var t = n7e(this.entries, (function(t) {
        return t[0] === e
      }
    ));
    return ~t && r7e(this.entries, t, 1),
      !!~t
  }
};
var l7e, u7e = {
  getConstructor: function(e, t, n, r) {
    var o = e((function(e, o) {
        V9e(e, a),
          Z9e(e, {
            type: t,
            id: o7e++,
            frozen: void 0
          }),
        null != o && M9e(o, e[r], {
          that: e,
          AS_ENTRIES: n
        })
      }
    ))
      , a = o.prototype
      , i = e7e(t)
      , s = function(e, t, n) {
      var r = i(e)
        , o = J9e(Q3e(t), !0);
      return !0 === o ? a7e(r).set(t, n) : o[r.id] = n,
        e
    };
    return y9e(a, {
      delete: function(e) {
        var t = i(this);
        if (!o3e(e))
          return !1;
        var n = J9e(e);
        return !0 === n ? a7e(t).delete(e) : n && _3e(n, t.id) && delete n[t.id]
      },
      has: function(e) {
        var t = i(this);
        if (!o3e(e))
          return !1;
        var n = J9e(e);
        return !0 === n ? a7e(t).has(e) : n && _3e(n, t.id)
      }
    }),
      y9e(a, n ? {
        get: function(e) {
          var t = i(this);
          if (o3e(e)) {
            var n = J9e(e);
            return !0 === n ? a7e(t).get(e) : n ? n[t.id] : void 0
          }
        },
        set: function(e, t) {
          return s(this, e, t)
        }
      } : {
        add: function(e) {
          return s(this, e, !0)
        }
      }),
      o
  }
}, c7e = b8e.enforce, d7e = !P4e.ActiveXObject && "ActiveXObject"in P4e, f7e = function(e) {
  return function() {
    return e(this, arguments.length ? arguments[0] : void 0)
  }
}, p7e = function(e, t, n) {
  var r = -1 !== e.indexOf("Map")
    , o = -1 !== e.indexOf("Weak")
    , a = r ? "set" : "add"
    , i = P4e[e]
    , s = i && i.prototype
    , l = i
    , u = {}
    , c = function(e) {
    var t = G4e(s[e]);
    A8e(s, e, "add" == e ? function(e) {
          return t(this, 0 === e ? 0 : e),
            this
        }
        : "delete" == e ? function(e) {
            return !(o && !o3e(e)) && t(this, 0 === e ? 0 : e)
          }
          : "get" == e ? function(e) {
              return o && !o3e(e) ? void 0 : t(this, 0 === e ? 0 : e)
            }
            : "has" == e ? function(e) {
                return !(o && !o3e(e)) && t(this, 0 === e ? 0 : e)
              }
              : function(e, n) {
                return t(this, 0 === e ? 0 : e, n),
                  this
              }
    )
  };
  if (X8e(e, !r3e(i) || !(o || s.forEach && !F4e((function() {
      (new i).entries().next()
    }
  )))))
    l = n.getConstructor(t, e, r, a),
      k9e.enable();
  else if (X8e(e, !0)) {
    var d = new l
      , f = d[a](o ? {} : -0, 1) != d
      , p = F4e((function() {
        d.has(1)
      }
    ))
      , h = K9e((function(e) {
        new i(e)
      }
    ))
      , v = !o && F4e((function() {
        for (var e = new i, t = 5; t--; )
          e[a](t, t);
        return !e.has(-0)
      }
    ));
    h || ((l = t((function(e, t) {
        V9e(e, s);
        var n, o, u, c, d, f = (n = new i,
          o = e,
          u = l,
        o9e && r3e(c = o.constructor) && c !== u && o3e(d = c.prototype) && d !== u.prototype && o9e(n, d),
          n);
        return null != t && M9e(t, f[a], {
          that: f,
          AS_ENTRIES: r
        }),
          f
      }
    ))).prototype = s,
      s.constructor = l),
    (p || v) && (c("delete"),
      c("has"),
    r && c("get")),
    (v || f) && c(a),
    o && s.clear && delete s.clear
  }
  return u[e] = l,
    J8e({
      global: !0,
      forced: l != i
    }, u),
    Z5e(l, e),
  o || n.setStrong(l, e, r),
    l
}("WeakMap", f7e, u7e);
if (l8e && d7e) {
  l7e = u7e.getConstructor(f7e, "WeakMap", !0),
    k9e.enable();
  var h7e = p7e.prototype
    , v7e = G4e(h7e.delete)
    , g7e = G4e(h7e.has)
    , m7e = G4e(h7e.get)
    , y7e = G4e(h7e.set);
  y9e(h7e, {
    delete: function(e) {
      if (o3e(e) && !A9e(e)) {
        var t = c7e(this);
        return t.frozen || (t.frozen = new l7e),
        v7e(this, e) || t.frozen.delete(e)
      }
      return v7e(this, e)
    },
    has: function(e) {
      if (o3e(e) && !A9e(e)) {
        var t = c7e(this);
        return t.frozen || (t.frozen = new l7e),
        g7e(this, e) || t.frozen.has(e)
      }
      return g7e(this, e)
    },
    get: function(e) {
      if (o3e(e) && !A9e(e)) {
        var t = c7e(this);
        return t.frozen || (t.frozen = new l7e),
          g7e(this, e) ? m7e(this, e) : t.frozen.get(e)
      }
      return m7e(this, e)
    },
    set: function(e, t) {
      if (o3e(e) && !A9e(e)) {
        var n = c7e(this);
        n.frozen || (n.frozen = new l7e),
          g7e(this, e) ? y7e(this, e, t) : n.frozen.set(e, t)
      } else
        y7e(this, e, t);
      return this
    }
  })
}
var b7e = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}
  , w7e = K3e("span").classList
  , x7e = w7e && w7e.constructor && w7e.constructor.prototype
  , S7e = x7e === Object.prototype ? void 0 : x7e
  , E7e = j3e("iterator")
  , A7e = j3e("toStringTag")
  , C7e = h9e.values
  , k7e = function(e, t) {
  if (e) {
    if (e[E7e] !== C7e)
      try {
        t8e(e, E7e, C7e)
      } catch (r) {
        e[E7e] = C7e
      }
    if (e[A7e] || t8e(e, A7e, t),
      b7e[t])
      for (var n in h9e)
        if (e[n] !== h9e[n])
          try {
            t8e(e, n, h9e[n])
          } catch (r) {
            e[n] = h9e[n]
          }
  }
};
for (var T7e in b7e)
  k7e(P4e[T7e] && P4e[T7e].prototype, T7e);
k7e(S7e, "DOMTokenList");
var D7e = function(e, t) {
  var n = [][e];
  return !!n && F4e((function() {
      n.call(null, t || function() {
        throw 1
      }
        , 1)
    }
  ))
}
  , O7e = Q9e.forEach
  , _7e = D7e("forEach") ? [].forEach : function(e) {
  return O7e(this, e, arguments.length > 1 ? arguments[1] : void 0)
}
  , R7e = function(e) {
  if (e && e.forEach !== _7e)
    try {
      t8e(e, "forEach", _7e)
    } catch (X_) {
      e.forEach = _7e
    }
};
for (var L7e in b7e)
  b7e[L7e] && R7e(P4e[L7e] && P4e[L7e].prototype);
R7e(S7e);
var I7e, P7e, F7e, B7e, N7e = P4e.Promise, M7e = j3e("species"), j7e = /(?:ipad|iphone|ipod).*applewebkit/i.test(s3e), V7e = "process" == X4e(P4e.process), U7e = P4e.setImmediate, $7e = P4e.clearImmediate, H7e = P4e.process, z7e = P4e.Dispatch, K7e = P4e.Function, W7e = P4e.MessageChannel, G7e = P4e.String, q7e = 0, Y7e = {};
try {
  I7e = P4e.location
} catch (lbt) {}
var X7e = function(e) {
  if (_3e(Y7e, e)) {
    var t = Y7e[e];
    delete Y7e[e],
      t()
  }
}
  , Q7e = function(e) {
  return function() {
    X7e(e)
  }
}
  , J7e = function(e) {
  X7e(e.data)
}
  , Z7e = function(e) {
  P4e.postMessage(G7e(e), I7e.protocol + "//" + I7e.host)
};
U7e && $7e || (U7e = function(e) {
    var t = g6e(arguments, 1);
    return Y7e[++q7e] = function() {
      s5e(r3e(e) ? e : K7e(e), void 0, t)
    }
      ,
      P7e(q7e),
      q7e
  }
    ,
    $7e = function(e) {
      delete Y7e[e]
    }
    ,
    V7e ? P7e = function(e) {
        H7e.nextTick(Q7e(e))
      }
      : z7e && z7e.now ? P7e = function(e) {
          z7e.now(Q7e(e))
        }
        : W7e && !j7e ? (B7e = (F7e = new W7e).port2,
          F7e.port1.onmessage = J7e,
          P7e = D9e(B7e.postMessage, B7e)) : P4e.addEventListener && r3e(P4e.postMessage) && !P4e.importScripts && I7e && "file:" !== I7e.protocol && !F4e(Z7e) ? (P7e = Z7e,
          P4e.addEventListener("message", J7e, !1)) : P7e = "onreadystatechange"in K3e("script") ? function(e) {
            L6e.appendChild(K3e("script")).onreadystatechange = function() {
              L6e.removeChild(this),
                X7e(e)
            }
          }
          : function(e) {
            setTimeout(Q7e(e), 0)
          }
);
var eet, tet, net, ret, oet, aet, iet, set, uet = {
  set: U7e,
  clear: $7e
}, cet = /ipad|iphone|ipod/i.test(s3e) && void 0 !== P4e.Pebble, det = /web0s(?!.*chrome)/i.test(s3e), fet = q3e.f, pet = uet.set, het = P4e.MutationObserver || P4e.WebKitMutationObserver, vet = P4e.document, get = P4e.process, met = P4e.Promise, yet = fet(P4e, "queueMicrotask"), bet = yet && yet.value;
bet || (eet = function() {
  var e, t;
  for (V7e && (e = get.domain) && e.exit(); tet; ) {
    t = tet.fn,
      tet = tet.next;
    try {
      t()
    } catch (n) {
      throw tet ? ret() : net = void 0,
        n
    }
  }
  net = void 0,
  e && e.enter()
}
  ,
  j7e || V7e || det || !het || !vet ? !cet && met && met.resolve ? ((iet = met.resolve(void 0)).constructor = met,
      set = D9e(iet.then, iet),
      ret = function() {
        set(eet)
      }
  ) : V7e ? ret = function() {
      get.nextTick(eet)
    }
    : (pet = D9e(pet, P4e),
        ret = function() {
          pet(eet)
        }
    ) : (oet = !0,
      aet = vet.createTextNode(""),
      new het(eet).observe(aet, {
        characterData: !0
      }),
      ret = function() {
        aet.data = oet = !oet
      }
  ));
var wet, xet, Eet, Aet, Cet = bet || function(e) {
  var t = {
    fn: e,
    next: void 0
  };
  net && (net.next = t),
  tet || (tet = t,
    ret()),
    net = t
}
  , ket = function(e) {
  var t, n;
  this.promise = new e((function(e, r) {
      if (void 0 !== t || void 0 !== n)
        throw TypeError("Bad Promise constructor");
      t = e,
        n = r
    }
  )),
    this.resolve = w3e(t),
    this.reject = w3e(n)
}, Tet = {
  f: function(e) {
    return new ket(e)
  }
}, Det = function(e) {
  try {
    return {
      error: !1,
      value: e()
    }
  } catch (t) {
    return {
      error: !0,
      value: t
    }
  }
}, Oet = "object" == typeof window, _et = uet.set, Ret = j3e("species"), Let = "Promise", Iet = b8e.getterFor(Let), Pet = b8e.set, Fet = b8e.getterFor(Let), Bet = N7e && N7e.prototype, Net = N7e, Met = Bet, jet = P4e.TypeError, Vet = P4e.document, Uet = P4e.process, $et = Tet.f, Het = $et, zet = !!(Vet && Vet.createEvent && P4e.dispatchEvent), Ket = r3e(P4e.PromiseRejectionEvent), Wet = !1, Get = X8e(Let, (function() {
    var e = i8e(Net)
      , t = e !== String(Net);
    if (!t && 66 === f3e)
      return !0;
    if (f3e >= 51 && /native code/.test(e))
      return !1;
    var n = new Net((function(e) {
        e(1)
      }
    ))
      , r = function(e) {
      e((function() {}
      ), (function() {}
      ))
    };
    return (n.constructor = {})[Ret] = r,
    !(Wet = n.then((function() {}
    ))instanceof r) || !t && Oet && !Ket
  }
)), qet = Get || !K9e((function(e) {
    Net.all(e).catch((function() {}
    ))
  }
)), Yet = function(e) {
  var t;
  return !(!o3e(e) || !r3e(t = e.then)) && t
}, Xet = function(e, t) {
  if (!e.notified) {
    e.notified = !0;
    var n = e.reactions;
    Cet((function() {
        for (var r = e.value, o = 1 == e.state, a = 0; n.length > a; ) {
          var i, s, l, u = n[a++], c = o ? u.ok : u.fail, d = u.resolve, f = u.reject, p = u.domain;
          try {
            c ? (o || (2 === e.rejection && ett(e),
              e.rejection = 1),
              !0 === c ? i = r : (p && p.enter(),
                i = c(r),
              p && (p.exit(),
                l = !0)),
              i === u.promise ? f(jet("Promise-chain cycle")) : (s = Yet(i)) ? M4e(s, i, d, f) : d(i)) : f(r)
          } catch (h) {
            p && !l && p.exit(),
              f(h)
          }
        }
        e.reactions = [],
          e.notified = !1,
        t && !e.rejection && Jet(e)
      }
    ))
  }
}, Qet = function(e, t, n) {
  var r, o;
  zet ? ((r = Vet.createEvent("Event")).promise = t,
    r.reason = n,
    r.initEvent(e, !1, !0),
    P4e.dispatchEvent(r)) : r = {
    promise: t,
    reason: n
  },
    !Ket && (o = P4e["on" + e]) ? o(r) : "unhandledrejection" === e && function(e, t) {
      var n = P4e.console;
      n && n.error && (1 == arguments.length ? n.error(e) : n.error(e, t))
    }("Unhandled promise rejection", n)
}, Jet = function(e) {
  M4e(_et, P4e, (function() {
      var t, n = e.facade, r = e.value;
      if (Zet(e) && (t = Det((function() {
          V7e ? Uet.emit("unhandledRejection", r, n) : Qet("unhandledrejection", n, r)
        }
      )),
        e.rejection = V7e || Zet(e) ? 2 : 1,
        t.error))
        throw t.value
    }
  ))
}, Zet = function(e) {
  return 1 !== e.rejection && !e.parent
}, ett = function(e) {
  M4e(_et, P4e, (function() {
      var t = e.facade;
      V7e ? Uet.emit("rejectionHandled", t) : Qet("rejectionhandled", t, e.value)
    }
  ))
}, ttt = function(e, t, n) {
  return function(r) {
    e(t, r, n)
  }
}, ntt = function(e, t, n) {
  e.done || (e.done = !0,
  n && (e = n),
    e.value = t,
    e.state = 2,
    Xet(e, !0))
}, rtt = function(e, t, n) {
  if (!e.done) {
    e.done = !0,
    n && (e = n);
    try {
      if (e.facade === t)
        throw jet("Promise can't be resolved itself");
      var r = Yet(t);
      r ? Cet((function() {
          var n = {
            done: !1
          };
          try {
            M4e(r, t, ttt(rtt, n, e), ttt(ntt, n, e))
          } catch (o) {
            ntt(n, o, e)
          }
        }
      )) : (e.value = t,
        e.state = 1,
        Xet(e, !1))
    } catch (o) {
      ntt({
        done: !1
      }, o, e)
    }
  }
};
if (Get && (Met = (Net = function(e) {
    V9e(this, Met),
      w3e(e),
      M4e(wet, this);
    var t = Iet(this);
    try {
      e(ttt(rtt, t), ttt(ntt, t))
    } catch (n) {
      ntt(t, n)
    }
  }
).prototype,
  (wet = function(e) {
      Pet(this, {
        type: Let,
        done: !1,
        notified: !1,
        parent: !1,
        reactions: [],
        rejection: !1,
        state: 0,
        value: void 0
      })
    }
  ).prototype = y9e(Met, {
    then: function(e, t) {
      var n = Fet(this)
        , r = n.reactions
        , o = $et(p5e(this, Net));
      return o.ok = !r3e(e) || e,
        o.fail = r3e(t) && t,
        o.domain = V7e ? Uet.domain : void 0,
        n.parent = !0,
        r[r.length] = o,
      0 != n.state && Xet(n, !1),
        o.promise
    },
    catch: function(e) {
      return this.then(void 0, e)
    }
  }),
  xet = function() {
    var e = new wet
      , t = Iet(e);
    this.promise = e,
      this.resolve = ttt(rtt, t),
      this.reject = ttt(ntt, t)
  }
  ,
  Tet.f = $et = function(e) {
    return e === Net || e === Eet ? new xet(e) : Het(e)
  }
  ,
r3e(N7e) && Bet !== Object.prototype)) {
  Aet = Bet.then,
  Wet || (A8e(Bet, "then", (function(e, t) {
      var n = this;
      return new Net((function(e, t) {
          M4e(Aet, n, e, t)
        }
      )).then(e, t)
    }
  ), {
    unsafe: !0
  }),
    A8e(Bet, "catch", Met.catch, {
      unsafe: !0
    }));
  try {
    delete Bet.constructor
  } catch (lbt) {}
  o9e && o9e(Bet, Met)
}
J8e({
  global: !0,
  wrap: !0,
  forced: Get
}, {
  Promise: Net
}),
  Z5e(Net, Let, !1),
  function(e) {
    var t = a3e("Promise")
      , n = e8e.f;
    B4e && t && !t[M7e] && n(t, M7e, {
      configurable: !0,
      get: function() {
        return this
      }
    })
  }(),
  Eet = a3e(Let),
  J8e({
    target: Let,
    stat: !0,
    forced: Get
  }, {
    reject: function(e) {
      var t = $et(this);
      return M4e(t.reject, void 0, e),
        t.promise
    }
  }),
  J8e({
    target: Let,
    stat: !0,
    forced: Get
  }, {
    resolve: function(e) {
      return function(e, t) {
        if (Q3e(e),
        o3e(t) && t.constructor === e)
          return t;
        var n = Tet.f(e);
        return (0,
          n.resolve)(t),
          n.promise
      }(this, e)
    }
  }),
  J8e({
    target: Let,
    stat: !0,
    forced: qet
  }, {
    all: function(e) {
      var t = this
        , n = $et(t)
        , r = n.resolve
        , o = n.reject
        , a = Det((function() {
          var n = w3e(t.resolve)
            , a = []
            , i = 0
            , s = 1;
          M9e(e, (function(e) {
              var l = i++
                , u = !1;
              s++,
                M4e(n, t, e).then((function(e) {
                    u || (u = !0,
                      a[l] = e,
                    --s || r(a))
                  }
                ), o)
            }
          )),
          --s || r(a)
        }
      ));
      return a.error && o(a.value),
        n.promise
    },
    race: function(e) {
      var t = this
        , n = $et(t)
        , r = n.reject
        , o = Det((function() {
          var o = w3e(t.resolve);
          M9e(e, (function(e) {
              M4e(o, t, e).then(n.resolve, r)
            }
          ))
        }
      ));
      return o.error && r(o.value),
        n.promise
    }
  });
var ott = E8e.PROPER
  , att = RegExp.prototype
  , itt = att.toString
  , stt = G4e(C6e)
  , ltt = F4e((function() {
    return "/a/b" != itt.call({
      source: "a",
      flags: "b"
    })
  }
))
  , utt = ott && "toString" != itt.name;
(ltt || utt) && A8e(RegExp.prototype, "toString", (function() {
    var e = Q3e(this)
      , t = A6e(e.source)
      , n = e.flags;
    return "/" + t + "/" + A6e(void 0 === n && i3e(att, e) && !("flags"in att) ? stt(e) : n)
  }
), {
  unsafe: !0
});
var ctt = E8e.EXISTS
  , dtt = e8e.f
  , ftt = Function.prototype
  , ptt = G4e(ftt.toString)
  , htt = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/
  , vtt = G4e(htt.exec);
B4e && !ctt && dtt(ftt, "name", {
  configurable: !0,
  get: function() {
    try {
      return vtt(htt, ptt(this))[1]
    } catch (Y_) {
      return ""
    }
  }
});
var gtt = new WeakMap;
function mtt(e) {
  return e.getMenuConfig("uploadImage")
}
function ytt(e, t) {
  return I5e(this, void 0, void 0, (function() {
      return P5e(this, (function(n) {
          return [2, new Promise((function(n) {
              var r = new FileReader;
              r.readAsDataURL(t),
                r.onload = function() {
                  var o = r.result;
                  if (o) {
                    var a = o.toString()
                      , i = 0 === a.indexOf("data:image") ? "" : a;
                    eRe(e, a, t.name, i),
                      n("ok")
                  }
                }
            }
          ))]
        }
      ))
    }
  ))
}
function btt(e, t) {
  return I5e(this, void 0, void 0, (function() {
      var n, r, o, a;
      return P5e(this, (function(i) {
          switch (i.label) {
            case 0:
              return n = function(e) {
                var t = gtt.get(e);
                if (null != t)
                  return t;
                var n = mtt(e)
                  , r = n.onSuccess
                  , o = n.onProgress
                  , a = n.onFailed
                  , i = n.customInsert
                  , s = n.onError;
                return t = ISe(L5e(L5e({}, n), {
                  onProgress: function(t) {
                    e.showProgressBar(t),
                    o && o(t)
                  },
                  onSuccess: function(t, n) {
                    if (i)
                      return i(n, (function(t, n, r) {
                          return eRe(e, t, n, r)
                        }
                      )),
                        void r(t, n);
                    var o = n.errno
                      , s = void 0 === o ? 1 : o
                      , l = n.data
                      , u = void 0 === l ? {} : l;
                    if (0 === s) {
                      if (Array.isArray(u))
                        u.forEach((function(t) {
                            var n = t.url
                              , r = void 0 === n ? "" : n
                              , o = t.alt
                              , a = void 0 === o ? "" : o
                              , i = t.href;
                            eRe(e, r, a, void 0 === i ? "" : i)
                          }
                        ));
                      else {
                        var c = u.url
                          , d = void 0 === c ? "" : c
                          , f = u.alt
                          , p = void 0 === f ? "" : f
                          , h = u.href;
                        eRe(e, d, p, void 0 === h ? "" : h)
                      }
                      r(t, n)
                    } else
                      a(t, n)
                  },
                  onError: function(e, t, n) {
                    s(e, t, n)
                  }
                })),
                  gtt.set(e, t),
                  t
              }(e),
                r = t.name,
                o = t.type,
                a = t.size,
                n.addFile({
                  name: r,
                  type: o,
                  size: a,
                  data: t
                }),
                [4, n.upload()];
            case 1:
              return i.sent(),
                [2]
          }
        }
      ))
    }
  ))
}
function wtt(e, t) {
  var n, r;
  return I5e(this, void 0, void 0, (function() {
      var o, a, i, s, l, u, c, d, f;
      return P5e(this, (function(p) {
          switch (p.label) {
            case 0:
              if (null == t)
                return [2];
              o = Array.prototype.slice.call(t),
                a = mtt(e),
                i = a.customUpload,
                s = a.base64LimitSize,
                p.label = 1;
            case 1:
              p.trys.push([1, 11, 12, 17]),
                l = function(e) {
                  if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined.");
                  var t, n = e[Symbol.asyncIterator];
                  return n ? n.call(e) : (e = function(e) {
                    var t = "function" == typeof Symbol && Symbol.iterator
                      , n = t && e[t]
                      , r = 0;
                    if (n)
                      return n.call(e);
                    if (e && "number" == typeof e.length)
                      return {
                        next: function() {
                          return e && r >= e.length && (e = void 0),
                            {
                              value: e && e[r++],
                              done: !e
                            }
                        }
                      };
                    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
                  }(e),
                    t = {},
                    r("next"),
                    r("throw"),
                    r("return"),
                    t[Symbol.asyncIterator] = function() {
                      return this
                    }
                    ,
                    t);
                  function r(n) {
                    t[n] = e[n] && function(t) {
                      return new Promise((function(r, o) {
                          var a, i, s, l;
                          a = r,
                            i = o,
                            s = (t = e[n](t)).done,
                            l = t.value,
                            Promise.resolve(l).then((function(e) {
                                a({
                                  value: e,
                                  done: s
                                })
                              }
                            ), i)
                        }
                      ))
                    }
                  }
                }(o),
                p.label = 2;
            case 2:
              return [4, l.next()];
            case 3:
              return (u = p.sent()).done ? [3, 10] : (c = u.value,
                d = c.size,
                s && d <= s ? [4, ytt(e, c)] : [3, 5]);
            case 4:
              return p.sent(),
                [3, 9];
            case 5:
              return i ? [4, i(c, (function(t, n, r) {
                  return eRe(e, t, n, r)
                }
              ))] : [3, 7];
            case 6:
              return p.sent(),
                [3, 9];
            case 7:
              return [4, btt(e, c)];
            case 8:
              p.sent(),
                p.label = 9;
            case 9:
              return [3, 2];
            case 10:
              return [3, 17];
            case 11:
              return f = p.sent(),
                n = {
                  error: f
                },
                [3, 17];
            case 12:
              return p.trys.push([12, , 15, 16]),
                u && !u.done && (r = l.return) ? [4, r.call(l)] : [3, 14];
            case 13:
              p.sent(),
                p.label = 14;
            case 14:
              return [3, 16];
            case 15:
              if (n)
                throw n.error;
              return [7];
            case 16:
              return [7];
            case 17:
              return [2]
          }
        }
      ))
    }
  ))
}
var xtt = G4e([].join)
  , Stt = Z4e != Object
  , Ett = D7e("join", ",");
J8e({
  target: "Array",
  proto: !0,
  forced: Stt || !Ett
}, {
  join: function(e) {
    return xtt(n3e(this), void 0 === e ? "," : e)
  }
}),
yoe && (Qre.fn.append = yoe),
aoe && (Qre.fn.on = aoe),
Aoe && (Qre.fn.remove = Aoe),
ooe && (Qre.fn.val = ooe),
Doe && (Qre.fn.click = Doe),
coe && (Qre.fn.hide = coe);
var Att = function() {
  function e() {
    this.title = SEe("uploadImgModule.uploadImage"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M828.708571 585.045333a48.761905 48.761905 0 0 0-48.737523 48.761905v18.529524l-72.143238-72.167619a135.972571 135.972571 0 0 0-191.585524 0l-34.133334 34.133333-120.880762-120.953905a138.898286 138.898286 0 0 0-191.585523 0l-72.167619 72.167619V292.400762a48.786286 48.786286 0 0 1 48.761904-48.761905h341.23581a48.737524 48.737524 0 0 0 34.474667-83.285333 48.737524 48.737524 0 0 0-34.474667-14.287238H146.236952A146.212571 146.212571 0 0 0 0 292.400762v585.289143A146.358857 146.358857 0 0 0 146.236952 1024h584.996572a146.212571 146.212571 0 0 0 146.236952-146.310095V633.807238a48.786286 48.786286 0 0 0-48.761905-48.761905zM146.261333 926.45181a48.737524 48.737524 0 0 1-48.761904-48.761905v-174.128762l141.409523-141.458286a38.497524 38.497524 0 0 1 53.126096 0l154.526476 154.624 209.627428 209.724953H146.236952z m633.734096-48.761905c-0.073143 9.337905-3.145143 18.383238-8.777143 25.843809l-219.843048-220.94019 34.133333-34.133334a37.546667 37.546667 0 0 1 53.613715 0l140.873143 141.897143V877.714286zM1009.615238 160.231619L863.329524 13.897143a48.737524 48.737524 0 0 0-16.091429-10.24c-11.849143-4.87619-25.161143-4.87619-37.059047 0a48.761905 48.761905 0 0 0-16.067048 10.24l-146.236952 146.334476a49.005714 49.005714 0 0 0 69.217523 69.241905l62.902858-63.390476v272.627809a48.761905 48.761905 0 1 0 97.475047 0V166.083048l62.902857 63.390476a48.737524 48.737524 0 0 0 69.217524 0 48.761905 48.761905 0 0 0 0-69.241905z"></path></svg>',
      this.tag = "button"
  }
  return e.prototype.getValue = function(e) {
    return ""
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.isDisabled = function(e) {
      return tRe(e)
    }
    ,
    e.prototype.getMenuConfig = function(e) {
      return e.getMenuConfig("uploadImage")
    }
    ,
    e.prototype.exec = function(e, t) {
      var n = this.getMenuConfig(e)
        , r = n.allowedFileTypes
        , o = void 0 === r ? [] : r
        , a = n.customBrowseAndUpload;
      if (a)
        a((function(t, n, r) {
            return eRe(e, t, n, r)
          }
        ));
      else {
        var i = "";
        o.length > 0 && (i = 'accept="' + o.join(", ") + '"');
        var s = Qre("body")
          , l = Qre('<input type="file" ' + i + " multiple/>");
        l.hide(),
          s.append(l),
          l.click(),
          l.on("change", (function() {
              var t = l[0].files;
              wtt(e, t)
            }
          ))
      }
    }
    ,
    e
}()
  , Ctt = {
  menus: [{
    key: "uploadImage",
    factory: function() {
      return new Att
    },
    config: {
      server: "",
      fieldName: "wangeditor-uploaded-image",
      maxFileSize: 2097152,
      maxNumberOfFiles: 100,
      allowedFileTypes: ["image/*"],
      meta: {},
      metaWithUrl: !1,
      withCredentials: !1,
      timeout: 1e4,
      onBeforeUpload: function(e) {
        return e
      },
      onProgress: function(e) {},
      onSuccess: function(e, t) {},
      onFailed: function(e, t) {
        console.error("'" + e.name + "' upload failed", t)
      },
      onError: function(e, t, n) {
        console.error("'" + e.name + "' upload error", n)
      },
      base64LimitSize: 0
    }
  }],
  editorPlugin: function(e) {
    var t = e.insertData
      , n = e;
    return n.insertData = function(r) {
      if (tRe(n))
        t(r);
      else if (r.getData("text/plain"))
        t(r);
      else {
        var o = r.files;
        o.length <= 0 ? t(r) : Array.prototype.slice.call(o).some((function(e) {
            return "image" === function(e, t) {
              var n = "function" == typeof Symbol && e[Symbol.iterator];
              if (!n)
                return e;
              var r, o, a = n.call(e), i = [];
              try {
                for (; (void 0 === t || t-- > 0) && !(r = a.next()).done; )
                  i.push(r.value)
              } catch (s) {
                o = {
                  error: s
                }
              } finally {
                try {
                  r && !r.done && (n = a.return) && n.call(a)
                } finally {
                  if (o)
                    throw o.error
                }
              }
              return i
            }(e.type.split("/"), 1)[0]
          }
        )) ? wtt(e, o) : t(r)
      }
    }
      ,
      n
  }
};
xEe("en", {
  highLightModule: {
    selectLang: "Language"
  }
}),
  xEe("zh-CN", {
    highLightModule: {
      selectLang: "选择语言"
    }
  });
var ktt = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function Ttt(e) {
  var t = {
    exports: {}
  };
  return e(t, t.exports),
    t.exports
}
var Dtt, Ott, _tt = function(e) {
  return e && e.Math == Math && e
}, Rtt = _tt("object" == typeof globalThis && globalThis) || _tt("object" == typeof window && window) || _tt("object" == typeof self && self) || _tt("object" == typeof ktt && ktt) || function() {
  return this
}() || Function("return this")(), Ltt = Object.defineProperty, Itt = function(e, t) {
  try {
    Ltt(Rtt, e, {
      value: t,
      configurable: !0,
      writable: !0
    })
  } catch (AEe) {
    Rtt[e] = t
  }
  return t
}, Ptt = Rtt["__core-js_shared__"] || Itt("__core-js_shared__", {}), Ftt = Ttt((function(e) {
    (e.exports = function(e, t) {
        return Ptt[e] || (Ptt[e] = void 0 !== t ? t : {})
      }
    )("versions", []).push({
      version: "3.19.3",
      mode: "global",
      copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
    })
  }
)), Btt = Function.prototype, Ntt = Btt.bind, Mtt = Btt.call, jtt = Ntt && Ntt.bind(Mtt), Vtt = Ntt ? function(e) {
    return e && jtt(Mtt, e)
  }
  : function(e) {
    return e && function() {
      return Mtt.apply(e, arguments)
    }
  }
  , Utt = Rtt.TypeError, $tt = function(e) {
  if (null == e)
    throw Utt("Can't call method on " + e);
  return e
}, Htt = Rtt.Object, ztt = function(e) {
  return Htt($tt(e))
}, Ktt = Vtt({}.hasOwnProperty), Wtt = Object.hasOwn || function(e, t) {
  return Ktt(ztt(e), t)
}
  , Gtt = 0, qtt = Math.random(), Ytt = Vtt(1..toString), Xtt = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + Ytt(++Gtt + qtt, 36)
}, Qtt = function(e) {
  return "function" == typeof e
}, Jtt = function(e, t) {
  return arguments.length < 2 ? function(e) {
    return Qtt(e) ? e : void 0
  }(Rtt[e]) : Rtt[e] && Rtt[e][t]
}, Ztt = Jtt("navigator", "userAgent") || "", ent = Rtt.process, tnt = Rtt.Deno, nnt = ent && ent.versions || tnt && tnt.version, rnt = nnt && nnt.v8;
rnt && (Ott = (Dtt = rnt.split("."))[0] > 0 && Dtt[0] < 4 ? 1 : +(Dtt[0] + Dtt[1])),
!Ott && Ztt && (!(Dtt = Ztt.match(/Edge\/(\d+)/)) || Dtt[1] >= 74) && (Dtt = Ztt.match(/Chrome\/(\d+)/)) && (Ott = +Dtt[1]);
var ont = Ott
  , ant = function(e) {
  try {
    return !!e()
  } catch (t) {
    return !0
  }
}
  , int = !!Object.getOwnPropertySymbols && !ant((function() {
    var e = Symbol();
    return !String(e) || !(Object(e)instanceof Symbol) || !Symbol.sham && ont && ont < 41
  }
))
  , snt = int && !Symbol.sham && "symbol" == typeof Symbol.iterator
  , lnt = Ftt("wks")
  , unt = Rtt.Symbol
  , cnt = unt && unt.for
  , dnt = snt ? unt : unt && unt.withoutSetter || Xtt
  , fnt = function(e) {
  if (!Wtt(lnt, e) || !int && "string" != typeof lnt[e]) {
    var t = "Symbol." + e;
    int && Wtt(unt, e) ? lnt[e] = unt[e] : lnt[e] = snt && cnt ? cnt(t) : dnt(t)
  }
  return lnt[e]
}
  , pnt = {};
pnt[fnt("toStringTag")] = "z";
var hnt = "[object z]" === String(pnt)
  , vnt = !ant((function() {
    return 7 != Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1]
  }
))
  , gnt = function(e) {
  return "object" == typeof e ? null !== e : Qtt(e)
}
  , mnt = Rtt.document
  , ynt = gnt(mnt) && gnt(mnt.createElement)
  , bnt = function(e) {
  return ynt ? mnt.createElement(e) : {}
}
  , wnt = !vnt && !ant((function() {
    return 7 != Object.defineProperty(bnt("div"), "a", {
      get: function() {
        return 7
      }
    }).a
  }
))
  , xnt = Rtt.String
  , Snt = Rtt.TypeError
  , Ent = function(e) {
  if (gnt(e))
    return e;
  throw Snt(xnt(e) + " is not an object")
}
  , Ant = Function.prototype.call
  , Cnt = Ant.bind ? Ant.bind(Ant) : function() {
  return Ant.apply(Ant, arguments)
}
  , knt = Vtt({}.isPrototypeOf)
  , Tnt = Rtt.Object
  , Dnt = snt ? function(e) {
    return "symbol" == typeof e
  }
  : function(e) {
    var t = Jtt("Symbol");
    return Qtt(t) && knt(t.prototype, Tnt(e))
  }
  , Ont = Rtt.String
  , _nt = function(e) {
  try {
    return Ont(e)
  } catch (t) {
    return "Object"
  }
}
  , Rnt = Rtt.TypeError
  , Lnt = function(e) {
  if (Qtt(e))
    return e;
  throw Rnt(_nt(e) + " is not a function")
}
  , Int = function(e, t) {
  var n = e[t];
  return null == n ? void 0 : Lnt(n)
}
  , Pnt = Rtt.TypeError
  , Fnt = Rtt.TypeError
  , Bnt = fnt("toPrimitive")
  , Nnt = function(e) {
  var t = function(e, t) {
    if (!gnt(e) || Dnt(e))
      return e;
    var n, r = Int(e, Bnt);
    if (r) {
      if (void 0 === t && (t = "default"),
        n = Cnt(r, e, t),
      !gnt(n) || Dnt(n))
        return n;
      throw Fnt("Can't convert object to primitive value")
    }
    return void 0 === t && (t = "number"),
      function(e, t) {
        var n, r;
        if ("string" === t && Qtt(n = e.toString) && !gnt(r = Cnt(n, e)))
          return r;
        if (Qtt(n = e.valueOf) && !gnt(r = Cnt(n, e)))
          return r;
        if ("string" !== t && Qtt(n = e.toString) && !gnt(r = Cnt(n, e)))
          return r;
        throw Pnt("Can't convert object to primitive value")
      }(e, t)
  }(e, "string");
  return Dnt(t) ? t : t + ""
}
  , Mnt = Rtt.TypeError
  , jnt = Object.defineProperty
  , Vnt = {
  f: vnt ? jnt : function(e, t, n) {
    if (Ent(e),
      t = Nnt(t),
      Ent(n),
      wnt)
      try {
        return jnt(e, t, n)
      } catch (r) {}
    if ("get"in n || "set"in n)
      throw Mnt("Accessors not supported");
    return "value"in n && (e[t] = n.value),
      e
  }
}
  , Unt = function(e, t) {
  return {
    enumerable: !(1 & e),
    configurable: !(2 & e),
    writable: !(4 & e),
    value: t
  }
}
  , $nt = vnt ? function(e, t, n) {
    return Vnt.f(e, t, Unt(1, n))
  }
  : function(e, t, n) {
    return e[t] = n,
      e
  }
  , Hnt = Vtt(Function.toString);
Qtt(Ptt.inspectSource) || (Ptt.inspectSource = function(e) {
    return Hnt(e)
  }
);
var znt, Knt, Wnt, Gnt = Ptt.inspectSource, qnt = Rtt.WeakMap, Ynt = Qtt(qnt) && /native code/.test(Gnt(qnt)), Xnt = Ftt("keys"), Qnt = function(e) {
  return Xnt[e] || (Xnt[e] = Xtt(e))
}, Jnt = {}, Znt = Rtt.TypeError, ert = Rtt.WeakMap;
if (Ynt || Ptt.state) {
  var trt = Ptt.state || (Ptt.state = new ert)
    , nrt = Vtt(trt.get)
    , rrt = Vtt(trt.has)
    , ort = Vtt(trt.set);
  znt = function(e, t) {
    if (rrt(trt, e))
      throw new Znt("Object already initialized");
    return t.facade = e,
      ort(trt, e, t),
      t
  }
    ,
    Knt = function(e) {
      return nrt(trt, e) || {}
    }
    ,
    Wnt = function(e) {
      return rrt(trt, e)
    }
} else {
  var art = Qnt("state");
  Jnt[art] = !0,
    znt = function(e, t) {
      if (Wtt(e, art))
        throw new Znt("Object already initialized");
      return t.facade = e,
        $nt(e, art, t),
        t
    }
    ,
    Knt = function(e) {
      return Wtt(e, art) ? e[art] : {}
    }
    ,
    Wnt = function(e) {
      return Wtt(e, art)
    }
}
var irt = {
    set: znt,
    get: Knt,
    has: Wnt,
    enforce: function(e) {
      return Wnt(e) ? Knt(e) : znt(e, {})
    },
    getterFor: function(e) {
      return function(t) {
        var n;
        if (!gnt(t) || (n = Knt(t)).type !== e)
          throw Znt("Incompatible receiver, " + e + " required");
        return n
      }
    }
  }
  , srt = Function.prototype
  , lrt = vnt && Object.getOwnPropertyDescriptor
  , urt = Wtt(srt, "name")
  , crt = {
    EXISTS: urt,
    PROPER: urt && "something" === function() {}
      .name,
    CONFIGURABLE: urt && (!vnt || vnt && lrt(srt, "name").configurable)
  }
  , drt = Ttt((function(e) {
      var t = crt.CONFIGURABLE
        , n = irt.get
        , r = irt.enforce
        , o = String(String).split("String");
      (e.exports = function(e, n, a, i) {
          var s, l = !!i && !!i.unsafe, u = !!i && !!i.enumerable, c = !!i && !!i.noTargetGet, d = i && void 0 !== i.name ? i.name : n;
          Qtt(a) && ("Symbol(" === String(d).slice(0, 7) && (d = "[" + String(d).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
          (!Wtt(a, "name") || t && a.name !== d) && $nt(a, "name", d),
          (s = r(a)).source || (s.source = o.join("string" == typeof d ? d : ""))),
            e !== Rtt ? (l ? !c && e[n] && (u = !0) : delete e[n],
              u ? e[n] = a : $nt(e, n, a)) : u ? e[n] = a : Itt(n, a)
        }
      )(Function.prototype, "toString", (function() {
          return Qtt(this) && n(this).source || Gnt(this)
        }
      ))
    }
  ))
  , frt = Vtt({}.toString)
  , prt = Vtt("".slice)
  , hrt = function(e) {
    return prt(frt(e), 8, -1)
  }
  , vrt = fnt("toStringTag")
  , grt = Rtt.Object
  , mrt = "Arguments" == hrt(function() {
    return arguments
  }())
  , yrt = hnt ? hrt : function(e) {
    var t, n, r;
    return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = function(e, t) {
      try {
        return e[t]
      } catch (n) {}
    }(t = grt(e), vrt)) ? n : mrt ? hrt(t) : "Object" == (r = hrt(t)) && Qtt(t.callee) ? "Arguments" : r
  }
  , brt = hnt ? {}.toString : function() {
    return "[object " + yrt(this) + "]"
  }
;
hnt || drt(Object.prototype, "toString", brt, {
  unsafe: !0
});
var wrt, xrt = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}, Srt = bnt("span").classList, Ert = Srt && Srt.constructor && Srt.constructor.prototype, Art = Ert === Object.prototype ? void 0 : Ert, Crt = Vtt(Vtt.bind), krt = Rtt.Object, Trt = Vtt("".split), Drt = ant((function() {
    return !krt("z").propertyIsEnumerable(0)
  }
)) ? function(e) {
    return "String" == hrt(e) ? Trt(e, "") : krt(e)
  }
  : krt, Ort = Math.ceil, _rt = Math.floor, Rrt = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : (t > 0 ? _rt : Ort)(t)
}, Lrt = Math.min, Irt = function(e) {
  return e > 0 ? Lrt(Rrt(e), 9007199254740991) : 0
}, Prt = function(e) {
  return Irt(e.length)
}, Frt = Array.isArray || function(e) {
  return "Array" == hrt(e)
}
  , Brt = function() {}, Nrt = [], Mrt = Jtt("Reflect", "construct"), jrt = /^\s*(?:class|function)\b/, Vrt = Vtt(jrt.exec), Urt = !jrt.exec(Brt), $rt = function(e) {
  if (!Qtt(e))
    return !1;
  try {
    return Mrt(Brt, Nrt, e),
      !0
  } catch (t) {
    return !1
  }
}, Hrt = !Mrt || ant((function() {
    var e;
    return $rt($rt.call) || !$rt(Object) || !$rt((function() {
        e = !0
      }
    )) || e
  }
)) ? function(e) {
    if (!Qtt(e))
      return !1;
    switch (yrt(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    return Urt || !!Vrt(jrt, Gnt(e))
  }
  : $rt, zrt = fnt("species"), Krt = Rtt.Array, Wrt = function(e, t) {
  return new (Frt(n = e) && (r = n.constructor,
  (Hrt(r) && (r === Krt || Frt(r.prototype)) || gnt(r) && null === (r = r[zrt])) && (r = void 0)),
    void 0 === r ? Krt : r)(0 === t ? 0 : t);
  var n, r
}, Grt = Vtt([].push), qrt = function(e) {
  var t = 1 == e
    , n = 2 == e
    , r = 3 == e
    , o = 4 == e
    , a = 6 == e
    , i = 7 == e
    , s = 5 == e || a;
  return function(l, u, c, d) {
    for (var f, p, h = ztt(l), v = Drt(h), g = function(e, t) {
      return Lnt(e),
        void 0 === t ? e : Crt ? Crt(e, t) : function() {
          return e.apply(t, arguments)
        }
    }(u, c), m = Prt(v), y = 0, b = d || Wrt, w = t ? b(l, m) : n || i ? b(l, 0) : void 0; m > y; y++)
      if ((s || y in v) && (p = g(f = v[y], y, h),
        e))
        if (t)
          w[y] = p;
        else if (p)
          switch (e) {
            case 3:
              return !0;
            case 5:
              return f;
            case 6:
              return y;
            case 2:
              Grt(w, f)
          }
        else
          switch (e) {
            case 4:
              return !1;
            case 7:
              Grt(w, f)
          }
    return a ? -1 : r || o ? o : w
  }
}, Yrt = [qrt(0), qrt(1), qrt(2), qrt(3), qrt(4), qrt(5), qrt(6), qrt(7)][0], Xrt = (wrt = [].forEach) && ant((function() {
    wrt.call(null, (function() {
        throw 1
      }
    ), 1)
  }
)) ? [].forEach : function(e) {
  return Yrt(this, e, arguments.length > 1 ? arguments[1] : void 0)
}
  , Qrt = function(e) {
  if (e && e.forEach !== Xrt)
    try {
      $nt(e, "forEach", Xrt)
    } catch (X_) {
      e.forEach = Xrt
    }
};
for (var Jrt in xrt)
  xrt[Jrt] && Qrt(Rtt[Jrt] && Rtt[Jrt].prototype);
Qrt(Art);
var Zrt = {}.propertyIsEnumerable
  , eot = Object.getOwnPropertyDescriptor
  , tot = {
  f: eot && !Zrt.call({
    1: 2
  }, 1) ? function(e) {
      var t = eot(this, e);
      return !!t && t.enumerable
    }
    : Zrt
}
  , not = function(e) {
  return Drt($tt(e))
}
  , rot = Object.getOwnPropertyDescriptor
  , oot = {
  f: vnt ? rot : function(e, t) {
    if (e = not(e),
      t = Nnt(t),
      wnt)
      try {
        return rot(e, t)
      } catch (n) {}
    if (Wtt(e, t))
      return Unt(!Cnt(tot.f, e, t), e[t])
  }
}
  , aot = Math.max
  , iot = Math.min
  , sot = function(e, t) {
  var n = Rrt(e);
  return n < 0 ? aot(n + t, 0) : iot(n, t)
}
  , lot = function(e) {
  return function(t, n, r) {
    var o, a = not(t), i = Prt(a), s = sot(r, i);
    if (e && n != n) {
      for (; i > s; )
        if ((o = a[s++]) != o)
          return !0
    } else
      for (; i > s; s++)
        if ((e || s in a) && a[s] === n)
          return e || s || 0;
    return !e && -1
  }
}(!1)
  , uot = Vtt([].push)
  , cot = function(e, t) {
  var n, r = not(e), o = 0, a = [];
  for (n in r)
    !Wtt(Jnt, n) && Wtt(r, n) && uot(a, n);
  for (; t.length > o; )
    Wtt(r, n = t[o++]) && (~lot(a, n) || uot(a, n));
  return a
}
  , dot = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
  , fot = dot.concat("length", "prototype")
  , pot = {
  f: Object.getOwnPropertyNames || function(e) {
    return cot(e, fot)
  }
}
  , hot = {
  f: Object.getOwnPropertySymbols
}
  , vot = Vtt([].concat)
  , got = Jtt("Reflect", "ownKeys") || function(e) {
  var t = pot.f(Ent(e))
    , n = hot.f;
  return n ? vot(t, n(e)) : t
}
  , mot = function(e, t) {
  for (var n = got(t), r = Vnt.f, o = oot.f, a = 0; a < n.length; a++) {
    var i = n[a];
    Wtt(e, i) || r(e, i, o(t, i))
  }
}
  , yot = /#|\.prototype\./
  , bot = function(e, t) {
  var n = xot[wot(e)];
  return n == Eot || n != Sot && (Qtt(t) ? ant(t) : !!t)
}
  , wot = bot.normalize = function(e) {
  return String(e).replace(yot, ".").toLowerCase()
}
  , xot = bot.data = {}
  , Sot = bot.NATIVE = "N"
  , Eot = bot.POLYFILL = "P"
  , Aot = bot
  , Cot = oot.f
  , kot = function(e, t) {
  var n, r, o, a, i, s = e.target, l = e.global, u = e.stat;
  if (n = l ? Rtt : u ? Rtt[s] || Itt(s, {}) : (Rtt[s] || {}).prototype)
    for (r in t) {
      if (a = t[r],
        o = e.noTargetGet ? (i = Cot(n, r)) && i.value : n[r],
      !Aot(l ? r : s + (u ? "." : "#") + r, e.forced) && void 0 !== o) {
        if (typeof a == typeof o)
          continue;
        mot(a, o)
      }
      (e.sham || o && o.sham) && $nt(a, "sham", !0),
        drt(n, r, a, e)
    }
}
  , Tot = Object.keys || function(e) {
  return cot(e, dot)
}
  , Dot = Object.assign
  , Oot = Object.defineProperty
  , _ot = Vtt([].concat)
  , Rot = !Dot || ant((function() {
    if (vnt && 1 !== Dot({
      b: 1
    }, Dot(Oot({}, "a", {
      enumerable: !0,
      get: function() {
        Oot(this, "b", {
          value: 3,
          enumerable: !1
        })
      }
    }), {
      b: 2
    })).b)
      return !0;
    var e = {}
      , t = {}
      , n = Symbol()
      , r = "abcdefghijklmnopqrst";
    return e[n] = 7,
      r.split("").forEach((function(e) {
          t[e] = e
        }
      )),
    7 != Dot({}, e)[n] || Tot(Dot({}, t)).join("") != r
  }
)) ? function(e, t) {
    for (var n = ztt(e), r = arguments.length, o = 1, a = hot.f, i = tot.f; r > o; )
      for (var s, l = Drt(arguments[o++]), u = a ? _ot(Tot(l), a(l)) : Tot(l), c = u.length, d = 0; c > d; )
        s = u[d++],
        vnt && !Cnt(i, l, s) || (n[s] = l[s]);
    return n
  }
  : Dot;
kot({
  target: "Object",
  stat: !0,
  forced: Object.assign !== Rot
}, {
  assign: Rot
});
var Lot = Ttt((function(e) {
    var t = function(e) {
      var t = /\blang(?:uage)?-([\w-]+)\b/i
        , n = 0
        , r = {}
        , o = {
        manual: e.Prism && e.Prism.manual,
        disableWorkerMessageHandler: e.Prism && e.Prism.disableWorkerMessageHandler,
        util: {
          encode: function e(t) {
            return t instanceof a ? new a(t.type,e(t.content),t.alias) : Array.isArray(t) ? t.map(e) : t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ")
          },
          type: function(e) {
            return Object.prototype.toString.call(e).slice(8, -1)
          },
          objId: function(e) {
            return e.__id || Object.defineProperty(e, "__id", {
              value: ++n
            }),
              e.__id
          },
          clone: function e(t, n) {
            var r, a;
            switch (n = n || {},
              o.util.type(t)) {
              case "Object":
                if (a = o.util.objId(t),
                  n[a])
                  return n[a];
                for (var i in r = {},
                  n[a] = r,
                  t)
                  t.hasOwnProperty(i) && (r[i] = e(t[i], n));
                return r;
              case "Array":
                return a = o.util.objId(t),
                  n[a] ? n[a] : (r = [],
                    n[a] = r,
                    t.forEach((function(t, o) {
                        r[o] = e(t, n)
                      }
                    )),
                    r);
              default:
                return t
            }
          },
          getLanguage: function(e) {
            for (; e && !t.test(e.className); )
              e = e.parentElement;
            return e ? (e.className.match(t) || [, "none"])[1].toLowerCase() : "none"
          },
          currentScript: function() {
            if ("undefined" == typeof document)
              return null;
            if ("currentScript"in document)
              return document.currentScript;
            try {
              throw new Error
            } catch (r) {
              var e = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(r.stack) || [])[1];
              if (e) {
                var t = document.getElementsByTagName("script");
                for (var n in t)
                  if (t[n].src == e)
                    return t[n]
              }
              return null
            }
          },
          isActive: function(e, t, n) {
            for (var r = "no-" + t; e; ) {
              var o = e.classList;
              if (o.contains(t))
                return !0;
              if (o.contains(r))
                return !1;
              e = e.parentElement
            }
            return !!n
          }
        },
        languages: {
          plain: r,
          plaintext: r,
          text: r,
          txt: r,
          extend: function(e, t) {
            var n = o.util.clone(o.languages[e]);
            for (var r in t)
              n[r] = t[r];
            return n
          },
          insertBefore: function(e, t, n, r) {
            var a = (r = r || o.languages)[e]
              , i = {};
            for (var s in a)
              if (a.hasOwnProperty(s)) {
                if (s == t)
                  for (var l in n)
                    n.hasOwnProperty(l) && (i[l] = n[l]);
                n.hasOwnProperty(s) || (i[s] = a[s])
              }
            var u = r[e];
            return r[e] = i,
              o.languages.DFS(o.languages, (function(t, n) {
                  n === u && t != e && (this[t] = i)
                }
              )),
              i
          },
          DFS: function e(t, n, r, a) {
            a = a || {};
            var i = o.util.objId;
            for (var s in t)
              if (t.hasOwnProperty(s)) {
                n.call(t, s, t[s], r || s);
                var l = t[s]
                  , u = o.util.type(l);
                "Object" !== u || a[i(l)] ? "Array" !== u || a[i(l)] || (a[i(l)] = !0,
                  e(l, n, s, a)) : (a[i(l)] = !0,
                  e(l, n, null, a))
              }
          }
        },
        plugins: {},
        highlightAll: function(e, t) {
          o.highlightAllUnder(document, e, t)
        },
        highlightAllUnder: function(e, t, n) {
          var r = {
            callback: n,
            container: e,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          o.hooks.run("before-highlightall", r),
            r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)),
            o.hooks.run("before-all-elements-highlight", r);
          for (var a, i = 0; a = r.elements[i++]; )
            o.highlightElement(a, !0 === t, r.callback)
        },
        highlightElement: function(n, r, a) {
          var i = o.util.getLanguage(n)
            , s = o.languages[i];
          n.className = n.className.replace(t, "").replace(/\s+/g, " ") + " language-" + i;
          var l = n.parentElement;
          l && "pre" === l.nodeName.toLowerCase() && (l.className = l.className.replace(t, "").replace(/\s+/g, " ") + " language-" + i);
          var u = {
            element: n,
            language: i,
            grammar: s,
            code: n.textContent
          };
          function c(e) {
            u.highlightedCode = e,
              o.hooks.run("before-insert", u),
              u.element.innerHTML = u.highlightedCode,
              o.hooks.run("after-highlight", u),
              o.hooks.run("complete", u),
            a && a.call(u.element)
          }
          if (o.hooks.run("before-sanity-check", u),
          (l = u.element.parentElement) && "pre" === l.nodeName.toLowerCase() && !l.hasAttribute("tabindex") && l.setAttribute("tabindex", "0"),
            !u.code)
            return o.hooks.run("complete", u),
              void (a && a.call(u.element));
          if (o.hooks.run("before-highlight", u),
            u.grammar)
            if (r && e.Worker) {
              var d = new Worker(o.filename);
              d.onmessage = function(e) {
                c(e.data)
              }
                ,
                d.postMessage(JSON.stringify({
                  language: u.language,
                  code: u.code,
                  immediateClose: !0
                }))
            } else
              c(o.highlight(u.code, u.grammar, u.language));
          else
            c(o.util.encode(u.code))
        },
        highlight: function(e, t, n) {
          var r = {
            code: e,
            grammar: t,
            language: n
          };
          return o.hooks.run("before-tokenize", r),
            r.tokens = o.tokenize(r.code, r.grammar),
            o.hooks.run("after-tokenize", r),
            a.stringify(o.util.encode(r.tokens), r.language)
        },
        tokenize: function(e, t) {
          var n = t.rest;
          if (n) {
            for (var r in n)
              t[r] = n[r];
            delete t.rest
          }
          var o = new l;
          return u(o, o.head, e),
            s(e, o, t, o.head, 0),
            function(e) {
              for (var t = [], n = e.head.next; n !== e.tail; )
                t.push(n.value),
                  n = n.next;
              return t
            }(o)
        },
        hooks: {
          all: {},
          add: function(e, t) {
            var n = o.hooks.all;
            n[e] = n[e] || [],
              n[e].push(t)
          },
          run: function(e, t) {
            var n = o.hooks.all[e];
            if (n && n.length)
              for (var r, a = 0; r = n[a++]; )
                r(t)
          }
        },
        Token: a
      };
      function a(e, t, n, r) {
        this.type = e,
          this.content = t,
          this.alias = n,
          this.length = 0 | (r || "").length
      }
      function i(e, t, n, r) {
        e.lastIndex = t;
        var o = e.exec(n);
        if (o && r && o[1]) {
          var a = o[1].length;
          o.index += a,
            o[0] = o[0].slice(a)
        }
        return o
      }
      function s(e, t, n, r, l, d) {
        for (var f in n)
          if (n.hasOwnProperty(f) && n[f]) {
            var p = n[f];
            p = Array.isArray(p) ? p : [p];
            for (var h = 0; h < p.length; ++h) {
              if (d && d.cause == f + "," + h)
                return;
              var v = p[h]
                , g = v.inside
                , m = !!v.lookbehind
                , y = !!v.greedy
                , b = v.alias;
              if (y && !v.pattern.global) {
                var w = v.pattern.toString().match(/[imsuy]*$/)[0];
                v.pattern = RegExp(v.pattern.source, w + "g")
              }
              for (var x = v.pattern || v, S = r.next, E = l; S !== t.tail && !(d && E >= d.reach); E += S.value.length,
                S = S.next) {
                var A = S.value;
                if (t.length > e.length)
                  return;
                if (!(A instanceof a)) {
                  var C, k = 1;
                  if (y) {
                    if (!(C = i(x, E, e, m)))
                      break;
                    var T = C.index
                      , D = C.index + C[0].length
                      , O = E;
                    for (O += S.value.length; T >= O; )
                      O += (S = S.next).value.length;
                    if (E = O -= S.value.length,
                    S.value instanceof a)
                      continue;
                    for (var _ = S; _ !== t.tail && (O < D || "string" == typeof _.value); _ = _.next)
                      k++,
                        O += _.value.length;
                    k--,
                      A = e.slice(E, O),
                      C.index -= E
                  } else if (!(C = i(x, 0, A, m)))
                    continue;
                  T = C.index;
                  var R = C[0]
                    , L = A.slice(0, T)
                    , I = A.slice(T + R.length)
                    , P = E + A.length;
                  d && P > d.reach && (d.reach = P);
                  var F = S.prev;
                  if (L && (F = u(t, F, L),
                    E += L.length),
                    c(t, F, k),
                    S = u(t, F, new a(f,g ? o.tokenize(R, g) : R,b,R)),
                  I && u(t, S, I),
                  k > 1) {
                    var B = {
                      cause: f + "," + h,
                      reach: P
                    };
                    s(e, t, n, S.prev, E, B),
                    d && B.reach > d.reach && (d.reach = B.reach)
                  }
                }
              }
            }
          }
      }
      function l() {
        var e = {
          value: null,
          prev: null,
          next: null
        }
          , t = {
          value: null,
          prev: e,
          next: null
        };
        e.next = t,
          this.head = e,
          this.tail = t,
          this.length = 0
      }
      function u(e, t, n) {
        var r = t.next
          , o = {
          value: n,
          prev: t,
          next: r
        };
        return t.next = o,
          r.prev = o,
          e.length++,
          o
      }
      function c(e, t, n) {
        for (var r = t.next, o = 0; o < n && r !== e.tail; o++)
          r = r.next;
        t.next = r,
          r.prev = t,
          e.length -= o
      }
      if (e.Prism = o,
        a.stringify = function e(t, n) {
          if ("string" == typeof t)
            return t;
          if (Array.isArray(t)) {
            var r = "";
            return t.forEach((function(t) {
                r += e(t, n)
              }
            )),
              r
          }
          var a = {
            type: t.type,
            content: e(t.content, n),
            tag: "span",
            classes: ["token", t.type],
            attributes: {},
            language: n
          }
            , i = t.alias;
          i && (Array.isArray(i) ? Array.prototype.push.apply(a.classes, i) : a.classes.push(i)),
            o.hooks.run("wrap", a);
          var s = "";
          for (var l in a.attributes)
            s += " " + l + '="' + (a.attributes[l] || "").replace(/"/g, "&quot;") + '"';
          return "<" + a.tag + ' class="' + a.classes.join(" ") + '"' + s + ">" + a.content + "</" + a.tag + ">"
        }
        ,
        !e.document)
        return e.addEventListener ? (o.disableWorkerMessageHandler || e.addEventListener("message", (function(t) {
            var n = JSON.parse(t.data)
              , r = n.language
              , a = n.code
              , i = n.immediateClose;
            e.postMessage(o.highlight(a, o.languages[r], r)),
            i && e.close()
          }
        ), !1),
          o) : o;
      var d = o.util.currentScript();
      function f() {
        o.manual || o.highlightAll()
      }
      if (d && (o.filename = d.src,
      d.hasAttribute("data-manual") && (o.manual = !0)),
        !o.manual) {
        var p = document.readyState;
        "loading" === p || "interactive" === p && d && d.defer ? document.addEventListener("DOMContentLoaded", f) : window.requestAnimationFrame ? window.requestAnimationFrame(f) : window.setTimeout(f, 16)
      }
      return o
    }("undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {});
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    e.exports && (e.exports = t),
    void 0 !== ktt && (ktt.Prism = t),
      t.languages.markup = {
        comment: {
          pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
          greedy: !0
        },
        prolog: {
          pattern: /<\?[\s\S]+?\?>/,
          greedy: !0
        },
        doctype: {
          pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
          greedy: !0,
          inside: {
            "internal-subset": {
              pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
              lookbehind: !0,
              greedy: !0,
              inside: null
            },
            string: {
              pattern: /"[^"]*"|'[^']*'/,
              greedy: !0
            },
            punctuation: /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            name: /[^\s<>'"]+/
          }
        },
        cdata: {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          greedy: !0
        },
        tag: {
          pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
          greedy: !0,
          inside: {
            tag: {
              pattern: /^<\/?[^\s>\/]+/,
              inside: {
                punctuation: /^<\/?/,
                namespace: /^[^\s>\/:]+:/
              }
            },
            "special-attr": [],
            "attr-value": {
              pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
              inside: {
                punctuation: [{
                  pattern: /^=/,
                  alias: "attr-equals"
                }, /"|'/]
              }
            },
            punctuation: /\/?>/,
            "attr-name": {
              pattern: /[^\s>\/]+/,
              inside: {
                namespace: /^[^\s>\/:]+:/
              }
            }
          }
        },
        entity: [{
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        }, /&#x?[\da-f]{1,8};/i]
      },
      t.languages.markup.tag.inside["attr-value"].inside.entity = t.languages.markup.entity,
      t.languages.markup.doctype.inside["internal-subset"].inside = t.languages.markup,
      t.hooks.add("wrap", (function(e) {
          "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"))
        }
      )),
      Object.defineProperty(t.languages.markup.tag, "addInlined", {
        value: function(e, n) {
          var r = {};
          r["language-" + n] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: !0,
            inside: t.languages[n]
          },
            r.cdata = /^<!\[CDATA\[|\]\]>$/i;
          var o = {
            "included-cdata": {
              pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
              inside: r
            }
          };
          o["language-" + n] = {
            pattern: /[\s\S]+/,
            inside: t.languages[n]
          };
          var a = {};
          a[e] = {
            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, (function() {
                return e
              }
            )), "i"),
            lookbehind: !0,
            greedy: !0,
            inside: o
          },
            t.languages.insertBefore("markup", "cdata", a)
        }
      }),
      Object.defineProperty(t.languages.markup.tag, "addAttribute", {
        value: function(e, n) {
          t.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(/(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
            lookbehind: !0,
            inside: {
              "attr-name": /^[^\s=]+/,
              "attr-value": {
                pattern: /=[\s\S]+/,
                inside: {
                  value: {
                    pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                    lookbehind: !0,
                    alias: [n, "language-" + n],
                    inside: t.languages[n]
                  },
                  punctuation: [{
                    pattern: /^=/,
                    alias: "attr-equals"
                  }, /"|'/]
                }
              }
            }
          })
        }
      }),
      t.languages.html = t.languages.markup,
      t.languages.mathml = t.languages.markup,
      t.languages.svg = t.languages.markup,
      t.languages.xml = t.languages.extend("markup", {}),
      t.languages.ssml = t.languages.xml,
      t.languages.atom = t.languages.xml,
      t.languages.rss = t.languages.xml,
      function(e) {
        var t = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        e.languages.css = {
          comment: /\/\*[\s\S]*?\*\//,
          atrule: {
            pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
            inside: {
              rule: /^@[\w-]+/,
              "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: !0,
                alias: "selector"
              },
              keyword: {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: !0
              }
            }
          },
          url: {
            pattern: RegExp("\\burl\\((?:" + t.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
            greedy: !0,
            inside: {
              function: /^url/i,
              punctuation: /^\(|\)$/,
              string: {
                pattern: RegExp("^" + t.source + "$"),
                alias: "url"
              }
            }
          },
          selector: {
            pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|" + t.source + ")*(?=\\s*\\{)"),
            lookbehind: !0
          },
          string: {
            pattern: t,
            greedy: !0
          },
          property: {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: !0
          },
          important: /!important\b/i,
          function: {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: !0
          },
          punctuation: /[(){};:,]/
        },
          e.languages.css.atrule.inside.rest = e.languages.css;
        var n = e.languages.markup;
        n && (n.tag.addInlined("style", "css"),
          n.tag.addAttribute("style", "css"))
      }(t),
      t.languages.clike = {
        comment: [{
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        }, {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }],
        string: {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: !0
        },
        "class-name": {
          pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
          lookbehind: !0,
          inside: {
            punctuation: /[.\\]/
          }
        },
        keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
        boolean: /\b(?:true|false)\b/,
        function: /\b\w+(?=\()/,
        number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        punctuation: /[{}[\];(),.:]/
      },
      t.languages.javascript = t.languages.extend("clike", {
        "class-name": [t.languages.clike["class-name"], {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
          lookbehind: !0
        }],
        keyword: [{
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: !0
        }, {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0
        }],
        function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
        operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
      }),
      t.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/,
      t.languages.insertBefore("javascript", "keyword", {
        regex: {
          pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            "regex-source": {
              pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
              lookbehind: !0,
              alias: "language-regex",
              inside: t.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
          }
        },
        "function-variable": {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: "function"
        },
        parameter: [{
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: t.languages.javascript
        }, {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: t.languages.javascript
        }, {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: t.languages.javascript
        }, {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: t.languages.javascript
        }],
        constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
      }),
      t.languages.insertBefore("javascript", "string", {
        hashbang: {
          pattern: /^#!.*/,
          greedy: !0,
          alias: "comment"
        },
        "template-string": {
          pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
          greedy: !0,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
              lookbehind: !0,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: t.languages.javascript
              }
            },
            string: /[\s\S]+/
          }
        }
      }),
    t.languages.markup && (t.languages.markup.tag.addInlined("script", "javascript"),
      t.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")),
      t.languages.js = t.languages.javascript,
      function() {
        if (void 0 !== t && "undefined" != typeof document) {
          Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
          var e = {
            js: "javascript",
            py: "python",
            rb: "ruby",
            ps1: "powershell",
            psm1: "powershell",
            sh: "bash",
            bat: "batch",
            h: "c",
            tex: "latex"
          }
            , n = "data-src-status"
            , r = 'pre[data-src]:not([data-src-status="loaded"]):not([data-src-status="loading"])'
            , o = /\blang(?:uage)?-([\w-]+)\b/i;
          t.hooks.add("before-highlightall", (function(e) {
              e.selector += ", " + r
            }
          )),
            t.hooks.add("before-sanity-check", (function(o) {
                var a = o.element;
                if (a.matches(r)) {
                  o.code = "",
                    a.setAttribute(n, "loading");
                  var s = a.appendChild(document.createElement("CODE"));
                  s.textContent = "Loading…";
                  var l = a.getAttribute("data-src")
                    , u = o.language;
                  if ("none" === u) {
                    var c = (/\.(\w+)$/.exec(l) || [, "none"])[1];
                    u = e[c] || c
                  }
                  i(s, u),
                    i(a, u);
                  var d = t.plugins.autoloader;
                  d && d.loadLanguages(u);
                  var f = new XMLHttpRequest;
                  f.open("GET", l, !0),
                    f.onreadystatechange = function() {
                      4 == f.readyState && (f.status < 400 && f.responseText ? (a.setAttribute(n, "loaded"),
                        s.textContent = f.responseText,
                        t.highlightElement(s)) : (a.setAttribute(n, "failed"),
                        f.status >= 400 ? s.textContent = "✖ Error " + f.status + " while fetching file: " + f.statusText : s.textContent = "✖ Error: File does not exist or is empty"))
                    }
                    ,
                    f.send(null)
                }
              }
            )),
            t.plugins.fileHighlight = {
              highlight: function(e) {
                for (var n, o = (e || document).querySelectorAll(r), a = 0; n = o[a++]; )
                  t.highlightElement(n)
              }
            };
          var a = !1;
          t.fileHighlight = function() {
            a || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."),
              a = !0),
              t.plugins.fileHighlight.highlight.apply(this, arguments)
          }
        }
        function i(e, t) {
          var n = e.className;
          n = n.replace(o, " ") + " language-" + t,
            e.className = n.replace(/\s+/g, " ").trim()
        }
      }()
  }
));
!function(e) {
  var t = e.util.clone(e.languages.javascript)
    , n = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source
    , r = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source
    , o = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function a(e, t) {
    return e = e.replace(/<S>/g, (function() {
        return n
      }
    )).replace(/<BRACES>/g, (function() {
        return r
      }
    )).replace(/<SPREAD>/g, (function() {
        return o
      }
    )),
      RegExp(e, t)
  }
  o = a(o).source,
    e.languages.jsx = e.languages.extend("markup", t),
    e.languages.jsx.tag.pattern = a(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source),
    e.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/i,
    e.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/i,
    e.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/,
    e.languages.jsx.tag.inside.comment = t.comment,
    e.languages.insertBefore("inside", "attr-name", {
      spread: {
        pattern: a(/<SPREAD>/.source),
        inside: e.languages.jsx
      }
    }, e.languages.jsx.tag),
    e.languages.insertBefore("inside", "special-attr", {
      script: {
        pattern: a(/=<BRACES>/.source),
        inside: {
          "script-punctuation": {
            pattern: /^=(?=\{)/,
            alias: "punctuation"
          },
          rest: e.languages.jsx
        },
        alias: "language-javascript"
      }
    }, e.languages.jsx.tag);
  var i = function(e) {
    return e ? "string" == typeof e ? e : "string" == typeof e.content ? e.content : e.content.map(i).join("") : ""
  }
    , s = function(t) {
    for (var n = [], r = 0; r < t.length; r++) {
      var o = t[r]
        , a = !1;
      if ("string" != typeof o && ("tag" === o.type && o.content[0] && "tag" === o.content[0].type ? "</" === o.content[0].content[0].content ? n.length > 0 && n[n.length - 1].tagName === i(o.content[0].content[1]) && n.pop() : "/>" === o.content[o.content.length - 1].content || n.push({
        tagName: i(o.content[0].content[1]),
        openedBraces: 0
      }) : n.length > 0 && "punctuation" === o.type && "{" === o.content ? n[n.length - 1].openedBraces++ : n.length > 0 && n[n.length - 1].openedBraces > 0 && "punctuation" === o.type && "}" === o.content ? n[n.length - 1].openedBraces-- : a = !0),
      (a || "string" == typeof o) && n.length > 0 && 0 === n[n.length - 1].openedBraces) {
        var l = i(o);
        r < t.length - 1 && ("string" == typeof t[r + 1] || "plain-text" === t[r + 1].type) && (l += i(t[r + 1]),
          t.splice(r + 1, 1)),
        r > 0 && ("string" == typeof t[r - 1] || "plain-text" === t[r - 1].type) && (l = i(t[r - 1]) + l,
          t.splice(r - 1, 1),
          r--),
          t[r] = new e.Token("plain-text",l,null,l)
      }
      o.content && "string" != typeof o.content && s(o.content)
    }
  };
  e.hooks.add("after-tokenize", (function(e) {
      "jsx" !== e.language && "tsx" !== e.language || s(e.tokens)
    }
  ))
}(Prism),
  function(e) {
    e.languages.typescript = e.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: !0,
        greedy: !0,
        inside: null
      },
      builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/
    }),
      e.languages.typescript.keyword.push(/\b(?:abstract|as|declare|implements|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/),
      delete e.languages.typescript.parameter;
    var t = e.languages.extend("typescript", {});
    delete t["class-name"],
      e.languages.typescript["class-name"].inside = t,
      e.languages.insertBefore("typescript", "function", {
        decorator: {
          pattern: /@[$\w\xA0-\uFFFF]+/,
          inside: {
            at: {
              pattern: /^@/,
              alias: "operator"
            },
            function: /^[\s\S]+/
          }
        },
        "generic-function": {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
          greedy: !0,
          inside: {
            function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
            generic: {
              pattern: /<[\s\S]+/,
              alias: "class-name",
              inside: t
            }
          }
        }
      }),
      e.languages.ts = e.languages.typescript
  }(Prism),
  Prism.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [{
      pattern: /&[\da-z]{1,8};/i,
      alias: "named-entity"
    }, /&#x?[\da-f]{1,8};/i]
  },
  Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity,
  Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup,
  Prism.hooks.add("wrap", (function(e) {
      "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"))
    }
  )),
  Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    value: function(e, t) {
      var n = {};
      n["language-" + t] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: Prism.languages[t]
      },
        n.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var r = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: n
        }
      };
      r["language-" + t] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[t]
      };
      var o = {};
      o[e] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, (function() {
            return e
          }
        )), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: r
      },
        Prism.languages.insertBefore("markup", "cdata", o)
    }
  }),
  Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    value: function(e, t) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(/(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [t, "language-" + t],
                inside: Prism.languages[t]
              },
              punctuation: [{
                pattern: /^=/,
                alias: "attr-equals"
              }, /"|'/]
            }
          }
        }
      })
    }
  }),
  Prism.languages.html = Prism.languages.markup,
  Prism.languages.mathml = Prism.languages.markup,
  Prism.languages.svg = Prism.languages.markup,
  Prism.languages.xml = Prism.languages.extend("markup", {}),
  Prism.languages.ssml = Prism.languages.xml,
  Prism.languages.atom = Prism.languages.xml,
  Prism.languages.rss = Prism.languages.xml,
  Prism.languages.go = Prism.languages.extend("clike", {
    string: {
      pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
      greedy: !0
    },
    keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    boolean: /\b(?:_|iota|nil|true|false)\b/,
    number: /(?:\b0x[a-f\d]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[-+]?\d+)?)i?/i,
    operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    builtin: /\b(?:bool|byte|complex(?:64|128)|error|float(?:32|64)|rune|string|u?int(?:8|16|32|64)?|uintptr|append|cap|close|complex|copy|delete|imag|len|make|new|panic|print(?:ln)?|real|recover)\b/
  }),
  delete Prism.languages.go["class-name"],
  function(e) {
    var t = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/
      , n = [{
      pattern: /\b(?:false|true)\b/i,
      alias: "boolean"
    }, {
      pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
      greedy: !0,
      lookbehind: !0
    }, {
      pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
      greedy: !0,
      lookbehind: !0
    }, /\b(?:null)\b/i, /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/]
      , r = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i
      , o = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/
      , a = /[{}\[\](),:;]/;
    e.languages.php = {
      delimiter: {
        pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
        alias: "important"
      },
      comment: t,
      variable: /\$+(?:\w+\b|(?=\{))/i,
      package: {
        pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      },
      "class-name-definition": {
        pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
        lookbehind: !0,
        alias: "class-name"
      },
      "function-definition": {
        pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
        lookbehind: !0,
        alias: "function"
      },
      keyword: [{
        pattern: /(\(\s*)\b(?:bool|boolean|int|integer|float|string|object|array)\b(?=\s*\))/i,
        alias: "type-casting",
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /([(,?]\s*)\b(?:bool|int|float|string|object|array(?!\s*\()|mixed|self|static|callable|iterable|(?:null|false)(?=\s*\|))\b(?=\s*\$)/i,
        alias: "type-hint",
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /([(,?]\s*[\w|]\|\s*)(?:null|false)\b(?=\s*\$)/i,
        alias: "type-hint",
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:bool|int|float|string|object|void|array(?!\s*\()|mixed|self|static|callable|iterable|(?:null|false)(?=\s*\|))\b/i,
        alias: "return-type",
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /(\)\s*:\s*(?:\?\s*)?[\w|]\|\s*)(?:null|false)\b/i,
        alias: "return-type",
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /\b(?:bool|int|float|string|object|void|array(?!\s*\()|mixed|iterable|(?:null|false)(?=\s*\|))\b/i,
        alias: "type-declaration",
        greedy: !0
      }, {
        pattern: /(\|\s*)(?:null|false)\b/i,
        alias: "type-declaration",
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /\b(?:parent|self|static)(?=\s*::)/i,
        alias: "static-context",
        greedy: !0
      }, {
        pattern: /(\byield\s+)from\b/i,
        lookbehind: !0
      }, /\bclass\b/i, {
        pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|match|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\b/i,
        lookbehind: !0
      }],
      "argument-name": {
        pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i,
        lookbehind: !0
      },
      "class-name": [{
        pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
        greedy: !0
      }, {
        pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
        alias: "class-name-fully-qualified",
        greedy: !0,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      }, {
        pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
        alias: "class-name-fully-qualified",
        greedy: !0,
        inside: {
          punctuation: /\\/
        }
      }, {
        pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        alias: "class-name-fully-qualified",
        greedy: !0,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      }, {
        pattern: /\b[a-z_]\w*(?=\s*\$)/i,
        alias: "type-declaration",
        greedy: !0
      }, {
        pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
        alias: ["class-name-fully-qualified", "type-declaration"],
        greedy: !0,
        inside: {
          punctuation: /\\/
        }
      }, {
        pattern: /\b[a-z_]\w*(?=\s*::)/i,
        alias: "static-context",
        greedy: !0
      }, {
        pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
        alias: ["class-name-fully-qualified", "static-context"],
        greedy: !0,
        inside: {
          punctuation: /\\/
        }
      }, {
        pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
        alias: "type-hint",
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
        alias: ["class-name-fully-qualified", "type-hint"],
        greedy: !0,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      }, {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
        alias: "return-type",
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        alias: ["class-name-fully-qualified", "return-type"],
        greedy: !0,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      }],
      constant: n,
      function: {
        pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
        lookbehind: !0,
        inside: {
          punctuation: /\\/
        }
      },
      property: {
        pattern: /(->\s*)\w+/,
        lookbehind: !0
      },
      number: r,
      operator: o,
      punctuation: a
    };
    var i = {
      pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
      lookbehind: !0,
      inside: e.languages.php
    }
      , s = [{
      pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
      alias: "nowdoc-string",
      greedy: !0,
      inside: {
        delimiter: {
          pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
          alias: "symbol",
          inside: {
            punctuation: /^<<<'?|[';]$/
          }
        }
      }
    }, {
      pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
      alias: "heredoc-string",
      greedy: !0,
      inside: {
        delimiter: {
          pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
          alias: "symbol",
          inside: {
            punctuation: /^<<<"?|[";]$/
          }
        },
        interpolation: i
      }
    }, {
      pattern: /`(?:\\[\s\S]|[^\\`])*`/,
      alias: "backtick-quoted-string",
      greedy: !0
    }, {
      pattern: /'(?:\\[\s\S]|[^\\'])*'/,
      alias: "single-quoted-string",
      greedy: !0
    }, {
      pattern: /"(?:\\[\s\S]|[^\\"])*"/,
      alias: "double-quoted-string",
      greedy: !0,
      inside: {
        interpolation: i
      }
    }];
    e.languages.insertBefore("php", "variable", {
      string: s,
      attribute: {
        pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
        greedy: !0,
        inside: {
          "attribute-content": {
            pattern: /^(#\[)[\s\S]+(?=\]$)/,
            lookbehind: !0,
            inside: {
              comment: t,
              string: s,
              "attribute-class-name": [{
                pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                alias: "class-name",
                greedy: !0,
                lookbehind: !0
              }, {
                pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                alias: ["class-name", "class-name-fully-qualified"],
                greedy: !0,
                lookbehind: !0,
                inside: {
                  punctuation: /\\/
                }
              }],
              constant: n,
              number: r,
              operator: o,
              punctuation: a
            }
          },
          delimiter: {
            pattern: /^#\[|\]$/,
            alias: "punctuation"
          }
        }
      }
    }),
      e.hooks.add("before-tokenize", (function(t) {
          /<\?/.test(t.code) && e.languages["markup-templating"].buildPlaceholders(t, "php", /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/gi)
        }
      )),
      e.hooks.add("after-tokenize", (function(t) {
          e.languages["markup-templating"].tokenizePlaceholders(t, "php")
        }
      ))
  }(Prism),
  Prism.languages.c = Prism.languages.extend("clike", {
    comment: {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: !0
    },
    keyword: /\b(?:__attribute__|_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  }),
  Prism.languages.insertBefore("c", "string", {
    macro: {
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: !0,
      greedy: !0,
      alias: "property",
      inside: {
        string: [{
          pattern: /^(#\s*include\s*)<[^>]+>/,
          lookbehind: !0
        }, Prism.languages.c.string],
        comment: Prism.languages.c.comment,
        "macro-name": [{
          pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
          lookbehind: !0
        }, {
          pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
          lookbehind: !0,
          alias: "function"
        }],
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: !0,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    },
    constant: /\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/
  }),
  delete Prism.languages.c.boolean,
  Prism.languages.python = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: !0
    },
    "string-interpolation": {
      pattern: /(?:f|rf|fr)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: !0,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: !0
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        string: /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|rb|br)?("""|''')[\s\S]*?\1/i,
      greedy: !0,
      alias: "string"
    },
    string: {
      pattern: /(?:[rub]|rb|br)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: !0
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: !0
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: !0
    },
    decorator: {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/im,
      lookbehind: !0,
      alias: ["annotation", "punctuation"],
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:True|False|None)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?\b/i,
    operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  },
  Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python,
  Prism.languages.py = Prism.languages.python,
  function(e) {
    var t = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/
      , n = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source
      , r = {
      pattern: RegExp(n + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: !0,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /\./
      }
    };
    e.languages.java = e.languages.extend("clike", {
      "class-name": [r, {
        pattern: RegExp(n + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),
        lookbehind: !0,
        inside: r.inside
      }],
      keyword: t,
      function: [e.languages.clike.function, {
        pattern: /(::\s*)[a-z_]\w*/,
        lookbehind: !0
      }],
      number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: !0
      }
    }),
      e.languages.insertBefore("java", "string", {
        "triple-quoted-string": {
          pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
          greedy: !0,
          alias: "string"
        }
      }),
      e.languages.insertBefore("java", "class-name", {
        annotation: {
          pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
          lookbehind: !0,
          alias: "punctuation"
        },
        generics: {
          pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
          inside: {
            "class-name": r,
            keyword: t,
            punctuation: /[<>(),.:]/,
            operator: /[?&|]/
          }
        },
        namespace: {
          pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, (function() {
              return t.source
            }
          ))),
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        }
      })
  }(Prism),
  function(e) {
    var t = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/
      , n = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, (function() {
        return t.source
      }
    ));
    e.languages.cpp = e.languages.extend("c", {
      "class-name": [{
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, (function() {
            return t.source
          }
        ))),
        lookbehind: !0
      }, /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/],
      keyword: t,
      number: {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: !0
      },
      operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      boolean: /\b(?:true|false)\b/
    }),
      e.languages.insertBefore("cpp", "string", {
        module: {
          pattern: RegExp(/(\b(?:module|import)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, (function() {
              return n
            }
          )) + ")"),
          lookbehind: !0,
          greedy: !0,
          inside: {
            string: /^[<"][\s\S]+/,
            operator: /:/,
            punctuation: /\./
          }
        },
        "raw-string": {
          pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
          alias: "string",
          greedy: !0
        }
      }),
      e.languages.insertBefore("cpp", "keyword", {
        "generic-function": {
          pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
          inside: {
            function: /^\w+/,
            generic: {
              pattern: /<[\s\S]+/,
              alias: "class-name",
              inside: e.languages.cpp
            }
          }
        }
      }),
      e.languages.insertBefore("cpp", "operator", {
        "double-colon": {
          pattern: /::/,
          alias: "punctuation"
        }
      }),
      e.languages.insertBefore("cpp", "class-name", {
        "base-clause": {
          pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
          lookbehind: !0,
          greedy: !0,
          inside: e.languages.extend("cpp", {})
        }
      }),
      e.languages.insertBefore("inside", "double-colon", {
        "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
      }, e.languages.cpp["base-clause"])
  }(Prism),
  function(e) {
    function t(e, t) {
      return e.replace(/<<(\d+)>>/g, (function(e, n) {
          return "(?:" + t[+n] + ")"
        }
      ))
    }
    function n(e, n, r) {
      return RegExp(t(e, n), r || "")
    }
    function r(e, t) {
      for (var n = 0; n < t; n++)
        e = e.replace(/<<self>>/g, (function() {
            return "(?:" + e + ")"
          }
        ));
      return e.replace(/<<self>>/g, "[^\\s\\S]")
    }
    var o = "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void"
      , a = "class enum interface record struct"
      , i = "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)"
      , s = "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield";
    function l(e) {
      return "\\b(?:" + e.trim().replace(/ /g, "|") + ")\\b"
    }
    var u = l(a)
      , c = RegExp(l(o + " " + a + " " + i + " " + s))
      , d = l(a + " " + i + " " + s)
      , f = l(o + " " + a + " " + s)
      , p = r(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2)
      , h = r(/\((?:[^()]|<<self>>)*\)/.source, 2)
      , v = /@?\b[A-Za-z_]\w*\b/.source
      , g = t(/<<0>>(?:\s*<<1>>)?/.source, [v, p])
      , m = t(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [d, g])
      , y = /\[\s*(?:,\s*)*\]/.source
      , b = t(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [m, y])
      , w = t(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [p, h, y])
      , x = t(/\(<<0>>+(?:,<<0>>+)+\)/.source, [w])
      , S = t(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [x, m, y])
      , E = {
      keyword: c,
      punctuation: /[<>()?,.:[\]]/
    }
      , A = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source
      , C = /"(?:\\.|[^\\"\r\n])*"/.source
      , k = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
    e.languages.csharp = e.languages.extend("clike", {
      string: [{
        pattern: n(/(^|[^$\\])<<0>>/.source, [k]),
        lookbehind: !0,
        greedy: !0
      }, {
        pattern: n(/(^|[^@$\\])<<0>>/.source, [C]),
        lookbehind: !0,
        greedy: !0
      }, {
        pattern: RegExp(A),
        greedy: !0,
        alias: "character"
      }],
      "class-name": [{
        pattern: n(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [m]),
        lookbehind: !0,
        inside: E
      }, {
        pattern: n(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [v, S]),
        lookbehind: !0,
        inside: E
      }, {
        pattern: n(/(\busing\s+)<<0>>(?=\s*=)/.source, [v]),
        lookbehind: !0
      }, {
        pattern: n(/(\b<<0>>\s+)<<1>>/.source, [u, g]),
        lookbehind: !0,
        inside: E
      }, {
        pattern: n(/(\bcatch\s*\(\s*)<<0>>/.source, [m]),
        lookbehind: !0,
        inside: E
      }, {
        pattern: n(/(\bwhere\s+)<<0>>/.source, [v]),
        lookbehind: !0
      }, {
        pattern: n(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [b]),
        lookbehind: !0,
        inside: E
      }, {
        pattern: n(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [S, f, v]),
        inside: E
      }],
      keyword: c,
      number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:ul|lu|[dflmu])?\b/i,
      operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
      punctuation: /\?\.?|::|[{}[\];(),.:]/
    }),
      e.languages.insertBefore("csharp", "number", {
        range: {
          pattern: /\.\./,
          alias: "operator"
        }
      }),
      e.languages.insertBefore("csharp", "punctuation", {
        "named-parameter": {
          pattern: n(/([(,]\s*)<<0>>(?=\s*:)/.source, [v]),
          lookbehind: !0,
          alias: "punctuation"
        }
      }),
      e.languages.insertBefore("csharp", "class-name", {
        namespace: {
          pattern: n(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [v]),
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        },
        "type-expression": {
          pattern: n(/(\b(?:default|typeof|sizeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [h]),
          lookbehind: !0,
          alias: "class-name",
          inside: E
        },
        "return-type": {
          pattern: n(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [S, m]),
          inside: E,
          alias: "class-name"
        },
        "constructor-invocation": {
          pattern: n(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [S]),
          lookbehind: !0,
          inside: E,
          alias: "class-name"
        },
        "generic-method": {
          pattern: n(/<<0>>\s*<<1>>(?=\s*\()/.source, [v, p]),
          inside: {
            function: n(/^<<0>>/.source, [v]),
            generic: {
              pattern: RegExp(p),
              alias: "class-name",
              inside: E
            }
          }
        },
        "type-list": {
          pattern: n(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [u, g, v, S, c.source, h, /\bnew\s*\(\s*\)/.source]),
          lookbehind: !0,
          inside: {
            "record-arguments": {
              pattern: n(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [g, h]),
              lookbehind: !0,
              greedy: !0,
              inside: e.languages.csharp
            },
            keyword: c,
            "class-name": {
              pattern: RegExp(S),
              greedy: !0,
              inside: E
            },
            punctuation: /[,()]/
          }
        },
        preprocessor: {
          pattern: /(^[\t ]*)#.*/m,
          lookbehind: !0,
          alias: "property",
          inside: {
            directive: {
              pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
              lookbehind: !0,
              alias: "keyword"
            }
          }
        }
      });
    var T = C + "|" + A
      , D = t(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [T])
      , O = r(t(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [D]), 2)
      , _ = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source
      , R = t(/<<0>>(?:\s*\(<<1>>*\))?/.source, [m, O]);
    e.languages.insertBefore("csharp", "class-name", {
      attribute: {
        pattern: n(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [_, R]),
        lookbehind: !0,
        greedy: !0,
        inside: {
          target: {
            pattern: n(/^<<0>>(?=\s*:)/.source, [_]),
            alias: "keyword"
          },
          "attribute-arguments": {
            pattern: n(/\(<<0>>*\)/.source, [O]),
            inside: e.languages.csharp
          },
          "class-name": {
            pattern: RegExp(m),
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[:,]/
        }
      }
    });
    var L = /:[^}\r\n]+/.source
      , I = r(t(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [D]), 2)
      , P = t(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [I, L])
      , F = r(t(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [T]), 2)
      , B = t(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [F, L]);
    function N(t, r) {
      return {
        interpolation: {
          pattern: n(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [t]),
          lookbehind: !0,
          inside: {
            "format-string": {
              pattern: n(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [r, L]),
              lookbehind: !0,
              inside: {
                punctuation: /^:/
              }
            },
            punctuation: /^\{|\}$/,
            expression: {
              pattern: /[\s\S]+/,
              alias: "language-csharp",
              inside: e.languages.csharp
            }
          }
        },
        string: /[\s\S]+/
      }
    }
    e.languages.insertBefore("csharp", "string", {
      "interpolation-string": [{
        pattern: n(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [P]),
        lookbehind: !0,
        greedy: !0,
        inside: N(P, I)
      }, {
        pattern: n(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [B]),
        lookbehind: !0,
        greedy: !0,
        inside: N(B, F)
      }]
    })
  }(Prism),
  Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp,
  Prism.languages["visual-basic"] = {
    comment: {
      pattern: /(?:['‘’]|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
      inside: {
        keyword: /^REM/i
      }
    },
    directive: {
      pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:[^\S\r\n]_[^\S\r\n]*(?:\r\n?|\n)|.)+/i,
      alias: "comment",
      greedy: !0
    },
    string: {
      pattern: /\$?["“”](?:["“”]{2}|[^"“”])*["“”]C?/i,
      greedy: !0
    },
    date: {
      pattern: /#[^\S\r\n]*(?:\d+([/-])\d+\1\d+(?:[^\S\r\n]+(?:\d+[^\S\r\n]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[^\S\r\n]*(?:AM|PM))?))?|\d+[^\S\r\n]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[^\S\r\n]*(?:AM|PM))?)[^\S\r\n]*#/i,
      alias: "builtin"
    },
    number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:U?[ILS]|[FRD])?/i,
    boolean: /\b(?:True|False|Nothing)\b/i,
    keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Until|Xor)\b/i,
    operator: [/[+\-*/\\^<=>&#@$%!]/, {
      pattern: /([^\S\r\n])_(?=[^\S\r\n]*[\r\n])/,
      lookbehind: !0
    }],
    punctuation: /[{}().,:?]/
  },
  Prism.languages.vb = Prism.languages["visual-basic"],
  Prism.languages.vba = Prism.languages["visual-basic"],
  Prism.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: !0
    },
    variable: [{
      pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
      greedy: !0
    }, /@[\w.$]+/],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: !0,
      lookbehind: !0
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:S|ING)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:TRUE|FALSE|NULL)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|IN|ILIKE|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  },
  function(e) {
    e.languages.ruby = e.languages.extend("clike", {
      comment: [/#.*/, {
        pattern: /^=begin\s[\s\S]*?^=end/m,
        greedy: !0
      }],
      "class-name": {
        pattern: /(\b(?:class)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|protected|private|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/
    });
    var t = {
      pattern: /#\{[^}]+\}/,
      inside: {
        delimiter: {
          pattern: /^#\{|\}$/,
          alias: "tag"
        },
        rest: e.languages.ruby
      }
    };
    delete e.languages.ruby.function,
      e.languages.insertBefore("ruby", "keyword", {
        regex: [{
          pattern: RegExp(/%r/.source + "(?:" + [/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S])*\)/.source, /\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S])*\]/.source, /<(?:[^<>\\]|\\[\s\S])*>/.source].join("|") + ")" + /[egimnosux]{0,6}/.source),
          greedy: !0,
          inside: {
            interpolation: t
          }
        }, {
          pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            interpolation: t
          }
        }],
        variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
        symbol: {
          pattern: /(^|[^:]):[a-zA-Z_]\w*(?:[?!]|\b)/,
          lookbehind: !0
        },
        "method-definition": {
          pattern: /(\bdef\s+)[\w.]+/,
          lookbehind: !0,
          inside: {
            function: /\w+$/,
            rest: e.languages.ruby
          }
        }
      }),
      e.languages.insertBefore("ruby", "number", {
        builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|Fixnum|Float|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/,
        constant: /\b[A-Z]\w*(?:[?!]|\b)/
      }),
      e.languages.ruby.string = [{
        pattern: RegExp(/%[qQiIwWxs]?/.source + "(?:" + [/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S])*\)/.source, /\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S])*\]/.source, /<(?:[^<>\\]|\\[\s\S])*>/.source].join("|") + ")"),
        greedy: !0,
        inside: {
          interpolation: t
        }
      }, {
        pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
        greedy: !0,
        inside: {
          interpolation: t
        }
      }, {
        pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
        alias: "heredoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<[-~]?[a-z_]\w*|[a-z_]\w*$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<[-~]?/
            }
          },
          interpolation: t
        }
      }, {
        pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
        alias: "heredoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<[-~]?'[a-z_]\w*'|[a-z_]\w*$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<[-~]?'|'$/
            }
          }
        }
      }],
      e.languages.rb = e.languages.ruby
  }(Prism),
  Prism.languages.swift = {
    comment: {
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: !0,
      greedy: !0
    },
    "string-literal": [{
      pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: !0,
          inside: null
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        punctuation: /\\(?=[\r\n])/,
        string: /[\s\S]+/
      }
    }, {
      pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"),
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: !0,
          inside: null
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        string: /[\s\S]+/
      }
    }],
    directive: {
      pattern: RegExp(/#/.source + "(?:" + /(?:elseif|if)\b/.source + "(?:[ \t]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+|" + /(?:else|endif)\b/.source + ")"),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        boolean: /\b(?:true|false)\b/,
        number: /\b\d+(?:\.\d+)*\b/,
        operator: /!|&&|\|\||[<>]=?/,
        punctuation: /[(),]/
      }
    },
    literal: {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: !0,
      alias: "function"
    },
    label: {
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: !0,
      alias: "important"
    },
    keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    boolean: /\b(?:true|false)\b/,
    nil: {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    omit: {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    punctuation: /[{}[\]();,.:\\]/
  },
  Prism.languages.swift["string-literal"].forEach((function(e) {
      e.inside.interpolation.inside = Prism.languages.swift
    }
  )),
  function(e) {
    var t = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b"
      , n = {
      pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
      lookbehind: !0,
      alias: "punctuation",
      inside: null
    }
      , r = {
      bash: n,
      environment: {
        pattern: RegExp("\\$" + t),
        alias: "constant"
      },
      variable: [{
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: !0,
        inside: {
          variable: [{
            pattern: /(^\$\(\([\s\S]+)\)\)/,
            lookbehind: !0
          }, /^\$\(\(/],
          number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          punctuation: /\(\(?|\)\)?|,|;/
        }
      }, {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: !0,
        inside: {
          variable: /^\$\(|^`|\)$|`$/
        }
      }, {
        pattern: /\$\{[^}]+\}/,
        greedy: !0,
        inside: {
          operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          punctuation: /[\[\]]/,
          environment: {
            pattern: RegExp("(\\{)" + t),
            lookbehind: !0,
            alias: "constant"
          }
        }
      }, /\$(?:\w+|[#?*!@$])/],
      entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})/
    };
    e.languages.bash = {
      shebang: {
        pattern: /^#!\s*\/.*/,
        alias: "important"
      },
      comment: {
        pattern: /(^|[^"{\\$])#.*/,
        lookbehind: !0
      },
      "function-name": [{
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: !0,
        alias: "function"
      }, {
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }],
      "for-or-select": {
        pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
        alias: "variable",
        lookbehind: !0
      },
      "assign-left": {
        pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
        inside: {
          environment: {
            pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + t),
            lookbehind: !0,
            alias: "constant"
          }
        },
        alias: "variable",
        lookbehind: !0
      },
      string: [{
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: !0,
        greedy: !0,
        inside: r
      }, {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          bash: n
        }
      }, {
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: !0,
        greedy: !0,
        inside: r
      }, {
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: !0,
        greedy: !0
      }, {
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: !0,
        inside: {
          entity: r.entity
        }
      }],
      environment: {
        pattern: RegExp("\\$?" + t),
        alias: "constant"
      },
      variable: r.variable,
      function: {
        pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|aptitude|apt-cache|apt-get|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      keyword: {
        pattern: /(^|[\s;|&]|[<>]\()(?:if|then|else|elif|fi|for|while|in|case|esac|function|select|do|done|until)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      builtin: {
        pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|break|cd|continue|eval|exec|exit|export|getopts|hash|pwd|readonly|return|shift|test|times|trap|umask|unset|alias|bind|builtin|caller|command|declare|echo|enable|help|let|local|logout|mapfile|printf|read|readarray|source|type|typeset|ulimit|unalias|set|shopt)(?=$|[)\s;|&])/,
        lookbehind: !0,
        alias: "class-name"
      },
      boolean: {
        pattern: /(^|[\s;|&]|[<>]\()(?:true|false)(?=$|[)\s;|&])/,
        lookbehind: !0
      },
      "file-descriptor": {
        pattern: /\B&\d\b/,
        alias: "important"
      },
      operator: {
        pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
        inside: {
          "file-descriptor": {
            pattern: /^\d/,
            alias: "important"
          }
        }
      },
      punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
      number: {
        pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
        lookbehind: !0
      }
    },
      n.inside = e.languages.bash;
    for (var o = ["comment", "function-name", "for-or-select", "assign-left", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"], a = r.variable[1].inside, i = 0; i < o.length; i++)
      a[o[i]] = e.languages.bash[o[i]];
    e.languages.shell = e.languages.bash
  }(Prism),
  function(e) {
    var t = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    function n(e) {
      return e = e.replace(/<inner>/g, (function() {
          return t
        }
      )),
        RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + e + ")")
    }
    var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source
      , o = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, (function() {
        return r
      }
    ))
      , a = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
    e.languages.markdown = e.languages.extend("markup", {}),
      e.languages.insertBefore("markdown", "prolog", {
        "front-matter-block": {
          pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            punctuation: /^---|---$/,
            "font-matter": {
              pattern: /\S+(?:\s+\S+)*/,
              alias: ["yaml", "language-yaml"],
              inside: e.languages.yaml
            }
          }
        },
        blockquote: {
          pattern: /^>(?:[\t ]*>)*/m,
          alias: "punctuation"
        },
        table: {
          pattern: RegExp("^" + o + a + "(?:" + o + ")*", "m"),
          inside: {
            "table-data-rows": {
              pattern: RegExp("^(" + o + a + ")(?:" + o + ")*$"),
              lookbehind: !0,
              inside: {
                "table-data": {
                  pattern: RegExp(r),
                  inside: e.languages.markdown
                },
                punctuation: /\|/
              }
            },
            "table-line": {
              pattern: RegExp("^(" + o + ")" + a + "$"),
              lookbehind: !0,
              inside: {
                punctuation: /\||:?-{3,}:?/
              }
            },
            "table-header-row": {
              pattern: RegExp("^" + o + "$"),
              inside: {
                "table-header": {
                  pattern: RegExp(r),
                  alias: "important",
                  inside: e.languages.markdown
                },
                punctuation: /\|/
              }
            }
          }
        },
        code: [{
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: !0,
          alias: "keyword"
        }, {
          pattern: /^```[\s\S]*?^```$/m,
          greedy: !0,
          inside: {
            "code-block": {
              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
              lookbehind: !0
            },
            "code-language": {
              pattern: /^(```).+/,
              lookbehind: !0
            },
            punctuation: /```/
          }
        }],
        title: [{
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: {
            punctuation: /==+$|--+$/
          }
        }, {
          pattern: /(^\s*)#.+/m,
          lookbehind: !0,
          alias: "important",
          inside: {
            punctuation: /^#+|#+$/
          }
        }],
        hr: {
          pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
          lookbehind: !0,
          alias: "punctuation"
        },
        list: {
          pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
          lookbehind: !0,
          alias: "punctuation"
        },
        "url-reference": {
          pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
          inside: {
            variable: {
              pattern: /^(!?\[)[^\]]+/,
              lookbehind: !0
            },
            string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
            punctuation: /^[\[\]!:]|[<>]/
          },
          alias: "url"
        },
        bold: {
          pattern: n(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            content: {
              pattern: /(^..)[\s\S]+(?=..$)/,
              lookbehind: !0,
              inside: {}
            },
            punctuation: /\*\*|__/
          }
        },
        italic: {
          pattern: n(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            content: {
              pattern: /(^.)[\s\S]+(?=.$)/,
              lookbehind: !0,
              inside: {}
            },
            punctuation: /[*_]/
          }
        },
        strike: {
          pattern: n(/(~~?)(?:(?!~)<inner>)+\2/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            content: {
              pattern: /(^~~?)[\s\S]+(?=\1$)/,
              lookbehind: !0,
              inside: {}
            },
            punctuation: /~~?/
          }
        },
        "code-snippet": {
          pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
          lookbehind: !0,
          greedy: !0,
          alias: ["code", "keyword"]
        },
        url: {
          pattern: n(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            operator: /^!/,
            content: {
              pattern: /(^\[)[^\]]+(?=\])/,
              lookbehind: !0,
              inside: {}
            },
            variable: {
              pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
              lookbehind: !0
            },
            url: {
              pattern: /(^\]\()[^\s)]+/,
              lookbehind: !0
            },
            string: {
              pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
              lookbehind: !0
            }
          }
        }
      }),
      ["url", "bold", "italic", "strike"].forEach((function(t) {
          ["url", "bold", "italic", "strike", "code-snippet"].forEach((function(n) {
              t !== n && (e.languages.markdown[t].inside.content.inside[n] = e.languages.markdown[n])
            }
          ))
        }
      )),
      e.hooks.add("after-tokenize", (function(e) {
          "markdown" !== e.language && "md" !== e.language || function e(t) {
            if (t && "string" != typeof t)
              for (var n = 0, r = t.length; n < r; n++) {
                var o = t[n];
                if ("code" === o.type) {
                  var a = o.content[1]
                    , i = o.content[3];
                  if (a && i && "code-language" === a.type && "code-block" === i.type && "string" == typeof a.content) {
                    var s = a.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp")
                      , l = "language-" + (s = (/[a-z][\w-]*/i.exec(s) || [""])[0].toLowerCase());
                    i.alias ? "string" == typeof i.alias ? i.alias = [i.alias, l] : i.alias.push(l) : i.alias = [l]
                  }
                } else
                  e(o.content)
              }
          }(e.tokens)
        }
      )),
      e.hooks.add("wrap", (function(t) {
          if ("code-block" === t.type) {
            for (var n = "", r = 0, o = t.classes.length; r < o; r++) {
              var a = t.classes[r]
                , u = /language-(.+)/.exec(a);
              if (u) {
                n = u[1];
                break
              }
            }
            var c = e.languages[n];
            if (c)
              t.content = e.highlight(t.content.replace(i, "").replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, (function(e, t) {
                  var n;
                  return "#" === (t = t.toLowerCase())[0] ? (n = "x" === t[1] ? parseInt(t.slice(2), 16) : Number(t.slice(1)),
                    l(n)) : s[t] || e
                }
              )), c, n);
            else if (n && "none" !== n && e.plugins.autoloader) {
              var d = "md-" + (new Date).valueOf() + "-" + Math.floor(1e16 * Math.random());
              t.attributes.id = d,
                e.plugins.autoloader.loadLanguages(n, (function() {
                    var t = document.getElementById(d);
                    t && (t.innerHTML = e.highlight(t.textContent, e.languages[n], n))
                  }
                ))
            }
          }
        }
      ));
    var i = RegExp(e.languages.markup.tag.pattern.source, "gi")
      , s = {
      amp: "&",
      lt: "<",
      gt: ">",
      quot: '"'
    }
      , l = String.fromCodePoint || String.fromCharCode;
    e.languages.md = e.languages.markdown
  }(Prism),
  Prism.languages.lua = {
    comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
    string: {
      pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
      greedy: !0
    },
    number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
    keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
    function: /(?!\d)\w+(?=\s*(?:[({]))/,
    operator: [/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/, {
      pattern: /(^|[^.])\.\.(?!\.)/,
      lookbehind: !0
    }],
    punctuation: /[\[\](){},;]|\.+|:+/
  },
  Prism.languages.groovy = Prism.languages.extend("clike", {
    string: [{
      pattern: /("""|''')(?:[^\\]|\\[\s\S])*?\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
      greedy: !0
    }, {
      pattern: /(["'/])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    }],
    keyword: /\b(?:as|def|in|abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
    number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
    operator: {
      pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
      lookbehind: !0
    },
    punctuation: /\.+|[{}[\];(),:$]/
  }),
  Prism.languages.insertBefore("groovy", "string", {
    shebang: {
      pattern: /#!.+/,
      alias: "comment"
    }
  }),
  Prism.languages.insertBefore("groovy", "punctuation", {
    "spock-block": /\b(?:setup|given|when|then|and|cleanup|expect|where):/
  }),
  Prism.languages.insertBefore("groovy", "function", {
    annotation: {
      pattern: /(^|[^.])@\w+/,
      lookbehind: !0,
      alias: "punctuation"
    }
  }),
  Prism.hooks.add("wrap", (function(e) {
      if ("groovy" === e.language && "string" === e.type) {
        var t = e.content[0];
        if ("'" != t) {
          var n = /([^\\])(?:\$(?:\{.*?\}|[\w.]+))/;
          "$" === t && (n = /([^\$])(?:\$(?:\{.*?\}|[\w.]+))/),
            e.content = e.content.replace(/&lt;/g, "<").replace(/&amp;/g, "&"),
            e.content = Prism.highlight(e.content, {
              expression: {
                pattern: n,
                lookbehind: !0,
                inside: Prism.languages.groovy
              }
            }),
            e.classes.push("/" === t ? "regex" : "gstring")
        }
      }
    }
  ));
var Iot = ["comment", "prolog", "doctype", "cdata", "punctuation", "namespace", "property", "tag", "boolean", "number", "constant", "symbol", "deleted", "selector", "attr-name", "string", "builtin", "inserted", "operator", "entity", "url", "string", "atrule", "attr-value", "keyword", "function", "class-name", "regex", "important", "variable", "bold", "italic", "entity", "char"];
function Pot(e) {
  return "string" == typeof e ? e.length : "string" == typeof e.content ? e.content.length : e.content.reduce((function(e, t) {
      return e + Pot(t)
    }
  ), 0)
}
var Fot, Bot = Rtt.String, Not = function(e) {
  if ("Symbol" === yrt(e))
    throw TypeError("Cannot convert a Symbol value to a string");
  return Bot(e)
}, Mot = function() {
  var e = Ent(this)
    , t = "";
  return e.global && (t += "g"),
  e.ignoreCase && (t += "i"),
  e.multiline && (t += "m"),
  e.dotAll && (t += "s"),
  e.unicode && (t += "u"),
  e.sticky && (t += "y"),
    t
}, jot = Rtt.RegExp, Vot = ant((function() {
    var e = jot("a", "y");
    return e.lastIndex = 2,
    null != e.exec("abcd")
  }
)), Uot = Vot || ant((function() {
    return !jot("a", "y").sticky
  }
)), $ot = {
  BROKEN_CARET: Vot || ant((function() {
      var e = jot("^r", "gy");
      return e.lastIndex = 2,
      null != e.exec("str")
    }
  )),
  MISSED_STICKY: Uot,
  UNSUPPORTED_Y: Vot
}, Hot = vnt ? Object.defineProperties : function(e, t) {
  Ent(e);
  for (var n, r = not(t), o = Tot(t), a = o.length, i = 0; a > i; )
    Vnt.f(e, n = o[i++], r[n]);
  return e
}
  , zot = Jtt("document", "documentElement"), Kot = Qnt("IE_PROTO"), Wot = function() {}, Got = function(e) {
  return "<script>" + e + "<\/script>"
}, qot = function(e) {
  e.write(Got("")),
    e.close();
  var t = e.parentWindow.Object;
  return e = null,
    t
}, Yot = function() {
  try {
    Fot = new ActiveXObject("htmlfile")
  } catch (r) {}
  var e, t;
  Yot = "undefined" != typeof document ? document.domain && Fot ? qot(Fot) : ((t = bnt("iframe")).style.display = "none",
    zot.appendChild(t),
    t.src = String("javascript:"),
    (e = t.contentWindow.document).open(),
    e.write(Got("document.F=Object")),
    e.close(),
    e.F) : qot(Fot);
  for (var n = dot.length; n--; )
    delete Yot.prototype[dot[n]];
  return Yot()
};
Jnt[Kot] = !0;
var Xot, Qot, Jot = Object.create || function(e, t) {
  var n;
  return null !== e ? (Wot.prototype = Ent(e),
    n = new Wot,
    Wot.prototype = null,
    n[Kot] = e) : n = Yot(),
    void 0 === t ? n : Hot(n, t)
}
  , Zot = Rtt.RegExp, eat = ant((function() {
    var e = Zot(".", "s");
    return !(e.dotAll && e.exec("\n") && "s" === e.flags)
  }
)), tat = Rtt.RegExp, nat = ant((function() {
    var e = tat("(?<a>b)", "g");
    return "b" !== e.exec("b").groups.a || "bc" !== "b".replace(e, "$<a>c")
  }
)), rat = irt.get, oat = Ftt("native-string-replace", String.prototype.replace), aat = RegExp.prototype.exec, iat = aat, sat = Vtt("".charAt), lat = Vtt("".indexOf), uat = Vtt("".replace), cat = Vtt("".slice), dat = (Qot = /b*/g,
  Cnt(aat, Xot = /a/, "a"),
  Cnt(aat, Qot, "a"),
0 !== Xot.lastIndex || 0 !== Qot.lastIndex), fat = $ot.BROKEN_CARET, pat = void 0 !== /()??/.exec("")[1];
(dat || pat || fat || eat || nat) && (iat = function(e) {
    var t, n, r, o, a, i, s, l = this, u = rat(l), c = Not(e), d = u.raw;
    if (d)
      return d.lastIndex = l.lastIndex,
        t = Cnt(iat, d, c),
        l.lastIndex = d.lastIndex,
        t;
    var f = u.groups
      , p = fat && l.sticky
      , h = Cnt(Mot, l)
      , v = l.source
      , g = 0
      , m = c;
    if (p && (h = uat(h, "y", ""),
    -1 === lat(h, "g") && (h += "g"),
      m = cat(c, l.lastIndex),
    l.lastIndex > 0 && (!l.multiline || l.multiline && "\n" !== sat(c, l.lastIndex - 1)) && (v = "(?: " + v + ")",
      m = " " + m,
      g++),
      n = new RegExp("^(?:" + v + ")",h)),
    pat && (n = new RegExp("^" + v + "$(?!\\s)",h)),
    dat && (r = l.lastIndex),
      o = Cnt(aat, p ? n : l, m),
      p ? o ? (o.input = cat(o.input, g),
        o[0] = cat(o[0], g),
        o.index = l.lastIndex,
        l.lastIndex += o[0].length) : l.lastIndex = 0 : dat && o && (l.lastIndex = l.global ? o.index + o[0].length : r),
    pat && o && o.length > 1 && Cnt(oat, o[0], n, (function() {
        for (a = 1; a < arguments.length - 2; a++)
          void 0 === arguments[a] && (o[a] = void 0)
      }
    )),
    o && f)
      for (o.groups = i = Jot(null),
             a = 0; a < f.length; a++)
        i[(s = f[a])[0]] = o[s[1]];
    return o
  }
);
var hat = iat;
kot({
  target: "RegExp",
  proto: !0,
  forced: /./.exec !== hat
}, {
  exec: hat
});
var vat = Function.prototype
  , gat = vat.apply
  , mat = vat.bind
  , yat = vat.call
  , bat = "object" == typeof Reflect && Reflect.apply || (mat ? yat.bind(gat) : function() {
    return yat.apply(gat, arguments)
  }
)
  , wat = fnt("species")
  , xat = RegExp.prototype
  , Sat = fnt("match")
  , Eat = Rtt.TypeError
  , Aat = fnt("species")
  , Cat = Vtt("".charAt)
  , kat = Vtt("".charCodeAt)
  , Tat = Vtt("".slice)
  , Dat = function(e) {
  return function(t, n) {
    var r, o, a = Not($tt(t)), i = Rrt(n), s = a.length;
    return i < 0 || i >= s ? e ? "" : void 0 : (r = kat(a, i)) < 55296 || r > 56319 || i + 1 === s || (o = kat(a, i + 1)) < 56320 || o > 57343 ? e ? Cat(a, i) : r : e ? Tat(a, i, i + 2) : o - 56320 + (r - 55296 << 10) + 65536
  }
}(!0)
  , Oat = function(e, t, n) {
  return t + (n ? Dat(e, t).length : 1)
}
  , _at = Rtt.Array
  , Rat = Math.max
  , Lat = function(e, t, n) {
  for (var r, o, a, i, s = Prt(e), l = sot(t, s), u = sot(void 0 === n ? s : n, s), c = _at(Rat(u - l, 0)), d = 0; l < u; l++,
    d++)
    r = c,
      o = d,
      a = e[l],
      (i = Nnt(o))in r ? Vnt.f(r, i, Unt(0, a)) : r[i] = a;
  return c.length = d,
    c
}
  , Iat = Rtt.TypeError
  , Pat = function(e, t) {
  var n = e.exec;
  if (Qtt(n)) {
    var r = Cnt(n, e, t);
    return null !== r && Ent(r),
      r
  }
  if ("RegExp" === hrt(e))
    return Cnt(hat, e, t);
  throw Iat("RegExp#exec called on incompatible receiver")
}
  , Fat = $ot.UNSUPPORTED_Y
  , Bat = Math.min
  , Nat = [].push
  , Mat = Vtt(/./.exec)
  , jat = Vtt(Nat)
  , Vat = Vtt("".slice);
!function(e, t, n, r) {
  var o, a, i, s = fnt(e), l = !ant((function() {
      var t = {};
      return t[s] = function() {
        return 7
      }
        ,
      7 != ""[e](t)
    }
  )), u = l && !ant((function() {
      var e = !1
        , t = /a/;
      return (t = {}).constructor = {},
        t.constructor[wat] = function() {
          return t
        }
        ,
        t.flags = "",
        t[s] = /./[s],
        t.exec = function() {
          return e = !0,
            null
        }
        ,
        t[s](""),
        !e
    }
  ));
  if (!l || !u || n) {
    var c = Vtt(/./[s])
      , d = (o = s,
      a = ""[e],
      i = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e, t) {
          var n, r, o = Not($tt(this)), i = void 0 === t ? 4294967295 : t >>> 0;
          if (0 === i)
            return [];
          if (void 0 === e)
            return [o];
          if (!gnt(n = e) || !(void 0 !== (r = n[Sat]) ? r : "RegExp" == hrt(n)))
            return Cnt(a, o, e, i);
          for (var s, l, u, c = [], d = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), f = 0, p = new RegExp(e.source,d + "g"); (s = Cnt(hat, p, o)) && !((l = p.lastIndex) > f && (jat(c, Vat(o, f, s.index)),
          s.length > 1 && s.index < o.length && bat(Nat, c, Lat(s, 1)),
            u = s[0].length,
            f = l,
          c.length >= i)); )
            p.lastIndex === s.index && p.lastIndex++;
          return f === o.length ? !u && Mat(p, "") || jat(c, "") : jat(c, Vat(o, f)),
            c.length > i ? Lat(c, 0, i) : c
        }
        : "0".split(void 0, 0).length ? function(e, t) {
            return void 0 === e && 0 === t ? [] : Cnt(a, this, e, t)
          }
          : a,
      [function(e, t) {
        var n = $tt(this)
          , r = null == e ? void 0 : Int(e, o);
        return r ? Cnt(r, e, n, t) : Cnt(i, Not(n), e, t)
      }
        , function(e, t) {
        var n = Ent(this)
          , r = Not(e)
          , o = function(e, t, n, r, o) {
          var a = Vtt(e)
            , i = t.exec;
          return i === hat || i === xat.exec ? l && !o ? {
            done: !0,
            value: c(t, n, r)
          } : {
            done: !0,
            value: a(n, t, r)
          } : {
            done: !1
          }
        }(i, n, r, t, i !== a);
        if (o.done)
          return o.value;
        var s, u, d, f = (s = RegExp,
          void 0 === (d = Ent(n).constructor) || null == (u = Ent(d)[Aat]) ? s : function(e) {
            if (Hrt(e))
              return e;
            throw Eat(_nt(e) + " is not a constructor")
          }(u)), p = n.unicode, h = (n.ignoreCase ? "i" : "") + (n.multiline ? "m" : "") + (n.unicode ? "u" : "") + (Fat ? "g" : "y"), v = new f(Fat ? "^(?:" + n.source + ")" : n,h), g = void 0 === t ? 4294967295 : t >>> 0;
        if (0 === g)
          return [];
        if (0 === r.length)
          return null === Pat(v, r) ? [r] : [];
        for (var m = 0, y = 0, b = []; y < r.length; ) {
          v.lastIndex = Fat ? 0 : y;
          var w, x = Pat(v, Fat ? Vat(r, y) : r);
          if (null === x || (w = Bat(Irt(v.lastIndex + (Fat ? y : 0)), r.length)) === m)
            y = Oat(r, y, p);
          else {
            if (jat(b, Vat(r, m, y)),
            b.length === g)
              return b;
            for (var S = 1; S <= x.length - 1; S++)
              if (jat(b, x[S]),
              b.length === g)
                return b;
            y = m = w
          }
        }
        return jat(b, Vat(r, m)),
          b
      }
      ]);
    drt(String.prototype, e, d[0]),
      drt(xat, s, d[1])
  }
  r && $nt(xat[s], "sham", !0)
}("split", 0, !!ant((function() {
    var e = /(?:)/
      , t = e.exec;
    e.exec = function() {
      return t.apply(this, arguments)
    }
    ;
    var n = "ab".split(e);
    return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
  }
)), Fat),
  kot({
    global: !0
  }, {
    globalThis: Rtt
  }),
toe && (Qre.fn.attr = toe);
var Uat = crt.PROPER
  , $at = RegExp.prototype
  , Hat = $at.toString
  , zat = Vtt(Mot)
  , Kat = ant((function() {
    return "/a/b" != Hat.call({
      source: "a",
      flags: "b"
    })
  }
))
  , Wat = Uat && "toString" != Hat.name;
(Kat || Wat) && drt(RegExp.prototype, "toString", (function() {
    var e = Ent(this)
      , t = Not(e.source)
      , n = e.flags;
    return "/" + t + "/" + Not(void 0 === n && knt($at, e) && !("flags"in $at) ? zat(e) : n)
  }
), {
  unsafe: !0
});
var Gat = function() {
  function e() {
    this.title = SEe("highLightModule.selectLang"),
      this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M64 64v896h896V64H64z m487.6 698.8c0 87.2-51.2 127-125.8 127-67.4 0-106.4-34.8-126.4-77l68.6-41.4c13.2 23.4 25.2 43.2 54.2 43.2 27.6 0 45.2-10.8 45.2-53V475.4h84.2v287.4z m199.2 127c-78.2 0-128.8-37.2-153.4-86l68.6-39.6c18 29.4 41.6 51.2 83 51.2 34.8 0 57.2-17.4 57.2-41.6 0-28.8-22.8-39-61.4-56l-21-9c-60.8-25.8-101-58.4-101-127 0-63.2 48.2-111.2 123.2-111.2 53.6 0 92 18.6 119.6 67.4L800 580c-14.4-25.8-30-36-54.2-36-24.6 0-40.2 15.6-40.2 36 0 25.2 15.6 35.4 51.8 51.2l21 9c71.6 30.6 111.8 62 111.8 132.4 0 75.6-59.6 117.2-139.4 117.2z"></path></svg>',
      this.tag = "select",
      this.width = 95,
      this.selectPanelWidth = 115
  }
  return e.prototype.getOptions = function(e) {
    var t = []
      , n = e.getMenuConfig("codeSelectLang").codeLangs
      , r = void 0 === n ? [] : n;
    t.push({
      text: "plain text",
      value: ""
    }),
      r.forEach((function(e) {
          var n = e.text
            , r = e.value;
          t.push({
            text: n,
            value: r
          })
        }
      ));
    var o = this.getValue(e);
    return t.forEach((function(e) {
        e.value === o ? e.selected = !0 : delete e.selected
      }
    )),
      t
  }
    ,
    e.prototype.isActive = function(e) {
      return !1
    }
    ,
    e.prototype.getValue = function(e) {
      var t = this.getSelectCodeElem(e);
      if (null == t)
        return "";
      if (!Hte.isElement(t))
        return "";
      var n = t.language.toString()
        , r = e.getMenuConfig("codeSelectLang").codeLangs;
      return (void 0 === r ? [] : r).some((function(e) {
          return e.value === n
        }
      )) ? n : ""
    }
    ,
    e.prototype.isDisabled = function(e) {
      return null == e.selection || !this.getSelectCodeElem(e)
    }
    ,
    e.prototype.exec = function(e, t) {
      if (null != this.getSelectCodeElem(e)) {
        var n = {
          language: t.toString()
        };
        Nne.setNodes(e, n, {
          match: function(e) {
            return qme.checkNodeType(e, "code")
          }
        })
      }
    }
    ,
    e.prototype.getSelectCodeElem = function(e) {
      var t = qme.getSelectedNodeByType(e, "code");
      if (null == t)
        return null;
      var n = qme.getParentNode(e, t);
      return Hte.isElement(n) ? "pre" !== n.type ? null : t : null
    }
    ,
    e
}()
  , qat = {
  renderStyle: function(e, t) {
    var n = e
      , r = t
      , o = "";
    return Iot.forEach((function(e) {
        n[e] && (o = e)
      }
    )),
    o && function(e, t) {
      null == e.data && (e.data = {});
      var n = e.data;
      null == n.props && (n.props = {}),
        Object.assign(n.props, {
          className: t
        })
    }(r, o = "token " + o),
      r
  },
  parseStyleHtml: function(e, t, n) {
    var r = Qre(e);
    if (!Hte.isElement(t))
      return t;
    if ("code" !== qme.getNodeType(t))
      return t;
    var o = t
      , a = r.attr("class") || "";
    return 0 === a.indexOf("language-") ? o.language = a.split("-")[1] || "" : o.language = a.toLowerCase(),
      o
  },
  menus: [{
    key: "codeSelectLang",
    factory: function() {
      return new Gat
    },
    config: {
      codeLangs: [{
        text: "CSS",
        value: "css"
      }, {
        text: "HTML",
        value: "html"
      }, {
        text: "XML",
        value: "xml"
      }, {
        text: "Javascript",
        value: "javascript"
      }, {
        text: "Typescript",
        value: "typescript"
      }, {
        text: "JSX",
        value: "jsx"
      }, {
        text: "Go",
        value: "go"
      }, {
        text: "PHP",
        value: "php"
      }, {
        text: "C",
        value: "c"
      }, {
        text: "Python",
        value: "python"
      }, {
        text: "Java",
        value: "java"
      }, {
        text: "C++",
        value: "cpp"
      }, {
        text: "C#",
        value: "csharp"
      }, {
        text: "Visual Basic",
        value: "visual-basic"
      }, {
        text: "SQL",
        value: "sql"
      }, {
        text: "Ruby",
        value: "ruby"
      }, {
        text: "Swift",
        value: "swift"
      }, {
        text: "Bash",
        value: "bash"
      }, {
        text: "Lua",
        value: "lua"
      }, {
        text: "Groovy",
        value: "groovy"
      }, {
        text: "Markdown",
        value: "markdown"
      }]
    }
  }],
  elemsToHtml: [{
    type: "code",
    elemToHtml: function(e, t) {
      var n = e.language
        , r = void 0 === n ? "" : n;
      return "<code " + (r ? 'class="language-' + r + '"' : "") + ">" + t + "</code>"
    }
  }]
}
  , Yat = /"/g
  , Xat = Vtt("".replace);
kot({
  target: "String",
  proto: !0,
  forced: ant((function() {
      var e = "".anchor('"');
      return e !== e.toLowerCase() || e.split('"').length > 3
    }
  ))
}, {
  anchor: function(e) {
    return t = e,
      n = Not($tt(this)),
      r = "<a",
    (r += ' name="' + Xat(Not(t), Yat, "&quot;") + '"') + ">" + n + "</a>";
    var t, n, r
  }
});
var Qat = function(e) {
  var t, n, r, o = function(e, t) {
    var n = "function" == typeof Symbol && e[Symbol.iterator];
    if (!n)
      return e;
    var r, o, a = n.call(e), i = [];
    try {
      for (; (void 0 === t || t-- > 0) && !(r = a.next()).done; )
        i.push(r.value)
    } catch (s) {
      o = {
        error: s
      }
    } finally {
      try {
        r && !r.done && (n = a.return) && n.call(a)
      } finally {
        if (o)
          throw o.error
      }
    }
    return i
  }(e, 2), a = o[0], i = o[1], s = [], l = function(e) {
    if (!bne.isText(e))
      return null;
    var t = qme.getParentNode(null, e);
    if (t && "code" === qme.getNodeType(t)) {
      var n = qme.getParentNode(null, t);
      if (n && "pre" === qme.getNodeType(n))
        return t
    }
    return null
  }(a);
  if (null == l)
    return s;
  var u = l.language
    , c = void 0 === u ? "" : u;
  if (!c)
    return s;
  var d = function(e, t) {
    if (!t)
      return [];
    var n = Lot.languages[t];
    return n ? Lot.tokenize(e.text, n) : []
  }(a, c)
    , f = 0;
  try {
    for (var p = /*! *****************************************************************************
      Copyright (c) Microsoft Corporation.

      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.

      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** */
      function(e) {
        var t = "function" == typeof Symbol && Symbol.iterator
          , n = t && e[t]
          , r = 0;
        if (n)
          return n.call(e);
        if (e && "number" == typeof e.length)
          return {
            next: function() {
              return e && r >= e.length && (e = void 0),
                {
                  value: e && e[r++],
                  done: !e
                }
            }
          };
        throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
      }(d), h = p.next(); !h.done; h = p.next()) {
      var v = h.value
        , g = f + Pot(v);
      "string" != typeof v && s.push(((r = {})[v.type] = !0,
        r.anchor = {
          path: i,
          offset: f
        },
        r.focus = {
          path: i,
          offset: g
        },
        r)),
        f = g
    }
  } catch (m) {
    t = {
      error: m
    }
  } finally {
    try {
      h && !h.done && (n = p.return) && n.call(p)
    } finally {
      if (t)
        throw t.error
    }
  }
  return s
}
  , Jat = function() {
  return Jat = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++)
      for (var o in t = arguments[n])
        Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    return e
  }
    ,
    Jat.apply(this, arguments)
}
  , Zat = function() {
  function e() {
    throw new Error("不能实例化\nCan not construct a instance")
  }
  return e.setEditorConfig = function(e) {
    void 0 === e && (e = {}),
      this.editorConfig = Jat(Jat({}, this.editorConfig), e)
  }
    ,
    e.setSimpleEditorConfig = function(e) {
      void 0 === e && (e = {}),
        this.simpleEditorConfig = Jat(Jat({}, this.simpleEditorConfig), e)
    }
    ,
    e.setToolbarConfig = function(e) {
      void 0 === e && (e = {}),
        this.toolbarConfig = Jat(Jat({}, this.toolbarConfig), e)
    }
    ,
    e.setSimpleToolbarConfig = function(e) {
      void 0 === e && (e = {}),
        this.simpleToolbarConfig = Jat(Jat({}, this.simpleToolbarConfig), e)
    }
    ,
    e.registerPlugin = function(e) {
      this.plugins.push(e)
    }
    ,
    e.registerMenu = function(e, t) {
      !function(e, t) {
        var n, r, o = e.key, a = e.factory, i = e.config, s = Zve(Zve({}, i), t || {});
        if (null != Qme[o])
          throw new Error("Duplicated key '" + o + "' in menu items");
        Qme[o] = a,
          n = o,
        null != (r = s) && (Xme[n] = r)
      }(e, t)
    }
    ,
    e.registerRenderElem = function(e) {
      !function(e) {
        var t = e.type
          , n = e.renderElem;
        _xe[t || ""] = n
      }(e)
    }
    ,
    e.registerRenderStyle = function(e) {
      var t;
      t = e,
        Oxe.push(t)
    }
    ,
    e.registerElemToHtml = function(e) {
      !function(e) {
        var t = e.type
          , n = e.elemToHtml;
        cye[t || ""] = n
      }(e)
    }
    ,
    e.registerStyleToHtml = function(e) {
      var t;
      t = e,
        uye.push(t)
    }
    ,
    e.registerPreParseHtml = function(e) {
      var t;
      t = e,
        Jbe.push(t)
    }
    ,
    e.registerParseElemHtml = function(e) {
      !function(e) {
        var t = e.selector
          , n = e.parseElemHtml;
        ewe[t] = n
      }(e)
    }
    ,
    e.registerParseStyleHtml = function(e) {
      var t;
      t = e,
        Zbe.push(t)
    }
    ,
    e.registerModule = function(e) {
      eit(e)
    }
    ,
    e.editorConfig = {},
    e.simpleEditorConfig = {},
    e.toolbarConfig = {},
    e.simpleToolbarConfig = {},
    e.plugins = [],
    e
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function eit(e) {
  var t = e.menus
    , n = e.renderElems
    , r = e.renderStyle
    , o = e.elemsToHtml
    , a = e.styleToHtml
    , i = e.preParseHtml
    , s = e.parseElemsHtml
    , l = e.parseStyleHtml
    , u = e.editorPlugin;
  t && t.forEach((function(e) {
      return Zat.registerMenu(e)
    }
  )),
  n && n.forEach((function(e) {
      return Zat.registerRenderElem(e)
    }
  )),
  r && Zat.registerRenderStyle(r),
  o && o.forEach((function(e) {
      return Zat.registerElemToHtml(e)
    }
  )),
  a && Zat.registerStyleToHtml(a),
  i && i.forEach((function(e) {
      return Zat.registerPreParseHtml(e)
    }
  )),
  s && s.forEach((function(e) {
      return Zat.registerParseElemHtml(e)
    }
  )),
  l && Zat.registerParseStyleHtml(l),
  u && Zat.registerPlugin(u)
}
uNe.forEach((function(e) {
    return eit(e)
  }
)),
  eit(kHe),
  eit(iYe),
  eit(D4e),
  eit(Ctt),
  eit(qat);
var tit = '<svg viewBox="0 0 1024 1024"><path d="M959.877 128l0.123 0.123v767.775l-0.123 0.122H64.102l-0.122-0.122V128.123l0.122-0.123h895.775zM960 64H64C28.795 64 0 92.795 0 128v768c0 35.205 28.795 64 64 64h896c35.205 0 64-28.795 64-64V128c0-35.205-28.795-64-64-64zM832 288.01c0 53.023-42.988 96.01-96.01 96.01s-96.01-42.987-96.01-96.01S682.967 192 735.99 192 832 234.988 832 288.01zM896 832H128V704l224.01-384 256 320h64l224.01-192z"></path></svg>'
  , nit = {
  link: {
    menuKeys: ["editLink", "unLink", "viewLink"]
  },
  image: {
    menuKeys: ["imageWidth30", "imageWidth50", "imageWidth100", "editImage", "viewImageLink", "deleteImage"]
  },
  pre: {
    menuKeys: ["enter", "codeBlock", "codeSelectLang"]
  },
  table: {
    menuKeys: ["enter", "tableHeader", "tableFullWidth", "insertTableRow", "deleteTableRow", "insertTableCol", "deleteTableCol", "deleteTable"]
  },
  divider: {
    menuKeys: ["enter"]
  },
  video: {
    menuKeys: ["enter", "editVideoSize"]
  }
}
  , rit = {
  hoverbarKeys: Jat(Jat({}, nit), {
    text: {
      menuKeys: ["headerSelect", "insertLink", "bulletedList", "|", "bold", "through", "color", "bgColor", "clearStyle"]
    }
  })
};
Zat.setEditorConfig(Jat(Jat({}, rit), {
  decorate: Qat
}));
var oit = {
  hoverbarKeys: nit
};
Zat.setSimpleEditorConfig(Jat(Jat({}, oit), {
  decorate: Qat
}));
var ait = {
  toolbarKeys: ["headerSelect", "blockquote", "|", "bold", "underline", "italic", {
    key: "group-more-style",
    title: SEe("editor.more"),
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M204.8 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path><path d="M505.6 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path><path d="M806.4 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path></svg>',
    menuKeys: ["through", "code", "sup", "sub", "clearStyle"]
  }, "color", "bgColor", "|", "fontSize", "fontFamily", "lineHeight", "|", "bulletedList", "numberedList", "todo", {
    key: "group-justify",
    title: SEe("editor.justify"),
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M768 793.6v102.4H51.2v-102.4h716.8z m204.8-230.4v102.4H51.2v-102.4h921.6z m-204.8-230.4v102.4H51.2v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>',
    menuKeys: ["justifyLeft", "justifyRight", "justifyCenter", "justifyJustify"]
  }, {
    key: "group-indent",
    title: SEe("editor.indent"),
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m0-128V320l256 192z"></path></svg>',
    menuKeys: ["indent", "delIndent"]
  }, "|", "emotion", "insertLink", {
    key: "group-image",
    title: SEe("editor.image"),
    iconSvg: tit,
    menuKeys: ["insertImage", "uploadImage"]
  }, {
    key: "group-video",
    title: SEe("editor.video"),
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M981.184 160.096C837.568 139.456 678.848 128 512 128S186.432 139.456 42.816 160.096C15.296 267.808 0 386.848 0 512s15.264 244.16 42.816 351.904C186.464 884.544 345.152 896 512 896s325.568-11.456 469.184-32.096C1008.704 756.192 1024 637.152 1024 512s-15.264-244.16-42.816-351.904zM384 704V320l320 192-320 192z"></path></svg>',
    menuKeys: ["insertVideo", "uploadVideo"]
  }, "insertTable", "codeBlock", "divider", "|", "undo", "redo", "|", "fullScreen"]
};
Zat.setToolbarConfig(ait);
var iit = {
  toolbarKeys: ["blockquote", "header1", "header2", "header3", "|", "bold", "underline", "italic", "through", "color", "bgColor", "clearStyle", "|", "bulletedList", "numberedList", "todo", "justifyLeft", "justifyRight", "justifyCenter", "|", "insertLink", {
    key: "group-image",
    title: SEe("editor.image"),
    iconSvg: tit,
    menuKeys: ["insertImage", "uploadImage"]
  }, "insertVideo", "insertTable", "codeBlock", "|", "undo", "redo", "|", "fullScreen"]
};
Zat.setSimpleToolbarConfig(iit);
var sit = Object.defineProperty
  , lit = Object.defineProperties
  , uit = Object.getOwnPropertyDescriptors
  , cit = Object.getOwnPropertySymbols
  , dit = Object.prototype.hasOwnProperty
  , fit = Object.prototype.propertyIsEnumerable
  , pit = (e,t,n)=>t in e ? sit(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : e[t] = n
  , hit = (e,t)=>{
  for (var n in t || (t = {}))
    dit.call(t, n) && pit(e, n, t[n]);
  if (cit)
    for (var n of cit(t))
      fit.call(t, n) && pit(e, n, t[n]);
  return e
}
  , vit = (e,t)=>lit(e, uit(t));
function git(e) {
  let t = `请使用 '@${e}' 事件，不要放在 props 中`;
  return t += `\nPlease use '@${e}' event instead of props`,
    t
}
var mit = (e,t)=>{
    for (const [n,r] of t)
      e[n] = r;
    return e
  }
;
const yit = vr({
  props: {
    mode: {
      type: String,
      default: "default"
    },
    defaultContent: {
      type: Array,
      default: []
    },
    defaultHtml: {
      type: String,
      default: ""
    },
    defaultConfig: {
      type: Object,
      default: {}
    },
    modelValue: {
      type: String,
      default: ""
    }
  },
  setup(e, t) {
    const n = Ft(null)
      , r = Bt(null)
      , o = Ft("")
      , a = ()=>{
        if (!n.value)
          return;
        const a = Dt(e.defaultContent);
        !function(e) {
          void 0 === e && (e = {});
          var t = e.selector
            , n = void 0 === t ? "" : t
            , r = e.content
            , o = void 0 === r ? [] : r
            , a = e.html
            , i = e.config
            , s = void 0 === i ? {} : i
            , l = e.mode
            , u = "simple" === (void 0 === l ? "default" : l) ? Zat.simpleEditorConfig : Zat.editorConfig
            , c = Jat(Jat({}, u.hoverbarKeys || {}), s.hoverbarKeys || {});
          SSe({
            selector: n,
            config: Jat(Jat(Jat({}, u), s), {
              hoverbarKeys: c
            }),
            content: o,
            html: a,
            plugins: Zat.plugins
          })
        }({
          selector: n.value,
          mode: e.mode,
          content: a || [],
          html: e.defaultHtml || e.modelValue || "",
          config: vit(hit({}, e.defaultConfig), {
            onCreated(n) {
              if (r.value = n,
                t.emit("onCreated", n),
                e.defaultConfig.onCreated) {
                const e = git("onCreated");
                throw new Error(e)
              }
            },
            onChange(n) {
              const r = n.getHtml();
              if (o.value = r,
                t.emit("update:modelValue", r),
                t.emit("onChange", n),
                e.defaultConfig.onChange) {
                const e = git("onChange");
                throw new Error(e)
              }
            },
            onDestroyed(n) {
              if (t.emit("onDestroyed", n),
                e.defaultConfig.onDestroyed) {
                const e = git("onDestroyed");
                throw new Error(e)
              }
            },
            onMaxLength(n) {
              if (t.emit("onMaxLength", n),
                e.defaultConfig.onMaxLength) {
                const e = git("onMaxLength");
                throw new Error(e)
              }
            },
            onFocus(n) {
              if (t.emit("onFocus", n),
                e.defaultConfig.onFocus) {
                const e = git("onFocus");
                throw new Error(e)
              }
            },
            onBlur(n) {
              if (t.emit("onBlur", n),
                e.defaultConfig.onBlur) {
                const e = git("onBlur");
                throw new Error(e)
              }
            },
            customAlert(n, r) {
              if (t.emit("customAlert", n, r),
                e.defaultConfig.customAlert) {
                const e = git("customAlert");
                throw new Error(e)
              }
            },
            customPaste: (n,r)=>{
              if (e.defaultConfig.customPaste) {
                const e = git("customPaste");
                throw new Error(e)
              }
              let o;
              return t.emit("customPaste", n, r, (e=>{
                  o = e
                }
              )),
                o
            }
          })
        })
      }
    ;
    return Lr((()=>{
        a()
      }
    )),
      Jn((()=>e.modelValue), (e=>{
          e !== o.value && function(e) {
            const t = r.value;
            null != t && t.setHtml(e)
          }(e)
        }
      )),
      {
        box: n
      }
  }
})
  , bit = {
  ref: "box",
  style: {
    height: "100%"
  }
};
var wit = mit(yit, [["render", function(e, t, n, r, o, a) {
  return Ca(),
    _a("div", bit, null, 512)
}
]]);
function xit(e, t, n, r) {
  var o, a = !1, i = 0;
  function s() {
    o && clearTimeout(o)
  }
  function l() {
    for (var l = arguments.length, u = new Array(l), c = 0; c < l; c++)
      u[c] = arguments[c];
    var d = this
      , f = Date.now() - i;
    function p() {
      i = Date.now(),
        n.apply(d, u)
    }
    a || (r && !o && p(),
      s(),
      void 0 === r && f > e ? p() : !0 !== t && (o = setTimeout(r ? function() {
          o = void 0
        }
        : p, void 0 === r ? e - f : e)))
  }
  return "boolean" != typeof t && (r = n,
    n = t,
    t = void 0),
    l.cancel = function() {
      s(),
        a = !0
    }
    ,
    l
}
function Sit(e, t, n) {
  return void 0 === n ? xit(e, t, !1) : xit(e, n, !1 !== t)
}
function Eit(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var Ait, Cit, kit, Tit, Dit, Oit = {
  exports: {}
};
Ait = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/,
  Cit = /^(?=([^\/?#]*))\1([^]*)$/,
  kit = /(?:\/|^)\.(?=\/)/g,
  Tit = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
var _it = Oit.exports = Dit = {
  buildAbsoluteURL: function(e, t, n) {
    if (n = n || {},
      e = e.trim(),
      !(t = t.trim())) {
      if (!n.alwaysNormalize)
        return e;
      var r = Dit.parseURL(e);
      if (!r)
        throw new Error("Error trying to parse base URL.");
      return r.path = Dit.normalizePath(r.path),
        Dit.buildURLFromParts(r)
    }
    var o = Dit.parseURL(t);
    if (!o)
      throw new Error("Error trying to parse relative URL.");
    if (o.scheme)
      return n.alwaysNormalize ? (o.path = Dit.normalizePath(o.path),
        Dit.buildURLFromParts(o)) : t;
    var a = Dit.parseURL(e);
    if (!a)
      throw new Error("Error trying to parse base URL.");
    if (!a.netLoc && a.path && "/" !== a.path[0]) {
      var i = Cit.exec(a.path);
      a.netLoc = i[1],
        a.path = i[2]
    }
    a.netLoc && !a.path && (a.path = "/");
    var s = {
      scheme: a.scheme,
      netLoc: o.netLoc,
      path: null,
      params: o.params,
      query: o.query,
      fragment: o.fragment
    };
    if (!o.netLoc && (s.netLoc = a.netLoc,
    "/" !== o.path[0]))
      if (o.path) {
        var l = a.path
          , u = l.substring(0, l.lastIndexOf("/") + 1) + o.path;
        s.path = Dit.normalizePath(u)
      } else
        s.path = a.path,
        o.params || (s.params = a.params,
        o.query || (s.query = a.query));
    return null === s.path && (s.path = n.alwaysNormalize ? Dit.normalizePath(o.path) : o.path),
      Dit.buildURLFromParts(s)
  },
  parseURL: function(e) {
    var t = Ait.exec(e);
    return t ? {
      scheme: t[1] || "",
      netLoc: t[2] || "",
      path: t[3] || "",
      params: t[4] || "",
      query: t[5] || "",
      fragment: t[6] || ""
    } : null
  },
  normalizePath: function(e) {
    for (e = e.split("").reverse().join("").replace(kit, ""); e.length !== (e = e.replace(Tit, "")).length; )
      ;
    return e.split("").reverse().join("")
  },
  buildURLFromParts: function(e) {
    return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
  }
};
function Rit(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }
    ))),
      n.push.apply(n, r)
  }
  return n
}
function Lit(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = null != arguments[t] ? arguments[t] : {};
    t % 2 ? Rit(Object(n), !0).forEach((function(t) {
        Iit(e, t, n[t])
      }
    )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rit(Object(n)).forEach((function(t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
      }
    ))
  }
  return e
}
function Iit(e, t, n) {
  return (t = function(e) {
    var t = function(e, t) {
      if ("object" != typeof e || null === e)
        return e;
      var n = e[Symbol.toPrimitive];
      if (void 0 !== n) {
        var r = n.call(e, t || "default");
        if ("object" != typeof r)
          return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
      }
      return ("string" === t ? String : Number)(e)
    }(e, "string");
    return "symbol" == typeof t ? t : String(t)
  }(t))in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n,
    e
}
function Pit() {
  return Pit = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
    }
    return e
  }
    ,
    Pit.apply(this, arguments)
}
const Fit = Number.isFinite || function(e) {
    return "number" == typeof e && isFinite(e)
  }
;
let Bit = function(e) {
  return e.MEDIA_ATTACHING = "hlsMediaAttaching",
    e.MEDIA_ATTACHED = "hlsMediaAttached",
    e.MEDIA_DETACHING = "hlsMediaDetaching",
    e.MEDIA_DETACHED = "hlsMediaDetached",
    e.BUFFER_RESET = "hlsBufferReset",
    e.BUFFER_CODECS = "hlsBufferCodecs",
    e.BUFFER_CREATED = "hlsBufferCreated",
    e.BUFFER_APPENDING = "hlsBufferAppending",
    e.BUFFER_APPENDED = "hlsBufferAppended",
    e.BUFFER_EOS = "hlsBufferEos",
    e.BUFFER_FLUSHING = "hlsBufferFlushing",
    e.BUFFER_FLUSHED = "hlsBufferFlushed",
    e.MANIFEST_LOADING = "hlsManifestLoading",
    e.MANIFEST_LOADED = "hlsManifestLoaded",
    e.MANIFEST_PARSED = "hlsManifestParsed",
    e.LEVEL_SWITCHING = "hlsLevelSwitching",
    e.LEVEL_SWITCHED = "hlsLevelSwitched",
    e.LEVEL_LOADING = "hlsLevelLoading",
    e.LEVEL_LOADED = "hlsLevelLoaded",
    e.LEVEL_UPDATED = "hlsLevelUpdated",
    e.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated",
    e.LEVELS_UPDATED = "hlsLevelsUpdated",
    e.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated",
    e.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching",
    e.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched",
    e.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading",
    e.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded",
    e.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated",
    e.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared",
    e.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch",
    e.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading",
    e.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded",
    e.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed",
    e.CUES_PARSED = "hlsCuesParsed",
    e.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound",
    e.INIT_PTS_FOUND = "hlsInitPtsFound",
    e.FRAG_LOADING = "hlsFragLoading",
    e.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted",
    e.FRAG_LOADED = "hlsFragLoaded",
    e.FRAG_DECRYPTED = "hlsFragDecrypted",
    e.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment",
    e.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata",
    e.FRAG_PARSING_METADATA = "hlsFragParsingMetadata",
    e.FRAG_PARSED = "hlsFragParsed",
    e.FRAG_BUFFERED = "hlsFragBuffered",
    e.FRAG_CHANGED = "hlsFragChanged",
    e.FPS_DROP = "hlsFpsDrop",
    e.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping",
    e.ERROR = "hlsError",
    e.DESTROYING = "hlsDestroying",
    e.KEY_LOADING = "hlsKeyLoading",
    e.KEY_LOADED = "hlsKeyLoaded",
    e.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached",
    e.BACK_BUFFER_REACHED = "hlsBackBufferReached",
    e
}({})
  , Nit = function(e) {
  return e.NETWORK_ERROR = "networkError",
    e.MEDIA_ERROR = "mediaError",
    e.KEY_SYSTEM_ERROR = "keySystemError",
    e.MUX_ERROR = "muxError",
    e.OTHER_ERROR = "otherError",
    e
}({})
  , Mit = function(e) {
  return e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys",
    e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess",
    e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession",
    e.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense",
    e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed",
    e.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed",
    e.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed",
    e.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed",
    e.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted",
    e.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError",
    e.MANIFEST_LOAD_ERROR = "manifestLoadError",
    e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut",
    e.MANIFEST_PARSING_ERROR = "manifestParsingError",
    e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError",
    e.LEVEL_EMPTY_ERROR = "levelEmptyError",
    e.LEVEL_LOAD_ERROR = "levelLoadError",
    e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut",
    e.LEVEL_PARSING_ERROR = "levelParsingError",
    e.LEVEL_SWITCH_ERROR = "levelSwitchError",
    e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError",
    e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut",
    e.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError",
    e.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut",
    e.FRAG_LOAD_ERROR = "fragLoadError",
    e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut",
    e.FRAG_DECRYPT_ERROR = "fragDecryptError",
    e.FRAG_PARSING_ERROR = "fragParsingError",
    e.FRAG_GAP = "fragGap",
    e.REMUX_ALLOC_ERROR = "remuxAllocError",
    e.KEY_LOAD_ERROR = "keyLoadError",
    e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut",
    e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError",
    e.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError",
    e.BUFFER_APPEND_ERROR = "bufferAppendError",
    e.BUFFER_APPENDING_ERROR = "bufferAppendingError",
    e.BUFFER_STALLED_ERROR = "bufferStalledError",
    e.BUFFER_FULL_ERROR = "bufferFullError",
    e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole",
    e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall",
    e.INTERNAL_EXCEPTION = "internalException",
    e.INTERNAL_ABORTED = "aborted",
    e.UNKNOWN = "unknown",
    e
}({});
const jit = function() {}
  , Vit = {
  trace: jit,
  debug: jit,
  log: jit,
  warn: jit,
  info: jit,
  error: jit
};
let Uit = Vit;
function $it(e, ...t) {
  t.forEach((function(t) {
      Uit[t] = e[t] ? e[t].bind(e) : function(e) {
        const t = self.console[e];
        return t ? t.bind(self.console, `[${e}] >`) : jit
      }(t)
    }
  ))
}
const Hit = Uit
  , zit = /^(\d+)x(\d+)$/
  , Kit = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class Wit {
  constructor(e) {
    "string" == typeof e && (e = Wit.parseAttrList(e));
    for (const t in e)
      e.hasOwnProperty(t) && ("X-" === t.substring(0, 2) && (this.clientAttrs = this.clientAttrs || [],
        this.clientAttrs.push(t)),
        this[t] = e[t])
  }
  decimalInteger(e) {
    const t = parseInt(this[e], 10);
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
  }
  hexadecimalInteger(e) {
    if (this[e]) {
      let t = (this[e] || "0x").slice(2);
      t = (1 & t.length ? "0" : "") + t;
      const n = new Uint8Array(t.length / 2);
      for (let e = 0; e < t.length / 2; e++)
        n[e] = parseInt(t.slice(2 * e, 2 * e + 2), 16);
      return n
    }
    return null
  }
  hexadecimalIntegerAsNumber(e) {
    const t = parseInt(this[e], 16);
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
  }
  decimalFloatingPoint(e) {
    return parseFloat(this[e])
  }
  optionalFloat(e, t) {
    const n = this[e];
    return n ? parseFloat(n) : t
  }
  enumeratedString(e) {
    return this[e]
  }
  bool(e) {
    return "YES" === this[e]
  }
  decimalResolution(e) {
    const t = zit.exec(this[e]);
    if (null !== t)
      return {
        width: parseInt(t[1], 10),
        height: parseInt(t[2], 10)
      }
  }
  static parseAttrList(e) {
    let t;
    const n = {};
    for (Kit.lastIndex = 0; null !== (t = Kit.exec(e)); ) {
      let e = t[2];
      0 === e.indexOf('"') && e.lastIndexOf('"') === e.length - 1 && (e = e.slice(1, -1));
      n[t[1].trim()] = e
    }
    return n
  }
}
function Git(e) {
  return "SCTE35-OUT" === e || "SCTE35-IN" === e
}
class qit {
  constructor(e, t) {
    if (this.attr = void 0,
      this._startDate = void 0,
      this._endDate = void 0,
      this._badValueForSameId = void 0,
      t) {
      const n = t.attr;
      for (const t in n)
        if (Object.prototype.hasOwnProperty.call(e, t) && e[t] !== n[t]) {
          Hit.warn(`DATERANGE tag attribute: "${t}" does not match for tags with ID: "${e.ID}"`),
            this._badValueForSameId = t;
          break
        }
      e = Pit(new Wit({}), n, e)
    }
    if (this.attr = e,
      this._startDate = new Date(e["START-DATE"]),
    "END-DATE"in this.attr) {
      const e = new Date(this.attr["END-DATE"]);
      Fit(e.getTime()) && (this._endDate = e)
    }
  }
  get id() {
    return this.attr.ID
  }
  get class() {
    return this.attr.CLASS
  }
  get startDate() {
    return this._startDate
  }
  get endDate() {
    if (this._endDate)
      return this._endDate;
    const e = this.duration;
    return null !== e ? new Date(this._startDate.getTime() + 1e3 * e) : null
  }
  get duration() {
    if ("DURATION"in this.attr) {
      const e = this.attr.decimalFloatingPoint("DURATION");
      if (Fit(e))
        return e
    } else if (this._endDate)
      return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
    return null
  }
  get plannedDuration() {
    return "PLANNED-DURATION"in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null
  }
  get endOnNext() {
    return this.attr.bool("END-ON-NEXT")
  }
  get isValid() {
    return !!this.id && !this._badValueForSameId && Fit(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class)
  }
}
class Yit {
  constructor() {
    this.aborted = !1,
      this.loaded = 0,
      this.retry = 0,
      this.total = 0,
      this.chunkCount = 0,
      this.bwEstimate = 0,
      this.loading = {
        start: 0,
        first: 0,
        end: 0
      },
      this.parsing = {
        start: 0,
        end: 0
      },
      this.buffering = {
        start: 0,
        first: 0,
        end: 0
      }
  }
}
var Xit = "audio"
  , Qit = "video"
  , Jit = "audiovideo";
class Zit {
  constructor(e) {
    this._byteRange = null,
      this._url = null,
      this.baseurl = void 0,
      this.relurl = void 0,
      this.elementaryStreams = {
        [Xit]: null,
        [Qit]: null,
        [Jit]: null
      },
      this.baseurl = e
  }
  setByteRange(e, t) {
    const n = e.split("@", 2)
      , r = [];
    1 === n.length ? r[0] = t ? t.byteRangeEndOffset : 0 : r[0] = parseInt(n[1]),
      r[1] = parseInt(n[0]) + r[0],
      this._byteRange = r
  }
  get byteRange() {
    return this._byteRange ? this._byteRange : []
  }
  get byteRangeStartOffset() {
    return this.byteRange[0]
  }
  get byteRangeEndOffset() {
    return this.byteRange[1]
  }
  get url() {
    return !this._url && this.baseurl && this.relurl && (this._url = _it.buildAbsoluteURL(this.baseurl, this.relurl, {
      alwaysNormalize: !0
    })),
    this._url || ""
  }
  set url(e) {
    this._url = e
  }
}
class est extends Zit {
  constructor(e, t) {
    super(t),
      this._decryptdata = null,
      this.rawProgramDateTime = null,
      this.programDateTime = null,
      this.tagList = [],
      this.duration = 0,
      this.sn = 0,
      this.levelkeys = void 0,
      this.type = void 0,
      this.loader = null,
      this.keyLoader = null,
      this.level = -1,
      this.cc = 0,
      this.startPTS = void 0,
      this.endPTS = void 0,
      this.startDTS = void 0,
      this.endDTS = void 0,
      this.start = 0,
      this.deltaPTS = void 0,
      this.maxStartPTS = void 0,
      this.minEndPTS = void 0,
      this.stats = new Yit,
      this.urlId = 0,
      this.data = void 0,
      this.bitrateTest = !1,
      this.title = null,
      this.initSegment = null,
      this.endList = void 0,
      this.gap = void 0,
      this.type = e
  }
  get decryptdata() {
    const {levelkeys: e} = this;
    if (!e && !this._decryptdata)
      return null;
    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
      const e = this.levelkeys.identity;
      if (e)
        this._decryptdata = e.getDecryptData(this.sn);
      else {
        const e = Object.keys(this.levelkeys);
        if (1 === e.length)
          return this._decryptdata = this.levelkeys[e[0]].getDecryptData(this.sn)
      }
    }
    return this._decryptdata
  }
  get end() {
    return this.start + this.duration
  }
  get endProgramDateTime() {
    if (null === this.programDateTime)
      return null;
    if (!Fit(this.programDateTime))
      return null;
    const e = Fit(this.duration) ? this.duration : 0;
    return this.programDateTime + 1e3 * e
  }
  get encrypted() {
    var e;
    if (null != (e = this._decryptdata) && e.encrypted)
      return !0;
    if (this.levelkeys) {
      const e = Object.keys(this.levelkeys)
        , t = e.length;
      if (t > 1 || 1 === t && this.levelkeys[e[0]].encrypted)
        return !0
    }
    return !1
  }
  setKeyFormat(e) {
    if (this.levelkeys) {
      const t = this.levelkeys[e];
      t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn))
    }
  }
  abortRequests() {
    var e, t;
    null == (e = this.loader) || e.abort(),
    null == (t = this.keyLoader) || t.abort()
  }
  setElementaryStreamInfo(e, t, n, r, o, a=!1) {
    const {elementaryStreams: i} = this
      , s = i[e];
    s ? (s.startPTS = Math.min(s.startPTS, t),
      s.endPTS = Math.max(s.endPTS, n),
      s.startDTS = Math.min(s.startDTS, r),
      s.endDTS = Math.max(s.endDTS, o)) : i[e] = {
      startPTS: t,
      endPTS: n,
      startDTS: r,
      endDTS: o,
      partial: a
    }
  }
  clearElementaryStreamInfo() {
    const {elementaryStreams: e} = this;
    e[Xit] = null,
      e[Qit] = null,
      e[Jit] = null
  }
}
class tst extends Zit {
  constructor(e, t, n, r, o) {
    super(n),
      this.fragOffset = 0,
      this.duration = 0,
      this.gap = !1,
      this.independent = !1,
      this.relurl = void 0,
      this.fragment = void 0,
      this.index = void 0,
      this.stats = new Yit,
      this.duration = e.decimalFloatingPoint("DURATION"),
      this.gap = e.bool("GAP"),
      this.independent = e.bool("INDEPENDENT"),
      this.relurl = e.enumeratedString("URI"),
      this.fragment = t,
      this.index = r;
    const a = e.enumeratedString("BYTERANGE");
    a && this.setByteRange(a, o),
    o && (this.fragOffset = o.fragOffset + o.duration)
  }
  get start() {
    return this.fragment.start + this.fragOffset
  }
  get end() {
    return this.start + this.duration
  }
  get loaded() {
    const {elementaryStreams: e} = this;
    return !!(e.audio || e.video || e.audiovideo)
  }
}
class nst {
  constructor(e) {
    this.PTSKnown = !1,
      this.alignedSliding = !1,
      this.averagetargetduration = void 0,
      this.endCC = 0,
      this.endSN = 0,
      this.fragments = void 0,
      this.fragmentHint = void 0,
      this.partList = null,
      this.dateRanges = void 0,
      this.live = !0,
      this.ageHeader = 0,
      this.advancedDateTime = void 0,
      this.updated = !0,
      this.advanced = !0,
      this.availabilityDelay = void 0,
      this.misses = 0,
      this.startCC = 0,
      this.startSN = 0,
      this.startTimeOffset = null,
      this.targetduration = 0,
      this.totalduration = 0,
      this.type = null,
      this.url = void 0,
      this.m3u8 = "",
      this.version = null,
      this.canBlockReload = !1,
      this.canSkipUntil = 0,
      this.canSkipDateRanges = !1,
      this.skippedSegments = 0,
      this.recentlyRemovedDateranges = void 0,
      this.partHoldBack = 0,
      this.holdBack = 0,
      this.partTarget = 0,
      this.preloadHint = void 0,
      this.renditionReports = void 0,
      this.tuneInGoal = 0,
      this.deltaUpdateFailed = void 0,
      this.driftStartTime = 0,
      this.driftEndTime = 0,
      this.driftStart = 0,
      this.driftEnd = 0,
      this.encryptedFragments = void 0,
      this.playlistParsingError = null,
      this.variableList = null,
      this.hasVariableRefs = !1,
      this.fragments = [],
      this.encryptedFragments = [],
      this.dateRanges = {},
      this.url = e
  }
  reloaded(e) {
    if (!e)
      return this.advanced = !0,
        void (this.updated = !0);
    const t = this.lastPartSn - e.lastPartSn
      , n = this.lastPartIndex - e.lastPartIndex;
    this.updated = this.endSN !== e.endSN || !!n || !!t,
      this.advanced = this.endSN > e.endSN || t > 0 || 0 === t && n > 0,
      this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1,
      this.availabilityDelay = e.availabilityDelay
  }
  get hasProgramDateTime() {
    return !!this.fragments.length && Fit(this.fragments[this.fragments.length - 1].programDateTime)
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || 10
  }
  get drift() {
    const e = this.driftEndTime - this.driftStartTime;
    if (e > 0) {
      return 1e3 * (this.driftEnd - this.driftStart) / e
    }
    return 1
  }
  get edge() {
    return this.partEnd || this.fragmentEnd
  }
  get partEnd() {
    var e;
    return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
  }
  get fragmentEnd() {
    var e;
    return null != (e = this.fragments) && e.length ? this.fragments[this.fragments.length - 1].end : 0
  }
  get age() {
    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
  }
  get lastPartIndex() {
    var e;
    return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].index : -1
  }
  get lastPartSn() {
    var e;
    return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
  }
}
function rst(e) {
  return Uint8Array.from(atob(e), (e=>e.charCodeAt(0)))
}
function ost(e) {
  const t = e.split(":");
  let n = null;
  if ("data" === t[0] && 2 === t.length) {
    const e = t[1].split(";")
      , r = e[e.length - 1].split(",");
    if (2 === r.length) {
      const t = "base64" === r[0]
        , o = r[1];
      t ? (e.splice(-1, 1),
        n = rst(o)) : n = function(e) {
        const t = ast(e).subarray(0, 16)
          , n = new Uint8Array(16);
        return n.set(t, 16 - t.length),
          n
      }(o)
    }
  }
  return n
}
function ast(e) {
  return Uint8Array.from(unescape(encodeURIComponent(e)), (e=>e.charCodeAt(0)))
}
var ist = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.fps",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "com.widevine.alpha"
}
  , sst = "org.w3.clearkey"
  , lst = "com.apple.streamingkeydelivery"
  , ust = "com.microsoft.playready"
  , cst = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
function dst(e) {
  switch (e) {
    case lst:
      return ist.FAIRPLAY;
    case ust:
      return ist.PLAYREADY;
    case cst:
      return ist.WIDEVINE;
    case sst:
      return ist.CLEARKEY
  }
}
var fst = "edef8ba979d64acea3c827dcd51d21ed";
function pst(e) {
  switch (e) {
    case ist.FAIRPLAY:
      return lst;
    case ist.PLAYREADY:
      return ust;
    case ist.WIDEVINE:
      return cst;
    case ist.CLEARKEY:
      return sst
  }
}
function hst(e) {
  const {drmSystems: t, widevineLicenseUrl: n} = e
    , r = t ? [ist.FAIRPLAY, ist.WIDEVINE, ist.PLAYREADY, ist.CLEARKEY].filter((e=>!!t[e])) : [];
  return !r[ist.WIDEVINE] && n && r.push(ist.WIDEVINE),
    r
}
const vst = "undefined" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
function gst(e, t, n) {
  return Uint8Array.prototype.slice ? e.slice(t, n) : new Uint8Array(Array.prototype.slice.call(e, t, n))
}
const mst = (e,t)=>t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
  , yst = (e,t)=>t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128
  , bst = (e,t)=>{
    const n = t;
    let r = 0;
    for (; mst(e, t); ) {
      r += 10;
      r += wst(e, t + 6),
      yst(e, t + 10) && (r += 10),
        t += r
    }
    if (r > 0)
      return e.subarray(n, n + r)
  }
  , wst = (e,t)=>{
    let n = 0;
    return n = (127 & e[t]) << 21,
      n |= (127 & e[t + 1]) << 14,
      n |= (127 & e[t + 2]) << 7,
      n |= 127 & e[t + 3],
      n
  }
  , xst = (e,t)=>mst(e, t) && wst(e, t + 6) + 10 <= e.length - t
  , Sst = e=>e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info
  , Est = e=>{
    const t = String.fromCharCode(e[0], e[1], e[2], e[3])
      , n = wst(e, 4);
    return {
      type: t,
      size: n,
      data: e.subarray(10, 10 + n)
    }
  }
  , Ast = e=>{
    let t = 0;
    const n = [];
    for (; mst(e, t); ) {
      const r = wst(e, t + 6);
      t += 10;
      const o = t + r;
      for (; t + 8 < o; ) {
        const r = Est(e.subarray(t))
          , o = Cst(r);
        o && n.push(o),
          t += r.size + 10
      }
      yst(e, t) && (t += 10)
    }
    return n
  }
  , Cst = e=>"PRIV" === e.type ? kst(e) : "W" === e.type[0] ? Dst(e) : Tst(e)
  , kst = e=>{
    if (e.size < 2)
      return;
    const t = _st(e.data, !0)
      , n = new Uint8Array(e.data.subarray(t.length + 1));
    return {
      key: e.type,
      info: t,
      data: n.buffer
    }
  }
  , Tst = e=>{
    if (e.size < 2)
      return;
    if ("TXXX" === e.type) {
      let t = 1;
      const n = _st(e.data.subarray(t), !0);
      t += n.length + 1;
      const r = _st(e.data.subarray(t));
      return {
        key: e.type,
        info: n,
        data: r
      }
    }
    const t = _st(e.data.subarray(1));
    return {
      key: e.type,
      data: t
    }
  }
  , Dst = e=>{
    if ("WXXX" === e.type) {
      if (e.size < 2)
        return;
      let t = 1;
      const n = _st(e.data.subarray(t), !0);
      t += n.length + 1;
      const r = _st(e.data.subarray(t));
      return {
        key: e.type,
        info: n,
        data: r
      }
    }
    const t = _st(e.data);
    return {
      key: e.type,
      data: t
    }
  }
  , Ost = e=>{
    if (8 === e.data.byteLength) {
      const t = new Uint8Array(e.data)
        , n = 1 & t[3];
      let r = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];
      return r /= 45,
      n && (r += 47721858.84),
        Math.round(r)
    }
  }
  , _st = (e,t=!1)=>{
    const n = function() {
      Rst || void 0 === self.TextDecoder || (Rst = new self.TextDecoder("utf-8"));
      return Rst
    }();
    if (n) {
      const r = n.decode(e);
      if (t) {
        const e = r.indexOf("\0");
        return -1 !== e ? r.substring(0, e) : r
      }
      return r.replace(/\0/g, "")
    }
    const r = e.length;
    let o, a, i, s = "", l = 0;
    for (; l < r; ) {
      if (o = e[l++],
      0 === o && t)
        return s;
      if (0 !== o && 3 !== o)
        switch (o >> 4) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            s += String.fromCharCode(o);
            break;
          case 12:
          case 13:
            a = e[l++],
              s += String.fromCharCode((31 & o) << 6 | 63 & a);
            break;
          case 14:
            a = e[l++],
              i = e[l++],
              s += String.fromCharCode((15 & o) << 12 | (63 & a) << 6 | (63 & i) << 0)
        }
    }
    return s
  }
;
let Rst;
const Lst = function(e) {
  let t = "";
  for (let n = 0; n < e.length; n++) {
    let r = e[n].toString(16);
    r.length < 2 && (r = "0" + r),
      t += r
  }
  return t
}
  , Ist = Math.pow(2, 32) - 1
  , Pst = [].push
  , Fst = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};
function Bst(e) {
  return String.fromCharCode.apply(null, e)
}
function Nst(e, t) {
  const n = e[t] << 8 | e[t + 1];
  return n < 0 ? 65536 + n : n
}
function Mst(e, t) {
  const n = jst(e, t);
  return n < 0 ? 4294967296 + n : n
}
function jst(e, t) {
  return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
}
function Vst(e, t, n) {
  e[t] = n >> 24,
    e[t + 1] = n >> 16 & 255,
    e[t + 2] = n >> 8 & 255,
    e[t + 3] = 255 & n
}
function Ust(e, t) {
  const n = [];
  if (!t.length)
    return n;
  const r = e.byteLength;
  for (let o = 0; o < r; ) {
    const a = Mst(e, o)
      , i = a > 1 ? o + a : r;
    if (Bst(e.subarray(o + 4, o + 8)) === t[0])
      if (1 === t.length)
        n.push(e.subarray(o + 8, i));
      else {
        const r = Ust(e.subarray(o + 8, i), t.slice(1));
        r.length && Pst.apply(n, r)
      }
    o = i
  }
  return n
}
function $st(e) {
  const t = []
    , n = e[0];
  let r = 8;
  const o = Mst(e, r);
  r += 4;
  r += 0 === n ? 8 : 16,
    r += 2;
  let a = e.length + 0;
  const i = Nst(e, r);
  r += 2;
  for (let s = 0; s < i; s++) {
    let n = r;
    const i = Mst(e, n);
    n += 4;
    const s = 2147483647 & i;
    if (1 === (2147483648 & i) >>> 31)
      return Hit.warn("SIDX has hierarchical references (not supported)"),
        null;
    const l = Mst(e, n);
    n += 4,
      t.push({
        referenceSize: s,
        subsegmentDuration: l,
        info: {
          duration: l / o,
          start: a,
          end: a + s - 1
        }
      }),
      a += s,
      n += 4,
      r = n
  }
  return {
    earliestPresentationTime: 0,
    timescale: o,
    version: n,
    referencesCount: i,
    references: t
  }
}
function Hst(e) {
  const t = []
    , n = Ust(e, ["moov", "trak"]);
  for (let r = 0; r < n.length; r++) {
    const e = n[r]
      , o = Ust(e, ["tkhd"])[0];
    if (o) {
      let n = o[0]
        , r = 0 === n ? 12 : 20;
      const a = Mst(o, r)
        , i = Ust(e, ["mdia", "mdhd"])[0];
      if (i) {
        n = i[0],
          r = 0 === n ? 12 : 20;
        const o = Mst(i, r)
          , s = Ust(e, ["mdia", "hdlr"])[0];
        if (s) {
          const n = Bst(s.subarray(8, 12))
            , r = {
            soun: Xit,
            vide: Qit
          }[n];
          if (r) {
            const n = Ust(e, ["mdia", "minf", "stbl", "stsd"])[0];
            let i;
            n && (i = Bst(n.subarray(12, 16))),
              t[a] = {
                timescale: o,
                type: r
              },
              t[r] = {
                timescale: o,
                id: a,
                codec: i
              }
          }
        }
      }
    }
  }
  return Ust(e, ["moov", "mvex", "trex"]).forEach((e=>{
      const n = Mst(e, 4)
        , r = t[n];
      r && (r.default = {
        duration: Mst(e, 12),
        flags: Mst(e, 20)
      })
    }
  )),
    t
}
function zst(e) {
  const t = Ust(e, ["schm"])[0];
  if (t) {
    const n = Bst(t.subarray(4, 8));
    if ("cbcs" === n || "cenc" === n)
      return Ust(e, ["schi", "tenc"])[0]
  }
  return Hit.error("[eme] missing 'schm' box"),
    null
}
function Kst(e) {
  const t = Mst(e, 0);
  let n = 8;
  1 & t && (n += 4),
  4 & t && (n += 4);
  let r = 0;
  const o = Mst(e, 4);
  for (let a = 0; a < o; a++) {
    if (256 & t) {
      r += Mst(e, n),
        n += 4
    }
    512 & t && (n += 4),
    1024 & t && (n += 4),
    2048 & t && (n += 4)
  }
  return r
}
function Wst(e, t) {
  const n = new Uint8Array(e.length + t.length);
  return n.set(e),
    n.set(t, e.length),
    n
}
function Gst(e, t) {
  const n = []
    , r = t.samples
    , o = t.timescale
    , a = t.id;
  let i = !1;
  return Ust(r, ["moof"]).map((s=>{
      const l = s.byteOffset - 8;
      Ust(s, ["traf"]).map((s=>{
          const u = Ust(s, ["tfdt"]).map((e=>{
              const t = e[0];
              let n = Mst(e, 4);
              return 1 === t && (n *= Math.pow(2, 32),
                n += Mst(e, 8)),
              n / o
            }
          ))[0];
          return void 0 !== u && (e = u),
            Ust(s, ["tfhd"]).map((u=>{
                const c = Mst(u, 4)
                  , d = 16777215 & Mst(u, 0);
                let f = 0;
                const p = 0 != (16 & d);
                let h = 0;
                const v = 0 != (32 & d);
                let g = 8;
                c === a && (0 != (1 & d) && (g += 8),
                0 != (2 & d) && (g += 4),
                0 != (8 & d) && (f = Mst(u, g),
                  g += 4),
                p && (h = Mst(u, g),
                  g += 4),
                v && (g += 4),
                "video" === t.type && (i = function(e) {
                  if (!e)
                    return !1;
                  const t = e.indexOf(".")
                    , n = t < 0 ? e : e.substring(0, t);
                  return "hvc1" === n || "hev1" === n || "dvh1" === n || "dvhe" === n
                }(t.codec)),
                  Ust(s, ["trun"]).map((a=>{
                      const s = a[0]
                        , u = 16777215 & Mst(a, 0)
                        , c = 0 != (1 & u);
                      let d = 0;
                      const p = 0 != (4 & u)
                        , v = 0 != (256 & u);
                      let g = 0;
                      const m = 0 != (512 & u);
                      let y = 0;
                      const b = 0 != (1024 & u)
                        , w = 0 != (2048 & u);
                      let x = 0;
                      const S = Mst(a, 4);
                      let E = 8;
                      c && (d = Mst(a, E),
                        E += 4),
                      p && (E += 4);
                      let A = d + l;
                      for (let l = 0; l < S; l++) {
                        if (v ? (g = Mst(a, E),
                          E += 4) : g = f,
                          m ? (y = Mst(a, E),
                            E += 4) : y = h,
                        b && (E += 4),
                        w && (x = 0 === s ? Mst(a, E) : jst(a, E),
                          E += 4),
                        t.type === Qit) {
                          let t = 0;
                          for (; t < y; ) {
                            const a = Mst(r, A);
                            if (A += 4,
                              qst(i, r[A])) {
                              Yst(r.subarray(A, A + a), i ? 2 : 1, e + x / o, n)
                            }
                            A += a,
                              t += a + 4
                          }
                        }
                        e += g / o
                      }
                    }
                  )))
              }
            ))
        }
      ))
    }
  )),
    n
}
function qst(e, t) {
  if (e) {
    const e = t >> 1 & 63;
    return 39 === e || 40 === e
  }
  return 6 === (31 & t)
}
function Yst(e, t, n, r) {
  const o = Xst(e);
  let a = 0;
  a += t;
  let i = 0
    , s = 0
    , l = !1
    , u = 0;
  for (; a < o.length; ) {
    i = 0;
    do {
      if (a >= o.length)
        break;
      u = o[a++],
        i += u
    } while (255 === u);
    s = 0;
    do {
      if (a >= o.length)
        break;
      u = o[a++],
        s += u
    } while (255 === u);
    const e = o.length - a;
    if (!l && 4 === i && a < o.length) {
      l = !0;
      if (181 === o[a++]) {
        const e = Nst(o, a);
        if (a += 2,
        49 === e) {
          const e = Mst(o, a);
          if (a += 4,
          1195456820 === e) {
            const e = o[a++];
            if (3 === e) {
              const t = o[a++]
                , s = 64 & t
                , l = s ? 2 + 3 * (31 & t) : 0
                , u = new Uint8Array(l);
              if (s) {
                u[0] = t;
                for (let e = 1; e < l; e++)
                  u[e] = o[a++]
              }
              r.push({
                type: e,
                payloadType: i,
                pts: n,
                bytes: u
              })
            }
          }
        }
      }
    } else if (5 === i && s < e) {
      if (l = !0,
      s > 16) {
        const e = [];
        for (let n = 0; n < 16; n++) {
          const t = o[a++].toString(16);
          e.push(1 == t.length ? "0" + t : t),
          3 !== n && 5 !== n && 7 !== n && 9 !== n || e.push("-")
        }
        const t = s - 16
          , l = new Uint8Array(t);
        for (let n = 0; n < t; n++)
          l[n] = o[a++];
        r.push({
          payloadType: i,
          pts: n,
          uuid: e.join(""),
          userData: _st(l),
          userDataBytes: l
        })
      }
    } else if (s < e)
      a += s;
    else if (s > e)
      break
  }
}
function Xst(e) {
  const t = e.byteLength
    , n = [];
  let r = 1;
  for (; r < t - 2; )
    0 === e[r] && 0 === e[r + 1] && 3 === e[r + 2] ? (n.push(r + 2),
      r += 2) : r++;
  if (0 === n.length)
    return e;
  const o = t - n.length
    , a = new Uint8Array(o);
  let i = 0;
  for (r = 0; r < o; i++,
    r++)
    i === n[0] && (i++,
      n.shift()),
      a[r] = e[i];
  return a
}
function Qst(e, t, n) {
  if (16 !== e.byteLength)
    throw new RangeError("Invalid system id");
  let r, o, a;
  if (t) {
    r = 1,
      o = new Uint8Array(16 * t.length);
    for (let e = 0; e < t.length; e++) {
      const n = t[e];
      if (16 !== n.byteLength)
        throw new RangeError("Invalid key");
      o.set(n, 16 * e)
    }
  } else
    r = 0,
      o = new Uint8Array;
  r > 0 ? (a = new Uint8Array(4),
  t.length > 0 && new DataView(a.buffer).setUint32(0, t.length, !1)) : a = new Uint8Array;
  const i = new Uint8Array(4);
  return n && n.byteLength > 0 && new DataView(i.buffer).setUint32(0, n.byteLength, !1),
    function(e, ...t) {
      const n = t.length;
      let r = 8
        , o = n;
      for (; o--; )
        r += t[o].byteLength;
      const a = new Uint8Array(r);
      for (a[0] = r >> 24 & 255,
             a[1] = r >> 16 & 255,
             a[2] = r >> 8 & 255,
             a[3] = 255 & r,
             a.set(e, 4),
             o = 0,
             r = 8; o < n; o++)
        a.set(t[o], r),
          r += t[o].byteLength;
      return a
    }([112, 115, 115, 104], new Uint8Array([r, 0, 0, 0]), e, a, o, i, n || new Uint8Array)
}
let Jst = {};
class Zst {
  static clearKeyUriToKeyIdMap() {
    Jst = {}
  }
  constructor(e, t, n, r=[1], o=null) {
    this.uri = void 0,
      this.method = void 0,
      this.keyFormat = void 0,
      this.keyFormatVersions = void 0,
      this.encrypted = void 0,
      this.isCommonEncryption = void 0,
      this.iv = null,
      this.key = null,
      this.keyId = null,
      this.pssh = null,
      this.method = e,
      this.uri = t,
      this.keyFormat = n,
      this.keyFormatVersions = r,
      this.iv = o,
      this.encrypted = !!e && "NONE" !== e,
      this.isCommonEncryption = this.encrypted && "AES-128" !== e
  }
  isSupported() {
    if (this.method) {
      if ("AES-128" === this.method || "NONE" === this.method)
        return !0;
      if ("identity" === this.keyFormat)
        return "SAMPLE-AES" === this.method;
      switch (this.keyFormat) {
        case lst:
        case cst:
        case ust:
        case sst:
          return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method)
      }
    }
    return !1
  }
  getDecryptData(e) {
    if (!this.encrypted || !this.uri)
      return null;
    if ("AES-128" === this.method && this.uri && !this.iv) {
      "number" != typeof e && ("AES-128" !== this.method || this.iv || Hit.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`),
        e = 0);
      const t = function(e) {
        const t = new Uint8Array(16);
        for (let n = 12; n < 16; n++)
          t[n] = e >> 8 * (15 - n) & 255;
        return t
      }(e);
      return new Zst(this.method,this.uri,"identity",this.keyFormatVersions,t)
    }
    const t = ost(this.uri);
    if (t)
      switch (this.keyFormat) {
        case cst:
          this.pssh = t,
          t.length >= 22 && (this.keyId = t.subarray(t.length - 22, t.length - 6));
          break;
        case ust:
        {
          const e = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
          this.pssh = Qst(e, null, t);
          const n = new Uint16Array(t.buffer,t.byteOffset,t.byteLength / 2)
            , r = String.fromCharCode.apply(null, Array.from(n))
            , o = r.substring(r.indexOf("<"), r.length)
            , a = (new DOMParser).parseFromString(o, "text/xml").getElementsByTagName("KID")[0];
          if (a) {
            const e = a.childNodes[0] ? a.childNodes[0].nodeValue : a.getAttribute("VALUE");
            if (e) {
              const t = rst(e).subarray(0, 16);
              !function(e) {
                const t = function(e, t, n) {
                  const r = e[t];
                  e[t] = e[n],
                    e[n] = r
                };
                t(e, 0, 3),
                  t(e, 1, 2),
                  t(e, 4, 5),
                  t(e, 6, 7)
              }(t),
                this.keyId = t
            }
          }
          break
        }
        default:
        {
          let e = t.subarray(0, 16);
          if (16 !== e.length) {
            const t = new Uint8Array(16);
            t.set(e, 16 - e.length),
              e = t
          }
          this.keyId = e;
          break
        }
      }
    if (!this.keyId || 16 !== this.keyId.byteLength) {
      let e = Jst[this.uri];
      if (!e) {
        const t = Object.keys(Jst).length % Number.MAX_SAFE_INTEGER;
        e = new Uint8Array(16);
        new DataView(e.buffer,12,4).setUint32(0, t),
          Jst[this.uri] = e
      }
      this.keyId = e
    }
    return this
  }
}
const elt = /\{\$([a-zA-Z0-9-_]+)\}/g;
function tlt(e) {
  return elt.test(e)
}
function nlt(e, t, n) {
  if (null !== e.variableList || e.hasVariableRefs)
    for (let r = n.length; r--; ) {
      const o = n[r]
        , a = t[o];
      a && (t[o] = rlt(e, a))
    }
}
function rlt(e, t) {
  if (null !== e.variableList || e.hasVariableRefs) {
    const n = e.variableList;
    return t.replace(elt, (t=>{
        const r = t.substring(2, t.length - 1)
          , o = null == n ? void 0 : n[r];
        return void 0 === o ? (e.playlistParsingError || (e.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${r}"`)),
          t) : o
      }
    ))
  }
  return t
}
function olt(e, t, n) {
  let r, o, a = e.variableList;
  if (a || (e.variableList = a = {}),
  "QUERYPARAM"in t) {
    r = t.QUERYPARAM;
    try {
      const e = new self.URL(n).searchParams;
      if (!e.has(r))
        throw new Error(`"${r}" does not match any query parameter in URI: "${n}"`);
      o = e.get(r)
    } catch (i) {
      e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${i.message}`))
    }
  } else
    r = t.NAME,
      o = t.VALUE;
  r in a ? e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${r}"`)) : a[r] = o || ""
}
function alt(e, t, n) {
  const r = t.IMPORT;
  if (n && r in n) {
    let t = e.variableList;
    t || (e.variableList = t = {}),
      t[r] = n[r]
  } else
    e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`))
}
function ilt() {
  if ("undefined" != typeof self)
    return self.MediaSource || self.WebKitMediaSource
}
const slt = {
  audio: {
    a3ds: !0,
    "ac-3": !0,
    "ac-4": !0,
    alac: !0,
    alaw: !0,
    dra1: !0,
    "dts+": !0,
    "dts-": !0,
    dtsc: !0,
    dtse: !0,
    dtsh: !0,
    "ec-3": !0,
    enca: !0,
    g719: !0,
    g726: !0,
    m4ae: !0,
    mha1: !0,
    mha2: !0,
    mhm1: !0,
    mhm2: !0,
    mlpa: !0,
    mp4a: !0,
    "raw ": !0,
    Opus: !0,
    opus: !0,
    samr: !0,
    sawb: !0,
    sawp: !0,
    sevc: !0,
    sqcp: !0,
    ssmv: !0,
    twos: !0,
    ulaw: !0
  },
  video: {
    avc1: !0,
    avc2: !0,
    avc3: !0,
    avc4: !0,
    avcp: !0,
    av01: !0,
    drac: !0,
    dva1: !0,
    dvav: !0,
    dvh1: !0,
    dvhe: !0,
    encv: !0,
    hev1: !0,
    hvc1: !0,
    mjp2: !0,
    mp4v: !0,
    mvc1: !0,
    mvc2: !0,
    mvc3: !0,
    mvc4: !0,
    resv: !0,
    rv60: !0,
    s263: !0,
    svc1: !0,
    svc2: !0,
    "vc-1": !0,
    vp08: !0,
    vp09: !0
  },
  text: {
    stpp: !0,
    wvtt: !0
  }
}
  , llt = ilt();
function ult(e, t) {
  var n;
  return null != (n = null == llt ? void 0 : llt.isTypeSupported(`${t || "video"}/mp4;codecs="${e}"`)) && n
}
const clt = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g
  , dlt = /#EXT-X-MEDIA:(.*)/g
  , flt = /^#EXT(?:INF|-X-TARGETDURATION):/m
  , plt = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"),"g")
  , hlt = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
class vlt {
  static findGroup(e, t) {
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      if (r.id === t)
        return r
    }
  }
  static convertAVC1ToAVCOTI(e) {
    const t = e.split(".");
    if (t.length > 2) {
      let e = t.shift() + ".";
      return e += parseInt(t.shift()).toString(16),
        e += ("000" + parseInt(t.shift()).toString(16)).slice(-4),
        e
    }
    return e
  }
  static resolve(e, t) {
    return _it.buildAbsoluteURL(t, e, {
      alwaysNormalize: !0
    })
  }
  static isMediaPlaylist(e) {
    return flt.test(e)
  }
  static parseMasterPlaylist(e, t) {
    const n = {
      contentSteering: null,
      levels: [],
      playlistParsingError: null,
      sessionData: null,
      sessionKeys: null,
      startTimeOffset: null,
      variableList: null,
      hasVariableRefs: tlt(e)
    }
      , r = [];
    let o;
    for (clt.lastIndex = 0; null != (o = clt.exec(e)); )
      if (o[1]) {
        var a;
        const e = new Wit(o[1]);
        nlt(n, e, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
        const i = rlt(n, o[2])
          , s = {
          attrs: e,
          bitrate: e.decimalInteger("AVERAGE-BANDWIDTH") || e.decimalInteger("BANDWIDTH"),
          name: e.NAME,
          url: vlt.resolve(i, t)
        }
          , l = e.decimalResolution("RESOLUTION");
        l && (s.width = l.width,
          s.height = l.height),
          ylt((e.CODECS || "").split(/[ ,]+/).filter((e=>e)), s),
        s.videoCodec && -1 !== s.videoCodec.indexOf("avc1") && (s.videoCodec = vlt.convertAVC1ToAVCOTI(s.videoCodec)),
        null != (a = s.unknownCodecs) && a.length || r.push(s),
          n.levels.push(s)
      } else if (o[3]) {
        const e = o[3]
          , r = o[4];
        switch (e) {
          case "SESSION-DATA":
          {
            const e = new Wit(r);
            nlt(n, e, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
            const t = e["DATA-ID"];
            t && (null === n.sessionData && (n.sessionData = {}),
              n.sessionData[t] = e);
            break
          }
          case "SESSION-KEY":
          {
            const e = glt(r, t, n);
            e.encrypted && e.isSupported() ? (null === n.sessionKeys && (n.sessionKeys = []),
              n.sessionKeys.push(e)) : Hit.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${r}"`);
            break
          }
          case "DEFINE":
          {
            const e = new Wit(r);
            nlt(n, e, ["NAME", "VALUE", "QUERYPARAM"]),
              olt(n, e, t)
          }
            break;
          case "CONTENT-STEERING":
          {
            const e = new Wit(r);
            nlt(n, e, ["SERVER-URI", "PATHWAY-ID"]),
              n.contentSteering = {
                uri: vlt.resolve(e["SERVER-URI"], t),
                pathwayId: e["PATHWAY-ID"] || "."
              };
            break
          }
          case "START":
            n.startTimeOffset = mlt(r)
        }
      }
    const i = r.length > 0 && r.length < n.levels.length;
    return n.levels = i ? r : n.levels,
    0 === n.levels.length && (n.playlistParsingError = new Error("no levels found in manifest")),
      n
  }
  static parseMasterPlaylistMedia(e, t, n) {
    let r;
    const o = {}
      , a = n.levels
      , i = {
      AUDIO: a.map((e=>({
        id: e.attrs.AUDIO,
        audioCodec: e.audioCodec
      }))),
      SUBTITLES: a.map((e=>({
        id: e.attrs.SUBTITLES,
        textCodec: e.textCodec
      }))),
      "CLOSED-CAPTIONS": []
    };
    let s = 0;
    for (dlt.lastIndex = 0; null !== (r = dlt.exec(e)); ) {
      const e = new Wit(r[1])
        , a = e.TYPE;
      if (a) {
        const r = i[a]
          , l = o[a] || [];
        o[a] = l,
          nlt(n, e, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
        const u = {
          attrs: e,
          bitrate: 0,
          id: s++,
          groupId: e["GROUP-ID"] || "",
          instreamId: e["INSTREAM-ID"],
          name: e.NAME || e.LANGUAGE || "",
          type: a,
          default: e.bool("DEFAULT"),
          autoselect: e.bool("AUTOSELECT"),
          forced: e.bool("FORCED"),
          lang: e.LANGUAGE,
          url: e.URI ? vlt.resolve(e.URI, t) : ""
        };
        if (null != r && r.length) {
          const e = vlt.findGroup(r, u.groupId) || r[0];
          blt(u, e, "audioCodec"),
            blt(u, e, "textCodec")
        }
        l.push(u)
      }
    }
    return o
  }
  static parseLevelPlaylist(e, t, n, r, o, a) {
    const i = new nst(t)
      , s = i.fragments;
    let l, u, c, d = null, f = 0, p = 0, h = 0, v = 0, g = null, m = new est(r,t), y = -1, b = !1;
    for (plt.lastIndex = 0,
           i.m3u8 = e,
           i.hasVariableRefs = tlt(e); null !== (l = plt.exec(e)); ) {
      b && (b = !1,
        m = new est(r,t),
        m.start = h,
        m.sn = f,
        m.cc = v,
        m.level = n,
      d && (m.initSegment = d,
        m.rawProgramDateTime = d.rawProgramDateTime,
        d.rawProgramDateTime = null));
      const e = l[1];
      if (e) {
        m.duration = parseFloat(e);
        const t = (" " + l[2]).slice(1);
        m.title = t || null,
          m.tagList.push(t ? ["INF", e, t] : ["INF", e])
      } else if (l[3]) {
        if (Fit(m.duration)) {
          m.start = h,
          c && Slt(m, c, i),
            m.sn = f,
            m.level = n,
            m.cc = v,
            m.urlId = o,
            s.push(m);
          const e = (" " + l[3]).slice(1);
          m.relurl = rlt(i, e),
            wlt(m, g),
            g = m,
            h += m.duration,
            f++,
            p = 0,
            b = !0
        }
      } else if (l[4]) {
        const e = (" " + l[4]).slice(1);
        g ? m.setByteRange(e, g) : m.setByteRange(e)
      } else if (l[5])
        m.rawProgramDateTime = (" " + l[5]).slice(1),
          m.tagList.push(["PROGRAM-DATE-TIME", m.rawProgramDateTime]),
        -1 === y && (y = s.length);
      else {
        if (l = l[0].match(hlt),
          !l) {
          Hit.warn("No matches on slow regex match for level playlist!");
          continue
        }
        for (u = 1; u < l.length && void 0 === l[u]; u++)
          ;
        const e = (" " + l[u]).slice(1)
          , o = (" " + l[u + 1]).slice(1)
          , h = l[u + 2] ? (" " + l[u + 2]).slice(1) : "";
        switch (e) {
          case "PLAYLIST-TYPE":
            i.type = o.toUpperCase();
            break;
          case "MEDIA-SEQUENCE":
            f = i.startSN = parseInt(o);
            break;
          case "SKIP":
          {
            const e = new Wit(o);
            nlt(i, e, ["RECENTLY-REMOVED-DATERANGES"]);
            const t = e.decimalInteger("SKIPPED-SEGMENTS");
            if (Fit(t)) {
              i.skippedSegments = t;
              for (let e = t; e--; )
                s.unshift(null);
              f += t
            }
            const n = e.enumeratedString("RECENTLY-REMOVED-DATERANGES");
            n && (i.recentlyRemovedDateranges = n.split("\t"));
            break
          }
          case "TARGETDURATION":
            i.targetduration = Math.max(parseInt(o), 1);
            break;
          case "VERSION":
            i.version = parseInt(o);
            break;
          case "EXTM3U":
            break;
          case "ENDLIST":
            i.live = !1;
            break;
          case "#":
            (o || h) && m.tagList.push(h ? [o, h] : [o]);
            break;
          case "DISCONTINUITY":
            v++,
              m.tagList.push(["DIS"]);
            break;
          case "GAP":
            m.gap = !0,
              m.tagList.push([e]);
            break;
          case "BITRATE":
            m.tagList.push([e, o]);
            break;
          case "DATERANGE":
          {
            const e = new Wit(o);
            nlt(i, e, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]),
              nlt(i, e, e.clientAttrs);
            const t = new qit(e,i.dateRanges[e.ID]);
            t.isValid || i.skippedSegments ? i.dateRanges[t.id] = t : Hit.warn(`Ignoring invalid DATERANGE tag: "${o}"`),
              m.tagList.push(["EXT-X-DATERANGE", o]);
            break
          }
          case "DEFINE":
          {
            const e = new Wit(o);
            nlt(i, e, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]),
              "IMPORT"in e ? alt(i, e, a) : olt(i, e, t)
          }
            break;
          case "DISCONTINUITY-SEQUENCE":
            v = parseInt(o);
            break;
          case "KEY":
          {
            const e = glt(o, t, i);
            if (e.isSupported()) {
              if ("NONE" === e.method) {
                c = void 0;
                break
              }
              c || (c = {}),
              c[e.keyFormat] && (c = Pit({}, c)),
                c[e.keyFormat] = e
            } else
              Hit.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${o}"`);
            break
          }
          case "START":
            i.startTimeOffset = mlt(o);
            break;
          case "MAP":
          {
            const e = new Wit(o);
            if (nlt(i, e, ["BYTERANGE", "URI"]),
              m.duration) {
              const o = new est(r,t);
              xlt(o, e, n, c),
                d = o,
                m.initSegment = d,
              d.rawProgramDateTime && !m.rawProgramDateTime && (m.rawProgramDateTime = d.rawProgramDateTime)
            } else
              xlt(m, e, n, c),
                d = m,
                b = !0;
            break
          }
          case "SERVER-CONTROL":
          {
            const e = new Wit(o);
            i.canBlockReload = e.bool("CAN-BLOCK-RELOAD"),
              i.canSkipUntil = e.optionalFloat("CAN-SKIP-UNTIL", 0),
              i.canSkipDateRanges = i.canSkipUntil > 0 && e.bool("CAN-SKIP-DATERANGES"),
              i.partHoldBack = e.optionalFloat("PART-HOLD-BACK", 0),
              i.holdBack = e.optionalFloat("HOLD-BACK", 0);
            break
          }
          case "PART-INF":
          {
            const e = new Wit(o);
            i.partTarget = e.decimalFloatingPoint("PART-TARGET");
            break
          }
          case "PART":
          {
            let e = i.partList;
            e || (e = i.partList = []);
            const n = p > 0 ? e[e.length - 1] : void 0
              , r = p++
              , a = new Wit(o);
            nlt(i, a, ["BYTERANGE", "URI"]);
            const s = new tst(a,m,t,r,n);
            e.push(s),
              m.duration += s.duration;
            break
          }
          case "PRELOAD-HINT":
          {
            const e = new Wit(o);
            nlt(i, e, ["URI"]),
              i.preloadHint = e;
            break
          }
          case "RENDITION-REPORT":
          {
            const e = new Wit(o);
            nlt(i, e, ["URI"]),
              i.renditionReports = i.renditionReports || [],
              i.renditionReports.push(e);
            break
          }
          default:
            Hit.warn(`line parsed but not handled: ${l}`)
        }
      }
    }
    g && !g.relurl ? (s.pop(),
      h -= g.duration,
    i.partList && (i.fragmentHint = g)) : i.partList && (wlt(m, g),
      m.cc = v,
      i.fragmentHint = m,
    c && Slt(m, c, i));
    const w = s.length
      , x = s[0]
      , S = s[w - 1];
    if (h += i.skippedSegments * i.targetduration,
    h > 0 && w && S) {
      i.averagetargetduration = h / w;
      const e = S.sn;
      i.endSN = "initSegment" !== e ? e : 0,
      i.live || (S.endList = !0),
      x && (i.startCC = x.cc)
    } else
      i.endSN = 0,
        i.startCC = 0;
    return i.fragmentHint && (h += i.fragmentHint.duration),
      i.totalduration = h,
      i.endCC = v,
    y > 0 && function(e, t) {
      let n = e[t];
      for (let r = t; r--; ) {
        const t = e[r];
        if (!t)
          return;
        t.programDateTime = n.programDateTime - 1e3 * t.duration,
          n = t
      }
    }(s, y),
      i
  }
}
function glt(e, t, n) {
  var r, o;
  const a = new Wit(e);
  nlt(n, a, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
  const i = null != (r = a.METHOD) ? r : ""
    , s = a.URI
    , l = a.hexadecimalInteger("IV")
    , u = a.KEYFORMATVERSIONS
    , c = null != (o = a.KEYFORMAT) ? o : "identity";
  s && a.IV && !l && Hit.error(`Invalid IV: ${a.IV}`);
  const d = s ? vlt.resolve(s, t) : ""
    , f = (u || "1").split("/").map(Number).filter(Number.isFinite);
  return new Zst(i,d,c,f,l)
}
function mlt(e) {
  const t = new Wit(e).decimalFloatingPoint("TIME-OFFSET");
  return Fit(t) ? t : null
}
function ylt(e, t) {
  ["video", "audio", "text"].forEach((n=>{
      const r = e.filter((e=>function(e, t) {
        const n = slt[t];
        return !!n && !0 === n[e.slice(0, 4)]
      }(e, n)));
      if (r.length) {
        const o = r.filter((e=>0 === e.lastIndexOf("avc1", 0) || 0 === e.lastIndexOf("mp4a", 0)));
        t[`${n}Codec`] = o.length > 0 ? o[0] : r[0],
          e = e.filter((e=>-1 === r.indexOf(e)))
      }
    }
  )),
    t.unknownCodecs = e
}
function blt(e, t, n) {
  const r = t[n];
  r && (e[n] = r)
}
function wlt(e, t) {
  e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime),
  Fit(e.programDateTime) || (e.programDateTime = null,
    e.rawProgramDateTime = null)
}
function xlt(e, t, n, r) {
  e.relurl = t.URI,
  t.BYTERANGE && e.setByteRange(t.BYTERANGE),
    e.level = n,
    e.sn = "initSegment",
  r && (e.levelkeys = r),
    e.initSegment = null
}
function Slt(e, t, n) {
  e.levelkeys = t;
  const {encryptedFragments: r} = n;
  r.length && r[r.length - 1].levelkeys === t || !Object.keys(t).some((e=>t[e].isCommonEncryption)) || r.push(e)
}
var Elt = "manifest"
  , Alt = "level"
  , Clt = "audioTrack"
  , klt = "subtitleTrack"
  , Tlt = "main"
  , Dlt = "audio"
  , Olt = "subtitle";
function _lt(e) {
  const {type: t} = e;
  switch (t) {
    case Clt:
      return Dlt;
    case klt:
      return Olt;
    default:
      return Tlt
  }
}
function Rlt(e, t) {
  let n = e.url;
  return void 0 !== n && 0 !== n.indexOf("data:") || (n = t.url),
    n
}
class Llt {
  constructor(e) {
    this.hls = void 0,
      this.loaders = Object.create(null),
      this.variableList = null,
      this.hls = e,
      this.registerListeners()
  }
  startLoad(e) {}
  stopLoad() {
    this.destroyInternalLoaders()
  }
  registerListeners() {
    const {hls: e} = this;
    e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(Bit.LEVEL_LOADING, this.onLevelLoading, this),
      e.on(Bit.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
      e.on(Bit.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
  }
  unregisterListeners() {
    const {hls: e} = this;
    e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(Bit.LEVEL_LOADING, this.onLevelLoading, this),
      e.off(Bit.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
      e.off(Bit.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
  }
  createInternalLoader(e) {
    const t = this.hls.config
      , n = t.pLoader
      , r = t.loader
      , o = new (n || r)(t);
    return this.loaders[e.type] = o,
      o
  }
  getInternalLoader(e) {
    return this.loaders[e.type]
  }
  resetInternalLoader(e) {
    this.loaders[e] && delete this.loaders[e]
  }
  destroyInternalLoaders() {
    for (const e in this.loaders) {
      const t = this.loaders[e];
      t && t.destroy(),
        this.resetInternalLoader(e)
    }
  }
  destroy() {
    this.variableList = null,
      this.unregisterListeners(),
      this.destroyInternalLoaders()
  }
  onManifestLoading(e, t) {
    const {url: n} = t;
    this.variableList = null,
      this.load({
        id: null,
        level: 0,
        responseType: "text",
        type: Elt,
        url: n,
        deliveryDirectives: null
      })
  }
  onLevelLoading(e, t) {
    const {id: n, level: r, url: o, deliveryDirectives: a} = t;
    this.load({
      id: n,
      level: r,
      responseType: "text",
      type: Alt,
      url: o,
      deliveryDirectives: a
    })
  }
  onAudioTrackLoading(e, t) {
    const {id: n, groupId: r, url: o, deliveryDirectives: a} = t;
    this.load({
      id: n,
      groupId: r,
      level: null,
      responseType: "text",
      type: Clt,
      url: o,
      deliveryDirectives: a
    })
  }
  onSubtitleTrackLoading(e, t) {
    const {id: n, groupId: r, url: o, deliveryDirectives: a} = t;
    this.load({
      id: n,
      groupId: r,
      level: null,
      responseType: "text",
      type: klt,
      url: o,
      deliveryDirectives: a
    })
  }
  load(e) {
    var t;
    const n = this.hls.config;
    let r, o = this.getInternalLoader(e);
    if (o) {
      const t = o.context;
      if (t && t.url === e.url)
        return void Hit.trace("[playlist-loader]: playlist request ongoing");
      Hit.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`),
        o.abort()
    }
    if (r = e.type === Elt ? n.manifestLoadPolicy.default : Pit({}, n.playlistLoadPolicy.default, {
      timeoutRetry: null,
      errorRetry: null
    }),
      o = this.createInternalLoader(e),
    null != (t = e.deliveryDirectives) && t.part) {
      let t;
      if (e.type === Alt && null !== e.level ? t = this.hls.levels[e.level].details : e.type === Clt && null !== e.id ? t = this.hls.audioTracks[e.id].details : e.type === klt && null !== e.id && (t = this.hls.subtitleTracks[e.id].details),
        t) {
        const e = t.partTarget
          , n = t.targetduration;
        if (e && n) {
          const t = 1e3 * Math.max(3 * e, .8 * n);
          r = Pit({}, r, {
            maxTimeToFirstByteMs: Math.min(t, r.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(t, r.maxTimeToFirstByteMs)
          })
        }
      }
    }
    const a = r.errorRetry || r.timeoutRetry || {}
      , i = {
      loadPolicy: r,
      timeout: r.maxLoadTimeMs,
      maxRetry: a.maxNumRetry || 0,
      retryDelay: a.retryDelayMs || 0,
      maxRetryDelay: a.maxRetryDelayMs || 0
    }
      , s = {
      onSuccess: (e,t,n,r)=>{
        const o = this.getInternalLoader(n);
        this.resetInternalLoader(n.type);
        const a = e.data;
        0 === a.indexOf("#EXTM3U") ? (t.parsing.start = performance.now(),
          vlt.isMediaPlaylist(a) ? this.handleTrackOrLevelPlaylist(e, t, n, r || null, o) : this.handleMasterPlaylist(e, t, n, r)) : this.handleManifestParsingError(e, n, new Error("no EXTM3U delimiter"), r || null, t)
      }
      ,
      onError: (e,t,n,r)=>{
        this.handleNetworkError(t, n, !1, e, r)
      }
      ,
      onTimeout: (e,t,n)=>{
        this.handleNetworkError(t, n, !0, void 0, e)
      }
    };
    o.load(e, i, s)
  }
  handleMasterPlaylist(e, t, n, r) {
    const o = this.hls
      , a = e.data
      , i = Rlt(e, n)
      , s = vlt.parseMasterPlaylist(a, i);
    if (s.playlistParsingError)
      return void this.handleManifestParsingError(e, n, s.playlistParsingError, r, t);
    const {contentSteering: l, levels: u, sessionData: c, sessionKeys: d, startTimeOffset: f, variableList: p} = s;
    this.variableList = p;
    const {AUDIO: h=[], SUBTITLES: v, "CLOSED-CAPTIONS": g} = vlt.parseMasterPlaylistMedia(a, i, s);
    if (h.length) {
      h.some((e=>!e.url)) || !u[0].audioCodec || u[0].attrs.AUDIO || (Hit.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"),
        h.unshift({
          type: "main",
          name: "main",
          groupId: "main",
          default: !1,
          autoselect: !1,
          forced: !1,
          id: -1,
          attrs: new Wit({}),
          bitrate: 0,
          url: ""
        }))
    }
    o.trigger(Bit.MANIFEST_LOADED, {
      levels: u,
      audioTracks: h,
      subtitles: v,
      captions: g,
      contentSteering: l,
      url: i,
      stats: t,
      networkDetails: r,
      sessionData: c,
      sessionKeys: d,
      startTimeOffset: f,
      variableList: p
    })
  }
  handleTrackOrLevelPlaylist(e, t, n, r, o) {
    const a = this.hls
      , {id: i, level: s, type: l} = n
      , u = Rlt(e, n)
      , c = Fit(i) ? i : 0
      , d = Fit(s) ? s : c
      , f = _lt(n)
      , p = vlt.parseLevelPlaylist(e.data, u, d, f, c, this.variableList);
    if (l === Elt) {
      const e = {
        attrs: new Wit({}),
        bitrate: 0,
        details: p,
        name: "",
        url: u
      };
      a.trigger(Bit.MANIFEST_LOADED, {
        levels: [e],
        audioTracks: [],
        url: u,
        stats: t,
        networkDetails: r,
        sessionData: null,
        sessionKeys: null,
        contentSteering: null,
        startTimeOffset: null,
        variableList: null
      })
    }
    t.parsing.end = performance.now(),
      n.levelDetails = p,
      this.handlePlaylistLoaded(p, e, t, n, r, o)
  }
  handleManifestParsingError(e, t, n, r, o) {
    this.hls.trigger(Bit.ERROR, {
      type: Nit.NETWORK_ERROR,
      details: Mit.MANIFEST_PARSING_ERROR,
      fatal: t.type === Elt,
      url: e.url,
      err: n,
      error: n,
      reason: n.message,
      response: e,
      context: t,
      networkDetails: r,
      stats: o
    })
  }
  handleNetworkError(e, t, n=!1, r, o) {
    let a = `A network ${n ? "timeout" : "error" + (r ? " (status " + r.code + ")" : "")} occurred while loading ${e.type}`;
    e.type === Alt ? a += `: ${e.level} id: ${e.id}` : e.type !== Clt && e.type !== klt || (a += ` id: ${e.id} group-id: "${e.groupId}"`);
    const i = new Error(a);
    Hit.warn(`[playlist-loader]: ${a}`);
    let s = Mit.UNKNOWN
      , l = !1;
    const u = this.getInternalLoader(e);
    switch (e.type) {
      case Elt:
        s = n ? Mit.MANIFEST_LOAD_TIMEOUT : Mit.MANIFEST_LOAD_ERROR,
          l = !0;
        break;
      case Alt:
        s = n ? Mit.LEVEL_LOAD_TIMEOUT : Mit.LEVEL_LOAD_ERROR,
          l = !1;
        break;
      case Clt:
        s = n ? Mit.AUDIO_TRACK_LOAD_TIMEOUT : Mit.AUDIO_TRACK_LOAD_ERROR,
          l = !1;
        break;
      case klt:
        s = n ? Mit.SUBTITLE_TRACK_LOAD_TIMEOUT : Mit.SUBTITLE_LOAD_ERROR,
          l = !1
    }
    u && this.resetInternalLoader(e.type);
    const c = {
      type: Nit.NETWORK_ERROR,
      details: s,
      fatal: l,
      url: e.url,
      loader: u,
      context: e,
      error: i,
      networkDetails: t,
      stats: o
    };
    if (r) {
      const n = (null == t ? void 0 : t.url) || e.url;
      c.response = Lit({
        url: n,
        data: void 0
      }, r)
    }
    this.hls.trigger(Bit.ERROR, c)
  }
  handlePlaylistLoaded(e, t, n, r, o, a) {
    const i = this.hls
      , {type: s, level: l, id: u, groupId: c, deliveryDirectives: d} = r
      , f = Rlt(t, r)
      , p = _lt(r)
      , h = "number" == typeof r.level && p === Tlt ? l : void 0;
    if (!e.fragments.length) {
      const e = new Error("No Segments found in Playlist");
      return void i.trigger(Bit.ERROR, {
        type: Nit.NETWORK_ERROR,
        details: Mit.LEVEL_EMPTY_ERROR,
        fatal: !1,
        url: f,
        error: e,
        reason: e.message,
        response: t,
        context: r,
        level: h,
        parent: p,
        networkDetails: o,
        stats: n
      })
    }
    e.targetduration || (e.playlistParsingError = new Error("Missing Target Duration"));
    const v = e.playlistParsingError;
    if (v)
      i.trigger(Bit.ERROR, {
        type: Nit.NETWORK_ERROR,
        details: Mit.LEVEL_PARSING_ERROR,
        fatal: !1,
        url: f,
        error: v,
        reason: v.message,
        response: t,
        context: r,
        level: h,
        parent: p,
        networkDetails: o,
        stats: n
      });
    else
      switch (e.live && a && (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0),
      a.getCacheAge && !isNaN(e.ageHeader) || (e.ageHeader = 0)),
        s) {
        case Elt:
        case Alt:
          i.trigger(Bit.LEVEL_LOADED, {
            details: e,
            level: h || 0,
            id: u || 0,
            stats: n,
            networkDetails: o,
            deliveryDirectives: d
          });
          break;
        case Clt:
          i.trigger(Bit.AUDIO_TRACK_LOADED, {
            details: e,
            id: u || 0,
            groupId: c || "",
            stats: n,
            networkDetails: o,
            deliveryDirectives: d
          });
          break;
        case klt:
          i.trigger(Bit.SUBTITLE_TRACK_LOADED, {
            details: e,
            id: u || 0,
            groupId: c || "",
            stats: n,
            networkDetails: o,
            deliveryDirectives: d
          })
      }
  }
}
function Ilt(e, t) {
  let n;
  try {
    n = new Event("addtrack")
  } catch (r) {
    n = document.createEvent("Event"),
      n.initEvent("addtrack", !1, !1)
  }
  n.track = e,
    t.dispatchEvent(n)
}
function Plt(e, t) {
  const n = e.mode;
  if ("disabled" === n && (e.mode = "hidden"),
  e.cues && !e.cues.getCueById(t.id))
    try {
      if (e.addCue(t),
        !e.cues.getCueById(t.id))
        throw new Error(`addCue is failed for: ${t}`)
    } catch (r) {
      Hit.debug(`[texttrack-utils]: ${r}`);
      try {
        const n = new self.TextTrackCue(t.startTime,t.endTime,t.text);
        n.id = t.id,
          e.addCue(n)
      } catch (o) {
        Hit.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${o}`)
      }
    }
  "disabled" === n && (e.mode = n)
}
function Flt(e) {
  const t = e.mode;
  if ("disabled" === t && (e.mode = "hidden"),
    e.cues)
    for (let n = e.cues.length; n--; )
      e.removeCue(e.cues[n]);
  "disabled" === t && (e.mode = t)
}
function Blt(e, t, n, r) {
  const o = e.mode;
  if ("disabled" === o && (e.mode = "hidden"),
  e.cues && e.cues.length > 0) {
    const o = function(e, t, n) {
      const r = []
        , o = function(e, t) {
        if (t < e[0].startTime)
          return 0;
        const n = e.length - 1;
        if (t > e[n].endTime)
          return -1;
        let r = 0
          , o = n;
        for (; r <= o; ) {
          const a = Math.floor((o + r) / 2);
          if (t < e[a].startTime)
            o = a - 1;
          else {
            if (!(t > e[a].startTime && r < n))
              return a;
            r = a + 1
          }
        }
        return e[r].startTime - t < t - e[o].startTime ? r : o
      }(e, t);
      if (o > -1)
        for (let a = o, i = e.length; a < i; a++) {
          const o = e[a];
          if (o.startTime >= t && o.endTime <= n)
            r.push(o);
          else if (o.startTime > n)
            return r
        }
      return r
    }(e.cues, t, n);
    for (let t = 0; t < o.length; t++)
      r && !r(o[t]) || e.removeCue(o[t])
  }
  "disabled" === o && (e.mode = o)
}
var Nlt = "org.id3"
  , Mlt = "com.apple.quicktime.HLS"
  , jlt = "https://aomedia.org/emsg/ID3";
function Vlt() {
  if ("undefined" != typeof self)
    return self.WebKitDataCue || self.VTTCue || self.TextTrackCue
}
const Ult = (()=>{
    const e = Vlt();
    try {
      new e(0,Number.POSITIVE_INFINITY,"")
    } catch (Y_) {
      return Number.MAX_VALUE
    }
    return Number.POSITIVE_INFINITY
  }
)();
function $lt(e, t) {
  return e.getTime() / 1e3 - t
}
class Hlt {
  constructor(e) {
    this.hls = void 0,
      this.id3Track = null,
      this.media = null,
      this.dateRangeCuesAppended = {},
      this.hls = e,
      this._registerListeners()
  }
  destroy() {
    this._unregisterListeners(),
      this.id3Track = null,
      this.media = null,
      this.dateRangeCuesAppended = {},
      this.hls = null
  }
  _registerListeners() {
    const {hls: e} = this;
    e.on(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(Bit.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
      e.on(Bit.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.on(Bit.LEVEL_UPDATED, this.onLevelUpdated, this)
  }
  _unregisterListeners() {
    const {hls: e} = this;
    e.off(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(Bit.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
      e.off(Bit.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.off(Bit.LEVEL_UPDATED, this.onLevelUpdated, this)
  }
  onMediaAttached(e, t) {
    this.media = t.media
  }
  onMediaDetaching() {
    this.id3Track && (Flt(this.id3Track),
      this.id3Track = null,
      this.media = null,
      this.dateRangeCuesAppended = {})
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {}
  }
  createTrack(e) {
    const t = this.getID3Track(e.textTracks);
    return t.mode = "hidden",
      t
  }
  getID3Track(e) {
    if (this.media) {
      for (let t = 0; t < e.length; t++) {
        const n = e[t];
        if ("metadata" === n.kind && "id3" === n.label)
          return Ilt(n, this.media),
            n
      }
      return this.media.addTextTrack("metadata", "id3")
    }
  }
  onFragParsingMetadata(e, t) {
    if (!this.media)
      return;
    const {hls: {config: {enableEmsgMetadataCues: n, enableID3MetadataCues: r}}} = this;
    if (!n && !r)
      return;
    const {samples: o} = t;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const a = Vlt();
    for (let i = 0; i < o.length; i++) {
      const e = o[i].type;
      if (e === jlt && !n || !r)
        continue;
      const t = Ast(o[i].data);
      if (t) {
        const n = o[i].pts;
        let r = n + o[i].duration;
        r > Ult && (r = Ult);
        r - n <= 0 && (r = n + .25);
        for (let o = 0; o < t.length; o++) {
          const i = t[o];
          if (!Sst(i)) {
            this.updateId3CueEnds(n, e);
            const t = new a(n,r,"");
            t.value = i,
            e && (t.type = e),
              this.id3Track.addCue(t)
          }
        }
      }
    }
  }
  updateId3CueEnds(e, t) {
    var n;
    const r = null == (n = this.id3Track) ? void 0 : n.cues;
    if (r)
      for (let o = r.length; o--; ) {
        const n = r[o];
        n.type === t && n.startTime < e && n.endTime === Ult && (n.endTime = e)
      }
  }
  onBufferFlushing(e, {startOffset: t, endOffset: n, type: r}) {
    const {id3Track: o, hls: a} = this;
    if (!a)
      return;
    const {config: {enableEmsgMetadataCues: i, enableID3MetadataCues: s}} = a;
    if (o && (i || s)) {
      let e;
      e = "audio" === r ? e=>e.type === Nlt && s : "video" === r ? e=>e.type === jlt && i : e=>e.type === Nlt && s || e.type === jlt && i,
        Blt(o, t, n, e)
    }
  }
  onLevelUpdated(e, {details: t}) {
    if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues)
      return;
    const {dateRangeCuesAppended: n, id3Track: r} = this
      , {dateRanges: o} = t
      , a = Object.keys(o);
    if (r) {
      const e = Object.keys(n).filter((e=>!a.includes(e)));
      for (let t = e.length; t--; ) {
        const o = e[t];
        Object.keys(n[o].cues).forEach((e=>{
            r.removeCue(n[o].cues[e])
          }
        )),
          delete n[o]
      }
    }
    const i = t.fragments[t.fragments.length - 1];
    if (0 === a.length || !Fit(null == i ? void 0 : i.programDateTime))
      return;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const s = i.programDateTime / 1e3 - i.start
      , l = Vlt();
    for (let d = 0; d < a.length; d++) {
      const e = a[d]
        , t = o[e]
        , r = n[e]
        , i = (null == r ? void 0 : r.cues) || {};
      let f = (null == r ? void 0 : r.durationKnown) || !1;
      const p = $lt(t.startDate, s);
      let h = Ult;
      const v = t.endDate;
      if (v)
        h = $lt(v, s),
          f = !0;
      else if (t.endOnNext && !f) {
        const e = a.reduce(((e,n)=>{
            const r = o[n];
            return r.class === t.class && r.id !== n && r.startDate > t.startDate && e.push(r),
              e
          }
        ), []).sort(((e,t)=>e.startDate.getTime() - t.startDate.getTime()))[0];
        e && (h = $lt(e.startDate, s),
          f = !0)
      }
      const g = Object.keys(t.attr);
      for (let n = 0; n < g.length; n++) {
        const o = g[n];
        if ("ID" === (c = o) || "CLASS" === c || "START-DATE" === c || "DURATION" === c || "END-DATE" === c || "END-ON-NEXT" === c)
          continue;
        let a = i[o];
        if (a)
          f && !r.durationKnown && (a.endTime = h);
        else {
          let n = t.attr[o];
          a = new l(p,h,""),
          Git(o) && (u = n,
            n = Uint8Array.from(u.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer),
            a.value = {
              key: o,
              data: n
            },
            a.type = Mlt,
            a.id = e,
            this.id3Track.addCue(a),
            i[o] = a
        }
      }
      n[e] = {
        cues: i,
        dateRange: t,
        durationKnown: f
      }
    }
    var u, c
  }
}
class zlt {
  constructor(e) {
    this.hls = void 0,
      this.config = void 0,
      this.media = null,
      this.levelDetails = null,
      this.currentTime = 0,
      this.stallCount = 0,
      this._latency = null,
      this.timeupdateHandler = ()=>this.timeupdate(),
      this.hls = e,
      this.config = e.config,
      this.registerListeners()
  }
  get latency() {
    return this._latency || 0
  }
  get maxLatency() {
    const {config: e, levelDetails: t} = this;
    return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0
  }
  get targetLatency() {
    const {levelDetails: e} = this;
    if (null === e)
      return null;
    const {holdBack: t, partHoldBack: n, targetduration: r} = e
      , {liveSyncDuration: o, liveSyncDurationCount: a, lowLatencyMode: i} = this.config
      , s = this.hls.userConfig;
    let l = i && n || t;
    (s.liveSyncDuration || s.liveSyncDurationCount || 0 === l) && (l = void 0 !== o ? o : a * r);
    const u = r;
    return l + Math.min(1 * this.stallCount, u)
  }
  get liveSyncPosition() {
    const e = this.estimateLiveEdge()
      , t = this.targetLatency
      , n = this.levelDetails;
    if (null === e || null === t || null === n)
      return null;
    const r = n.edge
      , o = e - t - this.edgeStalled
      , a = r - n.totalduration
      , i = r - (this.config.lowLatencyMode && n.partTarget || n.targetduration);
    return Math.min(Math.max(a, o), i)
  }
  get drift() {
    const {levelDetails: e} = this;
    return null === e ? 1 : e.drift
  }
  get edgeStalled() {
    const {levelDetails: e} = this;
    if (null === e)
      return 0;
    const t = 3 * (this.config.lowLatencyMode && e.partTarget || e.targetduration);
    return Math.max(e.age - t, 0)
  }
  get forwardBufferLength() {
    const {media: e, levelDetails: t} = this;
    if (!e || !t)
      return 0;
    const n = e.buffered.length;
    return (n ? e.buffered.end(n - 1) : t.edge) - this.currentTime
  }
  destroy() {
    this.unregisterListeners(),
      this.onMediaDetaching(),
      this.levelDetails = null,
      this.hls = this.timeupdateHandler = null
  }
  registerListeners() {
    this.hls.on(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
      this.hls.on(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
      this.hls.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      this.hls.on(Bit.LEVEL_UPDATED, this.onLevelUpdated, this),
      this.hls.on(Bit.ERROR, this.onError, this)
  }
  unregisterListeners() {
    this.hls.off(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
      this.hls.off(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
      this.hls.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      this.hls.off(Bit.LEVEL_UPDATED, this.onLevelUpdated, this),
      this.hls.off(Bit.ERROR, this.onError, this)
  }
  onMediaAttached(e, t) {
    this.media = t.media,
      this.media.addEventListener("timeupdate", this.timeupdateHandler)
  }
  onMediaDetaching() {
    this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler),
      this.media = null)
  }
  onManifestLoading() {
    this.levelDetails = null,
      this._latency = null,
      this.stallCount = 0
  }
  onLevelUpdated(e, {details: t}) {
    this.levelDetails = t,
    t.advanced && this.timeupdate(),
    !t.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
  }
  onError(e, t) {
    var n;
    t.details === Mit.BUFFER_STALLED_ERROR && (this.stallCount++,
    null != (n = this.levelDetails) && n.live && Hit.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
  }
  timeupdate() {
    const {media: e, levelDetails: t} = this;
    if (!e || !t)
      return;
    this.currentTime = e.currentTime;
    const n = this.computeLatency();
    if (null === n)
      return;
    this._latency = n;
    const {lowLatencyMode: r, maxLiveSyncPlaybackRate: o} = this.config;
    if (!r || 1 === o)
      return;
    const a = this.targetLatency;
    if (null === a)
      return;
    const i = n - a
      , s = i < Math.min(this.maxLatency, a + t.targetduration);
    if (t.live && s && i > .05 && this.forwardBufferLength > 1) {
      const t = Math.min(2, Math.max(1, o))
        , n = Math.round(2 / (1 + Math.exp(-.75 * i - this.edgeStalled)) * 20) / 20;
      e.playbackRate = Math.min(t, Math.max(1, n))
    } else
      1 !== e.playbackRate && 0 !== e.playbackRate && (e.playbackRate = 1)
  }
  estimateLiveEdge() {
    const {levelDetails: e} = this;
    return null === e ? null : e.edge + e.age
  }
  computeLatency() {
    const e = this.estimateLiveEdge();
    return null === e ? null : e - this.currentTime
  }
}
const Klt = ["NONE", "TYPE-0", "TYPE-1", null];
var Wlt = ""
  , Glt = "YES"
  , qlt = "v2";
class Ylt {
  constructor(e, t, n) {
    this.msn = void 0,
      this.part = void 0,
      this.skip = void 0,
      this.msn = e,
      this.part = t,
      this.skip = n
  }
  addDirectives(e) {
    const t = new self.URL(e);
    return void 0 !== this.msn && t.searchParams.set("_HLS_msn", this.msn.toString()),
    void 0 !== this.part && t.searchParams.set("_HLS_part", this.part.toString()),
    this.skip && t.searchParams.set("_HLS_skip", this.skip),
      t.href
  }
}
class Xlt {
  constructor(e) {
    this._attrs = void 0,
      this.audioCodec = void 0,
      this.bitrate = void 0,
      this.codecSet = void 0,
      this.height = void 0,
      this.id = void 0,
      this.name = void 0,
      this.videoCodec = void 0,
      this.width = void 0,
      this.unknownCodecs = void 0,
      this.audioGroupIds = void 0,
      this.details = void 0,
      this.fragmentError = 0,
      this.loadError = 0,
      this.loaded = void 0,
      this.realBitrate = 0,
      this.textGroupIds = void 0,
      this.url = void 0,
      this._urlId = 0,
      this.url = [e.url],
      this._attrs = [e.attrs],
      this.bitrate = e.bitrate,
    e.details && (this.details = e.details),
      this.id = e.id || 0,
      this.name = e.name,
      this.width = e.width || 0,
      this.height = e.height || 0,
      this.audioCodec = e.audioCodec,
      this.videoCodec = e.videoCodec,
      this.unknownCodecs = e.unknownCodecs,
      this.codecSet = [e.videoCodec, e.audioCodec].filter((e=>e)).join(",").replace(/\.[^.,]+/g, "")
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate)
  }
  get attrs() {
    return this._attrs[this._urlId]
  }
  get pathwayId() {
    return this.attrs["PATHWAY-ID"] || "."
  }
  get uri() {
    return this.url[this._urlId] || ""
  }
  get urlId() {
    return this._urlId
  }
  set urlId(e) {
    const t = e % this.url.length;
    this._urlId !== t && (this.fragmentError = 0,
      this.loadError = 0,
      this.details = void 0,
      this._urlId = t)
  }
  get audioGroupId() {
    var e;
    return null == (e = this.audioGroupIds) ? void 0 : e[this.urlId]
  }
  get textGroupId() {
    var e;
    return null == (e = this.textGroupIds) ? void 0 : e[this.urlId]
  }
  addFallback(e) {
    this.url.push(e.url),
      this._attrs.push(e.attrs)
  }
}
function Qlt(e, t) {
  const n = t.startPTS;
  if (Fit(n)) {
    let r, o = 0;
    t.sn > e.sn ? (o = n - e.start,
      r = e) : (o = e.start - n,
      r = t),
    r.duration !== o && (r.duration = o)
  } else if (t.sn > e.sn) {
    e.cc === t.cc && e.minEndPTS ? t.start = e.start + (e.minEndPTS - e.start) : t.start = e.start + e.duration
  } else
    t.start = Math.max(e.start - t.duration, 0)
}
function Jlt(e, t, n, r, o, a) {
  r - n <= 0 && (Hit.warn("Fragment should have a positive duration", t),
    r = n + t.duration,
    a = o + t.duration);
  let i = n
    , s = r;
  const l = t.startPTS
    , u = t.endPTS;
  if (Fit(l)) {
    const e = Math.abs(l - n);
    Fit(t.deltaPTS) ? t.deltaPTS = Math.max(e, t.deltaPTS) : t.deltaPTS = e,
      i = Math.max(n, l),
      n = Math.min(n, l),
      o = Math.min(o, t.startDTS),
      s = Math.min(r, u),
      r = Math.max(r, u),
      a = Math.max(a, t.endDTS)
  }
  const c = n - t.start;
  0 !== t.start && (t.start = n),
    t.duration = r - t.start,
    t.startPTS = n,
    t.maxStartPTS = i,
    t.startDTS = o,
    t.endPTS = r,
    t.minEndPTS = s,
    t.endDTS = a;
  const d = t.sn;
  if (!e || d < e.startSN || d > e.endSN)
    return 0;
  let f;
  const p = d - e.startSN
    , h = e.fragments;
  for (h[p] = t,
         f = p; f > 0; f--)
    Qlt(h[f], h[f - 1]);
  for (f = p; f < h.length - 1; f++)
    Qlt(h[f], h[f + 1]);
  return e.fragmentHint && Qlt(h[h.length - 1], e.fragmentHint),
    e.PTSKnown = e.alignedSliding = !0,
    c
}
function Zlt(e, t) {
  let n = null;
  const r = e.fragments;
  for (let l = r.length - 1; l >= 0; l--) {
    const e = r[l].initSegment;
    if (e) {
      n = e;
      break
    }
  }
  e.fragmentHint && delete e.fragmentHint.endPTS;
  let o, a = 0;
  if (function(e, t, n) {
    const r = t.skippedSegments
      , o = Math.max(e.startSN, t.startSN) - t.startSN
      , a = (e.fragmentHint ? 1 : 0) + (r ? t.endSN : Math.min(e.endSN, t.endSN)) - t.startSN
      , i = t.startSN - e.startSN
      , s = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments
      , l = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments;
    for (let u = o; u <= a; u++) {
      const e = l[i + u];
      let o = s[u];
      r && !o && u < r && (o = t.fragments[u] = e),
      e && o && n(e, o)
    }
  }(e, t, ((e,r)=>{
      e.relurl && (a = e.cc - r.cc),
      Fit(e.startPTS) && Fit(e.endPTS) && (r.start = r.startPTS = e.startPTS,
        r.startDTS = e.startDTS,
        r.maxStartPTS = e.maxStartPTS,
        r.endPTS = e.endPTS,
        r.endDTS = e.endDTS,
        r.minEndPTS = e.minEndPTS,
        r.duration = e.endPTS - e.startPTS,
      r.duration && (o = r),
        t.PTSKnown = t.alignedSliding = !0),
        r.elementaryStreams = e.elementaryStreams,
        r.loader = e.loader,
        r.stats = e.stats,
        r.urlId = e.urlId,
      e.initSegment && (r.initSegment = e.initSegment,
        n = e.initSegment)
    }
  )),
    n) {
    (t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments).forEach((e=>{
        var t;
        e.initSegment && e.initSegment.relurl !== (null == (t = n) ? void 0 : t.relurl) || (e.initSegment = n)
      }
    ))
  }
  if (t.skippedSegments)
    if (t.deltaUpdateFailed = t.fragments.some((e=>!e)),
      t.deltaUpdateFailed) {
      Hit.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
      for (let e = t.skippedSegments; e--; )
        t.fragments.shift();
      t.startSN = t.fragments[0].sn,
        t.startCC = t.fragments[0].cc
    } else
      t.canSkipDateRanges && (t.dateRanges = function(e, t, n) {
        const r = Pit({}, e);
        n && n.forEach((e=>{
            delete r[e]
          }
        ));
        return Object.keys(t).forEach((e=>{
            const n = new qit(t[e].attr,r[e]);
            n.isValid ? r[e] = n : Hit.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(t[e].attr)}"`)
          }
        )),
          r
      }(e.dateRanges, t.dateRanges, t.recentlyRemovedDateranges));
  const i = t.fragments;
  if (a) {
    Hit.warn("discontinuity sliding from playlist, take drift into account");
    for (let e = 0; e < i.length; e++)
      i[e].cc += a
  }
  t.skippedSegments && (t.startCC = t.fragments[0].cc),
    function(e, t, n) {
      if (e && t) {
        let r = 0;
        for (let o = 0, a = e.length; o <= a; o++) {
          const a = e[o]
            , i = t[o + r];
          a && i && a.index === i.index && a.fragment.sn === i.fragment.sn ? n(a, i) : r--
        }
      }
    }(e.partList, t.partList, ((e,t)=>{
        t.elementaryStreams = e.elementaryStreams,
          t.stats = e.stats
      }
    )),
    o ? Jlt(t, o, o.startPTS, o.endPTS, o.startDTS, o.endDTS) : eut(e, t),
  i.length && (t.totalduration = t.edge - i[0].start),
    t.driftStartTime = e.driftStartTime,
    t.driftStart = e.driftStart;
  const s = t.advancedDateTime;
  if (t.advanced && s) {
    const e = t.edge;
    t.driftStart || (t.driftStartTime = s,
      t.driftStart = e),
      t.driftEndTime = s,
      t.driftEnd = e
  } else
    t.driftEndTime = e.driftEndTime,
      t.driftEnd = e.driftEnd,
      t.advancedDateTime = e.advancedDateTime
}
function eut(e, t) {
  const n = t.startSN + t.skippedSegments - e.startSN
    , r = e.fragments;
  n < 0 || n >= r.length || tut(t, r[n].start)
}
function tut(e, t) {
  if (t) {
    const n = e.fragments;
    for (let r = e.skippedSegments; r < n.length; r++)
      n[r].start += t;
    e.fragmentHint && (e.fragmentHint.start += t)
  }
}
function nut(e, t, n) {
  var r;
  return null != e && e.details ? rut(null == (r = e.details) ? void 0 : r.partList, t, n) : null
}
function rut(e, t, n) {
  if (e)
    for (let r = e.length; r--; ) {
      const o = e[r];
      if (o.index === n && o.fragment.sn === t)
        return o
    }
  return null
}
function out(e) {
  switch (e.details) {
    case Mit.FRAG_LOAD_TIMEOUT:
    case Mit.KEY_LOAD_TIMEOUT:
    case Mit.LEVEL_LOAD_TIMEOUT:
    case Mit.MANIFEST_LOAD_TIMEOUT:
      return !0
  }
  return !1
}
function aut(e, t) {
  const n = out(t);
  return e.default[(n ? "timeout" : "error") + "Retry"]
}
function iut(e, t) {
  const n = "linear" === e.backoff ? 1 : Math.pow(2, t);
  return Math.min(n * e.retryDelayMs, e.maxRetryDelayMs)
}
function sut(e) {
  return Lit(Lit({}, e), {
    errorRetry: null,
    timeoutRetry: null
  })
}
function lut(e, t, n, r) {
  return !!e && t < e.maxNumRetry && (function(e) {
    return 0 === e && !1 === navigator.onLine || !!e && (e < 400 || e > 499)
  }(r) || !!n)
}
const uut = {
  search: function(e, t) {
    let n = 0
      , r = e.length - 1
      , o = null
      , a = null;
    for (; n <= r; ) {
      o = (n + r) / 2 | 0,
        a = e[o];
      const i = t(a);
      if (i > 0)
        n = o + 1;
      else {
        if (!(i < 0))
          return a;
        r = o - 1
      }
    }
    return null
  }
};
function cut(e, t, n=0, r=0) {
  let o = null;
  if (e ? o = t[e.sn - t[0].sn + 1] || null : 0 === n && 0 === t[0].start && (o = t[0]),
  o && 0 === dut(n, r, o))
    return o;
  const a = uut.search(t, dut.bind(null, n, r));
  return !a || a === e && o ? o : a
}
function dut(e=0, t=0, n) {
  if (n.start <= e && n.start + n.duration > e)
    return 0;
  const r = Math.min(t, n.duration + (n.deltaPTS ? n.deltaPTS : 0));
  return n.start + n.duration - r <= e ? 1 : n.start - r > e && n.start ? -1 : 0
}
function fut(e, t, n) {
  const r = 1e3 * Math.min(t, n.duration + (n.deltaPTS ? n.deltaPTS : 0));
  return (n.endProgramDateTime || 0) - r > e
}
var put = 0
  , hut = 2
  , vut = 5
  , gut = 0
  , mut = 1
  , yut = 2;
function but(e, t, n) {
  if (performance.now() - e.lastErrorPerfMs > 3e5)
    return !0;
  const r = e.details;
  if (t.details === Mit.FRAG_GAP && r && t.frag) {
    const e = t.frag.start
      , n = cut(null, r.fragments, e);
    if (n && !n.gap)
      return !0
  }
  if (n && e.errors.length < n.errors.length) {
    const n = e.errors[e.errors.length - 1];
    if (r && n.frag && t.frag && Math.abs(n.frag.start - t.frag.start) > 3 * r.targetduration)
      return !0
  }
  return !1
}
class wut {
  constructor(e, t) {
    this.hls = void 0,
      this.timer = -1,
      this.requestScheduled = -1,
      this.canLoad = !1,
      this.log = void 0,
      this.warn = void 0,
      this.log = Hit.log.bind(Hit, `${t}:`),
      this.warn = Hit.warn.bind(Hit, `${t}:`),
      this.hls = e
  }
  destroy() {
    this.clearTimer(),
      this.hls = this.log = this.warn = null
  }
  clearTimer() {
    clearTimeout(this.timer),
      this.timer = -1
  }
  startLoad() {
    this.canLoad = !0,
      this.requestScheduled = -1,
      this.loadPlaylist()
  }
  stopLoad() {
    this.canLoad = !1,
      this.clearTimer()
  }
  switchParams(e, t) {
    const n = null == t ? void 0 : t.renditionReports;
    if (n) {
      let o = -1;
      for (let a = 0; a < n.length; a++) {
        const i = n[a];
        let s;
        try {
          s = new self.URL(i.URI,t.url).href
        } catch (r) {
          Hit.warn(`Could not construct new URL for Rendition Report: ${r}`),
            s = i.URI || ""
        }
        if (s === e) {
          o = a;
          break
        }
        s === e.substring(0, s.length) && (o = a)
      }
      if (-1 !== o) {
        const e = n[o]
          , r = parseInt(e["LAST-MSN"]) || (null == t ? void 0 : t.lastPartSn);
        let a = parseInt(e["LAST-PART"]) || (null == t ? void 0 : t.lastPartIndex);
        if (this.hls.config.lowLatencyMode) {
          const e = Math.min(t.age - t.partTarget, t.targetduration);
          a >= 0 && e > t.partTarget && (a += 1)
        }
        return new Ylt(r,a >= 0 ? a : void 0,Wlt)
      }
    }
  }
  loadPlaylist(e) {
    -1 === this.requestScheduled && (this.requestScheduled = self.performance.now())
  }
  shouldLoadPlaylist(e) {
    return this.canLoad && !!e && !!e.url && (!e.details || e.details.live)
  }
  shouldReloadPlaylist(e) {
    return -1 === this.timer && -1 === this.requestScheduled && this.shouldLoadPlaylist(e)
  }
  playlistLoaded(e, t, n) {
    const {details: r, stats: o} = t
      , a = self.performance.now()
      , i = o.loading.first ? Math.max(0, a - o.loading.first) : 0;
    if (r.advancedDateTime = Date.now() - i,
    r.live || null != n && n.live) {
      if (r.reloaded(n),
      n && this.log(`live playlist ${e} ${r.advanced ? "REFRESHED " + r.lastPartSn + "-" + r.lastPartIndex : "MISSED"}`),
      n && r.fragments.length > 0 && Zlt(n, r),
      !this.canLoad || !r.live)
        return;
      let i, s, l;
      if (r.canBlockReload && r.endSN && r.advanced) {
        const e = this.hls.config.lowLatencyMode
          , o = r.lastPartSn
          , a = r.endSN
          , u = r.lastPartIndex
          , c = o === a;
        -1 !== u ? (s = c ? a + 1 : o,
          l = c ? e ? 0 : u : u + 1) : s = a + 1;
        const d = r.age
          , f = d + r.ageHeader;
        let p = Math.min(f - r.partTarget, 1.5 * r.targetduration);
        if (p > 0) {
          if (n && p > n.tuneInGoal)
            this.warn(`CDN Tune-in goal increased from: ${n.tuneInGoal} to: ${p} with playlist age: ${r.age}`),
              p = 0;
          else {
            const e = Math.floor(p / r.targetduration);
            if (s += e,
            void 0 !== l) {
              l += Math.round(p % r.targetduration / r.partTarget)
            }
            this.log(`CDN Tune-in age: ${r.ageHeader}s last advanced ${d.toFixed(2)}s goal: ${p} skip sn ${e} to part ${l}`)
          }
          r.tuneInGoal = p
        }
        if (i = this.getDeliveryDirectives(r, t.deliveryDirectives, s, l),
        e || !c)
          return void this.loadPlaylist(i)
      } else
        r.canBlockReload && (i = this.getDeliveryDirectives(r, t.deliveryDirectives, s, l));
      const u = this.hls.mainForwardBufferInfo
        , c = u ? u.end - u.len : 0
        , d = function(e, t=1 / 0) {
        let n = 1e3 * e.targetduration;
        if (e.updated) {
          const r = e.fragments
            , o = 4;
          if (r.length && n * o > t) {
            const e = 1e3 * r[r.length - 1].duration;
            e < n && (n = e)
          }
        } else
          n /= 2;
        return Math.round(n)
      }(r, 1e3 * (r.edge - c));
      r.updated && a > this.requestScheduled + d && (this.requestScheduled = o.loading.start),
        void 0 !== s && r.canBlockReload ? this.requestScheduled = o.loading.first + d - (1e3 * r.partTarget || 1e3) : -1 === this.requestScheduled || this.requestScheduled + d < a ? this.requestScheduled = a : this.requestScheduled - a <= 0 && (this.requestScheduled += d);
      let f = this.requestScheduled - a;
      f = Math.max(0, f),
        this.log(`reload live playlist ${e} in ${Math.round(f)} ms`),
        this.timer = self.setTimeout((()=>this.loadPlaylist(i)), f)
    } else
      this.clearTimer()
  }
  getDeliveryDirectives(e, t, n, r) {
    let o = function(e, t) {
      const {canSkipUntil: n, canSkipDateRanges: r, endSN: o} = e;
      return n && (void 0 !== t ? t - o : 0) < n ? r ? qlt : Glt : Wlt
    }(e, n);
    return null != t && t.skip && e.deltaUpdateFailed && (n = t.msn,
      r = t.part,
      o = Wlt),
      new Ylt(n,r,o)
  }
  checkRetry(e) {
    const t = e.details
      , n = out(e)
      , r = e.errorAction
      , {action: o, retryCount: a=0, retryConfig: i} = r || {}
      , s = !!r && !!i && (o === vut || !r.resolved && o === hut);
    if (s) {
      var l;
      if (this.requestScheduled = -1,
      a >= i.maxNumRetry)
        return !1;
      if (n && null != (l = e.context) && l.deliveryDirectives)
        this.warn(`Retrying playlist loading ${a + 1}/${i.maxNumRetry} after "${t}" without delivery-directives`),
          this.loadPlaylist();
      else {
        const e = iut(i, a);
        this.timer = self.setTimeout((()=>this.loadPlaylist()), e),
          this.warn(`Retrying playlist loading ${a + 1}/${i.maxNumRetry} after "${t}" in ${e}ms`)
      }
      e.levelRetry = !0,
        r.resolved = !0
    }
    return s
  }
}
let xut;
class Sut extends wut {
  constructor(e, t) {
    super(e, "[level-controller]"),
      this._levels = [],
      this._firstLevel = -1,
      this._startLevel = void 0,
      this.currentLevel = null,
      this.currentLevelIndex = -1,
      this.manualLevelIndex = -1,
      this.steering = void 0,
      this.onParsedComplete = void 0,
      this.steering = t,
      this._registerListeners()
  }
  _registerListeners() {
    const {hls: e} = this;
    e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(Bit.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.on(Bit.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on(Bit.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.on(Bit.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
      e.on(Bit.FRAG_LOADED, this.onFragLoaded, this),
      e.on(Bit.ERROR, this.onError, this)
  }
  _unregisterListeners() {
    const {hls: e} = this;
    e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(Bit.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.off(Bit.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off(Bit.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.off(Bit.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
      e.off(Bit.FRAG_LOADED, this.onFragLoaded, this),
      e.off(Bit.ERROR, this.onError, this)
  }
  destroy() {
    this._unregisterListeners(),
      this.steering = null,
      this.resetLevels(),
      super.destroy()
  }
  startLoad() {
    this._levels.forEach((e=>{
        e.loadError = 0,
          e.fragmentError = 0
      }
    )),
      super.startLoad()
  }
  resetLevels() {
    this._startLevel = void 0,
      this.manualLevelIndex = -1,
      this.currentLevelIndex = -1,
      this.currentLevel = null,
      this._levels = []
  }
  onManifestLoading(e, t) {
    this.resetLevels()
  }
  onManifestLoaded(e, t) {
    const n = []
      , r = {};
    let o;
    t.levels.forEach((e=>{
        var t;
        const a = e.attrs;
        -1 !== (null == (t = e.audioCodec) ? void 0 : t.indexOf("mp4a.40.34")) && (xut || (xut = /chrome|firefox/i.test(navigator.userAgent)),
        xut && (e.audioCodec = void 0));
        const {AUDIO: i, CODECS: s, "FRAME-RATE": l, "PATHWAY-ID": u, RESOLUTION: c, SUBTITLES: d} = a
          , f = `${`${u || "."}-`}${e.bitrate}-${c}-${l}-${s}`;
        o = r[f],
          o ? o.addFallback(e) : (o = new Xlt(e),
            r[f] = o,
            n.push(o)),
          Eut(o, "audio", i),
          Eut(o, "text", d)
      }
    )),
      this.filterAndSortMediaOptions(n, t)
  }
  filterAndSortMediaOptions(e, t) {
    let n = []
      , r = []
      , o = !1
      , a = !1
      , i = !1
      , s = e.filter((({audioCodec: e, videoCodec: t, width: n, height: r, unknownCodecs: s})=>(o || (o = !(!n || !r)),
    a || (a = !!t),
    i || (i = !!e),
    !(null != s && s.length) && (!e || ult(e, "audio")) && (!t || ult(t, "video")))));
    if ((o || a) && i && (s = s.filter((({videoCodec: e, width: t, height: n})=>!!e || !(!t || !n)))),
    0 === s.length)
      return void Promise.resolve().then((()=>{
          if (this.hls) {
            const e = new Error("no level with compatible codecs found in manifest");
            this.hls.trigger(Bit.ERROR, {
              type: Nit.MEDIA_ERROR,
              details: Mit.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
              fatal: !0,
              url: t.url,
              error: e,
              reason: e.message
            })
          }
        }
      ));
    t.audioTracks && (n = t.audioTracks.filter((e=>!e.audioCodec || ult(e.audioCodec, "audio"))),
      Aut(n)),
    t.subtitles && (r = t.subtitles,
      Aut(r));
    const l = s.slice(0);
    s.sort(((e,t)=>e.attrs["HDCP-LEVEL"] !== t.attrs["HDCP-LEVEL"] ? (e.attrs["HDCP-LEVEL"] || "") > (t.attrs["HDCP-LEVEL"] || "") ? 1 : -1 : e.bitrate !== t.bitrate ? e.bitrate - t.bitrate : e.attrs["FRAME-RATE"] !== t.attrs["FRAME-RATE"] ? e.attrs.decimalFloatingPoint("FRAME-RATE") - t.attrs.decimalFloatingPoint("FRAME-RATE") : e.attrs.SCORE !== t.attrs.SCORE ? e.attrs.decimalFloatingPoint("SCORE") - t.attrs.decimalFloatingPoint("SCORE") : o && e.height !== t.height ? e.height - t.height : 0));
    let u = l[0];
    if (this.steering && (s = this.steering.filterParsedLevels(s),
    s.length !== l.length))
      for (let f = 0; f < l.length; f++)
        if (l[f].pathwayId === s[0].pathwayId) {
          u = l[f];
          break
        }
    this._levels = s;
    for (let f = 0; f < s.length; f++)
      if (s[f] === u) {
        this._firstLevel = f,
          this.log(`manifest loaded, ${s.length} level(s) found, first bitrate: ${u.bitrate}`);
        break
      }
    const c = i && !a
      , d = {
      levels: s,
      audioTracks: n,
      subtitleTracks: r,
      sessionData: t.sessionData,
      sessionKeys: t.sessionKeys,
      firstLevel: this._firstLevel,
      stats: t.stats,
      audio: i,
      video: a,
      altAudio: !c && n.some((e=>!!e.url))
    };
    this.hls.trigger(Bit.MANIFEST_PARSED, d),
    (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
  }
  get levels() {
    return 0 === this._levels.length ? null : this._levels
  }
  get level() {
    return this.currentLevelIndex
  }
  set level(e) {
    const t = this._levels;
    if (0 === t.length)
      return;
    if (e < 0 || e >= t.length) {
      const n = new Error("invalid level idx")
        , r = e < 0;
      if (this.hls.trigger(Bit.ERROR, {
        type: Nit.OTHER_ERROR,
        details: Mit.LEVEL_SWITCH_ERROR,
        level: e,
        fatal: r,
        error: n,
        reason: n.message
      }),
        r)
        return;
      e = Math.min(e, t.length - 1)
    }
    const n = this.currentLevelIndex
      , r = this.currentLevel
      , o = r ? r.attrs["PATHWAY-ID"] : void 0
      , a = t[e]
      , i = a.attrs["PATHWAY-ID"];
    if (this.currentLevelIndex = e,
      this.currentLevel = a,
    n === e && a.details && r && o === i)
      return;
    this.log(`Switching to level ${e}${i ? " with Pathway " + i : ""} from level ${n}${o ? " with Pathway " + o : ""}`);
    const s = Pit({}, a, {
      level: e,
      maxBitrate: a.maxBitrate,
      attrs: a.attrs,
      uri: a.uri,
      urlId: a.urlId
    });
    delete s._attrs,
      delete s._urlId,
      this.hls.trigger(Bit.LEVEL_SWITCHING, s);
    const l = a.details;
    if (!l || l.live) {
      const e = this.switchParams(a.uri, null == r ? void 0 : r.details);
      this.loadPlaylist(e)
    }
  }
  get manualLevel() {
    return this.manualLevelIndex
  }
  set manualLevel(e) {
    this.manualLevelIndex = e,
    void 0 === this._startLevel && (this._startLevel = e),
    -1 !== e && (this.level = e)
  }
  get firstLevel() {
    return this._firstLevel
  }
  set firstLevel(e) {
    this._firstLevel = e
  }
  get startLevel() {
    if (void 0 === this._startLevel) {
      const e = this.hls.config.startLevel;
      return void 0 !== e ? e : this._firstLevel
    }
    return this._startLevel
  }
  set startLevel(e) {
    this._startLevel = e
  }
  onError(e, t) {
    !t.fatal && t.context && t.context.type === Alt && t.context.level === this.level && this.checkRetry(t)
  }
  onFragLoaded(e, {frag: t}) {
    if (void 0 !== t && t.type === Tlt) {
      const e = this._levels[t.level];
      void 0 !== e && (e.loadError = 0)
    }
  }
  onLevelLoaded(e, t) {
    var n;
    const {level: r, details: o} = t
      , a = this._levels[r];
    var i;
    if (!a)
      return this.warn(`Invalid level index ${r}`),
        void (null != (i = t.deliveryDirectives) && i.skip && (o.deltaUpdateFailed = !0));
    r === this.currentLevelIndex ? (0 === a.fragmentError && (a.loadError = 0),
      this.playlistLoaded(r, t, a.details)) : null != (n = t.deliveryDirectives) && n.skip && (o.deltaUpdateFailed = !0)
  }
  onAudioTrackSwitched(e, t) {
    const n = this.currentLevel;
    if (!n)
      return;
    const r = this.hls.audioTracks[t.id].groupId;
    if (n.audioGroupIds && n.audioGroupId !== r) {
      let e = -1;
      for (let t = 0; t < n.audioGroupIds.length; t++)
        if (n.audioGroupIds[t] === r) {
          e = t;
          break
        }
      -1 !== e && e !== n.urlId && (n.urlId = e,
      this.canLoad && this.startLoad())
    }
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const t = this.currentLevelIndex
      , n = this.currentLevel;
    if (n && this.shouldLoadPlaylist(n)) {
      const o = n.urlId;
      let a = n.uri;
      if (e)
        try {
          a = e.addDirectives(a)
        } catch (r) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${r}`)
        }
      const i = n.attrs["PATHWAY-ID"];
      this.log(`Loading level index ${t}${void 0 !== (null == e ? void 0 : e.msn) ? " at sn " + e.msn + " part " + e.part : ""} with${i ? " Pathway " + i : ""} URI ${o + 1}/${n.url.length} ${a}`),
        this.clearTimer(),
        this.hls.trigger(Bit.LEVEL_LOADING, {
          url: a,
          level: t,
          id: o,
          deliveryDirectives: e || null
        })
    }
  }
  get nextLoadLevel() {
    return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
  }
  set nextLoadLevel(e) {
    this.level = e,
    -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e)
  }
  removeLevel(e, t) {
    const n = (e,n)=>n !== t
      , r = this._levels.filter(((r,o)=>o !== e || (r.url.length > 1 && void 0 !== t ? (r.url = r.url.filter(n),
    r.audioGroupIds && (r.audioGroupIds = r.audioGroupIds.filter(n)),
    r.textGroupIds && (r.textGroupIds = r.textGroupIds.filter(n)),
      r.urlId = 0,
      !0) : (this.steering && this.steering.removeLevel(r),
      !1))));
    this.hls.trigger(Bit.LEVELS_UPDATED, {
      levels: r
    })
  }
  onLevelsUpdated(e, {levels: t}) {
    t.forEach(((e,t)=>{
        const {details: n} = e;
        null != n && n.fragments && n.fragments.forEach((e=>{
            e.level = t
          }
        ))
      }
    )),
      this._levels = t
  }
}
function Eut(e, t, n) {
  n && ("audio" === t ? (e.audioGroupIds || (e.audioGroupIds = []),
    e.audioGroupIds[e.url.length - 1] = n) : "text" === t && (e.textGroupIds || (e.textGroupIds = []),
    e.textGroupIds[e.url.length - 1] = n))
}
function Aut(e) {
  const t = {};
  e.forEach((e=>{
      const n = e.groupId || "";
      e.id = t[n] = t[n] || 0,
        t[n]++
    }
  ))
}
var Cut = "NOT_LOADED"
  , kut = "APPENDING"
  , Tut = "PARTIAL"
  , Dut = "OK";
class Out {
  constructor(e) {
    this.activePartLists = Object.create(null),
      this.endListFragments = Object.create(null),
      this.fragments = Object.create(null),
      this.timeRanges = Object.create(null),
      this.bufferPadding = .2,
      this.hls = void 0,
      this.hasGaps = !1,
      this.hls = e,
      this._registerListeners()
  }
  _registerListeners() {
    const {hls: e} = this;
    e.on(Bit.BUFFER_APPENDED, this.onBufferAppended, this),
      e.on(Bit.FRAG_BUFFERED, this.onFragBuffered, this),
      e.on(Bit.FRAG_LOADED, this.onFragLoaded, this)
  }
  _unregisterListeners() {
    const {hls: e} = this;
    e.off(Bit.BUFFER_APPENDED, this.onBufferAppended, this),
      e.off(Bit.FRAG_BUFFERED, this.onFragBuffered, this),
      e.off(Bit.FRAG_LOADED, this.onFragLoaded, this)
  }
  destroy() {
    this._unregisterListeners(),
      this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null
  }
  getAppendedFrag(e, t) {
    const n = this.activePartLists[t];
    if (n)
      for (let r = n.length; r--; ) {
        const t = n[r];
        if (!t)
          break;
        const o = t.end;
        if (t.start <= e && null !== o && e <= o)
          return t
      }
    return this.getBufferedFrag(e, t)
  }
  getBufferedFrag(e, t) {
    const {fragments: n} = this
      , r = Object.keys(n);
    for (let o = r.length; o--; ) {
      const a = n[r[o]];
      if ((null == a ? void 0 : a.body.type) === t && a.buffered) {
        const t = a.body;
        if (t.start <= e && e <= t.end)
          return t
      }
    }
    return null
  }
  detectEvictedFragments(e, t, n, r) {
    this.timeRanges && (this.timeRanges[e] = t);
    const o = (null == r ? void 0 : r.fragment.sn) || -1;
    Object.keys(this.fragments).forEach((r=>{
        const a = this.fragments[r];
        if (!a)
          return;
        if (o >= a.body.sn)
          return;
        if (!a.buffered && !a.loaded)
          return void (a.body.type === n && this.removeFragment(a.body));
        const i = a.range[e];
        i && i.time.some((e=>{
            const n = !this.isTimeBuffered(e.startPTS, e.endPTS, t);
            return n && this.removeFragment(a.body),
              n
          }
        ))
      }
    ))
  }
  detectPartialFragments(e) {
    const t = this.timeRanges
      , {frag: n, part: r} = e;
    if (!t || "initSegment" === n.sn)
      return;
    const o = Rut(n)
      , a = this.fragments[o];
    if (!a || a.buffered && n.gap)
      return;
    const i = !n.relurl;
    Object.keys(t).forEach((e=>{
        const o = n.elementaryStreams[e];
        if (!o)
          return;
        const s = t[e]
          , l = i || !0 === o.partial;
        a.range[e] = this.getBufferedTimes(n, r, l, s)
      }
    )),
      a.loaded = null,
      Object.keys(a.range).length ? (a.buffered = !0,
      a.body.endList && (this.endListFragments[a.body.type] = a),
      _ut(a) || this.removeParts(n.sn - 1, n.type)) : this.removeFragment(a.body)
  }
  removeParts(e, t) {
    const n = this.activePartLists[t];
    n && (this.activePartLists[t] = n.filter((t=>t.fragment.sn >= e)))
  }
  fragBuffered(e, t) {
    const n = Rut(e);
    let r = this.fragments[n];
    !r && t && (r = this.fragments[n] = {
      body: e,
      appendedPTS: null,
      loaded: null,
      buffered: !1,
      range: Object.create(null)
    },
    e.gap && (this.hasGaps = !0)),
    r && (r.loaded = null,
      r.buffered = !0)
  }
  getBufferedTimes(e, t, n, r) {
    const o = {
      time: [],
      partial: n
    }
      , a = e.start
      , i = e.end
      , s = e.minEndPTS || i
      , l = e.maxStartPTS || a;
    for (let u = 0; u < r.length; u++) {
      const e = r.start(u) - this.bufferPadding
        , t = r.end(u) + this.bufferPadding;
      if (l >= e && s <= t) {
        o.time.push({
          startPTS: Math.max(a, r.start(u)),
          endPTS: Math.min(i, r.end(u))
        });
        break
      }
      if (a < t && i > e)
        o.partial = !0,
          o.time.push({
            startPTS: Math.max(a, r.start(u)),
            endPTS: Math.min(i, r.end(u))
          });
      else if (i <= e)
        break
    }
    return o
  }
  getPartialFragment(e) {
    let t, n, r, o = null, a = 0;
    const {bufferPadding: i, fragments: s} = this;
    return Object.keys(s).forEach((l=>{
        const u = s[l];
        u && _ut(u) && (n = u.body.start - i,
          r = u.body.end + i,
        e >= n && e <= r && (t = Math.min(e - n, r - e),
        a <= t && (o = u.body,
          a = t)))
      }
    )),
      o
  }
  isEndListAppended(e) {
    const t = this.endListFragments[e];
    return void 0 !== t && (t.buffered || _ut(t))
  }
  getState(e) {
    const t = Rut(e)
      , n = this.fragments[t];
    return n ? n.buffered ? _ut(n) ? Tut : Dut : kut : Cut
  }
  isTimeBuffered(e, t, n) {
    let r, o;
    for (let a = 0; a < n.length; a++) {
      if (r = n.start(a) - this.bufferPadding,
        o = n.end(a) + this.bufferPadding,
      e >= r && t <= o)
        return !0;
      if (t <= r)
        return !1
    }
    return !1
  }
  onFragLoaded(e, t) {
    const {frag: n, part: r} = t;
    if ("initSegment" === n.sn || n.bitrateTest)
      return;
    const o = r ? null : t
      , a = Rut(n);
    this.fragments[a] = {
      body: n,
      appendedPTS: null,
      loaded: o,
      buffered: !1,
      range: Object.create(null)
    }
  }
  onBufferAppended(e, t) {
    const {frag: n, part: r, timeRanges: o} = t;
    if ("initSegment" === n.sn)
      return;
    const a = n.type;
    if (r) {
      let e = this.activePartLists[a];
      e || (this.activePartLists[a] = e = []),
        e.push(r)
    }
    this.timeRanges = o,
      Object.keys(o).forEach((e=>{
          const t = o[e];
          this.detectEvictedFragments(e, t, a, r)
        }
      ))
  }
  onFragBuffered(e, t) {
    this.detectPartialFragments(t)
  }
  hasFragment(e) {
    const t = Rut(e);
    return !!this.fragments[t]
  }
  hasParts(e) {
    var t;
    return !(null == (t = this.activePartLists[e]) || !t.length)
  }
  removeFragmentsInRange(e, t, n, r, o) {
    r && !this.hasGaps || Object.keys(this.fragments).forEach((a=>{
        const i = this.fragments[a];
        if (!i)
          return;
        const s = i.body;
        s.type !== n || r && !s.gap || s.start < t && s.end > e && (i.buffered || o) && this.removeFragment(s)
      }
    ))
  }
  removeFragment(e) {
    const t = Rut(e);
    e.stats.loaded = 0,
      e.clearElementaryStreamInfo();
    const n = this.activePartLists[e.type];
    if (n) {
      const t = e.sn;
      this.activePartLists[e.type] = n.filter((e=>e.fragment.sn !== t))
    }
    delete this.fragments[t],
    e.endList && delete this.endListFragments[e.type]
  }
  removeAllFragments() {
    this.fragments = Object.create(null),
      this.endListFragments = Object.create(null),
      this.activePartLists = Object.create(null),
      this.hasGaps = !1
  }
}
function _ut(e) {
  var t, n, r;
  return e.buffered && (e.body.gap || (null == (t = e.range.video) ? void 0 : t.partial) || (null == (n = e.range.audio) ? void 0 : n.partial) || (null == (r = e.range.audiovideo) ? void 0 : r.partial))
}
function Rut(e) {
  return `${e.type}_${e.level}_${e.urlId}_${e.sn}`
}
const Lut = Math.pow(2, 17);
class Iut {
  constructor(e) {
    this.config = void 0,
      this.loader = null,
      this.partLoadTimeout = -1,
      this.config = e
  }
  destroy() {
    this.loader && (this.loader.destroy(),
      this.loader = null)
  }
  abort() {
    this.loader && this.loader.abort()
  }
  load(e, t) {
    const n = e.url;
    if (!n)
      return Promise.reject(new But({
        type: Nit.NETWORK_ERROR,
        details: Mit.FRAG_LOAD_ERROR,
        fatal: !1,
        frag: e,
        error: new Error("Fragment does not have a " + (n ? "part list" : "url")),
        networkDetails: null
      }));
    this.abort();
    const r = this.config
      , o = r.fLoader
      , a = r.loader;
    return new Promise(((i,s)=>{
        if (this.loader && this.loader.destroy(),
          e.gap) {
          if (e.tagList.some((e=>"GAP" === e[0])))
            return void s(Fut(e));
          e.gap = !1
        }
        const l = this.loader = e.loader = o ? new o(r) : new a(r)
          , u = Put(e)
          , c = sut(r.fragLoadPolicy.default)
          , d = {
          loadPolicy: c,
          timeout: c.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: "initSegment" === e.sn ? 1 / 0 : Lut
        };
        e.stats = l.stats,
          l.load(u, d, {
            onSuccess: (t,n,r,o)=>{
              this.resetLoader(e, l);
              let a = t.data;
              r.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(a.slice(0, 16)),
                a = a.slice(16)),
                i({
                  frag: e,
                  part: null,
                  payload: a,
                  networkDetails: o
                })
            }
            ,
            onError: (t,r,o,a)=>{
              this.resetLoader(e, l),
                s(new But({
                  type: Nit.NETWORK_ERROR,
                  details: Mit.FRAG_LOAD_ERROR,
                  fatal: !1,
                  frag: e,
                  response: Lit({
                    url: n,
                    data: void 0
                  }, t),
                  error: new Error(`HTTP Error ${t.code} ${t.text}`),
                  networkDetails: o,
                  stats: a
                }))
            }
            ,
            onAbort: (t,n,r)=>{
              this.resetLoader(e, l),
                s(new But({
                  type: Nit.NETWORK_ERROR,
                  details: Mit.INTERNAL_ABORTED,
                  fatal: !1,
                  frag: e,
                  error: new Error("Aborted"),
                  networkDetails: r,
                  stats: t
                }))
            }
            ,
            onTimeout: (t,n,r)=>{
              this.resetLoader(e, l),
                s(new But({
                  type: Nit.NETWORK_ERROR,
                  details: Mit.FRAG_LOAD_TIMEOUT,
                  fatal: !1,
                  frag: e,
                  error: new Error(`Timeout after ${d.timeout}ms`),
                  networkDetails: r,
                  stats: t
                }))
            }
            ,
            onProgress: (n,r,o,a)=>{
              t && t({
                frag: e,
                part: null,
                payload: o,
                networkDetails: a
              })
            }
          })
      }
    ))
  }
  loadPart(e, t, n) {
    this.abort();
    const r = this.config
      , o = r.fLoader
      , a = r.loader;
    return new Promise(((i,s)=>{
        if (this.loader && this.loader.destroy(),
        e.gap || t.gap)
          return void s(Fut(e, t));
        const l = this.loader = e.loader = o ? new o(r) : new a(r)
          , u = Put(e, t)
          , c = sut(r.fragLoadPolicy.default)
          , d = {
          loadPolicy: c,
          timeout: c.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: Lut
        };
        t.stats = l.stats,
          l.load(u, d, {
            onSuccess: (r,o,a,s)=>{
              this.resetLoader(e, l),
                this.updateStatsFromPart(e, t);
              const u = {
                frag: e,
                part: t,
                payload: r.data,
                networkDetails: s
              };
              n(u),
                i(u)
            }
            ,
            onError: (n,r,o,a)=>{
              this.resetLoader(e, l),
                s(new But({
                  type: Nit.NETWORK_ERROR,
                  details: Mit.FRAG_LOAD_ERROR,
                  fatal: !1,
                  frag: e,
                  part: t,
                  response: Lit({
                    url: u.url,
                    data: void 0
                  }, n),
                  error: new Error(`HTTP Error ${n.code} ${n.text}`),
                  networkDetails: o,
                  stats: a
                }))
            }
            ,
            onAbort: (n,r,o)=>{
              e.stats.aborted = t.stats.aborted,
                this.resetLoader(e, l),
                s(new But({
                  type: Nit.NETWORK_ERROR,
                  details: Mit.INTERNAL_ABORTED,
                  fatal: !1,
                  frag: e,
                  part: t,
                  error: new Error("Aborted"),
                  networkDetails: o,
                  stats: n
                }))
            }
            ,
            onTimeout: (n,r,o)=>{
              this.resetLoader(e, l),
                s(new But({
                  type: Nit.NETWORK_ERROR,
                  details: Mit.FRAG_LOAD_TIMEOUT,
                  fatal: !1,
                  frag: e,
                  part: t,
                  error: new Error(`Timeout after ${d.timeout}ms`),
                  networkDetails: o,
                  stats: n
                }))
            }
          })
      }
    ))
  }
  updateStatsFromPart(e, t) {
    const n = e.stats
      , r = t.stats
      , o = r.total;
    if (n.loaded += r.loaded,
      o) {
      const r = Math.round(e.duration / t.duration)
        , a = Math.min(Math.round(n.loaded / o), r)
        , i = (r - a) * Math.round(n.loaded / a);
      n.total = n.loaded + i
    } else
      n.total = Math.max(n.loaded, n.total);
    const a = n.loading
      , i = r.loading;
    a.start ? a.first += i.first - i.start : (a.start = i.start,
      a.first = i.first),
      a.end = i.end
  }
  resetLoader(e, t) {
    e.loader = null,
    this.loader === t && (self.clearTimeout(this.partLoadTimeout),
      this.loader = null),
      t.destroy()
  }
}
function Put(e, t=null) {
  const n = t || e
    , r = {
    frag: e,
    part: t,
    responseType: "arraybuffer",
    url: n.url,
    headers: {},
    rangeStart: 0,
    rangeEnd: 0
  }
    , o = n.byteRangeStartOffset
    , a = n.byteRangeEndOffset;
  if (Fit(o) && Fit(a)) {
    var i;
    let t = o
      , n = a;
    if ("initSegment" === e.sn && "AES-128" === (null == (i = e.decryptdata) ? void 0 : i.method)) {
      const e = a - o;
      e % 16 && (n = a + (16 - e % 16)),
      0 !== o && (r.resetIV = !0,
        t = o - 16)
    }
    r.rangeStart = t,
      r.rangeEnd = n
  }
  return r
}
function Fut(e, t) {
  const n = new Error(`GAP ${e.gap ? "tag" : "attribute"} found`)
    , r = {
    type: Nit.MEDIA_ERROR,
    details: Mit.FRAG_GAP,
    fatal: !1,
    frag: e,
    error: n,
    networkDetails: null
  };
  return t && (r.part = t),
    (t || e).stats.aborted = !0,
    new But(r)
}
class But extends Error {
  constructor(e) {
    super(e.error.message),
      this.data = void 0,
      this.data = e
  }
}
class Nut {
  constructor(e) {
    this.config = void 0,
      this.keyUriToKeyInfo = {},
      this.emeController = null,
      this.config = e
  }
  abort(e) {
    for (const t in this.keyUriToKeyInfo) {
      const n = this.keyUriToKeyInfo[t].loader;
      if (n) {
        if (e && e !== n.context.frag.type)
          return;
        n.abort()
      }
    }
  }
  detach() {
    for (const e in this.keyUriToKeyInfo) {
      const t = this.keyUriToKeyInfo[e];
      (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e]
    }
  }
  destroy() {
    this.detach();
    for (const e in this.keyUriToKeyInfo) {
      const t = this.keyUriToKeyInfo[e].loader;
      t && t.destroy()
    }
    this.keyUriToKeyInfo = {}
  }
  createKeyLoadError(e, t=Mit.KEY_LOAD_ERROR, n, r, o) {
    return new But({
      type: Nit.NETWORK_ERROR,
      details: t,
      fatal: !1,
      frag: e,
      response: o,
      error: n,
      networkDetails: r
    })
  }
  loadClear(e, t) {
    if (this.emeController && this.config.emeEnabled) {
      const {sn: n, cc: r} = e;
      for (let e = 0; e < t.length; e++) {
        const o = t[e];
        if (r <= o.cc && ("initSegment" === n || "initSegment" === o.sn || n < o.sn)) {
          this.emeController.selectKeySystemFormat(o).then((e=>{
              o.setKeyFormat(e)
            }
          ));
          break
        }
      }
    }
  }
  load(e) {
    return !e.decryptdata && e.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(e).then((t=>this.loadInternal(e, t))) : this.loadInternal(e)
  }
  loadInternal(e, t) {
    var n, r;
    t && e.setKeyFormat(t);
    const o = e.decryptdata;
    if (!o) {
      const n = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : "Missing decryption data on fragment in onKeyLoading");
      return Promise.reject(this.createKeyLoadError(e, Mit.KEY_LOAD_ERROR, n))
    }
    const a = o.uri;
    if (!a)
      return Promise.reject(this.createKeyLoadError(e, Mit.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${a}"`)));
    let i = this.keyUriToKeyInfo[a];
    if (null != (n = i) && n.decryptdata.key)
      return o.key = i.decryptdata.key,
        Promise.resolve({
          frag: e,
          keyInfo: i
        });
    var s;
    if (null != (r = i) && r.keyLoadPromise)
      switch (null == (s = i.mediaKeySessionContext) ? void 0 : s.keyStatus) {
        case void 0:
        case "status-pending":
        case "usable":
        case "usable-in-future":
          return i.keyLoadPromise.then((t=>(o.key = t.keyInfo.decryptdata.key,
            {
              frag: e,
              keyInfo: i
            })))
      }
    switch (i = this.keyUriToKeyInfo[a] = {
      decryptdata: o,
      keyLoadPromise: null,
      loader: null,
      mediaKeySessionContext: null
    },
      o.method) {
      case "ISO-23001-7":
      case "SAMPLE-AES":
      case "SAMPLE-AES-CENC":
      case "SAMPLE-AES-CTR":
        return "identity" === o.keyFormat ? this.loadKeyHTTP(i, e) : this.loadKeyEME(i, e);
      case "AES-128":
        return this.loadKeyHTTP(i, e);
      default:
        return Promise.reject(this.createKeyLoadError(e, Mit.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${o.method}"`)))
    }
  }
  loadKeyEME(e, t) {
    const n = {
      frag: t,
      keyInfo: e
    };
    if (this.emeController && this.config.emeEnabled) {
      const t = this.emeController.loadKey(n);
      if (t)
        return (e.keyLoadPromise = t.then((t=>(e.mediaKeySessionContext = t,
          n)))).catch((t=>{
            throw e.keyLoadPromise = null,
              t
          }
        ))
    }
    return Promise.resolve(n)
  }
  loadKeyHTTP(e, t) {
    const n = this.config
      , r = new (0,
      n.loader)(n);
    return t.keyLoader = e.loader = r,
      e.keyLoadPromise = new Promise(((o,a)=>{
          const i = {
            keyInfo: e,
            frag: t,
            responseType: "arraybuffer",
            url: e.decryptdata.uri
          }
            , s = n.keyLoadPolicy.default
            , l = {
            loadPolicy: s,
            timeout: s.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0
          }
            , u = {
            onSuccess: (e,t,n,r)=>{
              const {frag: i, keyInfo: s, url: l} = n;
              if (!i.decryptdata || s !== this.keyUriToKeyInfo[l])
                return a(this.createKeyLoadError(i, Mit.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), r));
              s.decryptdata.key = i.decryptdata.key = new Uint8Array(e.data),
                i.keyLoader = null,
                s.loader = null,
                o({
                  frag: i,
                  keyInfo: s
                })
            }
            ,
            onError: (e,n,r,o)=>{
              this.resetLoader(n),
                a(this.createKeyLoadError(t, Mit.KEY_LOAD_ERROR, new Error(`HTTP Error ${e.code} loading key ${e.text}`), r, Lit({
                  url: i.url,
                  data: void 0
                }, e)))
            }
            ,
            onTimeout: (e,n,r)=>{
              this.resetLoader(n),
                a(this.createKeyLoadError(t, Mit.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), r))
            }
            ,
            onAbort: (e,n,r)=>{
              this.resetLoader(n),
                a(this.createKeyLoadError(t, Mit.INTERNAL_ABORTED, new Error("key loading aborted"), r))
            }
          };
          r.load(i, l, u)
        }
      ))
  }
  resetLoader(e) {
    const {frag: t, keyInfo: n, url: r} = e
      , o = n.loader;
    t.keyLoader === o && (t.keyLoader = null,
      n.loader = null),
      delete this.keyUriToKeyInfo[r],
    o && o.destroy()
  }
}
class Mut {
  constructor() {
    this._boundTick = void 0,
      this._tickTimer = null,
      this._tickInterval = null,
      this._tickCallCount = 0,
      this._boundTick = this.tick.bind(this)
  }
  destroy() {
    this.onHandlerDestroying(),
      this.onHandlerDestroyed()
  }
  onHandlerDestroying() {
    this.clearNextTick(),
      this.clearInterval()
  }
  onHandlerDestroyed() {}
  hasInterval() {
    return !!this._tickInterval
  }
  hasNextTick() {
    return !!this._tickTimer
  }
  setInterval(e) {
    return !this._tickInterval && (this._tickCallCount = 0,
      this._tickInterval = self.setInterval(this._boundTick, e),
      !0)
  }
  clearInterval() {
    return !!this._tickInterval && (self.clearInterval(this._tickInterval),
      this._tickInterval = null,
      !0)
  }
  clearNextTick() {
    return !!this._tickTimer && (self.clearTimeout(this._tickTimer),
      this._tickTimer = null,
      !0)
  }
  tick() {
    this._tickCallCount++,
    1 === this._tickCallCount && (this.doTick(),
    this._tickCallCount > 1 && this.tickImmediate(),
      this._tickCallCount = 0)
  }
  tickImmediate() {
    this.clearNextTick(),
      this._tickTimer = self.setTimeout(this._boundTick, 0)
  }
  doTick() {}
}
const jut = {
  length: 0,
  start: ()=>0,
  end: ()=>0
};
class Vut {
  static isBuffered(e, t) {
    try {
      if (e) {
        const n = Vut.getBuffered(e);
        for (let e = 0; e < n.length; e++)
          if (t >= n.start(e) && t <= n.end(e))
            return !0
      }
    } catch (n) {}
    return !1
  }
  static bufferInfo(e, t, n) {
    try {
      if (e) {
        const r = Vut.getBuffered(e)
          , o = [];
        let a;
        for (a = 0; a < r.length; a++)
          o.push({
            start: r.start(a),
            end: r.end(a)
          });
        return this.bufferedInfo(o, t, n)
      }
    } catch (r) {}
    return {
      len: 0,
      start: t,
      end: t,
      nextStart: void 0
    }
  }
  static bufferedInfo(e, t, n) {
    t = Math.max(0, t),
      e.sort((function(e, t) {
          const n = e.start - t.start;
          return n || t.end - e.end
        }
      ));
    let r = [];
    if (n)
      for (let l = 0; l < e.length; l++) {
        const t = r.length;
        if (t) {
          const o = r[t - 1].end;
          e[l].start - o < n ? e[l].end > o && (r[t - 1].end = e[l].end) : r.push(e[l])
        } else
          r.push(e[l])
      }
    else
      r = e;
    let o, a = 0, i = t, s = t;
    for (let l = 0; l < r.length; l++) {
      const e = r[l].start
        , u = r[l].end;
      if (t + n >= e && t < u)
        i = e,
          s = u,
          a = s - t;
      else if (t + n < e) {
        o = e;
        break
      }
    }
    return {
      len: a,
      start: i || 0,
      end: s || 0,
      nextStart: o
    }
  }
  static getBuffered(e) {
    try {
      return e.buffered
    } catch (Y_) {
      return Hit.log("failed to get media.buffered", Y_),
        jut
    }
  }
}
class Uut {
  constructor(e, t, n, r=0, o=-1, a=!1) {
    this.level = void 0,
      this.sn = void 0,
      this.part = void 0,
      this.id = void 0,
      this.size = void 0,
      this.partial = void 0,
      this.transmuxing = {
        start: 0,
        executeStart: 0,
        executeEnd: 0,
        end: 0
      },
      this.buffering = {
        audio: {
          start: 0,
          executeStart: 0,
          executeEnd: 0,
          end: 0
        },
        video: {
          start: 0,
          executeStart: 0,
          executeEnd: 0,
          end: 0
        },
        audiovideo: {
          start: 0,
          executeStart: 0,
          executeEnd: 0,
          end: 0
        }
      },
      this.level = e,
      this.sn = t,
      this.id = n,
      this.size = r,
      this.part = o,
      this.partial = a
  }
}
function $ut(e, t) {
  let n = null;
  for (let r = 0, o = e.length; r < o; r++) {
    const o = e[r];
    if (o && o.cc === t) {
      n = o;
      break
    }
  }
  return n
}
function Hut(e, t) {
  if (e) {
    const n = e.start + t;
    e.start = e.startPTS = n,
      e.endPTS = n + e.duration
  }
}
function zut(e, t) {
  const n = t.fragments;
  for (let r = 0, o = n.length; r < o; r++)
    Hut(n[r], e);
  t.fragmentHint && Hut(t.fragmentHint, e),
    t.alignedSliding = !0
}
function Kut(e, t, n) {
  t && (!function(e, t, n) {
    if (function(e, t, n) {
      return !(!t.details || !(n.endCC > n.startCC || e && e.cc < n.startCC))
    }(e, n, t)) {
      const e = function(e, t, n=0) {
        const r = e.fragments
          , o = t.fragments;
        if (!o.length || !r.length)
          return void Hit.log("No fragments to align");
        const a = $ut(r, o[0].cc);
        if (a && (!a || a.startPTS))
          return a;
        Hit.log("No frag in previous level to align on")
      }(n.details, t);
      e && Fit(e.start) && (Hit.log(`Adjusting PTS using last level due to CC increase within current level ${t.url}`),
        zut(e.start, t))
    }
  }(e, n, t),
  !n.alignedSliding && t.details && function(e, t) {
    if (!t.fragments.length || !e.hasProgramDateTime || !t.hasProgramDateTime)
      return;
    const n = t.fragments[0].programDateTime
      , r = e.fragments[0].programDateTime
      , o = (r - n) / 1e3 + t.fragments[0].start;
    o && Fit(o) && (Hit.log(`Adjusting PTS using programDateTime delta ${r - n}ms, sliding:${o.toFixed(3)} ${e.url} `),
      zut(o, e))
  }(n, t.details),
  n.alignedSliding || !t.details || n.skippedSegments || eut(t.details, n))
}
function Wut(e, t) {
  if (!e.hasProgramDateTime || !t.hasProgramDateTime)
    return;
  const n = e.fragments
    , r = t.fragments;
  if (!n.length || !r.length)
    return;
  const o = r[Math.round(r.length / 2) - 1]
    , a = $ut(n, o.cc) || n[Math.round(n.length / 2) - 1]
    , i = o.programDateTime
    , s = a.programDateTime;
  if (null === i || null === s)
    return;
  zut((s - i) / 1e3 - (a.start - o.start), e)
}
class Gut {
  constructor(e, t) {
    this.subtle = void 0,
      this.aesIV = void 0,
      this.subtle = e,
      this.aesIV = t
  }
  decrypt(e, t) {
    return this.subtle.decrypt({
      name: "AES-CBC",
      iv: this.aesIV
    }, t, e)
  }
}
class qut {
  constructor(e, t) {
    this.subtle = void 0,
      this.key = void 0,
      this.subtle = e,
      this.key = t
  }
  expandKey() {
    return this.subtle.importKey("raw", this.key, {
      name: "AES-CBC"
    }, !1, ["encrypt", "decrypt"])
  }
}
class Yut {
  constructor() {
    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
      this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)],
      this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)],
      this.sBox = new Uint32Array(256),
      this.invSBox = new Uint32Array(256),
      this.key = new Uint32Array(0),
      this.ksRows = 0,
      this.keySize = 0,
      this.keySchedule = void 0,
      this.invKeySchedule = void 0,
      this.initTable()
  }
  uint8ArrayToUint32Array_(e) {
    const t = new DataView(e)
      , n = new Uint32Array(4);
    for (let r = 0; r < 4; r++)
      n[r] = t.getUint32(4 * r);
    return n
  }
  initTable() {
    const e = this.sBox
      , t = this.invSBox
      , n = this.subMix
      , r = n[0]
      , o = n[1]
      , a = n[2]
      , i = n[3]
      , s = this.invSubMix
      , l = s[0]
      , u = s[1]
      , c = s[2]
      , d = s[3]
      , f = new Uint32Array(256);
    let p = 0
      , h = 0
      , v = 0;
    for (v = 0; v < 256; v++)
      f[v] = v < 128 ? v << 1 : v << 1 ^ 283;
    for (v = 0; v < 256; v++) {
      let n = h ^ h << 1 ^ h << 2 ^ h << 3 ^ h << 4;
      n = n >>> 8 ^ 255 & n ^ 99,
        e[p] = n,
        t[n] = p;
      const s = f[p]
        , v = f[s]
        , g = f[v];
      let m = 257 * f[n] ^ 16843008 * n;
      r[p] = m << 24 | m >>> 8,
        o[p] = m << 16 | m >>> 16,
        a[p] = m << 8 | m >>> 24,
        i[p] = m,
        m = 16843009 * g ^ 65537 * v ^ 257 * s ^ 16843008 * p,
        l[n] = m << 24 | m >>> 8,
        u[n] = m << 16 | m >>> 16,
        c[n] = m << 8 | m >>> 24,
        d[n] = m,
        p ? (p = s ^ f[f[f[g ^ s]]],
          h ^= f[f[h]]) : p = h = 1
    }
  }
  expandKey(e) {
    const t = this.uint8ArrayToUint32Array_(e);
    let n = !0
      , r = 0;
    for (; r < t.length && n; )
      n = t[r] === this.key[r],
        r++;
    if (n)
      return;
    this.key = t;
    const o = this.keySize = t.length;
    if (4 !== o && 6 !== o && 8 !== o)
      throw new Error("Invalid aes key size=" + o);
    const a = this.ksRows = 4 * (o + 6 + 1);
    let i, s;
    const l = this.keySchedule = new Uint32Array(a)
      , u = this.invKeySchedule = new Uint32Array(a)
      , c = this.sBox
      , d = this.rcon
      , f = this.invSubMix
      , p = f[0]
      , h = f[1]
      , v = f[2]
      , g = f[3];
    let m, y;
    for (i = 0; i < a; i++)
      i < o ? m = l[i] = t[i] : (y = m,
        i % o == 0 ? (y = y << 8 | y >>> 24,
          y = c[y >>> 24] << 24 | c[y >>> 16 & 255] << 16 | c[y >>> 8 & 255] << 8 | c[255 & y],
          y ^= d[i / o | 0] << 24) : o > 6 && i % o == 4 && (y = c[y >>> 24] << 24 | c[y >>> 16 & 255] << 16 | c[y >>> 8 & 255] << 8 | c[255 & y]),
        l[i] = m = (l[i - o] ^ y) >>> 0);
    for (s = 0; s < a; s++)
      i = a - s,
        y = 3 & s ? l[i] : l[i - 4],
        u[s] = s < 4 || i <= 4 ? y : p[c[y >>> 24]] ^ h[c[y >>> 16 & 255]] ^ v[c[y >>> 8 & 255]] ^ g[c[255 & y]],
        u[s] = u[s] >>> 0
  }
  networkToHostOrderSwap(e) {
    return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
  }
  decrypt(e, t, n) {
    const r = this.keySize + 6
      , o = this.invKeySchedule
      , a = this.invSBox
      , i = this.invSubMix
      , s = i[0]
      , l = i[1]
      , u = i[2]
      , c = i[3]
      , d = this.uint8ArrayToUint32Array_(n);
    let f = d[0]
      , p = d[1]
      , h = d[2]
      , v = d[3];
    const g = new Int32Array(e)
      , m = new Int32Array(g.length);
    let y, b, w, x, S, E, A, C, k, T, D, O, _, R;
    const L = this.networkToHostOrderSwap;
    for (; t < g.length; ) {
      for (k = L(g[t]),
             T = L(g[t + 1]),
             D = L(g[t + 2]),
             O = L(g[t + 3]),
             S = k ^ o[0],
             E = O ^ o[1],
             A = D ^ o[2],
             C = T ^ o[3],
             _ = 4,
             R = 1; R < r; R++)
        y = s[S >>> 24] ^ l[E >> 16 & 255] ^ u[A >> 8 & 255] ^ c[255 & C] ^ o[_],
          b = s[E >>> 24] ^ l[A >> 16 & 255] ^ u[C >> 8 & 255] ^ c[255 & S] ^ o[_ + 1],
          w = s[A >>> 24] ^ l[C >> 16 & 255] ^ u[S >> 8 & 255] ^ c[255 & E] ^ o[_ + 2],
          x = s[C >>> 24] ^ l[S >> 16 & 255] ^ u[E >> 8 & 255] ^ c[255 & A] ^ o[_ + 3],
          S = y,
          E = b,
          A = w,
          C = x,
          _ += 4;
      y = a[S >>> 24] << 24 ^ a[E >> 16 & 255] << 16 ^ a[A >> 8 & 255] << 8 ^ a[255 & C] ^ o[_],
        b = a[E >>> 24] << 24 ^ a[A >> 16 & 255] << 16 ^ a[C >> 8 & 255] << 8 ^ a[255 & S] ^ o[_ + 1],
        w = a[A >>> 24] << 24 ^ a[C >> 16 & 255] << 16 ^ a[S >> 8 & 255] << 8 ^ a[255 & E] ^ o[_ + 2],
        x = a[C >>> 24] << 24 ^ a[S >> 16 & 255] << 16 ^ a[E >> 8 & 255] << 8 ^ a[255 & A] ^ o[_ + 3],
        m[t] = L(y ^ f),
        m[t + 1] = L(x ^ p),
        m[t + 2] = L(w ^ h),
        m[t + 3] = L(b ^ v),
        f = k,
        p = T,
        h = D,
        v = O,
        t += 4
    }
    return m.buffer
  }
}
class Xut {
  constructor(e, {removePKCS7Padding: t=!0}={}) {
    if (this.logEnabled = !0,
      this.removePKCS7Padding = void 0,
      this.subtle = null,
      this.softwareDecrypter = null,
      this.key = null,
      this.fastAesKey = null,
      this.remainderData = null,
      this.currentIV = null,
      this.currentResult = null,
      this.useSoftware = void 0,
      this.useSoftware = e.enableSoftwareAES,
      this.removePKCS7Padding = t,
      t)
      try {
        const e = self.crypto;
        e && (this.subtle = e.subtle || e.webkitSubtle)
      } catch (Y_) {}
    null === this.subtle && (this.useSoftware = !0)
  }
  destroy() {
    this.subtle = null,
      this.softwareDecrypter = null,
      this.key = null,
      this.fastAesKey = null,
      this.remainderData = null,
      this.currentIV = null,
      this.currentResult = null
  }
  isSync() {
    return this.useSoftware
  }
  flush() {
    const {currentResult: e, remainderData: t} = this;
    if (!e || t)
      return this.reset(),
        null;
    const n = new Uint8Array(e);
    return this.reset(),
      this.removePKCS7Padding ? function(e) {
        const t = e.byteLength
          , n = t && new DataView(e.buffer).getUint8(t - 1);
        return n ? gst(e, 0, t - n) : e
      }(n) : n
  }
  reset() {
    this.currentResult = null,
      this.currentIV = null,
      this.remainderData = null,
    this.softwareDecrypter && (this.softwareDecrypter = null)
  }
  decrypt(e, t, n) {
    return this.useSoftware ? new Promise(((r,o)=>{
        this.softwareDecrypt(new Uint8Array(e), t, n);
        const a = this.flush();
        a ? r(a.buffer) : o(new Error("[softwareDecrypt] Failed to decrypt data"))
      }
    )) : this.webCryptoDecrypt(new Uint8Array(e), t, n)
  }
  softwareDecrypt(e, t, n) {
    const {currentIV: r, currentResult: o, remainderData: a} = this;
    this.logOnce("JS AES decrypt"),
    a && (e = Wst(a, e),
      this.remainderData = null);
    const i = this.getValidChunk(e);
    if (!i.length)
      return null;
    r && (n = r);
    let s = this.softwareDecrypter;
    s || (s = this.softwareDecrypter = new Yut),
      s.expandKey(t);
    const l = o;
    return this.currentResult = s.decrypt(i.buffer, 0, n),
      this.currentIV = gst(i, -16).buffer,
    l || null
  }
  webCryptoDecrypt(e, t, n) {
    const r = this.subtle;
    return this.key === t && this.fastAesKey || (this.key = t,
      this.fastAesKey = new qut(r,t)),
      this.fastAesKey.expandKey().then((t=>{
          if (!r)
            return Promise.reject(new Error("web crypto not initialized"));
          this.logOnce("WebCrypto AES decrypt");
          return new Gut(r,new Uint8Array(n)).decrypt(e.buffer, t)
        }
      )).catch((r=>(Hit.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${r.name}: ${r.message}`),
        this.onWebCryptoError(e, t, n))))
  }
  onWebCryptoError(e, t, n) {
    this.useSoftware = !0,
      this.logEnabled = !0,
      this.softwareDecrypt(e, t, n);
    const r = this.flush();
    if (r)
      return r.buffer;
    throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data")
  }
  getValidChunk(e) {
    let t = e;
    const n = e.length - e.length % 16;
    return n !== e.length && (t = gst(e, 0, n),
      this.remainderData = gst(e, n)),
      t
  }
  logOnce(e) {
    this.logEnabled && (Hit.log(`[decrypter]: ${e}`),
      this.logEnabled = !1)
  }
}
const Qut = function(e) {
  let t = "";
  const n = e.length;
  for (let r = 0; r < n; r++)
    t += `[${e.start(r).toFixed(3)}-${e.end(r).toFixed(3)}]`;
  return t
}
  , Jut = "STOPPED"
  , Zut = "IDLE"
  , ect = "KEY_LOADING"
  , tct = "FRAG_LOADING"
  , nct = "FRAG_LOADING_WAITING_RETRY"
  , rct = "WAITING_TRACK"
  , oct = "PARSING"
  , act = "PARSED"
  , ict = "ENDED"
  , sct = "ERROR"
  , lct = "WAITING_INIT_PTS"
  , uct = "WAITING_LEVEL";
class cct extends Mut {
  constructor(e, t, n, r, o) {
    super(),
      this.hls = void 0,
      this.fragPrevious = null,
      this.fragCurrent = null,
      this.fragmentTracker = void 0,
      this.transmuxer = null,
      this._state = Jut,
      this.playlistType = void 0,
      this.media = null,
      this.mediaBuffer = null,
      this.config = void 0,
      this.bitrateTest = !1,
      this.lastCurrentTime = 0,
      this.nextLoadPosition = 0,
      this.startPosition = 0,
      this.startTimeOffset = null,
      this.loadedmetadata = !1,
      this.retryDate = 0,
      this.levels = null,
      this.fragmentLoader = void 0,
      this.keyLoader = void 0,
      this.levelLastLoaded = null,
      this.startFragRequested = !1,
      this.decrypter = void 0,
      this.initPTS = [],
      this.onvseeking = null,
      this.onvended = null,
      this.logPrefix = "",
      this.log = void 0,
      this.warn = void 0,
      this.playlistType = o,
      this.logPrefix = r,
      this.log = Hit.log.bind(Hit, `${r}:`),
      this.warn = Hit.warn.bind(Hit, `${r}:`),
      this.hls = e,
      this.fragmentLoader = new Iut(e.config),
      this.keyLoader = n,
      this.fragmentTracker = t,
      this.config = e.config,
      this.decrypter = new Xut(e.config),
      e.on(Bit.MANIFEST_LOADED, this.onManifestLoaded, this)
  }
  doTick() {
    this.onTickEnd()
  }
  onTickEnd() {}
  startLoad(e) {}
  stopLoad() {
    this.fragmentLoader.abort(),
      this.keyLoader.abort(this.playlistType);
    const e = this.fragCurrent;
    null != e && e.loader && (e.abortRequests(),
      this.fragmentTracker.removeFragment(e)),
      this.resetTransmuxer(),
      this.fragCurrent = null,
      this.fragPrevious = null,
      this.clearInterval(),
      this.clearNextTick(),
      this.state = Jut
  }
  _streamEnded(e, t) {
    if (t.live || e.nextStart || !e.end || !this.media)
      return !1;
    const n = t.partList;
    if (null != n && n.length) {
      const e = n[n.length - 1];
      return Vut.isBuffered(this.media, e.start + e.duration / 2)
    }
    const r = t.fragments[t.fragments.length - 1].type;
    return this.fragmentTracker.isEndListAppended(r)
  }
  getLevelDetails() {
    var e;
    if (this.levels && null !== this.levelLastLoaded)
      return null == (e = this.levels[this.levelLastLoaded]) ? void 0 : e.details
  }
  onMediaAttached(e, t) {
    const n = this.media = this.mediaBuffer = t.media;
    this.onvseeking = this.onMediaSeeking.bind(this),
      this.onvended = this.onMediaEnded.bind(this),
      n.addEventListener("seeking", this.onvseeking),
      n.addEventListener("ended", this.onvended);
    const r = this.config;
    this.levels && r.autoStartLoad && this.state === Jut && this.startLoad(r.startPosition)
  }
  onMediaDetaching() {
    const e = this.media;
    null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"),
      this.startPosition = this.lastCurrentTime = 0),
    e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking),
      e.removeEventListener("ended", this.onvended),
      this.onvseeking = this.onvended = null),
    this.keyLoader && this.keyLoader.detach(),
      this.media = this.mediaBuffer = null,
      this.loadedmetadata = !1,
      this.fragmentTracker.removeAllFragments(),
      this.stopLoad()
  }
  onMediaSeeking() {
    const {config: e, fragCurrent: t, media: n, mediaBuffer: r, state: o} = this
      , a = n ? n.currentTime : 0
      , i = Vut.bufferInfo(r || n, a, e.maxBufferHole);
    if (this.log(`media seeking to ${Fit(a) ? a.toFixed(3) : a}, state: ${o}`),
    this.state === ict)
      this.resetLoadingState();
    else if (t) {
      const n = e.maxFragLookUpTolerance
        , r = t.start - n
        , o = t.start + t.duration + n;
      if (!i.len || o < i.start || r > i.end) {
        const e = a > o;
        (a < r || e) && (e && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"),
          t.abortRequests(),
          this.resetLoadingState()),
          this.fragPrevious = null)
      }
    }
    n && (this.fragmentTracker.removeFragmentsInRange(a, 1 / 0, this.playlistType, !0),
      this.lastCurrentTime = a),
    this.loadedmetadata || i.len || (this.nextLoadPosition = this.startPosition = a),
      this.tickImmediate()
  }
  onMediaEnded() {
    this.startPosition = this.lastCurrentTime = 0
  }
  onManifestLoaded(e, t) {
    this.startTimeOffset = t.startTimeOffset,
      this.initPTS = []
  }
  onHandlerDestroying() {
    this.stopLoad(),
      super.onHandlerDestroying()
  }
  onHandlerDestroyed() {
    this.state = Jut,
    this.fragmentLoader && this.fragmentLoader.destroy(),
    this.keyLoader && this.keyLoader.destroy(),
    this.decrypter && this.decrypter.destroy(),
      this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null,
      super.onHandlerDestroyed()
  }
  loadFragment(e, t, n) {
    this._loadFragForPlayback(e, t, n)
  }
  _loadFragForPlayback(e, t, n) {
    this._doFragLoad(e, t, n, (t=>{
        if (this.fragContextChanged(e))
          return this.warn(`Fragment ${e.sn}${t.part ? " p: " + t.part.index : ""} of level ${e.level} was dropped during download.`),
            void this.fragmentTracker.removeFragment(e);
        e.stats.chunkCount++,
          this._handleFragmentLoadProgress(t)
      }
    )).then((t=>{
        if (!t)
          return;
        const n = this.state;
        this.fragContextChanged(e) ? (n === tct || !this.fragCurrent && n === oct) && (this.fragmentTracker.removeFragment(e),
          this.state = Zut) : ("payload"in t && (this.log(`Loaded fragment ${e.sn} of level ${e.level}`),
          this.hls.trigger(Bit.FRAG_LOADED, t)),
          this._handleFragmentLoadComplete(t))
      }
    )).catch((t=>{
        this.state !== Jut && this.state !== sct && (this.warn(t),
          this.resetFragmentLoading(e))
      }
    ))
  }
  clearTrackerIfNeeded(e) {
    var t;
    const {fragmentTracker: n} = this;
    if (n.getState(e) === kut) {
      const t = e.type
        , r = this.getFwdBufferInfo(this.mediaBuffer, t)
        , o = Math.max(e.duration, r ? r.len : this.config.maxBufferLength);
      this.reduceMaxBufferLength(o) && n.removeFragment(e)
    } else
      0 === (null == (t = this.mediaBuffer) ? void 0 : t.buffered.length) ? n.removeAllFragments() : n.hasParts(e.type) && (n.detectPartialFragments({
        frag: e,
        part: null,
        stats: e.stats,
        id: e.type
      }),
      n.getState(e) === Tut && n.removeFragment(e))
  }
  flushMainBuffer(e, t, n=null) {
    if (!(e - t))
      return;
    const r = {
      startOffset: e,
      endOffset: t,
      type: n
    };
    this.hls.trigger(Bit.BUFFER_FLUSHING, r)
  }
  _loadInitSegment(e, t) {
    this._doFragLoad(e, t).then((t=>{
        if (!t || this.fragContextChanged(e) || !this.levels)
          throw new Error("init load aborted");
        return t
      }
    )).then((t=>{
        const {hls: n} = this
          , {payload: r} = t
          , o = e.decryptdata;
        if (r && r.byteLength > 0 && o && o.key && o.iv && "AES-128" === o.method) {
          const a = self.performance.now();
          return this.decrypter.decrypt(new Uint8Array(r), o.key.buffer, o.iv.buffer).catch((t=>{
              throw n.trigger(Bit.ERROR, {
                type: Nit.MEDIA_ERROR,
                details: Mit.FRAG_DECRYPT_ERROR,
                fatal: !1,
                error: t,
                reason: t.message,
                frag: e
              }),
                t
            }
          )).then((r=>{
              const o = self.performance.now();
              return n.trigger(Bit.FRAG_DECRYPTED, {
                frag: e,
                payload: r,
                stats: {
                  tstart: a,
                  tdecrypt: o
                }
              }),
                t.payload = r,
                t
            }
          ))
        }
        return t
      }
    )).then((n=>{
        const {fragCurrent: r, hls: o, levels: a} = this;
        if (!a)
          throw new Error("init load aborted, missing levels");
        const i = e.stats;
        this.state = Zut,
          t.fragmentError = 0,
          e.data = new Uint8Array(n.payload),
          i.parsing.start = i.buffering.start = self.performance.now(),
          i.parsing.end = i.buffering.end = self.performance.now(),
        n.frag === r && o.trigger(Bit.FRAG_BUFFERED, {
          stats: i,
          frag: r,
          part: null,
          id: e.type
        }),
          this.tick()
      }
    )).catch((t=>{
        this.state !== Jut && this.state !== sct && (this.warn(t),
          this.resetFragmentLoading(e))
      }
    ))
  }
  fragContextChanged(e) {
    const {fragCurrent: t} = this;
    return !e || !t || e.level !== t.level || e.sn !== t.sn || e.urlId !== t.urlId
  }
  fragBufferedComplete(e, t) {
    var n, r, o, a;
    const i = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.playlistType === Tlt ? "level" : "track"} ${e.level} (frag:[${(null != (n = e.startPTS) ? n : NaN).toFixed(3)}-${(null != (r = e.endPTS) ? r : NaN).toFixed(3)}] > buffer:${i ? Qut(Vut.getBuffered(i)) : "(detached)"})`),
      this.state = Zut,
    i && (!this.loadedmetadata && e.type == Tlt && i.buffered.length && (null == (o = this.fragCurrent) ? void 0 : o.sn) === (null == (a = this.fragPrevious) ? void 0 : a.sn) && (this.loadedmetadata = !0,
      this.seekToStartPos()),
      this.tick())
  }
  seekToStartPos() {}
  _handleFragmentLoadComplete(e) {
    const {transmuxer: t} = this;
    if (!t)
      return;
    const {frag: n, part: r, partsLoaded: o} = e
      , a = !o || 0 === o.length || o.some((e=>!e))
      , i = new Uut(n.level,n.sn,n.stats.chunkCount + 1,0,r ? r.index : -1,!a);
    t.flush(i)
  }
  _handleFragmentLoadProgress(e) {}
  _doFragLoad(e, t, n=null, r) {
    var o;
    const a = null == t ? void 0 : t.details;
    if (!this.levels || !a)
      throw new Error(`frag load aborted, missing level${a ? "" : " detail"}s`);
    let i = null;
    if (!e.encrypted || null != (o = e.decryptdata) && o.key ? !e.encrypted && a.encryptedFragments.length && this.keyLoader.loadClear(e, a.encryptedFragments) : (this.log(`Loading key for ${e.sn} of [${a.startSN}-${a.endSN}], ${"[stream-controller]" === this.logPrefix ? "level" : "track"} ${e.level}`),
      this.state = ect,
      this.fragCurrent = e,
      i = this.keyLoader.load(e).then((e=>{
          if (!this.fragContextChanged(e.frag))
            return this.hls.trigger(Bit.KEY_LOADED, e),
            this.state === ect && (this.state = Zut),
              e
        }
      )),
      this.hls.trigger(Bit.KEY_LOADING, {
        frag: e
      }),
    null === this.fragCurrent && (i = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING")))),
      n = Math.max(e.start, n || 0),
    this.config.lowLatencyMode && "initSegment" !== e.sn) {
      const o = a.partList;
      if (o && r) {
        n > e.end && a.fragmentHint && (e = a.fragmentHint);
        const s = this.getNextPart(o, e, n);
        if (s > -1) {
          const l = o[s];
          let u;
          return this.log(`Loading part sn: ${e.sn} p: ${l.index} cc: ${e.cc} of playlist [${a.startSN}-${a.endSN}] parts [0-${s}-${o.length - 1}] ${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${e.level}, target: ${parseFloat(n.toFixed(3))}`),
            this.nextLoadPosition = l.start + l.duration,
            this.state = tct,
            u = i ? i.then((n=>!n || this.fragContextChanged(n.frag) ? null : this.doFragPartsLoad(e, l, t, r))).catch((e=>this.handleFragLoadError(e))) : this.doFragPartsLoad(e, l, t, r).catch((e=>this.handleFragLoadError(e))),
            this.hls.trigger(Bit.FRAG_LOADING, {
              frag: e,
              part: l,
              targetBufferTime: n
            }),
            null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : u
        }
        if (!e.url || this.loadedEndOfParts(o, n))
          return Promise.resolve(null)
      }
    }
    this.log(`Loading fragment ${e.sn} cc: ${e.cc} ${a ? "of [" + a.startSN + "-" + a.endSN + "] " : ""}${"[stream-controller]" === this.logPrefix ? "level" : "track"}: ${e.level}, target: ${parseFloat(n.toFixed(3))}`),
    Fit(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration),
      this.state = tct;
    const s = this.config.progressive;
    let l;
    return l = s && i ? i.then((t=>!t || this.fragContextChanged(null == t ? void 0 : t.frag) ? null : this.fragmentLoader.load(e, r))).catch((e=>this.handleFragLoadError(e))) : Promise.all([this.fragmentLoader.load(e, s ? r : void 0), i]).then((([e])=>(!s && e && r && r(e),
      e))).catch((e=>this.handleFragLoadError(e))),
      this.hls.trigger(Bit.FRAG_LOADING, {
        frag: e,
        targetBufferTime: n
      }),
      null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : l
  }
  doFragPartsLoad(e, t, n, r) {
    return new Promise(((o,a)=>{
        var i;
        const s = []
          , l = null == (i = n.details) ? void 0 : i.partList
          , u = t=>{
            this.fragmentLoader.loadPart(e, t, r).then((r=>{
                s[t.index] = r;
                const a = r.part;
                this.hls.trigger(Bit.FRAG_LOADED, r);
                const i = nut(n, e.sn, t.index + 1) || rut(l, e.sn, t.index + 1);
                if (!i)
                  return o({
                    frag: e,
                    part: a,
                    partsLoaded: s
                  });
                u(i)
              }
            )).catch(a)
          }
        ;
        u(t)
      }
    ))
  }
  handleFragLoadError(e) {
    if ("data"in e) {
      const t = e.data;
      e.data && t.details === Mit.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(Bit.ERROR, t)
    } else
      this.hls.trigger(Bit.ERROR, {
        type: Nit.OTHER_ERROR,
        details: Mit.INTERNAL_EXCEPTION,
        err: e,
        error: e,
        fatal: !0
      });
    return null
  }
  _handleTransmuxerFlush(e) {
    const t = this.getCurrentContext(e);
    if (!t || this.state !== oct)
      return void (this.fragCurrent || this.state === Jut || this.state === sct || (this.state = Zut));
    const {frag: n, part: r, level: o} = t
      , a = self.performance.now();
    n.stats.parsing.end = a,
    r && (r.stats.parsing.end = a),
      this.updateLevelTiming(n, r, o, e.partial)
  }
  getCurrentContext(e) {
    const {levels: t, fragCurrent: n} = this
      , {level: r, sn: o, part: a} = e;
    if (null == t || !t[r])
      return this.warn(`Levels object was unset while buffering fragment ${o} of level ${r}. The current chunk will not be buffered.`),
        null;
    const i = t[r]
      , s = a > -1 ? nut(i, o, a) : null
      , l = s ? s.fragment : function(e, t, n) {
      if (null == e || !e.details)
        return null;
      const r = e.details;
      let o = r.fragments[t - r.startSN];
      return o || (o = r.fragmentHint,
        o && o.sn === t ? o : t < r.startSN && n && n.sn === t ? n : null)
    }(i, o, n);
    return l ? (n && n !== l && (l.stats = n.stats),
      {
        frag: l,
        part: s,
        level: i
      }) : null
  }
  bufferFragmentData(e, t, n, r, o) {
    var a;
    if (!e || this.state !== oct)
      return;
    const {data1: i, data2: s} = e;
    let l = i;
    if (i && s && (l = Wst(i, s)),
    null == (a = l) || !a.length)
      return;
    const u = {
      type: e.type,
      frag: t,
      part: n,
      chunkMeta: r,
      parent: t.type,
      data: l
    };
    if (this.hls.trigger(Bit.BUFFER_APPENDING, u),
    e.dropped && e.independent && !n) {
      if (o)
        return;
      this.flushBufferGap(t)
    }
  }
  flushBufferGap(e) {
    const t = this.media;
    if (!t)
      return;
    if (!Vut.isBuffered(t, t.currentTime))
      return void this.flushMainBuffer(0, e.start);
    const n = t.currentTime
      , r = Vut.bufferInfo(t, n, 0)
      , o = e.duration
      , a = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * o)
      , i = Math.max(Math.min(e.start - a, r.end - a), n + a);
    e.start - i > a && this.flushMainBuffer(i, e.start)
  }
  getFwdBufferInfo(e, t) {
    const n = this.getLoadPosition();
    return Fit(n) ? this.getFwdBufferInfoAtPos(e, n, t) : null
  }
  getFwdBufferInfoAtPos(e, t, n) {
    const {config: {maxBufferHole: r}} = this
      , o = Vut.bufferInfo(e, t, r);
    if (0 === o.len && void 0 !== o.nextStart) {
      const a = this.fragmentTracker.getBufferedFrag(t, n);
      if (a && o.nextStart < a.end)
        return Vut.bufferInfo(e, t, Math.max(o.nextStart, r))
    }
    return o
  }
  getMaxBufferLength(e) {
    const {config: t} = this;
    let n;
    return n = e ? Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : t.maxBufferLength,
      Math.min(n, t.maxMaxBufferLength)
  }
  reduceMaxBufferLength(e) {
    const t = this.config
      , n = e || t.maxBufferLength;
    return t.maxMaxBufferLength >= n && (t.maxMaxBufferLength /= 2,
      this.warn(`Reduce max buffer length to ${t.maxMaxBufferLength}s`),
      !0)
  }
  getAppendedFrag(e, t=Tlt) {
    const n = this.fragmentTracker.getAppendedFrag(e, Tlt);
    return n && "fragment"in n ? n.fragment : n
  }
  getNextFragment(e, t) {
    const n = t.fragments
      , r = n.length;
    if (!r)
      return null;
    const {config: o} = this
      , a = n[0].start;
    let i;
    if (t.live) {
      const a = o.initialLiveManifestSize;
      if (r < a)
        return this.warn(`Not enough fragments to start playback (have: ${r}, need: ${a})`),
          null;
      t.PTSKnown || this.startFragRequested || -1 !== this.startPosition || (i = this.getInitialLiveFragment(t, n),
        this.startPosition = i ? this.hls.liveSyncPosition || i.start : e)
    } else
      e <= a && (i = n[0]);
    if (!i) {
      const n = o.lowLatencyMode ? t.partEnd : t.fragmentEnd;
      i = this.getFragmentAtPosition(e, n, t)
    }
    return this.mapToInitFragWhenRequired(i)
  }
  isLoopLoading(e, t) {
    const n = this.fragmentTracker.getState(e);
    return (n === Dut || n === Tut && !!e.gap) && this.nextLoadPosition > t
  }
  getNextFragmentLoopLoading(e, t, n, r, o) {
    const a = e.gap
      , i = this.getNextFragment(this.nextLoadPosition, t);
    if (null === i)
      return i;
    if (e = i,
    a && e && !e.gap && n.nextStart) {
      const t = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, n.nextStart, r);
      if (null !== t && n.len + t.len >= o)
        return this.log(`buffer full after gaps in "${r}" playlist starting at sn: ${e.sn}`),
          null
    }
    return e
  }
  mapToInitFragWhenRequired(e) {
    return null == e || !e.initSegment || null != e && e.initSegment.data || this.bitrateTest ? e : e.initSegment
  }
  getNextPart(e, t, n) {
    let r = -1
      , o = !1
      , a = !0;
    for (let i = 0, s = e.length; i < s; i++) {
      const s = e[i];
      if (a = a && !s.independent,
      r > -1 && n < s.start)
        break;
      const l = s.loaded;
      l ? r = -1 : (o || s.independent || a) && s.fragment === t && (r = i),
        o = l
    }
    return r
  }
  loadedEndOfParts(e, t) {
    const n = e[e.length - 1];
    return n && t > n.start && n.loaded
  }
  getInitialLiveFragment(e, t) {
    const n = this.fragPrevious;
    let r = null;
    if (n) {
      if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${n.programDateTime}`),
        r = function(e, t, n) {
          if (null === t || !Array.isArray(e) || !e.length || !Fit(t))
            return null;
          if (t < (e[0].programDateTime || 0))
            return null;
          if (t >= (e[e.length - 1].endProgramDateTime || 0))
            return null;
          n = n || 0;
          for (let r = 0; r < e.length; ++r) {
            const o = e[r];
            if (fut(t, n, o))
              return o
          }
          return null
        }(t, n.endProgramDateTime, this.config.maxFragLookUpTolerance)),
        !r) {
        const o = n.sn + 1;
        if (o >= e.startSN && o <= e.endSN) {
          const a = t[o - e.startSN];
          n.cc === a.cc && (r = a,
            this.log(`Live playlist, switching playlist, load frag with next SN: ${r.sn}`))
        }
        r || (r = function(e, t) {
          return uut.search(e, (e=>e.cc < t ? 1 : e.cc > t ? -1 : 0))
        }(t, n.cc),
        r && this.log(`Live playlist, switching playlist, load frag with same CC: ${r.sn}`))
      }
    } else {
      const t = this.hls.liveSyncPosition;
      null !== t && (r = this.getFragmentAtPosition(t, this.bitrateTest ? e.fragmentEnd : e.edge, e))
    }
    return r
  }
  getFragmentAtPosition(e, t, n) {
    const {config: r} = this;
    let {fragPrevious: o} = this
      , {fragments: a, endSN: i} = n;
    const {fragmentHint: s} = n
      , l = r.maxFragLookUpTolerance
      , u = n.partList
      , c = !!(r.lowLatencyMode && null != u && u.length && s);
    let d;
    if (c && s && !this.bitrateTest && (a = a.concat(s),
      i = s.sn),
    e < t) {
      d = cut(o, a, e, e > t - l ? 0 : l)
    } else
      d = a[a.length - 1];
    if (d) {
      const e = d.sn - n.startSN
        , t = this.fragmentTracker.getState(d);
      if ((t === Dut || t === Tut && d.gap) && (o = d),
      o && d.sn === o.sn && (!c || u[0].fragment.sn > d.sn)) {
        if (o && d.level === o.level) {
          const t = a[e + 1];
          d = d.sn < i && this.fragmentTracker.getState(t) !== Dut ? t : null
        }
      }
    }
    return d
  }
  synchronizeToLiveEdge(e) {
    const {config: t, media: n} = this;
    if (!n)
      return;
    const r = this.hls.liveSyncPosition
      , o = n.currentTime
      , a = e.fragments[0].start
      , i = e.edge
      , s = o >= a - t.maxFragLookUpTolerance && o <= i;
    if (null !== r && n.duration > r && (o < r || !s)) {
      const a = void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
      (!s && n.readyState < 4 || o < i - a) && (this.loadedmetadata || (this.nextLoadPosition = r),
      n.readyState && (this.warn(`Playback: ${o.toFixed(3)} is located too far from the end of live sliding playlist: ${i}, reset currentTime to : ${r.toFixed(3)}`),
        n.currentTime = r))
    }
  }
  alignPlaylists(e, t) {
    const {levels: n, levelLastLoaded: r, fragPrevious: o} = this
      , a = null !== r ? n[r] : null
      , i = e.fragments.length;
    if (!i)
      return this.warn("No fragments in live playlist"),
        0;
    const s = e.fragments[0].start
      , l = !t
      , u = e.alignedSliding && Fit(s);
    if (l || !u && !s) {
      Kut(o, a, e);
      const n = e.fragments[0].start;
      return this.log(`Live playlist sliding: ${n.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} prev-sn: ${o ? o.sn : "na"} fragments: ${i}`),
        n
    }
    return s
  }
  waitForCdnTuneIn(e) {
    return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget)
  }
  setStartPosition(e, t) {
    let n = this.startPosition;
    if (n < t && (n = -1),
    -1 === n || -1 === this.lastCurrentTime) {
      const r = null !== this.startTimeOffset
        , o = r ? this.startTimeOffset : e.startTimeOffset;
      null !== o && Fit(o) ? (n = t + o,
      o < 0 && (n += e.totalduration),
        n = Math.min(Math.max(t, n), t + e.totalduration),
        this.log(`Start time offset ${o} found in ${r ? "multivariant" : "media"} playlist, adjust startPosition to ${n}`),
        this.startPosition = n) : e.live ? n = this.hls.liveSyncPosition || t : this.startPosition = n = 0,
        this.lastCurrentTime = n
    }
    this.nextLoadPosition = n
  }
  getLoadPosition() {
    const {media: e} = this;
    let t = 0;
    return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition),
      t
  }
  handleFragLoadAborted(e, t) {
    this.transmuxer && "initSegment" !== e.sn && e.stats.aborted && (this.warn(`Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} was aborted`),
      this.resetFragmentLoading(e))
  }
  resetFragmentLoading(e) {
    this.fragCurrent && (this.fragContextChanged(e) || this.state === nct) || (this.state = Zut)
  }
  onFragmentOrKeyLoadError(e, t) {
    if (t.chunkMeta && !t.frag) {
      const e = this.getCurrentContext(t.chunkMeta);
      e && (t.frag = e.frag)
    }
    const n = t.frag;
    if (!n || n.type !== e || !this.levels)
      return;
    var r;
    if (this.fragContextChanged(n))
      return void this.warn(`Frag load error must match current frag to retry ${n.url} > ${null == (r = this.fragCurrent) ? void 0 : r.url}`);
    const o = t.details === Mit.FRAG_GAP;
    o && this.fragmentTracker.fragBuffered(n, !0);
    const a = t.errorAction
      , {action: i, retryCount: s=0, retryConfig: l} = a || {};
    if (a && i === vut && l) {
      var u;
      this.resetStartWhenNotLoaded(null != (u = this.levelLastLoaded) ? u : n.level);
      const r = iut(l, s);
      this.warn(`Fragment ${n.sn} of ${e} ${n.level} errored with ${t.details}, retrying loading ${s + 1}/${l.maxNumRetry} in ${r}ms`),
        a.resolved = !0,
        this.retryDate = self.performance.now() + r,
        this.state = nct
    } else
      l && a ? (this.resetFragmentErrors(e),
        s < l.maxNumRetry ? o || (a.resolved = !0) : Hit.warn(`${t.details} reached or exceeded max retry (${s})`)) : (null == a ? void 0 : a.action) === hut ? this.state = uct : this.state = sct;
    this.tickImmediate()
  }
  reduceLengthAndFlushBuffer(e) {
    if (this.state === oct || this.state === act) {
      const t = e.parent
        , n = this.getFwdBufferInfo(this.mediaBuffer, t)
        , r = n && n.len > .5;
      r && this.reduceMaxBufferLength(n.len);
      const o = !r;
      return o && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${t} buffer`),
      e.frag && (this.fragmentTracker.removeFragment(e.frag),
        this.nextLoadPosition = e.frag.start),
        this.resetLoadingState(),
        o
    }
    return !1
  }
  resetFragmentErrors(e) {
    e === Dlt && (this.fragCurrent = null),
    this.loadedmetadata || (this.startFragRequested = !1),
    this.state !== Jut && (this.state = Zut)
  }
  afterBufferFlushed(e, t, n) {
    if (!e)
      return;
    const r = Vut.getBuffered(e);
    this.fragmentTracker.detectEvictedFragments(t, r, n),
    this.state === ict && this.resetLoadingState()
  }
  resetLoadingState() {
    this.log("Reset loading state"),
      this.fragCurrent = null,
      this.fragPrevious = null,
      this.state = Zut
  }
  resetStartWhenNotLoaded(e) {
    if (!this.loadedmetadata) {
      this.startFragRequested = !1;
      const t = this.levels ? this.levels[e].details : null;
      null != t && t.live ? (this.startPosition = -1,
        this.setStartPosition(t, 0),
        this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
    }
  }
  resetWhenMissingContext(e) {
    var t;
    this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`),
      this.removeUnbufferedFrags(),
      this.resetStartWhenNotLoaded(null != (t = this.levelLastLoaded) ? t : e.level),
      this.resetLoadingState()
  }
  removeUnbufferedFrags(e=0) {
    this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0)
  }
  updateLevelTiming(e, t, n, r) {
    var o;
    const a = n.details;
    if (!a)
      return void this.warn("level.details undefined");
    if (Object.keys(e.elementaryStreams).reduce(((t,o)=>{
        const i = e.elementaryStreams[o];
        if (i) {
          const s = i.endPTS - i.startPTS;
          if (s <= 0)
            return this.warn(`Could not parse fragment ${e.sn} ${o} duration reliably (${s})`),
            t || !1;
          const l = r ? 0 : Jlt(a, e, i.startPTS, i.endPTS, i.startDTS, i.endDTS);
          return this.hls.trigger(Bit.LEVEL_PTS_UPDATED, {
            details: a,
            level: n,
            drift: l,
            type: o,
            frag: e,
            start: i.startPTS,
            end: i.endPTS
          }),
            !0
        }
        return t
      }
    ), !1))
      n.fragmentError = 0;
    else if (null === (null == (o = this.transmuxer) ? void 0 : o.error)) {
      const t = new Error(`Found no media in fragment ${e.sn} of level ${e.level} resetting transmuxer to fallback to playlist timing`);
      if (0 === n.fragmentError && (n.fragmentError++,
        e.gap = !0,
        this.fragmentTracker.removeFragment(e),
        this.fragmentTracker.fragBuffered(e, !0)),
        this.warn(t.message),
        this.hls.trigger(Bit.ERROR, {
          type: Nit.MEDIA_ERROR,
          details: Mit.FRAG_PARSING_ERROR,
          fatal: !1,
          error: t,
          frag: e,
          reason: `Found no media in msn ${e.sn} of level "${n.url}"`
        }),
        !this.hls)
        return;
      this.resetTransmuxer()
    }
    this.state = act,
      this.hls.trigger(Bit.FRAG_PARSED, {
        frag: e,
        part: t
      })
  }
  resetTransmuxer() {
    this.transmuxer && (this.transmuxer.destroy(),
      this.transmuxer = null)
  }
  recoverWorkerError(e) {
    var t, n, r;
    "demuxerWorker" === e.event && (this.fragmentTracker.removeAllFragments(),
      this.resetTransmuxer(),
      this.resetStartWhenNotLoaded(null != (t = null != (n = this.levelLastLoaded) ? n : null == (r = this.fragCurrent) ? void 0 : r.level) ? t : 0),
      this.resetLoadingState())
  }
  set state(e) {
    const t = this._state;
    t !== e && (this._state = e,
      this.log(`${t}->${e}`))
  }
  get state() {
    return this._state
  }
}
function dct() {
  return self.SourceBuffer || self.WebKitSourceBuffer
}
function fct(e="", t=9e4) {
  return {
    type: e,
    id: -1,
    pid: -1,
    inputTimeScale: t,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  }
}
class pct {
  constructor() {
    this._audioTrack = void 0,
      this._id3Track = void 0,
      this.frameIndex = 0,
      this.cachedData = null,
      this.basePTS = null,
      this.initPTS = null,
      this.lastPTS = null
  }
  resetInitSegment(e, t, n, r) {
    this._id3Track = {
      type: "id3",
      id: 3,
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    }
  }
  resetTimeStamp(e) {
    this.initPTS = e,
      this.resetContiguity()
  }
  resetContiguity() {
    this.basePTS = null,
      this.lastPTS = null,
      this.frameIndex = 0
  }
  canParse(e, t) {
    return !1
  }
  appendFrame(e, t, n) {}
  demux(e, t) {
    this.cachedData && (e = Wst(this.cachedData, e),
      this.cachedData = null);
    let n, r = bst(e, 0), o = r ? r.length : 0;
    const a = this._audioTrack
      , i = this._id3Track
      , s = r ? (e=>{
        const t = Ast(e);
        for (let n = 0; n < t.length; n++) {
          const e = t[n];
          if (Sst(e))
            return Ost(e)
        }
      }
    )(r) : void 0
      , l = e.length;
    for ((null === this.basePTS || 0 === this.frameIndex && Fit(s)) && (this.basePTS = hct(s, t, this.initPTS),
      this.lastPTS = this.basePTS),
         null === this.lastPTS && (this.lastPTS = this.basePTS),
         r && r.length > 0 && i.samples.push({
           pts: this.lastPTS,
           dts: this.lastPTS,
           data: r,
           type: Nlt,
           duration: Number.POSITIVE_INFINITY
         }); o < l; ) {
      if (this.canParse(e, o)) {
        const t = this.appendFrame(a, e, o);
        t ? (this.frameIndex++,
          this.lastPTS = t.sample.pts,
          o += t.length,
          n = o) : o = l
      } else
        xst(e, o) ? (r = bst(e, o),
          i.samples.push({
            pts: this.lastPTS,
            dts: this.lastPTS,
            data: r,
            type: Nlt,
            duration: Number.POSITIVE_INFINITY
          }),
          o += r.length,
          n = o) : o++;
      if (o === l && n !== l) {
        const t = gst(e, n);
        this.cachedData ? this.cachedData = Wst(this.cachedData, t) : this.cachedData = t
      }
    }
    return {
      audioTrack: a,
      videoTrack: fct(),
      id3Track: i,
      textTrack: fct()
    }
  }
  demuxSampleAes(e, t, n) {
    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`))
  }
  flush(e) {
    const t = this.cachedData;
    return t && (this.cachedData = null,
      this.demux(t, 0)),
      {
        audioTrack: this._audioTrack,
        videoTrack: fct(),
        id3Track: this._id3Track,
        textTrack: fct()
      }
  }
  destroy() {}
}
const hct = (e,t,n)=>{
    if (Fit(e))
      return 90 * e;
    return 9e4 * t + (n ? 9e4 * n.baseTime / n.timescale : 0)
  }
;
function vct(e, t) {
  return 255 === e[t] && 240 == (246 & e[t + 1])
}
function gct(e, t) {
  return 1 & e[t + 1] ? 7 : 9
}
function mct(e, t) {
  return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5
}
function yct(e, t) {
  return t + 1 < e.length && vct(e, t)
}
function bct(e, t) {
  if (yct(e, t)) {
    const n = gct(e, t);
    if (t + n >= e.length)
      return !1;
    const r = mct(e, t);
    if (r <= n)
      return !1;
    const o = t + r;
    return o === e.length || yct(e, o)
  }
  return !1
}
function wct(e, t, n, r, o) {
  if (!e.samplerate) {
    const a = function(e, t, n, r) {
      let o, a, i, s;
      const l = navigator.userAgent.toLowerCase()
        , u = r
        , c = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
      o = 1 + ((192 & t[n + 2]) >>> 6);
      const d = (60 & t[n + 2]) >>> 2;
      if (!(d > c.length - 1))
        return i = (1 & t[n + 2]) << 2,
          i |= (192 & t[n + 3]) >>> 6,
          Hit.log(`manifest codec:${r}, ADTS type:${o}, samplingIndex:${d}`),
          /firefox/i.test(l) ? d >= 6 ? (o = 5,
            s = new Array(4),
            a = d - 3) : (o = 2,
            s = new Array(2),
            a = d) : -1 !== l.indexOf("android") ? (o = 2,
            s = new Array(2),
            a = d) : (o = 5,
            s = new Array(4),
            r && (-1 !== r.indexOf("mp4a.40.29") || -1 !== r.indexOf("mp4a.40.5")) || !r && d >= 6 ? a = d - 3 : ((r && -1 !== r.indexOf("mp4a.40.2") && (d >= 6 && 1 === i || /vivaldi/i.test(l)) || !r && 1 === i) && (o = 2,
              s = new Array(2)),
              a = d)),
          s[0] = o << 3,
          s[0] |= (14 & d) >> 1,
          s[1] |= (1 & d) << 7,
          s[1] |= i << 3,
        5 === o && (s[1] |= (14 & a) >> 1,
          s[2] = (1 & a) << 7,
          s[2] |= 8,
          s[3] = 0),
          {
            config: s,
            samplerate: c[d],
            channelCount: i,
            codec: "mp4a.40." + o,
            manifestCodec: u
          };
      e.trigger(Bit.ERROR, {
        type: Nit.MEDIA_ERROR,
        details: Mit.FRAG_PARSING_ERROR,
        fatal: !0,
        reason: `invalid ADTS sampling index:${d}`
      })
    }(t, n, r, o);
    if (!a)
      return;
    e.config = a.config,
      e.samplerate = a.samplerate,
      e.channelCount = a.channelCount,
      e.codec = a.codec,
      e.manifestCodec = a.manifestCodec,
      Hit.log(`parsed codec:${e.codec}, rate:${a.samplerate}, channels:${a.channelCount}`)
  }
}
function xct(e) {
  return 9216e4 / e
}
function Sct(e, t, n, r, o) {
  const a = r + o * xct(e.samplerate)
    , i = function(e, t) {
    const n = gct(e, t);
    if (t + n <= e.length) {
      const r = mct(e, t) - n;
      if (r > 0)
        return {
          headerLength: n,
          frameLength: r
        }
    }
  }(t, n);
  let s;
  if (i) {
    const {frameLength: r, headerLength: o} = i
      , l = o + r
      , u = Math.max(0, n + l - t.length);
    u ? (s = new Uint8Array(l - o),
      s.set(t.subarray(n + o, t.length), 0)) : s = t.subarray(n + o, n + l);
    const c = {
      unit: s,
      pts: a
    };
    return u || e.samples.push(c),
      {
        sample: c,
        length: l,
        missing: u
      }
  }
  const l = t.length - n;
  s = new Uint8Array(l),
    s.set(t.subarray(n, t.length), 0);
  return {
    sample: {
      unit: s,
      pts: a
    },
    length: l,
    missing: -1
  }
}
const Ect = /\/emsg[-/]ID3/i;
let Act = null;
const Cct = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160]
  , kct = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3]
  , Tct = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]]
  , Dct = [0, 1, 1, 4];
function Oct(e, t, n, r, o) {
  if (n + 24 > t.length)
    return;
  const a = _ct(t, n);
  if (a && n + a.frameLength <= t.length) {
    const i = r + o * (9e4 * a.samplesPerFrame / a.sampleRate)
      , s = {
      unit: t.subarray(n, n + a.frameLength),
      pts: i,
      dts: i
    };
    return e.config = [],
      e.channelCount = a.channelCount,
      e.samplerate = a.sampleRate,
      e.samples.push(s),
      {
        sample: s,
        length: a.frameLength,
        missing: 0
      }
  }
}
function _ct(e, t) {
  const n = e[t + 1] >> 3 & 3
    , r = e[t + 1] >> 1 & 3
    , o = e[t + 2] >> 4 & 15
    , a = e[t + 2] >> 2 & 3;
  if (1 !== n && 0 !== o && 15 !== o && 3 !== a) {
    const i = e[t + 2] >> 1 & 1
      , s = e[t + 3] >> 6
      , l = 1e3 * Cct[14 * (3 === n ? 3 - r : 3 === r ? 3 : 4) + o - 1]
      , u = kct[3 * (3 === n ? 0 : 2 === n ? 1 : 2) + a]
      , c = 3 === s ? 1 : 2
      , d = Tct[n][r]
      , f = Dct[r]
      , p = 8 * d * f
      , h = Math.floor(d * l / u + i) * f;
    if (null === Act) {
      const e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      Act = e ? parseInt(e[1]) : 0
    }
    return !!Act && Act <= 87 && 2 === r && l >= 224e3 && 0 === s && (e[t + 3] = 128 | e[t + 3]),
      {
        sampleRate: u,
        channelCount: c,
        frameLength: h,
        samplesPerFrame: p
      }
  }
}
function Rct(e, t) {
  return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1])
}
function Lct(e, t) {
  return t + 1 < e.length && Rct(e, t)
}
function Ict(e, t) {
  if (t + 1 < e.length && Rct(e, t)) {
    const n = 4
      , r = _ct(e, t);
    let o = n;
    null != r && r.frameLength && (o = r.frameLength);
    const a = t + o;
    return a === e.length || Lct(e, a)
  }
  return !1
}
class Pct {
  constructor(e) {
    this.data = void 0,
      this.bytesAvailable = void 0,
      this.word = void 0,
      this.bitsAvailable = void 0,
      this.data = e,
      this.bytesAvailable = e.byteLength,
      this.word = 0,
      this.bitsAvailable = 0
  }
  loadWord() {
    const e = this.data
      , t = this.bytesAvailable
      , n = e.byteLength - t
      , r = new Uint8Array(4)
      , o = Math.min(4, t);
    if (0 === o)
      throw new Error("no bytes available");
    r.set(e.subarray(n, n + o)),
      this.word = new DataView(r.buffer).getUint32(0),
      this.bitsAvailable = 8 * o,
      this.bytesAvailable -= o
  }
  skipBits(e) {
    let t;
    e = Math.min(e, 8 * this.bytesAvailable + this.bitsAvailable),
      this.bitsAvailable > e ? (this.word <<= e,
        this.bitsAvailable -= e) : (t = (e -= this.bitsAvailable) >> 3,
        e -= t << 3,
        this.bytesAvailable -= t,
        this.loadWord(),
        this.word <<= e,
        this.bitsAvailable -= e)
  }
  readBits(e) {
    let t = Math.min(this.bitsAvailable, e);
    const n = this.word >>> 32 - t;
    if (e > 32 && Hit.error("Cannot read more than 32 bits at a time"),
      this.bitsAvailable -= t,
    this.bitsAvailable > 0)
      this.word <<= t;
    else {
      if (!(this.bytesAvailable > 0))
        throw new Error("no bits available");
      this.loadWord()
    }
    return t = e - t,
      t > 0 && this.bitsAvailable ? n << t | this.readBits(t) : n
  }
  skipLZ() {
    let e;
    for (e = 0; e < this.bitsAvailable; ++e)
      if (0 != (this.word & 2147483648 >>> e))
        return this.word <<= e,
          this.bitsAvailable -= e,
          e;
    return this.loadWord(),
    e + this.skipLZ()
  }
  skipUEG() {
    this.skipBits(1 + this.skipLZ())
  }
  skipEG() {
    this.skipBits(1 + this.skipLZ())
  }
  readUEG() {
    const e = this.skipLZ();
    return this.readBits(e + 1) - 1
  }
  readEG() {
    const e = this.readUEG();
    return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
  }
  readBoolean() {
    return 1 === this.readBits(1)
  }
  readUByte() {
    return this.readBits(8)
  }
  readUShort() {
    return this.readBits(16)
  }
  readUInt() {
    return this.readBits(32)
  }
  skipScalingList(e) {
    let t, n = 8, r = 8;
    for (let o = 0; o < e; o++)
      0 !== r && (t = this.readEG(),
        r = (n + t + 256) % 256),
        n = 0 === r ? n : r
  }
  readSPS() {
    let e, t, n, r = 0, o = 0, a = 0, i = 0;
    const s = this.readUByte.bind(this)
      , l = this.readBits.bind(this)
      , u = this.readUEG.bind(this)
      , c = this.readBoolean.bind(this)
      , d = this.skipBits.bind(this)
      , f = this.skipEG.bind(this)
      , p = this.skipUEG.bind(this)
      , h = this.skipScalingList.bind(this);
    s();
    const v = s();
    if (l(5),
      d(3),
      s(),
      p(),
    100 === v || 110 === v || 122 === v || 244 === v || 44 === v || 83 === v || 86 === v || 118 === v || 128 === v) {
      const e = u();
      if (3 === e && d(1),
        p(),
        p(),
        d(1),
        c())
        for (t = 3 !== e ? 8 : 12,
               n = 0; n < t; n++)
          c() && h(n < 6 ? 16 : 64)
    }
    p();
    const g = u();
    if (0 === g)
      u();
    else if (1 === g)
      for (d(1),
             f(),
             f(),
             e = u(),
             n = 0; n < e; n++)
        f();
    p(),
      d(1);
    const m = u()
      , y = u()
      , b = l(1);
    0 === b && d(1),
      d(1),
    c() && (r = u(),
      o = u(),
      a = u(),
      i = u());
    let w = [1, 1];
    if (c() && c()) {
      switch (s()) {
        case 1:
          w = [1, 1];
          break;
        case 2:
          w = [12, 11];
          break;
        case 3:
          w = [10, 11];
          break;
        case 4:
          w = [16, 11];
          break;
        case 5:
          w = [40, 33];
          break;
        case 6:
          w = [24, 11];
          break;
        case 7:
          w = [20, 11];
          break;
        case 8:
          w = [32, 11];
          break;
        case 9:
          w = [80, 33];
          break;
        case 10:
          w = [18, 11];
          break;
        case 11:
          w = [15, 11];
          break;
        case 12:
          w = [64, 33];
          break;
        case 13:
          w = [160, 99];
          break;
        case 14:
          w = [4, 3];
          break;
        case 15:
          w = [3, 2];
          break;
        case 16:
          w = [2, 1];
          break;
        case 255:
          w = [s() << 8 | s(), s() << 8 | s()]
      }
    }
    return {
      width: Math.ceil(16 * (m + 1) - 2 * r - 2 * o),
      height: (2 - b) * (y + 1) * 16 - (b ? 2 : 4) * (a + i),
      pixelRatio: w
    }
  }
  readSliceType() {
    return this.readUByte(),
      this.readUEG(),
      this.readUEG()
  }
}
class Fct {
  constructor(e, t, n) {
    this.keyData = void 0,
      this.decrypter = void 0,
      this.keyData = n,
      this.decrypter = new Xut(t,{
        removePKCS7Padding: !1
      })
  }
  decryptBuffer(e) {
    return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer)
  }
  decryptAacSample(e, t, n) {
    const r = e[t].unit;
    if (r.length <= 16)
      return;
    const o = r.subarray(16, r.length - r.length % 16)
      , a = o.buffer.slice(o.byteOffset, o.byteOffset + o.length);
    this.decryptBuffer(a).then((o=>{
        const a = new Uint8Array(o);
        r.set(a, 16),
        this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, n)
      }
    ))
  }
  decryptAacSamples(e, t, n) {
    for (; ; t++) {
      if (t >= e.length)
        return void n();
      if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, n),
        !this.decrypter.isSync()))
        return
    }
  }
  getAvcEncryptedData(e) {
    const t = 16 * Math.floor((e.length - 48) / 160) + 16
      , n = new Int8Array(t);
    let r = 0;
    for (let o = 32; o < e.length - 16; o += 160,
      r += 16)
      n.set(e.subarray(o, o + 16), r);
    return n
  }
  getAvcDecryptedUnit(e, t) {
    const n = new Uint8Array(t);
    let r = 0;
    for (let o = 32; o < e.length - 16; o += 160,
      r += 16)
      e.set(n.subarray(r, r + 16), o);
    return e
  }
  decryptAvcSample(e, t, n, r, o) {
    const a = Xst(o.data)
      , i = this.getAvcEncryptedData(a);
    this.decryptBuffer(i.buffer).then((i=>{
        o.data = this.getAvcDecryptedUnit(a, i),
        this.decrypter.isSync() || this.decryptAvcSamples(e, t, n + 1, r)
      }
    ))
  }
  decryptAvcSamples(e, t, n, r) {
    if (e instanceof Uint8Array)
      throw new Error("Cannot decrypt samples of type Uint8Array");
    for (; ; t++,
               n = 0) {
      if (t >= e.length)
        return void r();
      const o = e[t].units;
      for (; !(n >= o.length); n++) {
        const a = o[n];
        if (!(a.data.length <= 48 || 1 !== a.type && 5 !== a.type || (this.decryptAvcSample(e, t, n, r, a),
          this.decrypter.isSync())))
          return
      }
    }
  }
}
const Bct = 188;
class Nct {
  constructor(e, t, n) {
    this.observer = void 0,
      this.config = void 0,
      this.typeSupported = void 0,
      this.sampleAes = null,
      this.pmtParsed = !1,
      this.audioCodec = void 0,
      this.videoCodec = void 0,
      this._duration = 0,
      this._pmtId = -1,
      this._avcTrack = void 0,
      this._audioTrack = void 0,
      this._id3Track = void 0,
      this._txtTrack = void 0,
      this.aacOverFlow = null,
      this.avcSample = null,
      this.remainderData = null,
      this.observer = e,
      this.config = t,
      this.typeSupported = n
  }
  static probe(e) {
    const t = Nct.syncOffset(e);
    return t > 0 && Hit.warn(`MPEG2-TS detected but first sync word found @ offset ${t}`),
    -1 !== t
  }
  static syncOffset(e) {
    const t = e.length;
    let n = Math.min(940, e.length - Bct) + 1
      , r = 0;
    for (; r < n; ) {
      let o = !1
        , a = -1
        , i = 0;
      for (let s = r; s < t; s += Bct) {
        if (71 !== e[s]) {
          if (i)
            return -1;
          break
        }
        if (i++,
        -1 === a && (a = s,
        0 !== a && (n = Math.min(a + 18612, e.length - Bct) + 1)),
        o || (o = 0 === jct(e, s)),
        o && i > 1 && (0 === a && i > 2 || s + Bct > n))
          return a
      }
      r++
    }
    return -1
  }
  static createTrack(e, t) {
    return {
      container: "video" === e || "audio" === e ? "video/mp2t" : void 0,
      type: e,
      id: Fst[e],
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: "audio" === e ? t : void 0
    }
  }
  resetInitSegment(e, t, n, r) {
    this.pmtParsed = !1,
      this._pmtId = -1,
      this._avcTrack = Nct.createTrack("video"),
      this._audioTrack = Nct.createTrack("audio", r),
      this._id3Track = Nct.createTrack("id3"),
      this._txtTrack = Nct.createTrack("text"),
      this._audioTrack.segmentCodec = "aac",
      this.aacOverFlow = null,
      this.avcSample = null,
      this.remainderData = null,
      this.audioCodec = t,
      this.videoCodec = n,
      this._duration = r
  }
  resetTimeStamp() {}
  resetContiguity() {
    const {_audioTrack: e, _avcTrack: t, _id3Track: n} = this;
    e && (e.pesData = null),
    t && (t.pesData = null),
    n && (n.pesData = null),
      this.aacOverFlow = null,
      this.avcSample = null,
      this.remainderData = null
  }
  demux(e, t, n=!1, r=!1) {
    let o;
    n || (this.sampleAes = null);
    const a = this._avcTrack
      , i = this._audioTrack
      , s = this._id3Track
      , l = this._txtTrack;
    let u = a.pid
      , c = a.pesData
      , d = i.pid
      , f = s.pid
      , p = i.pesData
      , h = s.pesData
      , v = null
      , g = this.pmtParsed
      , m = this._pmtId
      , y = e.length;
    if (this.remainderData && (y = (e = Wst(this.remainderData, e)).length,
      this.remainderData = null),
    y < Bct && !r)
      return this.remainderData = e,
        {
          audioTrack: i,
          videoTrack: a,
          id3Track: s,
          textTrack: l
        };
    const b = Math.max(0, Nct.syncOffset(e));
    y -= (y - b) % Bct,
    y < e.byteLength && !r && (this.remainderData = new Uint8Array(e.buffer,y,e.buffer.byteLength - y));
    let w = 0;
    for (let S = b; S < y; S += Bct)
      if (71 === e[S]) {
        const t = !!(64 & e[S + 1])
          , r = jct(e, S);
        let y;
        if ((48 & e[S + 3]) >> 4 > 1) {
          if (y = S + 5 + e[S + 4],
          y === S + Bct)
            continue
        } else
          y = S + 4;
        switch (r) {
          case u:
            t && (c && (o = $ct(c)) && this.parseAVCPES(a, l, o, !1),
              c = {
                data: [],
                size: 0
              }),
            c && (c.data.push(e.subarray(y, S + Bct)),
              c.size += S + Bct - y);
            break;
          case d:
            if (t) {
              if (p && (o = $ct(p)))
                switch (i.segmentCodec) {
                  case "aac":
                    this.parseAACPES(i, o);
                    break;
                  case "mp3":
                    this.parseMPEGPES(i, o)
                }
              p = {
                data: [],
                size: 0
              }
            }
            p && (p.data.push(e.subarray(y, S + Bct)),
              p.size += S + Bct - y);
            break;
          case f:
            t && (h && (o = $ct(h)) && this.parseID3PES(s, o),
              h = {
                data: [],
                size: 0
              }),
            h && (h.data.push(e.subarray(y, S + Bct)),
              h.size += S + Bct - y);
            break;
          case 0:
            t && (y += e[y] + 1),
              m = this._pmtId = Vct(e, y);
            break;
          case m:
          {
            t && (y += e[y] + 1);
            const r = Uct(e, y, this.typeSupported, n);
            u = r.avc,
            u > 0 && (a.pid = u),
              d = r.audio,
            d > 0 && (i.pid = d,
              i.segmentCodec = r.segmentCodec),
              f = r.id3,
            f > 0 && (s.pid = f),
            null === v || g || (Hit.warn(`MPEG-TS PMT found at ${S} after unknown PID '${v}'. Backtracking to sync byte @${b} to parse all TS packets.`),
              v = null,
              S = b - 188),
              g = this.pmtParsed = !0;
            break
          }
          case 17:
          case 8191:
            break;
          default:
            v = r
        }
      } else
        w++;
    if (w > 0) {
      const e = new Error(`Found ${w} TS packet/s that do not start with 0x47`);
      this.observer.emit(Bit.ERROR, Bit.ERROR, {
        type: Nit.MEDIA_ERROR,
        details: Mit.FRAG_PARSING_ERROR,
        fatal: !1,
        error: e,
        reason: e.message
      })
    }
    a.pesData = c,
      i.pesData = p,
      s.pesData = h;
    const x = {
      audioTrack: i,
      videoTrack: a,
      id3Track: s,
      textTrack: l
    };
    return r && this.extractRemainingSamples(x),
      x
  }
  flush() {
    const {remainderData: e} = this;
    let t;
    return this.remainderData = null,
      t = e ? this.demux(e, -1, !1, !0) : {
        videoTrack: this._avcTrack,
        audioTrack: this._audioTrack,
        id3Track: this._id3Track,
        textTrack: this._txtTrack
      },
      this.extractRemainingSamples(t),
      this.sampleAes ? this.decrypt(t, this.sampleAes) : t
  }
  extractRemainingSamples(e) {
    const {audioTrack: t, videoTrack: n, id3Track: r, textTrack: o} = e
      , a = n.pesData
      , i = t.pesData
      , s = r.pesData;
    let l;
    if (a && (l = $ct(a)) ? (this.parseAVCPES(n, o, l, !0),
      n.pesData = null) : n.pesData = a,
    i && (l = $ct(i))) {
      switch (t.segmentCodec) {
        case "aac":
          this.parseAACPES(t, l);
          break;
        case "mp3":
          this.parseMPEGPES(t, l)
      }
      t.pesData = null
    } else
      null != i && i.size && Hit.log("last AAC PES packet truncated,might overlap between fragments"),
        t.pesData = i;
    s && (l = $ct(s)) ? (this.parseID3PES(r, l),
      r.pesData = null) : r.pesData = s
  }
  demuxSampleAes(e, t, n) {
    const r = this.demux(e, n, !0, !this.config.progressive)
      , o = this.sampleAes = new Fct(this.observer,this.config,t);
    return this.decrypt(r, o)
  }
  decrypt(e, t) {
    return new Promise((n=>{
        const {audioTrack: r, videoTrack: o} = e;
        r.samples && "aac" === r.segmentCodec ? t.decryptAacSamples(r.samples, 0, (()=>{
            o.samples ? t.decryptAvcSamples(o.samples, 0, 0, (()=>{
                n(e)
              }
            )) : n(e)
          }
        )) : o.samples && t.decryptAvcSamples(o.samples, 0, 0, (()=>{
            n(e)
          }
        ))
      }
    ))
  }
  destroy() {
    this._duration = 0
  }
  parseAVCPES(e, t, n, r) {
    const o = this.parseAVCNALu(e, n.data);
    let a, i = this.avcSample, s = !1;
    n.data = null,
    i && o.length && !e.audFound && (Hct(i, e),
      i = this.avcSample = Mct(!1, n.pts, n.dts, "")),
      o.forEach((r=>{
          var o;
          switch (r.type) {
            case 1:
            {
              let t = !1;
              a = !0;
              const o = r.data;
              if (s && o.length > 4) {
                const e = new Pct(o).readSliceType();
                2 !== e && 4 !== e && 7 !== e && 9 !== e || (t = !0)
              }
              var l;
              if (t)
                null != (l = i) && l.frame && !i.key && (Hct(i, e),
                  i = this.avcSample = null);
              i || (i = this.avcSample = Mct(!0, n.pts, n.dts, "")),
                i.frame = !0,
                i.key = t;
              break
            }
            case 5:
              a = !0,
              null != (o = i) && o.frame && !i.key && (Hct(i, e),
                i = this.avcSample = null),
              i || (i = this.avcSample = Mct(!0, n.pts, n.dts, "")),
                i.key = !0,
                i.frame = !0;
              break;
            case 6:
              a = !0,
                Yst(r.data, 1, n.pts, t.samples);
              break;
            case 7:
              if (a = !0,
                s = !0,
                !e.sps) {
                const t = r.data
                  , n = new Pct(t).readSPS();
                e.width = n.width,
                  e.height = n.height,
                  e.pixelRatio = n.pixelRatio,
                  e.sps = [t],
                  e.duration = this._duration;
                const o = t.subarray(1, 4);
                let a = "avc1.";
                for (let e = 0; e < 3; e++) {
                  let t = o[e].toString(16);
                  t.length < 2 && (t = "0" + t),
                    a += t
                }
                e.codec = a
              }
              break;
            case 8:
              a = !0,
              e.pps || (e.pps = [r.data]);
              break;
            case 9:
              a = !1,
                e.audFound = !0,
              i && Hct(i, e),
                i = this.avcSample = Mct(!1, n.pts, n.dts, "");
              break;
            case 12:
              a = !0;
              break;
            default:
              a = !1,
              i && (i.debug += "unknown NAL " + r.type + " ")
          }
          if (i && a) {
            i.units.push(r)
          }
        }
      )),
    r && i && (Hct(i, e),
      this.avcSample = null)
  }
  getLastNalUnit(e) {
    var t;
    let n, r = this.avcSample;
    if (r && 0 !== r.units.length || (r = e[e.length - 1]),
    null != (t = r) && t.units) {
      const e = r.units;
      n = e[e.length - 1]
    }
    return n
  }
  parseAVCNALu(e, t) {
    const n = t.byteLength;
    let r = e.naluState || 0;
    const o = r
      , a = [];
    let i, s, l, u = 0, c = -1, d = 0;
    for (-1 === r && (c = 0,
      d = 31 & t[0],
      r = 0,
      u = 1); u < n; )
      if (i = t[u++],
        r)
        if (1 !== r)
          if (i)
            if (1 === i) {
              if (c >= 0) {
                const e = {
                  data: t.subarray(c, u - r - 1),
                  type: d
                };
                a.push(e)
              } else {
                const n = this.getLastNalUnit(e.samples);
                if (n && (o && u <= 4 - o && n.state && (n.data = n.data.subarray(0, n.data.byteLength - o)),
                  s = u - r - 1,
                s > 0)) {
                  const e = new Uint8Array(n.data.byteLength + s);
                  e.set(n.data, 0),
                    e.set(t.subarray(0, s), n.data.byteLength),
                    n.data = e,
                    n.state = 0
                }
              }
              u < n ? (l = 31 & t[u],
                c = u,
                d = l,
                r = 0) : r = -1
            } else
              r = 0;
          else
            r = 3;
        else
          r = i ? 0 : 2;
      else
        r = i ? 0 : 1;
    if (c >= 0 && r >= 0) {
      const e = {
        data: t.subarray(c, n),
        type: d,
        state: r
      };
      a.push(e)
    }
    if (0 === a.length) {
      const n = this.getLastNalUnit(e.samples);
      if (n) {
        const e = new Uint8Array(n.data.byteLength + t.byteLength);
        e.set(n.data, 0),
          e.set(t, n.data.byteLength),
          n.data = e
      }
    }
    return e.naluState = r,
      a
  }
  parseAACPES(e, t) {
    let n = 0;
    const r = this.aacOverFlow;
    let o, a, i, s = t.data;
    if (r) {
      this.aacOverFlow = null;
      const t = r.missing
        , o = r.sample.unit.byteLength;
      if (-1 === t) {
        const e = new Uint8Array(o + s.byteLength);
        e.set(r.sample.unit, 0),
          e.set(s, o),
          s = e
      } else {
        const a = o - t;
        r.sample.unit.set(s.subarray(0, t), a),
          e.samples.push(r.sample),
          n = r.missing
      }
    }
    for (o = n,
           a = s.length; o < a - 1 && !yct(s, o); o++)
      ;
    if (o !== n) {
      let e;
      const t = o < a - 1;
      e = t ? `AAC PES did not start with ADTS header,offset:${o}` : "No ADTS header found in AAC PES";
      const n = new Error(e);
      if (Hit.warn(`parsing error: ${e}`),
        this.observer.emit(Bit.ERROR, Bit.ERROR, {
          type: Nit.MEDIA_ERROR,
          details: Mit.FRAG_PARSING_ERROR,
          fatal: !1,
          levelRetry: t,
          error: n,
          reason: e
        }),
        !t)
        return
    }
    if (wct(e, this.observer, s, o, this.audioCodec),
    void 0 !== t.pts)
      i = t.pts;
    else {
      if (!r)
        return void Hit.warn("[tsdemuxer]: AAC PES unknown PTS");
      {
        const t = xct(e.samplerate);
        i = r.sample.pts + t
      }
    }
    let l, u = 0;
    for (; o < a; ) {
      if (l = Sct(e, s, o, i, u),
        o += l.length,
        l.missing) {
        this.aacOverFlow = l;
        break
      }
      for (u++; o < a - 1 && !yct(s, o); o++)
        ;
    }
  }
  parseMPEGPES(e, t) {
    const n = t.data
      , r = n.length;
    let o = 0
      , a = 0;
    const i = t.pts;
    if (void 0 !== i)
      for (; a < r; )
        if (Lct(n, a)) {
          const t = Oct(e, n, a, i, o);
          if (!t)
            break;
          a += t.length,
            o++
        } else
          a++;
    else
      Hit.warn("[tsdemuxer]: MPEG PES unknown PTS")
  }
  parseID3PES(e, t) {
    if (void 0 === t.pts)
      return void Hit.warn("[tsdemuxer]: ID3 PES unknown PTS");
    const n = Pit({}, t, {
      type: this._avcTrack ? jlt : Nlt,
      duration: Number.POSITIVE_INFINITY
    });
    e.samples.push(n)
  }
}
function Mct(e, t, n, r) {
  return {
    key: e,
    frame: !1,
    pts: t,
    dts: n,
    units: [],
    debug: r,
    length: 0
  }
}
function jct(e, t) {
  return ((31 & e[t + 1]) << 8) + e[t + 2]
}
function Vct(e, t) {
  return (31 & e[t + 10]) << 8 | e[t + 11]
}
function Uct(e, t, n, r) {
  const o = {
    audio: -1,
    avc: -1,
    id3: -1,
    segmentCodec: "aac"
  }
    , a = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4;
  for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < a; ) {
    const a = jct(e, t);
    switch (e[t]) {
      case 207:
        if (!r) {
          Hit.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
          break
        }
      case 15:
        -1 === o.audio && (o.audio = a);
        break;
      case 21:
        -1 === o.id3 && (o.id3 = a);
        break;
      case 219:
        if (!r) {
          Hit.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
          break
        }
      case 27:
        -1 === o.avc && (o.avc = a);
        break;
      case 3:
      case 4:
        !0 !== n.mpeg && !0 !== n.mp3 ? Hit.log("MPEG audio found, not supported in this browser") : -1 === o.audio && (o.audio = a,
          o.segmentCodec = "mp3");
        break;
      case 36:
        Hit.warn("Unsupported HEVC stream type found")
    }
    t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4])
  }
  return o
}
function $ct(e) {
  let t, n, r, o, a, i = 0;
  const s = e.data;
  if (!e || 0 === e.size)
    return null;
  for (; s[0].length < 19 && s.length > 1; ) {
    const e = new Uint8Array(s[0].length + s[1].length);
    e.set(s[0]),
      e.set(s[1], s[0].length),
      s[0] = e,
      s.splice(1, 1)
  }
  t = s[0];
  if (1 === (t[0] << 16) + (t[1] << 8) + t[2]) {
    if (n = (t[4] << 8) + t[5],
    n && n > e.size - 6)
      return null;
    const l = t[7];
    192 & l && (o = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2,
      64 & l ? (a = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2,
      o - a > 54e5 && (Hit.warn(`${Math.round((o - a) / 9e4)}s delta between PTS and DTS, align them`),
        o = a)) : a = o),
      r = t[8];
    let u = r + 9;
    if (e.size <= u)
      return null;
    e.size -= u;
    const c = new Uint8Array(e.size);
    for (let e = 0, n = s.length; e < n; e++) {
      t = s[e];
      let n = t.byteLength;
      if (u) {
        if (u > n) {
          u -= n;
          continue
        }
        t = t.subarray(u),
          n -= u,
          u = 0
      }
      c.set(t, i),
        i += n
    }
    return n && (n -= r + 3),
      {
        data: c,
        pts: o,
        dts: a,
        len: n
      }
  }
  return null
}
function Hct(e, t) {
  if (e.units.length && e.frame) {
    if (void 0 === e.pts) {
      const n = t.samples
        , r = n.length;
      if (!r)
        return void t.dropped++;
      {
        const t = n[r - 1];
        e.pts = t.pts,
          e.dts = t.dts
      }
    }
    t.samples.push(e)
  }
  e.debug.length && Hit.log(e.pts + "/" + e.dts + ":" + e.debug)
}
class zct {
  static getSilentFrame(e, t) {
    if ("mp4a.40.2" === e) {
      if (1 === t)
        return new Uint8Array([0, 200, 0, 128, 35, 128]);
      if (2 === t)
        return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
      if (3 === t)
        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
      if (4 === t)
        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
      if (5 === t)
        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
      if (6 === t)
        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
    } else {
      if (1 === t)
        return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
      if (2 === t)
        return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
      if (3 === t)
        return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
    }
  }
}
const Kct = Math.pow(2, 32) - 1;
class Wct {
  static init() {
    let e;
    for (e in Wct.types = {
      avc1: [],
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      ".mp3": [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    },
      Wct.types)
      Wct.types.hasOwnProperty(e) && (Wct.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
    const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0])
      , n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
    Wct.HDLR_TYPES = {
      video: t,
      audio: n
    };
    const r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1])
      , o = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
    Wct.STTS = Wct.STSC = Wct.STCO = o,
      Wct.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
      Wct.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]),
      Wct.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]),
      Wct.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
    const a = new Uint8Array([105, 115, 111, 109])
      , i = new Uint8Array([97, 118, 99, 49])
      , s = new Uint8Array([0, 0, 0, 1]);
    Wct.FTYP = Wct.box(Wct.types.ftyp, a, s, a, i),
      Wct.DINF = Wct.box(Wct.types.dinf, Wct.box(Wct.types.dref, r))
  }
  static box(e, ...t) {
    let n = 8
      , r = t.length;
    const o = r;
    for (; r--; )
      n += t[r].byteLength;
    const a = new Uint8Array(n);
    for (a[0] = n >> 24 & 255,
           a[1] = n >> 16 & 255,
           a[2] = n >> 8 & 255,
           a[3] = 255 & n,
           a.set(e, 4),
           r = 0,
           n = 8; r < o; r++)
      a.set(t[r], n),
        n += t[r].byteLength;
    return a
  }
  static hdlr(e) {
    return Wct.box(Wct.types.hdlr, Wct.HDLR_TYPES[e])
  }
  static mdat(e) {
    return Wct.box(Wct.types.mdat, e)
  }
  static mdhd(e, t) {
    t *= e;
    const n = Math.floor(t / (Kct + 1))
      , r = Math.floor(t % (Kct + 1));
    return Wct.box(Wct.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 85, 196, 0, 0]))
  }
  static mdia(e) {
    return Wct.box(Wct.types.mdia, Wct.mdhd(e.timescale, e.duration), Wct.hdlr(e.type), Wct.minf(e))
  }
  static mfhd(e) {
    return Wct.box(Wct.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e]))
  }
  static minf(e) {
    return "audio" === e.type ? Wct.box(Wct.types.minf, Wct.box(Wct.types.smhd, Wct.SMHD), Wct.DINF, Wct.stbl(e)) : Wct.box(Wct.types.minf, Wct.box(Wct.types.vmhd, Wct.VMHD), Wct.DINF, Wct.stbl(e))
  }
  static moof(e, t, n) {
    return Wct.box(Wct.types.moof, Wct.mfhd(e), Wct.traf(n, t))
  }
  static moov(e) {
    let t = e.length;
    const n = [];
    for (; t--; )
      n[t] = Wct.trak(e[t]);
    return Wct.box.apply(null, [Wct.types.moov, Wct.mvhd(e[0].timescale, e[0].duration)].concat(n).concat(Wct.mvex(e)))
  }
  static mvex(e) {
    let t = e.length;
    const n = [];
    for (; t--; )
      n[t] = Wct.trex(e[t]);
    return Wct.box.apply(null, [Wct.types.mvex, ...n])
  }
  static mvhd(e, t) {
    t *= e;
    const n = Math.floor(t / (Kct + 1))
      , r = Math.floor(t % (Kct + 1))
      , o = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
    return Wct.box(Wct.types.mvhd, o)
  }
  static sdtp(e) {
    const t = e.samples || []
      , n = new Uint8Array(4 + t.length);
    let r, o;
    for (r = 0; r < t.length; r++)
      o = t[r].flags,
        n[r + 4] = o.dependsOn << 4 | o.isDependedOn << 2 | o.hasRedundancy;
    return Wct.box(Wct.types.sdtp, n)
  }
  static stbl(e) {
    return Wct.box(Wct.types.stbl, Wct.stsd(e), Wct.box(Wct.types.stts, Wct.STTS), Wct.box(Wct.types.stsc, Wct.STSC), Wct.box(Wct.types.stsz, Wct.STSZ), Wct.box(Wct.types.stco, Wct.STCO))
  }
  static avc1(e) {
    let t, n, r, o = [], a = [];
    for (t = 0; t < e.sps.length; t++)
      n = e.sps[t],
        r = n.byteLength,
        o.push(r >>> 8 & 255),
        o.push(255 & r),
        o = o.concat(Array.prototype.slice.call(n));
    for (t = 0; t < e.pps.length; t++)
      n = e.pps[t],
        r = n.byteLength,
        a.push(r >>> 8 & 255),
        a.push(255 & r),
        a = a.concat(Array.prototype.slice.call(n));
    const i = Wct.box(Wct.types.avcC, new Uint8Array([1, o[3], o[4], o[5], 255, 224 | e.sps.length].concat(o).concat([e.pps.length]).concat(a)))
      , s = e.width
      , l = e.height
      , u = e.pixelRatio[0]
      , c = e.pixelRatio[1];
    return Wct.box(Wct.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, s >> 8 & 255, 255 & s, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), i, Wct.box(Wct.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), Wct.box(Wct.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u, c >> 24, c >> 16 & 255, c >> 8 & 255, 255 & c])))
  }
  static esds(e) {
    const t = e.config.length;
    return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]))
  }
  static mp4a(e) {
    const t = e.samplerate;
    return Wct.box(Wct.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]), Wct.box(Wct.types.esds, Wct.esds(e)))
  }
  static mp3(e) {
    const t = e.samplerate;
    return Wct.box(Wct.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]))
  }
  static stsd(e) {
    return "audio" === e.type ? "mp3" === e.segmentCodec && "mp3" === e.codec ? Wct.box(Wct.types.stsd, Wct.STSD, Wct.mp3(e)) : Wct.box(Wct.types.stsd, Wct.STSD, Wct.mp4a(e)) : Wct.box(Wct.types.stsd, Wct.STSD, Wct.avc1(e))
  }
  static tkhd(e) {
    const t = e.id
      , n = e.duration * e.timescale
      , r = e.width
      , o = e.height
      , a = Math.floor(n / (Kct + 1))
      , i = Math.floor(n % (Kct + 1));
    return Wct.box(Wct.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0, o >> 8 & 255, 255 & o, 0, 0]))
  }
  static traf(e, t) {
    const n = Wct.sdtp(e)
      , r = e.id
      , o = Math.floor(t / (Kct + 1))
      , a = Math.floor(t % (Kct + 1));
    return Wct.box(Wct.types.traf, Wct.box(Wct.types.tfhd, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), Wct.box(Wct.types.tfdt, new Uint8Array([1, 0, 0, 0, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a])), Wct.trun(e, n.length + 16 + 20 + 8 + 16 + 8 + 8), n)
  }
  static trak(e) {
    return e.duration = e.duration || 4294967295,
      Wct.box(Wct.types.trak, Wct.tkhd(e), Wct.mdia(e))
  }
  static trex(e) {
    const t = e.id;
    return Wct.box(Wct.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
  }
  static trun(e, t) {
    const n = e.samples || []
      , r = n.length
      , o = 12 + 16 * r
      , a = new Uint8Array(o);
    let i, s, l, u, c, d;
    for (t += 8 + o,
           a.set(["video" === e.type ? 1 : 0, 0, 15, 1, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0),
           i = 0; i < r; i++)
      s = n[i],
        l = s.duration,
        u = s.size,
        c = s.flags,
        d = s.cts,
        a.set([l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u, c.isLeading << 2 | c.dependsOn, c.isDependedOn << 6 | c.hasRedundancy << 4 | c.paddingValue << 1 | c.isNonSync, 61440 & c.degradPrio, 15 & c.degradPrio, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d], 12 + 16 * i);
    return Wct.box(Wct.types.trun, a)
  }
  static initSegment(e) {
    Wct.types || Wct.init();
    const t = Wct.moov(e)
      , n = new Uint8Array(Wct.FTYP.byteLength + t.byteLength);
    return n.set(Wct.FTYP),
      n.set(t, Wct.FTYP.byteLength),
      n
  }
}
Wct.types = void 0,
  Wct.HDLR_TYPES = void 0,
  Wct.STTS = void 0,
  Wct.STSC = void 0,
  Wct.STCO = void 0,
  Wct.STSZ = void 0,
  Wct.VMHD = void 0,
  Wct.SMHD = void 0,
  Wct.STSD = void 0,
  Wct.FTYP = void 0,
  Wct.DINF = void 0;
const Gct = 9e4;
function qct(e, t, n=1, r=!1) {
  const o = e * t * n;
  return r ? Math.round(o) : o
}
function Yct(e, t=!1) {
  return qct(e, 1e3, 1 / Gct, t)
}
let Xct, Qct = null, Jct = null;
class Zct {
  constructor(e, t, n, r="") {
    if (this.observer = void 0,
      this.config = void 0,
      this.typeSupported = void 0,
      this.ISGenerated = !1,
      this._initPTS = null,
      this._initDTS = null,
      this.nextAvcDts = null,
      this.nextAudioPts = null,
      this.videoSampleDuration = null,
      this.isAudioContiguous = !1,
      this.isVideoContiguous = !1,
      this.observer = e,
      this.config = t,
      this.typeSupported = n,
      this.ISGenerated = !1,
    null === Qct) {
      const e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      Qct = e ? parseInt(e[1]) : 0
    }
    if (null === Jct) {
      const e = navigator.userAgent.match(/Safari\/(\d+)/i);
      Jct = e ? parseInt(e[1]) : 0
    }
  }
  destroy() {}
  resetTimeStamp(e) {
    Hit.log("[mp4-remuxer]: initPTS & initDTS reset"),
      this._initPTS = this._initDTS = e
  }
  resetNextTimestamp() {
    Hit.log("[mp4-remuxer]: reset next timestamp"),
      this.isVideoContiguous = !1,
      this.isAudioContiguous = !1
  }
  resetInitSegment() {
    Hit.log("[mp4-remuxer]: ISGenerated flag reset"),
      this.ISGenerated = !1
  }
  getVideoStartPts(e) {
    let t = !1;
    const n = e.reduce(((e,n)=>{
        const r = n.pts - e;
        return r < -4294967296 ? (t = !0,
          edt(e, n.pts)) : r > 0 ? e : n.pts
      }
    ), e[0].pts);
    return t && Hit.debug("PTS rollover detected"),
      n
  }
  remux(e, t, n, r, o, a, i, s) {
    let l, u, c, d, f, p, h = o, v = o;
    const g = e.pid > -1
      , m = t.pid > -1
      , y = t.samples.length
      , b = e.samples.length > 0
      , w = i && y > 0 || y > 1;
    if ((!g || b) && (!m || w) || this.ISGenerated || i) {
      this.ISGenerated || (c = this.generateIS(e, t, o, a));
      const n = this.isVideoContiguous;
      let r, i = -1;
      if (w && (i = function(e) {
        for (let t = 0; t < e.length; t++)
          if (e[t].key)
            return t;
        return -1
      }(t.samples),
      !n && this.config.forceKeyFrameOnDiscontinuity))
        if (p = !0,
        i > 0) {
          Hit.warn(`[mp4-remuxer]: Dropped ${i} out of ${y} video samples due to a missing keyframe`);
          const e = this.getVideoStartPts(t.samples);
          t.samples = t.samples.slice(i),
            t.dropped += i,
            v += (t.samples[0].pts - e) / t.inputTimeScale,
            r = v
        } else
          -1 === i && (Hit.warn(`[mp4-remuxer]: No keyframe found out of ${y} video samples`),
            p = !1);
      if (this.ISGenerated) {
        if (b && w) {
          const n = this.getVideoStartPts(t.samples)
            , r = (edt(e.samples[0].pts, n) - n) / t.inputTimeScale;
          h += Math.max(0, r),
            v += Math.max(0, -r)
        }
        if (b) {
          if (e.samplerate || (Hit.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"),
            c = this.generateIS(e, t, o, a)),
            u = this.remuxAudio(e, h, this.isAudioContiguous, a, m || w || s === Dlt ? v : void 0),
            w) {
            const r = u ? u.endPTS - u.startPTS : 0;
            t.inputTimeScale || (Hit.warn("[mp4-remuxer]: regenerate InitSegment as video detected"),
              c = this.generateIS(e, t, o, a)),
              l = this.remuxVideo(t, v, n, r)
          }
        } else
          w && (l = this.remuxVideo(t, v, n, 0));
        l && (l.firstKeyFrame = i,
          l.independent = -1 !== i,
          l.firstKeyFramePTS = r)
      }
    }
    return this.ISGenerated && this._initPTS && this._initDTS && (n.samples.length && (f = tdt(n, o, this._initPTS, this._initDTS)),
    r.samples.length && (d = ndt(r, o, this._initPTS))),
      {
        audio: u,
        video: l,
        initSegment: c,
        independent: p,
        text: d,
        id3: f
      }
  }
  generateIS(e, t, n, r) {
    const o = e.samples
      , a = t.samples
      , i = this.typeSupported
      , s = {}
      , l = this._initPTS;
    let u, c, d, f = !l || r, p = "audio/mp4";
    if (f && (u = c = 1 / 0),
    e.config && o.length) {
      if (e.timescale = e.samplerate,
      "mp3" === e.segmentCodec)
        i.mpeg ? (p = "audio/mpeg",
          e.codec = "") : i.mp3 && (e.codec = "mp3");
      s.audio = {
        id: "audio",
        container: p,
        codec: e.codec,
        initSegment: "mp3" === e.segmentCodec && i.mpeg ? new Uint8Array(0) : Wct.initSegment([e]),
        metadata: {
          channelCount: e.channelCount
        }
      },
      f && (d = e.inputTimeScale,
        l && d === l.timescale ? f = !1 : u = c = o[0].pts - Math.round(d * n))
    }
    if (t.sps && t.pps && a.length && (t.timescale = t.inputTimeScale,
      s.video = {
        id: "main",
        container: "video/mp4",
        codec: t.codec,
        initSegment: Wct.initSegment([t]),
        metadata: {
          width: t.width,
          height: t.height
        }
      },
      f))
      if (d = t.inputTimeScale,
      l && d === l.timescale)
        f = !1;
      else {
        const e = this.getVideoStartPts(a)
          , t = Math.round(d * n);
        c = Math.min(c, edt(a[0].dts, e) - t),
          u = Math.min(u, e - t)
      }
    if (Object.keys(s).length)
      return this.ISGenerated = !0,
        f ? (this._initPTS = {
          baseTime: u,
          timescale: d
        },
          this._initDTS = {
            baseTime: c,
            timescale: d
          }) : u = d = void 0,
        {
          tracks: s,
          initPTS: u,
          timescale: d
        }
  }
  remuxVideo(e, t, n, r) {
    const o = e.inputTimeScale
      , a = e.samples
      , i = []
      , s = a.length
      , l = this._initPTS;
    let u, c, d = this.nextAvcDts, f = 8, p = this.videoSampleDuration, h = Number.POSITIVE_INFINITY, v = Number.NEGATIVE_INFINITY, g = !1;
    if (!n || null === d) {
      d = t * o - (a[0].pts - edt(a[0].dts, a[0].pts))
    }
    const m = l.baseTime * o / l.timescale;
    for (let L = 0; L < s; L++) {
      const e = a[L];
      e.pts = edt(e.pts - m, d),
        e.dts = edt(e.dts - m, d),
      e.dts < a[L > 0 ? L - 1 : L].dts && (g = !0)
    }
    g && a.sort((function(e, t) {
        const n = e.dts - t.dts
          , r = e.pts - t.pts;
        return n || r
      }
    )),
      u = a[0].dts,
      c = a[a.length - 1].dts;
    const y = c - u
      , b = y ? Math.round(y / (s - 1)) : p || e.inputTimeScale / 30;
    if (n) {
      const e = u - d
        , t = e > b
        , n = e < -1;
      if ((t || n) && (t ? Hit.warn(`AVC: ${Yct(e, !0)} ms (${e}dts) hole between fragments detected, filling it`) : Hit.warn(`AVC: ${Yct(-e, !0)} ms (${e}dts) overlapping between fragments detected`),
      !n || d >= a[0].pts)) {
        u = d;
        const t = a[0].pts - e;
        a[0].dts = u,
          a[0].pts = t,
          Hit.log(`Video: First PTS/DTS adjusted: ${Yct(t, !0)}/${Yct(u, !0)}, delta: ${Yct(e, !0)} ms`)
      }
    }
    u = Math.max(0, u);
    let w = 0
      , x = 0;
    for (let L = 0; L < s; L++) {
      const e = a[L]
        , t = e.units
        , n = t.length;
      let r = 0;
      for (let o = 0; o < n; o++)
        r += t[o].data.length;
      x += r,
        w += n,
        e.length = r,
        e.dts = Math.max(e.dts, u),
        h = Math.min(e.pts, h),
        v = Math.max(e.pts, v)
    }
    c = a[s - 1].dts;
    const S = x + 4 * w + 8;
    let E;
    try {
      E = new Uint8Array(S)
    } catch (R) {
      return void this.observer.emit(Bit.ERROR, Bit.ERROR, {
        type: Nit.MUX_ERROR,
        details: Mit.REMUX_ALLOC_ERROR,
        fatal: !1,
        error: R,
        bytes: S,
        reason: `fail allocating video mdat ${S}`
      })
    }
    const A = new DataView(E.buffer);
    A.setUint32(0, S),
      E.set(Wct.types.mdat, 4);
    let C = !1
      , k = Number.POSITIVE_INFINITY
      , T = Number.POSITIVE_INFINITY
      , D = Number.NEGATIVE_INFINITY
      , O = Number.NEGATIVE_INFINITY;
    for (let L = 0; L < s; L++) {
      const e = a[L]
        , t = e.units;
      let n, l = 0;
      for (let r = 0, o = t.length; r < o; r++) {
        const e = t[r]
          , n = e.data
          , o = e.data.byteLength;
        A.setUint32(f, o),
          f += 4,
          E.set(n, f),
          f += o,
          l += 4 + o
      }
      if (L < s - 1)
        p = a[L + 1].dts - e.dts,
          n = a[L + 1].pts - e.pts;
      else {
        const t = this.config
          , i = L > 0 ? e.dts - a[L - 1].dts : b;
        if (n = L > 0 ? e.pts - a[L - 1].pts : b,
        t.stretchShortVideoTrack && null !== this.nextAudioPts) {
          const n = Math.floor(t.maxBufferHole * o)
            , a = (r ? h + r * o : this.nextAudioPts) - e.pts;
          a > n ? (p = a - i,
            p < 0 ? p = i : C = !0,
            Hit.log(`[mp4-remuxer]: It is approximately ${a / 90} ms to the next segment; using duration ${p / 90} ms for the last video frame.`)) : p = i
        } else
          p = i
      }
      const u = Math.round(e.pts - e.dts);
      k = Math.min(k, p),
        D = Math.max(D, p),
        T = Math.min(T, n),
        O = Math.max(O, n),
        i.push(new rdt(e.key,p,l,u))
    }
    if (i.length)
      if (Qct) {
        if (Qct < 70) {
          const e = i[0].flags;
          e.dependsOn = 2,
            e.isNonSync = 0
        }
      } else if (Jct && O - T < D - k && b / D < .025 && 0 === i[0].cts) {
        Hit.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
        let e = u;
        for (let t = 0, n = i.length; t < n; t++) {
          const r = e + i[t].duration
            , o = e + i[t].cts;
          if (t < n - 1) {
            const e = r + i[t + 1].cts;
            i[t].duration = e - o
          } else
            i[t].duration = t ? i[t - 1].duration : b;
          i[t].cts = 0,
            e = r
        }
      }
    p = C || !p ? b : p,
      this.nextAvcDts = d = c + p,
      this.videoSampleDuration = p,
      this.isVideoContiguous = !0;
    const _ = {
      data1: Wct.moof(e.sequenceNumber++, u, Pit({}, e, {
        samples: i
      })),
      data2: E,
      startPTS: h / o,
      endPTS: (v + p) / o,
      startDTS: u / o,
      endDTS: d / o,
      type: "video",
      hasAudio: !1,
      hasVideo: !0,
      nb: i.length,
      dropped: e.dropped
    };
    return e.samples = [],
      e.dropped = 0,
      _
  }
  remuxAudio(e, t, n, r, o) {
    const a = e.inputTimeScale
      , i = a / (e.samplerate ? e.samplerate : a)
      , s = "aac" === e.segmentCodec ? 1024 : 1152
      , l = s * i
      , u = this._initPTS
      , c = "mp3" === e.segmentCodec && this.typeSupported.mpeg
      , d = []
      , f = void 0 !== o;
    let p = e.samples
      , h = c ? 0 : 8
      , v = this.nextAudioPts || -1;
    const g = t * a
      , m = u.baseTime * a / u.timescale;
    if (this.isAudioContiguous = n = n || p.length && v > 0 && (r && Math.abs(g - v) < 9e3 || Math.abs(edt(p[0].pts - m, g) - v) < 20 * l),
      p.forEach((function(e) {
          e.pts = edt(e.pts - m, g)
        }
      )),
    !n || v < 0) {
      if (p = p.filter((e=>e.pts >= 0)),
        !p.length)
        return;
      v = 0 === o ? 0 : r && !f ? Math.max(0, g) : p[0].pts
    }
    if ("aac" === e.segmentCodec) {
      const t = this.config.maxAudioFramesDrift;
      for (let n = 0, r = v; n < p.length; n++) {
        const o = p[n]
          , i = o.pts
          , s = i - r
          , u = Math.abs(1e3 * s / a);
        if (s <= -t * l && f)
          0 === n && (Hit.warn(`Audio frame @ ${(i / a).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * s / a)} ms.`),
            this.nextAudioPts = v = r = i);
        else if (s >= t * l && u < 1e4 && f) {
          let t = Math.round(s / l);
          r = i - t * l,
          r < 0 && (t--,
            r += l),
          0 === n && (this.nextAudioPts = v = r),
            Hit.warn(`[mp4-remuxer]: Injecting ${t} audio frame @ ${(r / a).toFixed(3)}s due to ${Math.round(1e3 * s / a)} ms gap.`);
          for (let a = 0; a < t; a++) {
            const t = Math.max(r, 0);
            let a = zct.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
            a || (Hit.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."),
              a = o.unit.subarray()),
              p.splice(n, 0, {
                unit: a,
                pts: t
              }),
              r += l,
              n++
          }
        }
        o.pts = r,
          r += l
      }
    }
    let y, b = null, w = null, x = 0, S = p.length;
    for (; S--; )
      x += p[S].unit.byteLength;
    for (let _ = 0, R = p.length; _ < R; _++) {
      const t = p[_]
        , r = t.unit;
      let o = t.pts;
      if (null !== w) {
        d[_ - 1].duration = Math.round((o - w) / i)
      } else {
        if (n && "aac" === e.segmentCodec && (o = v),
          b = o,
          !(x > 0))
          return;
        x += h;
        try {
          y = new Uint8Array(x)
        } catch (O) {
          return void this.observer.emit(Bit.ERROR, Bit.ERROR, {
            type: Nit.MUX_ERROR,
            details: Mit.REMUX_ALLOC_ERROR,
            fatal: !1,
            error: O,
            bytes: x,
            reason: `fail allocating audio mdat ${x}`
          })
        }
        if (!c) {
          new DataView(y.buffer).setUint32(0, x),
            y.set(Wct.types.mdat, 4)
        }
      }
      y.set(r, h);
      const a = r.byteLength;
      h += a,
        d.push(new rdt(!0,s,a,0)),
        w = o
    }
    const E = d.length;
    if (!E)
      return;
    const A = d[d.length - 1];
    this.nextAudioPts = v = w + i * A.duration;
    const C = c ? new Uint8Array(0) : Wct.moof(e.sequenceNumber++, b / i, Pit({}, e, {
      samples: d
    }));
    e.samples = [];
    const k = b / a
      , T = v / a
      , D = {
      data1: C,
      data2: y,
      startPTS: k,
      endPTS: T,
      startDTS: k,
      endDTS: T,
      type: "audio",
      hasAudio: !0,
      hasVideo: !1,
      nb: E
    };
    return this.isAudioContiguous = !0,
      D
  }
  remuxEmptyAudio(e, t, n, r) {
    const o = e.inputTimeScale
      , a = o / (e.samplerate ? e.samplerate : o)
      , i = this.nextAudioPts
      , s = this._initDTS
      , l = 9e4 * s.baseTime / s.timescale
      , u = (null !== i ? i : r.startDTS * o) + l
      , c = r.endDTS * o + l
      , d = 1024 * a
      , f = Math.ceil((c - u) / d)
      , p = zct.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
    if (Hit.warn("[mp4-remuxer]: remux empty Audio"),
      !p)
      return void Hit.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
    const h = [];
    for (let v = 0; v < f; v++) {
      const e = u + v * d;
      h.push({
        unit: p,
        pts: e,
        dts: e
      })
    }
    return e.samples = h,
      this.remuxAudio(e, t, n, !1)
  }
}
function edt(e, t) {
  let n;
  if (null === t)
    return e;
  for (n = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296; )
    e += n;
  return e
}
function tdt(e, t, n, r) {
  const o = e.samples.length;
  if (!o)
    return;
  const a = e.inputTimeScale;
  for (let s = 0; s < o; s++) {
    const o = e.samples[s];
    o.pts = edt(o.pts - n.baseTime * a / n.timescale, t * a) / a,
      o.dts = edt(o.dts - r.baseTime * a / r.timescale, t * a) / a
  }
  const i = e.samples;
  return e.samples = [],
    {
      samples: i
    }
}
function ndt(e, t, n) {
  const r = e.samples.length;
  if (!r)
    return;
  const o = e.inputTimeScale;
  for (let i = 0; i < r; i++) {
    const r = e.samples[i];
    r.pts = edt(r.pts - n.baseTime * o / n.timescale, t * o) / o
  }
  e.samples.sort(((e,t)=>e.pts - t.pts));
  const a = e.samples;
  return e.samples = [],
    {
      samples: a
    }
}
class rdt {
  constructor(e, t, n, r) {
    this.size = void 0,
      this.duration = void 0,
      this.cts = void 0,
      this.flags = void 0,
      this.duration = t,
      this.size = n,
      this.cts = r,
      this.flags = new odt(e)
  }
}
class odt {
  constructor(e) {
    this.isLeading = 0,
      this.isDependedOn = 0,
      this.hasRedundancy = 0,
      this.degradPrio = 0,
      this.dependsOn = 1,
      this.isNonSync = 1,
      this.dependsOn = e ? 2 : 1,
      this.isNonSync = e ? 0 : 1
  }
}
function adt(e, t) {
  const n = null == e ? void 0 : e.codec;
  return n && n.length > 4 ? n : "hvc1" === n || "hev1" === n ? "hvc1.1.6.L120.90" : "av01" === n ? "av01.0.04M.08" : "avc1" === n || t === Qit ? "avc1.42e01e" : "mp4a.40.5"
}
try {
  Xct = self.performance.now.bind(self.performance)
} catch (ubt) {
  Hit.debug("Unable to use Performance API on this environment"),
    Xct = "undefined" != typeof self && self.Date.now
}
const idt = [{
  demux: class {
    constructor(e, t) {
      this.remainderData = null,
        this.timeOffset = 0,
        this.config = void 0,
        this.videoTrack = void 0,
        this.audioTrack = void 0,
        this.id3Track = void 0,
        this.txtTrack = void 0,
        this.config = t
    }
    resetTimeStamp() {}
    resetInitSegment(e, t, n, r) {
      const o = this.videoTrack = fct("video", 1)
        , a = this.audioTrack = fct("audio", 1)
        , i = this.txtTrack = fct("text", 1);
      if (this.id3Track = fct("id3", 1),
        this.timeOffset = 0,
      null == e || !e.byteLength)
        return;
      const s = Hst(e);
      if (s.video) {
        const {id: e, timescale: t, codec: n} = s.video;
        o.id = e,
          o.timescale = i.timescale = t,
          o.codec = n
      }
      if (s.audio) {
        const {id: e, timescale: t, codec: n} = s.audio;
        a.id = e,
          a.timescale = t,
          a.codec = n
      }
      i.id = Fst.text,
        o.sampleDuration = 0,
        o.duration = a.duration = r
    }
    resetContiguity() {
      this.remainderData = null
    }
    static probe(e) {
      return Ust(e = e.length > 16384 ? e.subarray(0, 16384) : e, ["moof"]).length > 0
    }
    demux(e, t) {
      this.timeOffset = t;
      let n = e;
      const r = this.videoTrack
        , o = this.txtTrack;
      if (this.config.progressive) {
        this.remainderData && (n = Wst(this.remainderData, e));
        const t = function(e) {
          const t = {
            valid: null,
            remainder: null
          }
            , n = Ust(e, ["moof"]);
          if (!n)
            return t;
          if (n.length < 2)
            return t.remainder = e,
              t;
          const r = n[n.length - 1];
          return t.valid = gst(e, 0, r.byteOffset - 8),
            t.remainder = gst(e, r.byteOffset - 8),
            t
        }(n);
        this.remainderData = t.remainder,
          r.samples = t.valid || new Uint8Array
      } else
        r.samples = n;
      const a = this.extractID3Track(r, t);
      return o.samples = Gst(t, r),
        {
          videoTrack: r,
          audioTrack: this.audioTrack,
          id3Track: a,
          textTrack: this.txtTrack
        }
    }
    flush() {
      const e = this.timeOffset
        , t = this.videoTrack
        , n = this.txtTrack;
      t.samples = this.remainderData || new Uint8Array,
        this.remainderData = null;
      const r = this.extractID3Track(t, this.timeOffset);
      return n.samples = Gst(e, t),
        {
          videoTrack: t,
          audioTrack: fct(),
          id3Track: r,
          textTrack: fct()
        }
    }
    extractID3Track(e, t) {
      const n = this.id3Track;
      if (e.samples.length) {
        const r = Ust(e.samples, ["emsg"]);
        r && r.forEach((e=>{
            const r = function(e) {
              const t = e[0];
              let n = ""
                , r = ""
                , o = 0
                , a = 0
                , i = 0
                , s = 0
                , l = 0
                , u = 0;
              if (0 === t) {
                for (; "\0" !== Bst(e.subarray(u, u + 1)); )
                  n += Bst(e.subarray(u, u + 1)),
                    u += 1;
                for (n += Bst(e.subarray(u, u + 1)),
                       u += 1; "\0" !== Bst(e.subarray(u, u + 1)); )
                  r += Bst(e.subarray(u, u + 1)),
                    u += 1;
                r += Bst(e.subarray(u, u + 1)),
                  u += 1,
                  o = Mst(e, 12),
                  a = Mst(e, 16),
                  s = Mst(e, 20),
                  l = Mst(e, 24),
                  u = 28
              } else if (1 === t) {
                u += 4,
                  o = Mst(e, u),
                  u += 4;
                const t = Mst(e, u);
                u += 4;
                const a = Mst(e, u);
                for (u += 4,
                       i = 2 ** 32 * t + a,
                     Number.isSafeInteger(i) || (i = Number.MAX_SAFE_INTEGER,
                       Hit.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")),
                       s = Mst(e, u),
                       u += 4,
                       l = Mst(e, u),
                       u += 4; "\0" !== Bst(e.subarray(u, u + 1)); )
                  n += Bst(e.subarray(u, u + 1)),
                    u += 1;
                for (n += Bst(e.subarray(u, u + 1)),
                       u += 1; "\0" !== Bst(e.subarray(u, u + 1)); )
                  r += Bst(e.subarray(u, u + 1)),
                    u += 1;
                r += Bst(e.subarray(u, u + 1)),
                  u += 1
              }
              return {
                schemeIdUri: n,
                value: r,
                timeScale: o,
                presentationTime: i,
                presentationTimeDelta: a,
                eventDuration: s,
                id: l,
                payload: e.subarray(u, e.byteLength)
              }
            }(e);
            if (Ect.test(r.schemeIdUri)) {
              const e = Fit(r.presentationTime) ? r.presentationTime / r.timeScale : t + r.presentationTimeDelta / r.timeScale;
              let o = 4294967295 === r.eventDuration ? Number.POSITIVE_INFINITY : r.eventDuration / r.timeScale;
              o <= .001 && (o = Number.POSITIVE_INFINITY);
              const a = r.payload;
              n.samples.push({
                data: a,
                len: a.byteLength,
                dts: e,
                pts: e,
                type: jlt,
                duration: o
              })
            }
          }
        ))
      }
      return n
    }
    demuxSampleAes(e, t, n) {
      return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
    }
    destroy() {}
  }
  ,
  remux: class {
    constructor() {
      this.emitInitSegment = !1,
        this.audioCodec = void 0,
        this.videoCodec = void 0,
        this.initData = void 0,
        this.initPTS = null,
        this.initTracks = void 0,
        this.lastEndTime = null
    }
    destroy() {}
    resetTimeStamp(e) {
      this.initPTS = e,
        this.lastEndTime = null
    }
    resetNextTimestamp() {
      this.lastEndTime = null
    }
    resetInitSegment(e, t, n, r) {
      this.audioCodec = t,
        this.videoCodec = n,
        this.generateInitSegment(function(e, t) {
          if (!e || !t)
            return e;
          const n = t.keyId;
          n && t.isCommonEncryption && Ust(e, ["moov", "trak"]).forEach((e=>{
              const t = Ust(e, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
              let r = Ust(t, ["enca"]);
              const o = r.length > 0;
              o || (r = Ust(t, ["encv"])),
                r.forEach((e=>{
                    Ust(o ? e.subarray(28) : e.subarray(78), ["sinf"]).forEach((e=>{
                        const t = zst(e);
                        if (t) {
                          const e = t.subarray(8, 24);
                          e.some((e=>0 !== e)) || (Hit.log(`[eme] Patching keyId in 'enc${o ? "a" : "v"}>sinf>>tenc' box: ${Lst(e)} -> ${Lst(n)}`),
                            t.set(n, 8))
                        }
                      }
                    ))
                  }
                ))
            }
          ));
          return e
        }(e, r)),
        this.emitInitSegment = !0
    }
    generateInitSegment(e) {
      let {audioCodec: t, videoCodec: n} = this;
      if (null == e || !e.byteLength)
        return this.initTracks = void 0,
          void (this.initData = void 0);
      const r = this.initData = Hst(e);
      t || (t = adt(r.audio, Xit)),
      n || (n = adt(r.video, Qit));
      const o = {};
      r.audio && r.video ? o.audiovideo = {
        container: "video/mp4",
        codec: t + "," + n,
        initSegment: e,
        id: "main"
      } : r.audio ? o.audio = {
        container: "audio/mp4",
        codec: t,
        initSegment: e,
        id: "audio"
      } : r.video ? o.video = {
        container: "video/mp4",
        codec: n,
        initSegment: e,
        id: "main"
      } : Hit.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."),
        this.initTracks = o
    }
    remux(e, t, n, r, o, a) {
      var i, s;
      let {initPTS: l, lastEndTime: u} = this;
      const c = {
        audio: void 0,
        video: void 0,
        text: r,
        id3: n,
        initSegment: void 0
      };
      Fit(u) || (u = this.lastEndTime = o || 0);
      const d = t.samples;
      if (null == d || !d.length)
        return c;
      const f = {
        initPTS: void 0,
        timescale: 1
      };
      let p = this.initData;
      if (null != (i = p) && i.length || (this.generateInitSegment(d),
        p = this.initData),
      null == (s = p) || !s.length)
        return Hit.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."),
          c;
      this.emitInitSegment && (f.tracks = this.initTracks,
        this.emitInitSegment = !1);
      const h = function(e, t) {
        let n = 0
          , r = 0
          , o = 0;
        const a = Ust(e, ["moof", "traf"]);
        for (let i = 0; i < a.length; i++) {
          const e = a[i]
            , s = Ust(e, ["tfhd"])[0]
            , l = t[Mst(s, 4)];
          if (!l)
            continue;
          const u = l.default
            , c = Mst(s, 0) | (null == u ? void 0 : u.flags);
          let d = null == u ? void 0 : u.duration;
          8 & c && (d = Mst(s, 2 & c ? 12 : 8));
          const f = l.timescale || 9e4
            , p = Ust(e, ["trun"]);
          for (let t = 0; t < p.length; t++)
            n = Kst(p[t]),
            !n && d && (n = d * Mst(p[t], 4)),
              l.type === Qit ? r += n / f : l.type === Xit && (o += n / f)
        }
        if (0 === r && 0 === o) {
          let t = 0;
          const n = Ust(e, ["sidx"]);
          for (let e = 0; e < n.length; e++) {
            const r = $st(n[e]);
            null != r && r.references && (t += r.references.reduce(((e,t)=>e + t.info.duration || 0), 0))
          }
          return t
        }
        return r || o
      }(d, p)
        , v = function(e, t) {
        return Ust(t, ["moof", "traf"]).reduce(((t,n)=>{
            const r = Ust(n, ["tfdt"])[0]
              , o = r[0]
              , a = Ust(n, ["tfhd"]).reduce(((t,n)=>{
                const a = Mst(n, 4)
                  , i = e[a];
                if (i) {
                  let e = Mst(r, 4);
                  if (1 === o) {
                    if (e === Ist)
                      return Hit.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"),
                        t;
                    e *= Ist + 1,
                      e += Mst(r, 8)
                  }
                  const n = e / (i.timescale || 9e4);
                  if (isFinite(n) && (null === t || n < t))
                    return n
                }
                return t
              }
            ), null);
            return null !== a && isFinite(a) && (null === t || a < t) ? a : t
          }
        ), null)
      }(p, d)
        , g = null === v ? o : v;
      (function(e, t, n, r) {
        if (null === e)
          return !0;
        const o = Math.max(r, 1)
          , a = t - e.baseTime / e.timescale;
        return Math.abs(a - n) > o
      }(l, g, o, h) || f.timescale !== l.timescale && a) && (f.initPTS = g - o,
      l && 1 === l.timescale && Hit.warn("Adjusting initPTS by " + (f.initPTS - l.baseTime)),
        this.initPTS = l = {
          baseTime: f.initPTS,
          timescale: 1
        });
      const m = e ? g - l.baseTime / l.timescale : u
        , y = m + h;
      !function(e, t, n) {
        Ust(t, ["moof", "traf"]).forEach((t=>{
            Ust(t, ["tfhd"]).forEach((r=>{
                const o = Mst(r, 4)
                  , a = e[o];
                if (!a)
                  return;
                const i = a.timescale || 9e4;
                Ust(t, ["tfdt"]).forEach((e=>{
                    const t = e[0];
                    let r = Mst(e, 4);
                    if (0 === t)
                      r -= n * i,
                        r = Math.max(r, 0),
                        Vst(e, 4, r);
                    else {
                      r *= Math.pow(2, 32),
                        r += Mst(e, 8),
                        r -= n * i,
                        r = Math.max(r, 0);
                      const t = Math.floor(r / (Ist + 1))
                        , o = Math.floor(r % (Ist + 1));
                      Vst(e, 4, t),
                        Vst(e, 8, o)
                    }
                  }
                ))
              }
            ))
          }
        ))
      }(p, d, l.baseTime / l.timescale),
        h > 0 ? this.lastEndTime = y : (Hit.warn("Duration parsed from mp4 should be greater than zero"),
          this.resetNextTimestamp());
      const b = !!p.audio
        , w = !!p.video;
      let x = "";
      b && (x += "audio"),
      w && (x += "video");
      const S = {
        data1: d,
        startPTS: m,
        startDTS: m,
        endPTS: y,
        endDTS: y,
        type: x,
        hasAudio: b,
        hasVideo: w,
        nb: 1,
        dropped: 0
      };
      return c.audio = "audio" === S.type ? S : void 0,
        c.video = "audio" !== S.type ? S : void 0,
        c.initSegment = f,
        c.id3 = tdt(n, o, l, l),
      r.samples.length && (c.text = ndt(r, o, l)),
        c
    }
  }
}, {
  demux: Nct,
  remux: Zct
}, {
  demux: class extends pct {
    constructor(e, t) {
      super(),
        this.observer = void 0,
        this.config = void 0,
        this.observer = e,
        this.config = t
    }
    resetInitSegment(e, t, n, r) {
      super.resetInitSegment(e, t, n, r),
        this._audioTrack = {
          container: "audio/adts",
          type: "audio",
          id: 2,
          pid: -1,
          sequenceNumber: 0,
          segmentCodec: "aac",
          samples: [],
          manifestCodec: t,
          duration: r,
          inputTimeScale: 9e4,
          dropped: 0
        }
    }
    static probe(e) {
      if (!e)
        return !1;
      let t = (bst(e, 0) || []).length;
      for (let n = e.length; t < n; t++)
        if (bct(e, t))
          return Hit.log("ADTS sync word found !"),
            !0;
      return !1
    }
    canParse(e, t) {
      return function(e, t) {
        return function(e, t) {
          return t + 5 < e.length
        }(e, t) && vct(e, t) && mct(e, t) <= e.length - t
      }(e, t)
    }
    appendFrame(e, t, n) {
      wct(e, this.observer, t, n, e.manifestCodec);
      const r = Sct(e, t, n, this.basePTS, this.frameIndex);
      if (r && 0 === r.missing)
        return r
    }
  }
  ,
  remux: Zct
}, {
  demux: class extends pct {
    resetInitSegment(e, t, n, r) {
      super.resetInitSegment(e, t, n, r),
        this._audioTrack = {
          container: "audio/mpeg",
          type: "audio",
          id: 2,
          pid: -1,
          sequenceNumber: 0,
          segmentCodec: "mp3",
          samples: [],
          manifestCodec: t,
          duration: r,
          inputTimeScale: 9e4,
          dropped: 0
        }
    }
    static probe(e) {
      if (!e)
        return !1;
      let t = (bst(e, 0) || []).length;
      for (let n = e.length; t < n; t++)
        if (Ict(e, t))
          return Hit.log("MPEG Audio sync word found !"),
            !0;
      return !1
    }
    canParse(e, t) {
      return function(e, t) {
        return Rct(e, t) && 4 <= e.length - t
      }(e, t)
    }
    appendFrame(e, t, n) {
      if (null !== this.basePTS)
        return Oct(e, t, n, this.basePTS, this.frameIndex)
    }
  }
  ,
  remux: Zct
}];
class sdt {
  constructor(e, t, n, r, o) {
    this.async = !1,
      this.observer = void 0,
      this.typeSupported = void 0,
      this.config = void 0,
      this.vendor = void 0,
      this.id = void 0,
      this.demuxer = void 0,
      this.remuxer = void 0,
      this.decrypter = void 0,
      this.probe = void 0,
      this.decryptionPromise = null,
      this.transmuxConfig = void 0,
      this.currentTransmuxState = void 0,
      this.observer = e,
      this.typeSupported = t,
      this.config = n,
      this.vendor = r,
      this.id = o
  }
  configure(e) {
    this.transmuxConfig = e,
    this.decrypter && this.decrypter.reset()
  }
  push(e, t, n, r) {
    const o = n.transmuxing;
    o.executeStart = Xct();
    let a = new Uint8Array(e);
    const {currentTransmuxState: i, transmuxConfig: s} = this;
    r && (this.currentTransmuxState = r);
    const {contiguous: l, discontinuity: u, trackSwitch: c, accurateTimeOffset: d, timeOffset: f, initSegmentChange: p} = r || i
      , {audioCodec: h, videoCodec: v, defaultInitPts: g, duration: m, initSegmentData: y} = s
      , b = function(e, t) {
      let n = null;
      e.byteLength > 0 && null != t && null != t.key && null !== t.iv && null != t.method && (n = t);
      return n
    }(a, t);
    if (b && "AES-128" === b.method) {
      const e = this.getDecrypter();
      if (!e.isSync())
        return this.decryptionPromise = e.webCryptoDecrypt(a, b.key.buffer, b.iv.buffer).then((e=>{
            const t = this.push(e, null, n);
            return this.decryptionPromise = null,
              t
          }
        )),
          this.decryptionPromise;
      {
        let t = e.softwareDecrypt(a, b.key.buffer, b.iv.buffer);
        if (n.part > -1 && (t = e.flush()),
          !t)
          return o.executeEnd = Xct(),
            ldt(n);
        a = new Uint8Array(t)
      }
    }
    const w = this.needsProbing(u, c);
    if (w) {
      const e = this.configureTransmuxer(a);
      if (e)
        return Hit.warn(`[transmuxer] ${e.message}`),
          this.observer.emit(Bit.ERROR, Bit.ERROR, {
            type: Nit.MEDIA_ERROR,
            details: Mit.FRAG_PARSING_ERROR,
            fatal: !1,
            error: e,
            reason: e.message
          }),
          o.executeEnd = Xct(),
          ldt(n)
    }
    (u || c || p || w) && this.resetInitSegment(y, h, v, m, t),
    (u || p || w) && this.resetInitialTimestamp(g),
    l || this.resetContiguity();
    const x = this.transmux(a, b, f, d, n)
      , S = this.currentTransmuxState;
    return S.contiguous = !0,
      S.discontinuity = !1,
      S.trackSwitch = !1,
      o.executeEnd = Xct(),
      x
  }
  flush(e) {
    const t = e.transmuxing;
    t.executeStart = Xct();
    const {decrypter: n, currentTransmuxState: r, decryptionPromise: o} = this;
    if (o)
      return o.then((()=>this.flush(e)));
    const a = []
      , {timeOffset: i} = r;
    if (n) {
      const t = n.flush();
      t && a.push(this.push(t, null, e))
    }
    const {demuxer: s, remuxer: l} = this;
    if (!s || !l)
      return t.executeEnd = Xct(),
        [ldt(e)];
    const u = s.flush(i);
    return udt(u) ? u.then((t=>(this.flushRemux(a, t, e),
      a))) : (this.flushRemux(a, u, e),
      a)
  }
  flushRemux(e, t, n) {
    const {audioTrack: r, videoTrack: o, id3Track: a, textTrack: i} = t
      , {accurateTimeOffset: s, timeOffset: l} = this.currentTransmuxState;
    Hit.log(`[transmuxer.ts]: Flushed fragment ${n.sn}${n.part > -1 ? " p: " + n.part : ""} of level ${n.level}`);
    const u = this.remuxer.remux(r, o, a, i, l, s, !0, this.id);
    e.push({
      remuxResult: u,
      chunkMeta: n
    }),
      n.transmuxing.executeEnd = Xct()
  }
  resetInitialTimestamp(e) {
    const {demuxer: t, remuxer: n} = this;
    t && n && (t.resetTimeStamp(e),
      n.resetTimeStamp(e))
  }
  resetContiguity() {
    const {demuxer: e, remuxer: t} = this;
    e && t && (e.resetContiguity(),
      t.resetNextTimestamp())
  }
  resetInitSegment(e, t, n, r, o) {
    const {demuxer: a, remuxer: i} = this;
    a && i && (a.resetInitSegment(e, t, n, r),
      i.resetInitSegment(e, t, n, o))
  }
  destroy() {
    this.demuxer && (this.demuxer.destroy(),
      this.demuxer = void 0),
    this.remuxer && (this.remuxer.destroy(),
      this.remuxer = void 0)
  }
  transmux(e, t, n, r, o) {
    let a;
    return a = t && "SAMPLE-AES" === t.method ? this.transmuxSampleAes(e, t, n, r, o) : this.transmuxUnencrypted(e, n, r, o),
      a
  }
  transmuxUnencrypted(e, t, n, r) {
    const {audioTrack: o, videoTrack: a, id3Track: i, textTrack: s} = this.demuxer.demux(e, t, !1, !this.config.progressive);
    return {
      remuxResult: this.remuxer.remux(o, a, i, s, t, n, !1, this.id),
      chunkMeta: r
    }
  }
  transmuxSampleAes(e, t, n, r, o) {
    return this.demuxer.demuxSampleAes(e, t, n).then((e=>({
      remuxResult: this.remuxer.remux(e.audioTrack, e.videoTrack, e.id3Track, e.textTrack, n, r, !1, this.id),
      chunkMeta: o
    })))
  }
  configureTransmuxer(e) {
    const {config: t, observer: n, typeSupported: r, vendor: o} = this;
    let a;
    for (let c = 0, d = idt.length; c < d; c++)
      if (idt[c].demux.probe(e)) {
        a = idt[c];
        break
      }
    if (!a)
      return new Error("Failed to find demuxer by probing fragment data");
    const i = this.demuxer
      , s = this.remuxer
      , l = a.remux
      , u = a.demux;
    s && s instanceof l || (this.remuxer = new l(n,t,r,o)),
    i && i instanceof u || (this.demuxer = new u(n,t,r),
      this.probe = u.probe)
  }
  needsProbing(e, t) {
    return !this.demuxer || !this.remuxer || e || t
  }
  getDecrypter() {
    let e = this.decrypter;
    return e || (e = this.decrypter = new Xut(this.config)),
      e
  }
}
const ldt = e=>({
  remuxResult: {},
  chunkMeta: e
});
function udt(e) {
  return "then"in e && e.then instanceof Function
}
class cdt {
  constructor(e, t, n, r, o) {
    this.audioCodec = void 0,
      this.videoCodec = void 0,
      this.initSegmentData = void 0,
      this.duration = void 0,
      this.defaultInitPts = void 0,
      this.audioCodec = e,
      this.videoCodec = t,
      this.initSegmentData = n,
      this.duration = r,
      this.defaultInitPts = o || null
  }
}
class ddt {
  constructor(e, t, n, r, o, a) {
    this.discontinuity = void 0,
      this.contiguous = void 0,
      this.accurateTimeOffset = void 0,
      this.trackSwitch = void 0,
      this.timeOffset = void 0,
      this.initSegmentChange = void 0,
      this.discontinuity = e,
      this.contiguous = t,
      this.accurateTimeOffset = n,
      this.trackSwitch = r,
      this.timeOffset = o,
      this.initSegmentChange = a
  }
}
var fdt = {
  exports: {}
};
!function(e) {
  var t = Object.prototype.hasOwnProperty
    , n = "~";
  function r() {}
  function o(e, t, n) {
    this.fn = e,
      this.context = t,
      this.once = n || !1
  }
  function a(e, t, r, a, i) {
    if ("function" != typeof r)
      throw new TypeError("The listener must be a function");
    var s = new o(r,a || e,i)
      , l = n ? n + t : t;
    return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], s] : e._events[l].push(s) : (e._events[l] = s,
      e._eventsCount++),
      e
  }
  function i(e, t) {
    0 == --e._eventsCount ? e._events = new r : delete e._events[t]
  }
  function s() {
    this._events = new r,
      this._eventsCount = 0
  }
  Object.create && (r.prototype = Object.create(null),
  (new r).__proto__ || (n = !1)),
    s.prototype.eventNames = function() {
      var e, r, o = [];
      if (0 === this._eventsCount)
        return o;
      for (r in e = this._events)
        t.call(e, r) && o.push(n ? r.slice(1) : r);
      return Object.getOwnPropertySymbols ? o.concat(Object.getOwnPropertySymbols(e)) : o
    }
    ,
    s.prototype.listeners = function(e) {
      var t = n ? n + e : e
        , r = this._events[t];
      if (!r)
        return [];
      if (r.fn)
        return [r.fn];
      for (var o = 0, a = r.length, i = new Array(a); o < a; o++)
        i[o] = r[o].fn;
      return i
    }
    ,
    s.prototype.listenerCount = function(e) {
      var t = n ? n + e : e
        , r = this._events[t];
      return r ? r.fn ? 1 : r.length : 0
    }
    ,
    s.prototype.emit = function(e, t, r, o, a, i) {
      var s = n ? n + e : e;
      if (!this._events[s])
        return !1;
      var l, u, c = this._events[s], d = arguments.length;
      if (c.fn) {
        switch (c.once && this.removeListener(e, c.fn, void 0, !0),
          d) {
          case 1:
            return c.fn.call(c.context),
              !0;
          case 2:
            return c.fn.call(c.context, t),
              !0;
          case 3:
            return c.fn.call(c.context, t, r),
              !0;
          case 4:
            return c.fn.call(c.context, t, r, o),
              !0;
          case 5:
            return c.fn.call(c.context, t, r, o, a),
              !0;
          case 6:
            return c.fn.call(c.context, t, r, o, a, i),
              !0
        }
        for (u = 1,
               l = new Array(d - 1); u < d; u++)
          l[u - 1] = arguments[u];
        c.fn.apply(c.context, l)
      } else {
        var f, p = c.length;
        for (u = 0; u < p; u++)
          switch (c[u].once && this.removeListener(e, c[u].fn, void 0, !0),
            d) {
            case 1:
              c[u].fn.call(c[u].context);
              break;
            case 2:
              c[u].fn.call(c[u].context, t);
              break;
            case 3:
              c[u].fn.call(c[u].context, t, r);
              break;
            case 4:
              c[u].fn.call(c[u].context, t, r, o);
              break;
            default:
              if (!l)
                for (f = 1,
                       l = new Array(d - 1); f < d; f++)
                  l[f - 1] = arguments[f];
              c[u].fn.apply(c[u].context, l)
          }
      }
      return !0
    }
    ,
    s.prototype.on = function(e, t, n) {
      return a(this, e, t, n, !1)
    }
    ,
    s.prototype.once = function(e, t, n) {
      return a(this, e, t, n, !0)
    }
    ,
    s.prototype.removeListener = function(e, t, r, o) {
      var a = n ? n + e : e;
      if (!this._events[a])
        return this;
      if (!t)
        return i(this, a),
          this;
      var s = this._events[a];
      if (s.fn)
        s.fn !== t || o && !s.once || r && s.context !== r || i(this, a);
      else {
        for (var l = 0, u = [], c = s.length; l < c; l++)
          (s[l].fn !== t || o && !s[l].once || r && s[l].context !== r) && u.push(s[l]);
        u.length ? this._events[a] = 1 === u.length ? u[0] : u : i(this, a)
      }
      return this
    }
    ,
    s.prototype.removeAllListeners = function(e) {
      var t;
      return e ? (t = n ? n + e : e,
      this._events[t] && i(this, t)) : (this._events = new r,
        this._eventsCount = 0),
        this
    }
    ,
    s.prototype.off = s.prototype.removeListener,
    s.prototype.addListener = s.prototype.on,
    s.prefixed = n,
    s.EventEmitter = s,
    e.exports = s
}(fdt);
var pdt = Eit(fdt.exports);
const hdt = ilt() || {
  isTypeSupported: ()=>!1
};
class vdt {
  constructor(e, t, n, r) {
    this.error = null,
      this.hls = void 0,
      this.id = void 0,
      this.observer = void 0,
      this.frag = null,
      this.part = null,
      this.useWorker = void 0,
      this.workerContext = null,
      this.onwmsg = void 0,
      this.transmuxer = null,
      this.onTransmuxComplete = void 0,
      this.onFlush = void 0;
    const o = e.config;
    this.hls = e,
      this.id = t,
      this.useWorker = !!o.enableWorker,
      this.onTransmuxComplete = n,
      this.onFlush = r;
    const a = (e,t)=>{
        (t = t || {}).frag = this.frag,
          t.id = this.id,
        e === Bit.ERROR && (this.error = t.error),
          this.hls.trigger(e, t)
      }
    ;
    this.observer = new pdt,
      this.observer.on(Bit.FRAG_DECRYPTED, a),
      this.observer.on(Bit.ERROR, a);
    const i = {
      mp4: hdt.isTypeSupported("video/mp4"),
      mpeg: hdt.isTypeSupported("audio/mpeg"),
      mp3: hdt.isTypeSupported('audio/mp4; codecs="mp3"')
    }
      , s = navigator.vendor;
    if (this.useWorker && "undefined" != typeof Worker) {
      if (o.workerPath || "function" == typeof __HLS_WORKER_BUNDLE__) {
        try {
          o.workerPath ? (Hit.log(`loading Web Worker ${o.workerPath} for "${t}"`),
            this.workerContext = function(e) {
              const t = new self.URL(e,self.location.href).href;
              return {
                worker: new self.Worker(t),
                scriptURL: t
              }
            }(o.workerPath)) : (Hit.log(`injecting Web Worker for "${t}"`),
            this.workerContext = function() {
              const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`],{
                type: "text/javascript"
              })
                , t = self.URL.createObjectURL(e);
              return {
                worker: new self.Worker(t),
                objectURL: t
              }
            }()),
            this.onwmsg = e=>this.onWorkerMessage(e);
          const {worker: e} = this.workerContext;
          e.addEventListener("message", this.onwmsg),
            e.onerror = e=>{
              const n = new Error(`${e.message}  (${e.filename}:${e.lineno})`);
              o.enableWorker = !1,
                Hit.warn(`Error in "${t}" Web Worker, fallback to inline`),
                this.hls.trigger(Bit.ERROR, {
                  type: Nit.OTHER_ERROR,
                  details: Mit.INTERNAL_EXCEPTION,
                  fatal: !1,
                  event: "demuxerWorker",
                  error: n
                })
            }
            ,
            e.postMessage({
              cmd: "init",
              typeSupported: i,
              vendor: s,
              id: t,
              config: JSON.stringify(o)
            })
        } catch (ubt) {
          Hit.warn(`Error setting up "${t}" Web Worker, fallback to inline`, ubt),
            this.resetWorker(),
            this.error = null,
            this.transmuxer = new sdt(this.observer,i,o,s,t)
        }
        return
      }
    }
    this.transmuxer = new sdt(this.observer,i,o,s,t)
  }
  resetWorker() {
    if (this.workerContext) {
      const {worker: e, objectURL: t} = this.workerContext;
      t && self.URL.revokeObjectURL(t),
        e.removeEventListener("message", this.onwmsg),
        e.onerror = null,
        e.terminate(),
        this.workerContext = null
    }
  }
  destroy() {
    if (this.workerContext)
      this.resetWorker(),
        this.onwmsg = void 0;
    else {
      const e = this.transmuxer;
      e && (e.destroy(),
        this.transmuxer = null)
    }
    const e = this.observer;
    e && e.removeAllListeners(),
      this.frag = null,
      this.observer = null,
      this.hls = null
  }
  push(e, t, n, r, o, a, i, s, l, u) {
    var c, d;
    l.transmuxing.start = self.performance.now();
    const {transmuxer: f} = this
      , p = a ? a.start : o.start
      , h = o.decryptdata
      , v = this.frag
      , g = !(v && o.cc === v.cc)
      , m = !(v && l.level === v.level)
      , y = v ? l.sn - v.sn : -1
      , b = this.part ? l.part - this.part.index : -1
      , w = 0 === y && l.id > 1 && l.id === (null == v ? void 0 : v.stats.chunkCount)
      , x = !m && (1 === y || 0 === y && (1 === b || w && b <= 0))
      , S = self.performance.now();
    (m || y || 0 === o.stats.parsing.start) && (o.stats.parsing.start = S),
    !a || !b && x || (a.stats.parsing.start = S);
    const E = !(v && (null == (c = o.initSegment) ? void 0 : c.url) === (null == (d = v.initSegment) ? void 0 : d.url))
      , A = new ddt(g,x,s,m,p,E);
    if (!x || g || E) {
      Hit.log(`[transmuxer-interface, ${o.type}]: Starting new transmux session for sn: ${l.sn} p: ${l.part} level: ${l.level} id: ${l.id}\n        discontinuity: ${g}\n        trackSwitch: ${m}\n        contiguous: ${x}\n        accurateTimeOffset: ${s}\n        timeOffset: ${p}\n        initSegmentChange: ${E}`);
      const e = new cdt(n,r,t,i,u);
      this.configureTransmuxer(e)
    }
    if (this.frag = o,
      this.part = a,
      this.workerContext)
      this.workerContext.worker.postMessage({
        cmd: "demux",
        data: e,
        decryptdata: h,
        chunkMeta: l,
        state: A
      }, e instanceof ArrayBuffer ? [e] : []);
    else if (f) {
      const t = f.push(e, h, l, A);
      udt(t) ? (f.async = !0,
        t.then((e=>{
            this.handleTransmuxComplete(e)
          }
        )).catch((e=>{
            this.transmuxerError(e, l, "transmuxer-interface push error")
          }
        ))) : (f.async = !1,
        this.handleTransmuxComplete(t))
    }
  }
  flush(e) {
    e.transmuxing.start = self.performance.now();
    const {transmuxer: t} = this;
    if (this.workerContext)
      this.workerContext.worker.postMessage({
        cmd: "flush",
        chunkMeta: e
      });
    else if (t) {
      let n = t.flush(e);
      udt(n) || t.async ? (udt(n) || (n = Promise.resolve(n)),
        n.then((t=>{
            this.handleFlushResult(t, e)
          }
        )).catch((t=>{
            this.transmuxerError(t, e, "transmuxer-interface flush error")
          }
        ))) : this.handleFlushResult(n, e)
    }
  }
  transmuxerError(e, t, n) {
    this.hls && (this.error = e,
      this.hls.trigger(Bit.ERROR, {
        type: Nit.MEDIA_ERROR,
        details: Mit.FRAG_PARSING_ERROR,
        chunkMeta: t,
        fatal: !1,
        error: e,
        err: e,
        reason: n
      }))
  }
  handleFlushResult(e, t) {
    e.forEach((e=>{
        this.handleTransmuxComplete(e)
      }
    )),
      this.onFlush(t)
  }
  onWorkerMessage(e) {
    const t = e.data
      , n = this.hls;
    switch (t.event) {
      case "init":
      {
        var r;
        const e = null == (r = this.workerContext) ? void 0 : r.objectURL;
        e && self.URL.revokeObjectURL(e);
        break
      }
      case "transmuxComplete":
        this.handleTransmuxComplete(t.data);
        break;
      case "flush":
        this.onFlush(t.data);
        break;
      case "workerLog":
        Hit[t.data.logType] && Hit[t.data.logType](t.data.message);
        break;
      default:
        t.data = t.data || {},
          t.data.frag = this.frag,
          t.data.id = this.id,
          n.trigger(t.event, t.data)
    }
  }
  configureTransmuxer(e) {
    const {transmuxer: t} = this;
    this.workerContext ? this.workerContext.worker.postMessage({
      cmd: "configure",
      config: e
    }) : t && t.configure(e)
  }
  handleTransmuxComplete(e) {
    e.chunkMeta.transmuxing.end = self.performance.now(),
      this.onTransmuxComplete(e)
  }
}
class gdt {
  constructor(e, t, n, r) {
    this.config = void 0,
      this.media = null,
      this.fragmentTracker = void 0,
      this.hls = void 0,
      this.nudgeRetry = 0,
      this.stallReported = !1,
      this.stalled = null,
      this.moved = !1,
      this.seeking = !1,
      this.config = e,
      this.media = t,
      this.fragmentTracker = n,
      this.hls = r
  }
  destroy() {
    this.media = null,
      this.hls = this.fragmentTracker = null
  }
  poll(e, t) {
    const {config: n, media: r, stalled: o} = this;
    if (null === r)
      return;
    const {currentTime: a, seeking: i} = r
      , s = this.seeking && !i
      , l = !this.seeking && i;
    if (this.seeking = i,
    a !== e) {
      if (this.moved = !0,
      null !== o) {
        if (this.stallReported) {
          const e = self.performance.now() - o;
          Hit.warn(`playback not stuck anymore @${a}, after ${Math.round(e)}ms`),
            this.stallReported = !1
        }
        this.stalled = null,
          this.nudgeRetry = 0
      }
      return
    }
    if (l || s)
      return void (this.stalled = null);
    if (r.paused && !i || r.ended || 0 === r.playbackRate || !Vut.getBuffered(r).length)
      return;
    const u = Vut.bufferInfo(r, a, 0)
      , c = u.len > 0
      , d = u.nextStart || 0;
    if (!c && !d)
      return;
    if (i) {
      const e = u.len > 2
        , n = !d || t && t.start <= a || d - a > 2 && !this.fragmentTracker.getPartialFragment(a);
      if (e || n)
        return;
      this.moved = !1
    }
    if (!this.moved && null !== this.stalled) {
      var f;
      const e = Math.max(d, u.start || 0) - a
        , t = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null
        , n = (null == t || null == (f = t.details) ? void 0 : f.live) ? 2 * t.details.targetduration : 2
        , r = this.fragmentTracker.getPartialFragment(a);
      if (e > 0 && (e <= n || r))
        return void this._trySkipBufferHole(r)
    }
    const p = self.performance.now();
    if (null === o)
      return void (this.stalled = p);
    const h = p - o;
    if (!i && h >= 250 && (this._reportStall(u),
      !this.media))
      return;
    const v = Vut.bufferInfo(r, a, n.maxBufferHole);
    this._tryFixBufferStall(v, h)
  }
  _tryFixBufferStall(e, t) {
    const {config: n, fragmentTracker: r, media: o} = this;
    if (null === o)
      return;
    const a = o.currentTime
      , i = r.getPartialFragment(a);
    if (i) {
      if (this._trySkipBufferHole(i) || !this.media)
        return
    }
    (e.len > n.maxBufferHole || e.nextStart && e.nextStart - a < n.maxBufferHole) && t > 1e3 * n.highBufferWatchdogPeriod && (Hit.warn("Trying to nudge playhead over buffer-hole"),
      this.stalled = null,
      this._tryNudgeBuffer())
  }
  _reportStall(e) {
    const {hls: t, media: n, stallReported: r} = this;
    if (!r && n) {
      this.stallReported = !0;
      const r = new Error(`Playback stalling at @${n.currentTime} due to low buffer (${JSON.stringify(e)})`);
      Hit.warn(r.message),
        t.trigger(Bit.ERROR, {
          type: Nit.MEDIA_ERROR,
          details: Mit.BUFFER_STALLED_ERROR,
          fatal: !1,
          error: r,
          buffer: e.len
        })
    }
  }
  _trySkipBufferHole(e) {
    const {config: t, hls: n, media: r} = this;
    if (null === r)
      return 0;
    const o = r.currentTime
      , a = Vut.bufferInfo(r, o, 0)
      , i = o < a.start ? a.start : a.nextStart;
    if (i) {
      const s = a.len <= t.maxBufferHole
        , l = a.len > 0 && a.len < 1 && r.readyState < 3
        , u = i - o;
      if (u > 0 && (s || l)) {
        if (u > t.maxBufferHole) {
          const {fragmentTracker: t} = this;
          let n = !1;
          if (0 === o) {
            const e = t.getAppendedFrag(0, Tlt);
            e && i < e.end && (n = !0)
          }
          if (!n) {
            const n = e || t.getAppendedFrag(o, Tlt);
            if (n) {
              let e = !1
                , r = n.end;
              for (; r < i; ) {
                const n = t.getPartialFragment(r);
                if (!n) {
                  e = !0;
                  break
                }
                r += n.duration
              }
              if (e)
                return 0
            }
          }
        }
        const a = Math.max(i + .05, o + .1);
        if (Hit.warn(`skipping hole, adjusting currentTime from ${o} to ${a}`),
          this.moved = !0,
          this.stalled = null,
          r.currentTime = a,
        e && !e.gap) {
          const t = new Error(`fragment loaded with buffer holes, seeking from ${o} to ${a}`);
          n.trigger(Bit.ERROR, {
            type: Nit.MEDIA_ERROR,
            details: Mit.BUFFER_SEEK_OVER_HOLE,
            fatal: !1,
            error: t,
            reason: t.message,
            frag: e
          })
        }
        return a
      }
    }
    return 0
  }
  _tryNudgeBuffer() {
    const {config: e, hls: t, media: n, nudgeRetry: r} = this;
    if (null === n)
      return;
    const o = n.currentTime;
    if (this.nudgeRetry++,
    r < e.nudgeMaxRetry) {
      const a = o + (r + 1) * e.nudgeOffset
        , i = new Error(`Nudging 'currentTime' from ${o} to ${a}`);
      Hit.warn(i.message),
        n.currentTime = a,
        t.trigger(Bit.ERROR, {
          type: Nit.MEDIA_ERROR,
          details: Mit.BUFFER_NUDGE_ON_STALL,
          error: i,
          fatal: !1
        })
    } else {
      const n = new Error(`Playhead still not moving while enough data buffered @${o} after ${e.nudgeMaxRetry} nudges`);
      Hit.error(n.message),
        t.trigger(Bit.ERROR, {
          type: Nit.MEDIA_ERROR,
          details: Mit.BUFFER_STALLED_ERROR,
          error: n,
          fatal: !0
        })
    }
  }
}
class mdt extends cct {
  constructor(e, t, n) {
    super(e, t, n, "[stream-controller]", Tlt),
      this.audioCodecSwap = !1,
      this.gapController = null,
      this.level = -1,
      this._forceStartLoad = !1,
      this.altAudio = !1,
      this.audioOnly = !1,
      this.fragPlaying = null,
      this.onvplaying = null,
      this.onvseeked = null,
      this.fragLastKbps = 0,
      this.couldBacktrack = !1,
      this.backtrackFragment = null,
      this.audioCodecSwitch = !1,
      this.videoBuffer = null,
      this._registerListeners()
  }
  _registerListeners() {
    const {hls: e} = this;
    e.on(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on(Bit.LEVEL_LOADING, this.onLevelLoading, this),
      e.on(Bit.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on(Bit.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this),
      e.on(Bit.ERROR, this.onError, this),
      e.on(Bit.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.on(Bit.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
      e.on(Bit.BUFFER_CREATED, this.onBufferCreated, this),
      e.on(Bit.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.on(Bit.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.on(Bit.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  _unregisterListeners() {
    const {hls: e} = this;
    e.off(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off(Bit.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off(Bit.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this),
      e.off(Bit.ERROR, this.onError, this),
      e.off(Bit.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.off(Bit.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
      e.off(Bit.BUFFER_CREATED, this.onBufferCreated, this),
      e.off(Bit.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.off(Bit.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.off(Bit.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  onHandlerDestroying() {
    this._unregisterListeners(),
      this.onMediaDetaching()
  }
  startLoad(e) {
    if (this.levels) {
      const {lastCurrentTime: t, hls: n} = this;
      if (this.stopLoad(),
        this.setInterval(100),
        this.level = -1,
        !this.startFragRequested) {
        let e = n.startLevel;
        -1 === e && (n.config.testBandwidth && this.levels.length > 1 ? (e = 0,
          this.bitrateTest = !0) : e = n.nextAutoLevel),
          this.level = n.nextLoadLevel = e,
          this.loadedmetadata = !1
      }
      t > 0 && -1 === e && (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`),
        e = t),
        this.state = Zut,
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e,
        this.tick()
    } else
      this._forceStartLoad = !0,
        this.state = Jut
  }
  stopLoad() {
    this._forceStartLoad = !1,
      super.stopLoad()
  }
  doTick() {
    switch (this.state) {
      case uct:
      {
        var e;
        const {levels: t, level: n} = this
          , r = null == t || null == (e = t[n]) ? void 0 : e.details;
        if (r && (!r.live || this.levelLastLoaded === this.level)) {
          if (this.waitForCdnTuneIn(r))
            break;
          this.state = Zut;
          break
        }
        if (this.hls.nextLoadLevel !== this.level) {
          this.state = Zut;
          break
        }
        break
      }
      case nct:
      {
        var t;
        const e = self.performance.now()
          , n = this.retryDate;
        (!n || e >= n || null != (t = this.media) && t.seeking) && (this.resetStartWhenNotLoaded(this.level),
          this.state = Zut)
      }
    }
    this.state === Zut && this.doTickIdle(),
      this.onTickEnd()
  }
  onTickEnd() {
    super.onTickEnd(),
      this.checkBuffer(),
      this.checkFragmentChanged()
  }
  doTickIdle() {
    const {hls: e, levelLastLoaded: t, levels: n, media: r} = this
      , {config: o, nextLoadLevel: a} = e;
    if (null === t || !r && (this.startFragRequested || !o.startFragPrefetch))
      return;
    if (this.altAudio && this.audioOnly)
      return;
    if (null == n || !n[a])
      return;
    const i = n[a]
      , s = this.getMainFwdBufferInfo();
    if (null === s)
      return;
    const l = this.getLevelDetails();
    if (l && this._streamEnded(s, l)) {
      const e = {};
      return this.altAudio && (e.type = "video"),
        this.hls.trigger(Bit.BUFFER_EOS, e),
        void (this.state = ict)
    }
    e.loadLevel !== a && -1 === e.manualLevel && this.log(`Adapting to level ${a} from level ${this.level}`),
      this.level = e.nextLoadLevel = a;
    const u = i.details;
    if (!u || this.state === uct || u.live && this.levelLastLoaded !== a)
      return this.level = a,
        void (this.state = uct);
    const c = s.len
      , d = this.getMaxBufferLength(i.maxBitrate);
    if (c >= d)
      return;
    this.backtrackFragment && this.backtrackFragment.start > s.end && (this.backtrackFragment = null);
    const f = this.backtrackFragment ? this.backtrackFragment.start : s.end;
    let p = this.getNextFragment(f, u);
    if (this.couldBacktrack && !this.fragPrevious && p && "initSegment" !== p.sn && this.fragmentTracker.getState(p) !== Dut) {
      var h;
      const e = (null != (h = this.backtrackFragment) ? h : p).sn - u.startSN
        , t = u.fragments[e - 1];
      t && p.cc === t.cc && (p = t,
        this.fragmentTracker.removeFragment(t))
    } else
      this.backtrackFragment && s.len && (this.backtrackFragment = null);
    if (p && this.isLoopLoading(p, f)) {
      if (!p.gap) {
        const e = this.audioOnly && !this.altAudio ? Xit : Qit
          , t = (e === Qit ? this.videoBuffer : this.mediaBuffer) || this.media;
        t && this.afterBufferFlushed(t, e, Tlt)
      }
      p = this.getNextFragmentLoopLoading(p, u, s, Tlt, d)
    }
    p && (!p.initSegment || p.initSegment.data || this.bitrateTest || (p = p.initSegment),
      this.loadFragment(p, i, f))
  }
  loadFragment(e, t, n) {
    const r = this.fragmentTracker.getState(e);
    this.fragCurrent = e,
      r === Cut || r === Tut ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`),
        this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0,
        super.loadFragment(e, t, n)) : this.clearTrackerIfNeeded(e)
  }
  getBufferedFrag(e) {
    return this.fragmentTracker.getBufferedFrag(e, Tlt)
  }
  followingBufferedFrag(e) {
    return e ? this.getBufferedFrag(e.end + .5) : null
  }
  immediateLevelSwitch() {
    this.abortCurrentFrag(),
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
  }
  nextLevelSwitch() {
    const {levels: e, media: t} = this;
    if (null != t && t.readyState) {
      let n;
      const r = this.getAppendedFrag(t.currentTime);
      r && r.start > 1 && this.flushMainBuffer(0, r.start - 1);
      const o = this.getLevelDetails();
      if (null != o && o.live) {
        const e = this.getMainFwdBufferInfo();
        if (!e || e.len < 2 * o.targetduration)
          return
      }
      if (!t.paused && e) {
        const t = e[this.hls.nextLoadLevel]
          , r = this.fragLastKbps;
        n = r && this.fragCurrent ? this.fragCurrent.duration * t.maxBitrate / (1e3 * r) + 1 : 0
      } else
        n = 0;
      const a = this.getBufferedFrag(t.currentTime + n);
      if (a) {
        const e = this.followingBufferedFrag(a);
        if (e) {
          this.abortCurrentFrag();
          const t = e.maxStartPTS ? e.maxStartPTS : e.start
            , n = e.duration
            , r = Math.max(a.end, t + Math.min(Math.max(n - this.config.maxFragLookUpTolerance, .5 * n), .75 * n));
          this.flushMainBuffer(r, Number.POSITIVE_INFINITY)
        }
      }
    }
  }
  abortCurrentFrag() {
    const e = this.fragCurrent;
    switch (this.fragCurrent = null,
      this.backtrackFragment = null,
    e && (e.abortRequests(),
      this.fragmentTracker.removeFragment(e)),
      this.state) {
      case ect:
      case tct:
      case nct:
      case oct:
      case act:
        this.state = Zut
    }
    this.nextLoadPosition = this.getLoadPosition()
  }
  flushMainBuffer(e, t) {
    super.flushMainBuffer(e, t, this.altAudio ? "video" : null)
  }
  onMediaAttached(e, t) {
    super.onMediaAttached(e, t);
    const n = t.media;
    this.onvplaying = this.onMediaPlaying.bind(this),
      this.onvseeked = this.onMediaSeeked.bind(this),
      n.addEventListener("playing", this.onvplaying),
      n.addEventListener("seeked", this.onvseeked),
      this.gapController = new gdt(this.config,n,this.fragmentTracker,this.hls)
  }
  onMediaDetaching() {
    const {media: e} = this;
    e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying),
      e.removeEventListener("seeked", this.onvseeked),
      this.onvplaying = this.onvseeked = null,
      this.videoBuffer = null),
      this.fragPlaying = null,
    this.gapController && (this.gapController.destroy(),
      this.gapController = null),
      super.onMediaDetaching()
  }
  onMediaPlaying() {
    this.tick()
  }
  onMediaSeeked() {
    const e = this.media
      , t = e ? e.currentTime : null;
    Fit(t) && this.log(`Media seeked to ${t.toFixed(3)}`);
    const n = this.getMainFwdBufferInfo();
    null !== n && 0 !== n.len ? this.tick() : this.warn(`Main forward buffer length on "seeked" event ${n ? n.len : "empty"})`)
  }
  onManifestLoading() {
    this.log("Trigger BUFFER_RESET"),
      this.hls.trigger(Bit.BUFFER_RESET, void 0),
      this.fragmentTracker.removeAllFragments(),
      this.couldBacktrack = !1,
      this.startPosition = this.lastCurrentTime = 0,
      this.levels = this.fragPlaying = this.backtrackFragment = null,
      this.altAudio = this.audioOnly = !1
  }
  onManifestParsed(e, t) {
    let n, r = !1, o = !1;
    t.levels.forEach((e=>{
        n = e.audioCodec,
        n && (-1 !== n.indexOf("mp4a.40.2") && (r = !0),
        -1 !== n.indexOf("mp4a.40.5") && (o = !0))
      }
    )),
      this.audioCodecSwitch = r && o && !function() {
        var e;
        const t = dct();
        return "function" == typeof (null == t || null == (e = t.prototype) ? void 0 : e.changeType)
      }(),
    this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"),
      this.levels = t.levels,
      this.startFragRequested = !1
  }
  onLevelLoading(e, t) {
    const {levels: n} = this;
    if (!n || this.state !== Zut)
      return;
    const r = n[t.level];
    (!r.details || r.details.live && this.levelLastLoaded !== t.level || this.waitForCdnTuneIn(r.details)) && (this.state = uct)
  }
  onLevelLoaded(e, t) {
    var n;
    const {levels: r} = this
      , o = t.level
      , a = t.details
      , i = a.totalduration;
    if (!r)
      return void this.warn(`Levels were reset while loading level ${o}`);
    this.log(`Level ${o} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""}, cc [${a.startCC}, ${a.endCC}] duration:${i}`);
    const s = r[o]
      , l = this.fragCurrent;
    !l || this.state !== tct && this.state !== nct || l.level === t.level && l.urlId === s.urlId || !l.loader || this.abortCurrentFrag();
    let u = 0;
    if (a.live || null != (n = s.details) && n.live) {
      if (a.fragments[0] || (a.deltaUpdateFailed = !0),
        a.deltaUpdateFailed)
        return;
      u = this.alignPlaylists(a, s.details)
    }
    if (s.details = a,
      this.levelLastLoaded = o,
      this.hls.trigger(Bit.LEVEL_UPDATED, {
        details: a,
        level: o
      }),
    this.state === uct) {
      if (this.waitForCdnTuneIn(a))
        return;
      this.state = Zut
    }
    this.startFragRequested ? a.live && this.synchronizeToLiveEdge(a) : this.setStartPosition(a, u),
      this.tick()
  }
  _handleFragmentLoadProgress(e) {
    var t;
    const {frag: n, part: r, payload: o} = e
      , {levels: a} = this;
    if (!a)
      return void this.warn(`Levels were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
    const i = a[n.level]
      , s = i.details;
    if (!s)
      return this.warn(`Dropping fragment ${n.sn} of level ${n.level} after level details were reset`),
        void this.fragmentTracker.removeFragment(n);
    const l = i.videoCodec
      , u = s.PTSKnown || !s.live
      , c = null == (t = n.initSegment) ? void 0 : t.data
      , d = this._getAudioCodec(i)
      , f = this.transmuxer = this.transmuxer || new vdt(this.hls,Tlt,this._handleTransmuxComplete.bind(this),this._handleTransmuxerFlush.bind(this))
      , p = r ? r.index : -1
      , h = -1 !== p
      , v = new Uut(n.level,n.sn,n.stats.chunkCount,o.byteLength,p,h)
      , g = this.initPTS[n.cc];
    f.push(o, c, d, l, n, r, s.totalduration, u, v, g)
  }
  onAudioTrackSwitching(e, t) {
    const n = this.altAudio;
    if (!!!t.url) {
      if (this.mediaBuffer !== this.media) {
        this.log("Switching on main audio, use media.buffered to schedule main fragment loading"),
          this.mediaBuffer = this.media;
        const e = this.fragCurrent;
        e && (this.log("Switching to main audio track, cancel main fragment load"),
          e.abortRequests(),
          this.fragmentTracker.removeFragment(e)),
          this.resetTransmuxer(),
          this.resetLoadingState()
      } else
        this.audioOnly && this.resetTransmuxer();
      const e = this.hls;
      n && (e.trigger(Bit.BUFFER_FLUSHING, {
        startOffset: 0,
        endOffset: Number.POSITIVE_INFINITY,
        type: null
      }),
        this.fragmentTracker.removeAllFragments()),
        e.trigger(Bit.AUDIO_TRACK_SWITCHED, t)
    }
  }
  onAudioTrackSwitched(e, t) {
    const n = t.id
      , r = !!this.hls.audioTracks[n].url;
    if (r) {
      const e = this.videoBuffer;
      e && this.mediaBuffer !== e && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"),
        this.mediaBuffer = e)
    }
    this.altAudio = r,
      this.tick()
  }
  onBufferCreated(e, t) {
    const n = t.tracks;
    let r, o, a = !1;
    for (const i in n) {
      const e = n[i];
      if ("main" === e.id) {
        if (o = i,
          r = e,
        "video" === i) {
          const e = n[i];
          e && (this.videoBuffer = e.buffer)
        }
      } else
        a = !0
    }
    a && r ? (this.log(`Alternate track found, use ${o}.buffered to schedule main fragment loading`),
      this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media
  }
  onFragBuffered(e, t) {
    const {frag: n, part: r} = t;
    if (n && n.type !== Tlt)
      return;
    if (this.fragContextChanged(n))
      return this.warn(`Fragment ${n.sn}${r ? " p: " + r.index : ""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}`),
        void (this.state === act && (this.state = Zut));
    const o = r ? r.stats : n.stats;
    this.fragLastKbps = Math.round(8 * o.total / (o.buffering.end - o.loading.first)),
    "initSegment" !== n.sn && (this.fragPrevious = n),
      this.fragBufferedComplete(n, r)
  }
  onError(e, t) {
    var n;
    if (t.fatal)
      this.state = sct;
    else
      switch (t.details) {
        case Mit.FRAG_GAP:
        case Mit.FRAG_PARSING_ERROR:
        case Mit.FRAG_DECRYPT_ERROR:
        case Mit.FRAG_LOAD_ERROR:
        case Mit.FRAG_LOAD_TIMEOUT:
        case Mit.KEY_LOAD_ERROR:
        case Mit.KEY_LOAD_TIMEOUT:
          this.onFragmentOrKeyLoadError(Tlt, t);
          break;
        case Mit.LEVEL_LOAD_ERROR:
        case Mit.LEVEL_LOAD_TIMEOUT:
        case Mit.LEVEL_PARSING_ERROR:
          t.levelRetry || this.state !== uct || (null == (n = t.context) ? void 0 : n.type) !== Alt || (this.state = Zut);
          break;
        case Mit.BUFFER_FULL_ERROR:
          if (!t.parent || "main" !== t.parent)
            return;
          this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
          break;
        case Mit.INTERNAL_EXCEPTION:
          this.recoverWorkerError(t)
      }
  }
  checkBuffer() {
    const {media: e, gapController: t} = this;
    if (e && t && e.readyState) {
      if (this.loadedmetadata || !Vut.getBuffered(e).length) {
        const e = this.state !== Zut ? this.fragCurrent : null;
        t.poll(this.lastCurrentTime, e)
      }
      this.lastCurrentTime = e.currentTime
    }
  }
  onFragLoadEmergencyAborted() {
    this.state = Zut,
    this.loadedmetadata || (this.startFragRequested = !1,
      this.nextLoadPosition = this.startPosition),
      this.tickImmediate()
  }
  onBufferFlushed(e, {type: t}) {
    if (t !== Xit || this.audioOnly && !this.altAudio) {
      const e = (t === Qit ? this.videoBuffer : this.mediaBuffer) || this.media;
      this.afterBufferFlushed(e, t, Tlt)
    }
  }
  onLevelsUpdated(e, t) {
    this.levels = t.levels
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap
  }
  seekToStartPos() {
    const {media: e} = this;
    if (!e)
      return;
    const t = e.currentTime;
    let n = this.startPosition;
    if (n >= 0 && t < n) {
      if (e.seeking)
        return void this.log(`could not seek to ${n}, already seeking at ${t}`);
      const r = Vut.getBuffered(e)
        , o = (r.length ? r.start(0) : 0) - n;
      o > 0 && (o < this.config.maxBufferHole || o < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${o} to match buffer start`),
        n += o,
        this.startPosition = n),
        this.log(`seek to target start position ${n} from current time ${t}`),
        e.currentTime = n
    }
  }
  _getAudioCodec(e) {
    let t = this.config.defaultAudioCodec || e.audioCodec;
    return this.audioCodecSwap && t && (this.log("Swapping audio codec"),
      t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"),
      t
  }
  _loadBitrateTestFrag(e, t) {
    e.bitrateTest = !0,
      this._doFragLoad(e, t).then((n=>{
          const {hls: r} = this;
          if (!n || this.fragContextChanged(e))
            return;
          t.fragmentError = 0,
            this.state = Zut,
            this.startFragRequested = !1,
            this.bitrateTest = !1;
          const o = e.stats;
          o.parsing.start = o.parsing.end = o.buffering.start = o.buffering.end = self.performance.now(),
            r.trigger(Bit.FRAG_LOADED, n),
            e.bitrateTest = !1
        }
      ))
  }
  _handleTransmuxComplete(e) {
    var t;
    const n = "main"
      , {hls: r} = this
      , {remuxResult: o, chunkMeta: a} = e
      , i = this.getCurrentContext(a);
    if (!i)
      return void this.resetWhenMissingContext(a);
    const {frag: s, part: l, level: u} = i
      , {video: c, text: d, id3: f, initSegment: p} = o
      , {details: h} = u
      , v = this.altAudio ? void 0 : o.audio;
    if (this.fragContextChanged(s))
      this.fragmentTracker.removeFragment(s);
    else {
      if (this.state = oct,
        p) {
        if (null != p && p.tracks) {
          const e = s.initSegment || s;
          this._bufferInitSegment(u, p.tracks, e, a),
            r.trigger(Bit.FRAG_PARSING_INIT_SEGMENT, {
              frag: e,
              id: n,
              tracks: p.tracks
            })
        }
        const e = p.initPTS
          , t = p.timescale;
        Fit(e) && (this.initPTS[s.cc] = {
          baseTime: e,
          timescale: t
        },
          r.trigger(Bit.INIT_PTS_FOUND, {
            frag: s,
            id: n,
            initPTS: e,
            timescale: t
          }))
      }
      if (c && h && "initSegment" !== s.sn) {
        const e = h.fragments[s.sn - 1 - h.startSN]
          , t = s.sn === h.startSN
          , n = !e || s.cc > e.cc;
        if (!1 !== o.independent) {
          const {startPTS: e, endPTS: r, startDTS: o, endDTS: i} = c;
          if (l)
            l.elementaryStreams[c.type] = {
              startPTS: e,
              endPTS: r,
              startDTS: o,
              endDTS: i
            };
          else if (c.firstKeyFrame && c.independent && 1 === a.id && !n && (this.couldBacktrack = !0),
          c.dropped && c.independent) {
            const o = this.getMainFwdBufferInfo()
              , a = (o ? o.end : this.getLoadPosition()) + this.config.maxBufferHole
              , l = c.firstKeyFramePTS ? c.firstKeyFramePTS : e;
            if (!t && a < l - this.config.maxBufferHole && !n)
              return void this.backtrack(s);
            n && (s.gap = !0),
              s.setElementaryStreamInfo(c.type, s.start, r, s.start, i, !0)
          }
          s.setElementaryStreamInfo(c.type, e, r, o, i),
          this.backtrackFragment && (this.backtrackFragment = s),
            this.bufferFragmentData(c, s, l, a, t || n)
        } else {
          if (!t && !n)
            return void this.backtrack(s);
          s.gap = !0
        }
      }
      if (v) {
        const {startPTS: e, endPTS: t, startDTS: n, endDTS: r} = v;
        l && (l.elementaryStreams[Xit] = {
          startPTS: e,
          endPTS: t,
          startDTS: n,
          endDTS: r
        }),
          s.setElementaryStreamInfo(Xit, e, t, n, r),
          this.bufferFragmentData(v, s, l, a)
      }
      if (h && null != f && null != (t = f.samples) && t.length) {
        const e = {
          id: n,
          frag: s,
          details: h,
          samples: f.samples
        };
        r.trigger(Bit.FRAG_PARSING_METADATA, e)
      }
      if (h && d) {
        const e = {
          id: n,
          frag: s,
          details: h,
          samples: d.samples
        };
        r.trigger(Bit.FRAG_PARSING_USERDATA, e)
      }
    }
  }
  _bufferInitSegment(e, t, n, r) {
    if (this.state !== oct)
      return;
    this.audioOnly = !!t.audio && !t.video,
    this.altAudio && !this.audioOnly && delete t.audio;
    const {audio: o, video: a, audiovideo: i} = t;
    if (o) {
      let t = e.audioCodec;
      const n = navigator.userAgent.toLowerCase();
      this.audioCodecSwitch && (t && (t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"),
      1 !== o.metadata.channelCount && -1 === n.indexOf("firefox") && (t = "mp4a.40.5")),
      -1 !== n.indexOf("android") && "audio/mpeg" !== o.container && (t = "mp4a.40.2",
        this.log(`Android: force audio codec to ${t}`)),
      e.audioCodec && e.audioCodec !== t && this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${t}"`),
        o.levelCodec = t,
        o.id = "main",
        this.log(`Init audio buffer, container:${o.container}, codecs[selected/level/parsed]=[${t || ""}/${e.audioCodec || ""}/${o.codec}]`)
    }
    a && (a.levelCodec = e.videoCodec,
      a.id = "main",
      this.log(`Init video buffer, container:${a.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${a.codec}]`)),
    i && this.log(`Init audiovideo buffer, container:${i.container}, codecs[level/parsed]=[${e.attrs.CODECS || ""}/${i.codec}]`),
      this.hls.trigger(Bit.BUFFER_CODECS, t),
      Object.keys(t).forEach((e=>{
          const o = t[e].initSegment;
          null != o && o.byteLength && this.hls.trigger(Bit.BUFFER_APPENDING, {
            type: e,
            data: o,
            frag: n,
            part: null,
            chunkMeta: r,
            parent: n.type
          })
        }
      )),
      this.tick()
  }
  getMainFwdBufferInfo() {
    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, Tlt)
  }
  backtrack(e) {
    this.couldBacktrack = !0,
      this.backtrackFragment = e,
      this.resetTransmuxer(),
      this.flushBufferGap(e),
      this.fragmentTracker.removeFragment(e),
      this.fragPrevious = null,
      this.nextLoadPosition = e.start,
      this.state = Zut
  }
  checkFragmentChanged() {
    const e = this.media;
    let t = null;
    if (e && e.readyState > 1 && !1 === e.seeking) {
      const n = e.currentTime;
      if (Vut.isBuffered(e, n) ? t = this.getAppendedFrag(n) : Vut.isBuffered(e, n + .1) && (t = this.getAppendedFrag(n + .1)),
        t) {
        this.backtrackFragment = null;
        const e = this.fragPlaying
          , n = t.level;
        e && t.sn === e.sn && e.level === n && t.urlId === e.urlId || (this.fragPlaying = t,
          this.hls.trigger(Bit.FRAG_CHANGED, {
            frag: t
          }),
        e && e.level === n || this.hls.trigger(Bit.LEVEL_SWITCHED, {
          level: n
        }))
      }
    }
  }
  get nextLevel() {
    const e = this.nextBufferedFrag;
    return e ? e.level : -1
  }
  get currentFrag() {
    const e = this.media;
    return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null
  }
  get currentProgramDateTime() {
    const e = this.media;
    if (e) {
      const t = e.currentTime
        , n = this.currentFrag;
      if (n && Fit(t) && Fit(n.programDateTime)) {
        const e = n.programDateTime + 1e3 * (t - n.start);
        return new Date(e)
      }
    }
    return null
  }
  get currentLevel() {
    const e = this.currentFrag;
    return e ? e.level : -1
  }
  get nextBufferedFrag() {
    const e = this.currentFrag;
    return e ? this.followingBufferedFrag(e) : null
  }
  get forceStartLoad() {
    return this._forceStartLoad
  }
}
class ydt {
  constructor(e, t=0, n=0) {
    this.halfLife = void 0,
      this.alpha_ = void 0,
      this.estimate_ = void 0,
      this.totalWeight_ = void 0,
      this.halfLife = e,
      this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0,
      this.estimate_ = t,
      this.totalWeight_ = n
  }
  sample(e, t) {
    const n = Math.pow(this.alpha_, e);
    this.estimate_ = t * (1 - n) + n * this.estimate_,
      this.totalWeight_ += e
  }
  getTotalWeight() {
    return this.totalWeight_
  }
  getEstimate() {
    if (this.alpha_) {
      const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
      if (e)
        return this.estimate_ / e
    }
    return this.estimate_
  }
}
class bdt {
  constructor(e, t, n, r=100) {
    this.defaultEstimate_ = void 0,
      this.minWeight_ = void 0,
      this.minDelayMs_ = void 0,
      this.slow_ = void 0,
      this.fast_ = void 0,
      this.defaultTTFB_ = void 0,
      this.ttfb_ = void 0,
      this.defaultEstimate_ = n,
      this.minWeight_ = .001,
      this.minDelayMs_ = 50,
      this.slow_ = new ydt(e),
      this.fast_ = new ydt(t),
      this.defaultTTFB_ = r,
      this.ttfb_ = new ydt(e)
  }
  update(e, t) {
    const {slow_: n, fast_: r, ttfb_: o} = this;
    n.halfLife !== e && (this.slow_ = new ydt(e,n.getEstimate(),n.getTotalWeight())),
    r.halfLife !== t && (this.fast_ = new ydt(t,r.getEstimate(),r.getTotalWeight())),
    o.halfLife !== e && (this.ttfb_ = new ydt(e,o.getEstimate(),o.getTotalWeight()))
  }
  sample(e, t) {
    const n = (e = Math.max(e, this.minDelayMs_)) / 1e3
      , r = 8 * t / n;
    this.fast_.sample(n, r),
      this.slow_.sample(n, r)
  }
  sampleTTFB(e) {
    const t = e / 1e3
      , n = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
    this.ttfb_.sample(n, Math.max(e, 5))
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_
  }
  getEstimate() {
    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
  }
  getEstimateTTFB() {
    return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_
  }
  destroy() {}
}
class wdt {
  constructor() {
    this.chunks = [],
      this.dataLength = 0
  }
  push(e) {
    this.chunks.push(e),
      this.dataLength += e.length
  }
  flush() {
    const {chunks: e, dataLength: t} = this;
    let n;
    return e.length ? (n = 1 === e.length ? e[0] : function(e, t) {
      const n = new Uint8Array(t);
      let r = 0;
      for (let o = 0; o < e.length; o++) {
        const t = e[o];
        n.set(t, r),
          r += t.length
      }
      return n
    }(e, t),
      this.reset(),
      n) : new Uint8Array(0)
  }
  reset() {
    this.chunks.length = 0,
      this.dataLength = 0
  }
}
function xdt(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (!Sdt(e[n].attrs, t[n].attrs))
      return !1;
  return !0
}
function Sdt(e, t) {
  const n = e["STABLE-RENDITION-ID"];
  return n ? n === t["STABLE-RENDITION-ID"] : !["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED"].some((n=>e[n] !== t[n]))
}
class Edt {
  constructor(e) {
    this.buffered = void 0;
    const t = (t,n,r)=>{
        if ((n >>>= 0) > r - 1)
          throw new DOMException(`Failed to execute '${t}' on 'TimeRanges': The index provided (${n}) is greater than the maximum bound (${r})`);
        return e[n][t]
      }
    ;
    this.buffered = {
      get length() {
        return e.length
      },
      end: n=>t("end", n, e.length),
      start: n=>t("start", n, e.length)
    }
  }
}
function Adt(e) {
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    "subtitles" !== r.kind && "captions" !== r.kind || !r.label || t.push(e[n])
  }
  return t
}
class Cdt {
  constructor(e) {
    this.buffers = void 0,
      this.queues = {
        video: [],
        audio: [],
        audiovideo: []
      },
      this.buffers = e
  }
  append(e, t) {
    const n = this.queues[t];
    n.push(e),
    1 === n.length && this.buffers[t] && this.executeNext(t)
  }
  insertAbort(e, t) {
    this.queues[t].unshift(e),
      this.executeNext(t)
  }
  appendBlocker(e) {
    let t;
    const n = new Promise((e=>{
        t = e
      }
    ))
      , r = {
      execute: t,
      onStart: ()=>{}
      ,
      onComplete: ()=>{}
      ,
      onError: ()=>{}
    };
    return this.append(r, e),
      n
  }
  executeNext(e) {
    const {buffers: t, queues: n} = this
      , r = t[e]
      , o = n[e];
    if (o.length) {
      const t = o[0];
      try {
        t.execute()
      } catch (Y_) {
        Hit.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"),
          t.onError(Y_),
        null != r && r.updating || (o.shift(),
          this.executeNext(e))
      }
    }
  }
  shiftAndExecuteNext(e) {
    this.queues[e].shift(),
      this.executeNext(e)
  }
  current(e) {
    return this.queues[e][0]
  }
}
const kdt = ilt()
  , Tdt = /([ha]vc.)(?:\.[^.,]+)+/;
const Ddt = {
  42: 225,
  92: 233,
  94: 237,
  95: 243,
  96: 250,
  123: 231,
  124: 247,
  125: 209,
  126: 241,
  127: 9608,
  128: 174,
  129: 176,
  130: 189,
  131: 191,
  132: 8482,
  133: 162,
  134: 163,
  135: 9834,
  136: 224,
  137: 32,
  138: 232,
  139: 226,
  140: 234,
  141: 238,
  142: 244,
  143: 251,
  144: 193,
  145: 201,
  146: 211,
  147: 218,
  148: 220,
  149: 252,
  150: 8216,
  151: 161,
  152: 42,
  153: 8217,
  154: 9473,
  155: 169,
  156: 8480,
  157: 8226,
  158: 8220,
  159: 8221,
  160: 192,
  161: 194,
  162: 199,
  163: 200,
  164: 202,
  165: 203,
  166: 235,
  167: 206,
  168: 207,
  169: 239,
  170: 212,
  171: 217,
  172: 249,
  173: 219,
  174: 171,
  175: 187,
  176: 195,
  177: 227,
  178: 205,
  179: 204,
  180: 236,
  181: 210,
  182: 242,
  183: 213,
  184: 245,
  185: 123,
  186: 125,
  187: 92,
  188: 94,
  189: 95,
  190: 124,
  191: 8764,
  192: 196,
  193: 228,
  194: 214,
  195: 246,
  196: 223,
  197: 165,
  198: 164,
  199: 9475,
  200: 197,
  201: 229,
  202: 216,
  203: 248,
  204: 9487,
  205: 9491,
  206: 9495,
  207: 9499
}
  , Odt = function(e) {
  let t = e;
  return Ddt.hasOwnProperty(e) && (t = Ddt[e]),
    String.fromCharCode(t)
}
  , _dt = 15
  , Rdt = 100
  , Ldt = {
  17: 1,
  18: 3,
  21: 5,
  22: 7,
  23: 9,
  16: 11,
  19: 12,
  20: 14
}
  , Idt = {
  17: 2,
  18: 4,
  21: 6,
  22: 8,
  23: 10,
  19: 13,
  20: 15
}
  , Pdt = {
  25: 1,
  26: 3,
  29: 5,
  30: 7,
  31: 9,
  24: 11,
  27: 12,
  28: 14
}
  , Fdt = {
  25: 2,
  26: 4,
  29: 6,
  30: 8,
  31: 10,
  27: 13,
  28: 15
}
  , Bdt = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
class Ndt {
  constructor() {
    this.time = null,
      this.verboseLevel = 0
  }
  log(e, t) {
    if (this.verboseLevel >= e) {
      const n = "function" == typeof t ? t() : t;
      Hit.log(`${this.time} [${e}] ${n}`)
    }
  }
}
const Mdt = function(e) {
  const t = [];
  for (let n = 0; n < e.length; n++)
    t.push(e[n].toString(16));
  return t
};
class jdt {
  constructor(e, t, n, r, o) {
    this.foreground = void 0,
      this.underline = void 0,
      this.italics = void 0,
      this.background = void 0,
      this.flash = void 0,
      this.foreground = e || "white",
      this.underline = t || !1,
      this.italics = n || !1,
      this.background = r || "black",
      this.flash = o || !1
  }
  reset() {
    this.foreground = "white",
      this.underline = !1,
      this.italics = !1,
      this.background = "black",
      this.flash = !1
  }
  setStyles(e) {
    const t = ["foreground", "underline", "italics", "background", "flash"];
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      e.hasOwnProperty(r) && (this[r] = e[r])
    }
  }
  isDefault() {
    return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
  }
  equals(e) {
    return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
  }
  copy(e) {
    this.foreground = e.foreground,
      this.underline = e.underline,
      this.italics = e.italics,
      this.background = e.background,
      this.flash = e.flash
  }
  toString() {
    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
  }
}
class Vdt {
  constructor(e, t, n, r, o, a) {
    this.uchar = void 0,
      this.penState = void 0,
      this.uchar = e || " ",
      this.penState = new jdt(t,n,r,o,a)
  }
  reset() {
    this.uchar = " ",
      this.penState.reset()
  }
  setChar(e, t) {
    this.uchar = e,
      this.penState.copy(t)
  }
  setPenState(e) {
    this.penState.copy(e)
  }
  equals(e) {
    return this.uchar === e.uchar && this.penState.equals(e.penState)
  }
  copy(e) {
    this.uchar = e.uchar,
      this.penState.copy(e.penState)
  }
  isEmpty() {
    return " " === this.uchar && this.penState.isDefault()
  }
}
class Udt {
  constructor(e) {
    this.chars = void 0,
      this.pos = void 0,
      this.currPenState = void 0,
      this.cueStartTime = void 0,
      this.logger = void 0,
      this.chars = [];
    for (let t = 0; t < Rdt; t++)
      this.chars.push(new Vdt);
    this.logger = e,
      this.pos = 0,
      this.currPenState = new jdt
  }
  equals(e) {
    let t = !0;
    for (let n = 0; n < Rdt; n++)
      if (!this.chars[n].equals(e.chars[n])) {
        t = !1;
        break
      }
    return t
  }
  copy(e) {
    for (let t = 0; t < Rdt; t++)
      this.chars[t].copy(e.chars[t])
  }
  isEmpty() {
    let e = !0;
    for (let t = 0; t < Rdt; t++)
      if (!this.chars[t].isEmpty()) {
        e = !1;
        break
      }
    return e
  }
  setCursor(e) {
    this.pos !== e && (this.pos = e),
      this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos),
        this.pos = 0) : this.pos > Rdt && (this.logger.log(3, "Too large cursor position " + this.pos),
        this.pos = Rdt)
  }
  moveCursor(e) {
    const t = this.pos + e;
    if (e > 1)
      for (let n = this.pos + 1; n < t + 1; n++)
        this.chars[n].setPenState(this.currPenState);
    this.setCursor(t)
  }
  backSpace() {
    this.moveCursor(-1),
      this.chars[this.pos].setChar(" ", this.currPenState)
  }
  insertChar(e) {
    e >= 144 && this.backSpace();
    const t = Odt(e);
    this.pos >= Rdt ? this.logger.log(0, (()=>"Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!")) : (this.chars[this.pos].setChar(t, this.currPenState),
      this.moveCursor(1))
  }
  clearFromPos(e) {
    let t;
    for (t = e; t < Rdt; t++)
      this.chars[t].reset()
  }
  clear() {
    this.clearFromPos(0),
      this.pos = 0,
      this.currPenState.reset()
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos)
  }
  getTextString() {
    const e = [];
    let t = !0;
    for (let n = 0; n < Rdt; n++) {
      const r = this.chars[n].uchar;
      " " !== r && (t = !1),
        e.push(r)
    }
    return t ? "" : e.join("")
  }
  setPenStyles(e) {
    this.currPenState.setStyles(e);
    this.chars[this.pos].setPenState(this.currPenState)
  }
}
class $dt {
  constructor(e) {
    this.rows = void 0,
      this.currRow = void 0,
      this.nrRollUpRows = void 0,
      this.lastOutputScreen = void 0,
      this.logger = void 0,
      this.rows = [];
    for (let t = 0; t < _dt; t++)
      this.rows.push(new Udt(e));
    this.logger = e,
      this.currRow = 14,
      this.nrRollUpRows = null,
      this.lastOutputScreen = null,
      this.reset()
  }
  reset() {
    for (let e = 0; e < _dt; e++)
      this.rows[e].clear();
    this.currRow = 14
  }
  equals(e) {
    let t = !0;
    for (let n = 0; n < _dt; n++)
      if (!this.rows[n].equals(e.rows[n])) {
        t = !1;
        break
      }
    return t
  }
  copy(e) {
    for (let t = 0; t < _dt; t++)
      this.rows[t].copy(e.rows[t])
  }
  isEmpty() {
    let e = !0;
    for (let t = 0; t < _dt; t++)
      if (!this.rows[t].isEmpty()) {
        e = !1;
        break
      }
    return e
  }
  backSpace() {
    this.rows[this.currRow].backSpace()
  }
  clearToEndOfRow() {
    this.rows[this.currRow].clearToEndOfRow()
  }
  insertChar(e) {
    this.rows[this.currRow].insertChar(e)
  }
  setPen(e) {
    this.rows[this.currRow].setPenStyles(e)
  }
  moveCursor(e) {
    this.rows[this.currRow].moveCursor(e)
  }
  setCursor(e) {
    this.logger.log(2, "setCursor: " + e);
    this.rows[this.currRow].setCursor(e)
  }
  setPAC(e) {
    this.logger.log(2, (()=>"pacData = " + JSON.stringify(e)));
    let t = e.row - 1;
    if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1),
    this.nrRollUpRows && this.currRow !== t) {
      for (let t = 0; t < _dt; t++)
        this.rows[t].clear();
      const e = this.currRow + 1 - this.nrRollUpRows
        , n = this.lastOutputScreen;
      if (n) {
        const r = n.rows[e].cueStartTime
          , o = this.logger.time;
        if (r && null !== o && r < o)
          for (let a = 0; a < this.nrRollUpRows; a++)
            this.rows[t - this.nrRollUpRows + a + 1].copy(n.rows[e + a])
      }
    }
    this.currRow = t;
    const n = this.rows[this.currRow];
    if (null !== e.indent) {
      const t = e.indent
        , r = Math.max(t - 1, 0);
      n.setCursor(e.indent),
        e.color = n.chars[r].penState.foreground
    }
    const r = {
      foreground: e.color,
      underline: e.underline,
      italics: e.italics,
      background: "black",
      flash: !1
    };
    this.setPen(r)
  }
  setBkgData(e) {
    this.logger.log(2, (()=>"bkgData = " + JSON.stringify(e))),
      this.backSpace(),
      this.setPen(e),
      this.insertChar(32)
  }
  setRollUpRows(e) {
    this.nrRollUpRows = e
  }
  rollUp() {
    if (null === this.nrRollUpRows)
      return void this.logger.log(3, "roll_up but nrRollUpRows not set yet");
    this.logger.log(1, (()=>this.getDisplayText()));
    const e = this.currRow + 1 - this.nrRollUpRows
      , t = this.rows.splice(e, 1)[0];
    t.clear(),
      this.rows.splice(this.currRow, 0, t),
      this.logger.log(2, "Rolling up")
  }
  getDisplayText(e) {
    e = e || !1;
    const t = [];
    let n = ""
      , r = -1;
    for (let o = 0; o < _dt; o++) {
      const n = this.rows[o].getTextString();
      n && (r = o + 1,
        e ? t.push("Row " + r + ": '" + n + "'") : t.push(n.trim()))
    }
    return t.length > 0 && (n = e ? "[" + t.join(" | ") + "]" : t.join("\n")),
      n
  }
  getTextAndFormat() {
    return this.rows
  }
}
class Hdt {
  constructor(e, t, n) {
    this.chNr = void 0,
      this.outputFilter = void 0,
      this.mode = void 0,
      this.verbose = void 0,
      this.displayedMemory = void 0,
      this.nonDisplayedMemory = void 0,
      this.lastOutputScreen = void 0,
      this.currRollUpRow = void 0,
      this.writeScreen = void 0,
      this.cueStartTime = void 0,
      this.logger = void 0,
      this.chNr = e,
      this.outputFilter = t,
      this.mode = null,
      this.verbose = 0,
      this.displayedMemory = new $dt(n),
      this.nonDisplayedMemory = new $dt(n),
      this.lastOutputScreen = new $dt(n),
      this.currRollUpRow = this.displayedMemory.rows[14],
      this.writeScreen = this.displayedMemory,
      this.mode = null,
      this.cueStartTime = null,
      this.logger = n
  }
  reset() {
    this.mode = null,
      this.displayedMemory.reset(),
      this.nonDisplayedMemory.reset(),
      this.lastOutputScreen.reset(),
      this.outputFilter.reset(),
      this.currRollUpRow = this.displayedMemory.rows[14],
      this.writeScreen = this.displayedMemory,
      this.mode = null,
      this.cueStartTime = null
  }
  getHandler() {
    return this.outputFilter
  }
  setHandler(e) {
    this.outputFilter = e
  }
  setPAC(e) {
    this.writeScreen.setPAC(e)
  }
  setBkgData(e) {
    this.writeScreen.setBkgData(e)
  }
  setMode(e) {
    e !== this.mode && (this.mode = e,
      this.logger.log(2, (()=>"MODE=" + e)),
      "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory,
        this.writeScreen.reset()),
    "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null,
      this.nonDisplayedMemory.nrRollUpRows = null),
      this.mode = e)
  }
  insertChars(e) {
    for (let n = 0; n < e.length; n++)
      this.writeScreen.insertChar(e[n]);
    const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
    this.logger.log(2, (()=>t + ": " + this.writeScreen.getDisplayText(!0))),
    "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (this.logger.log(1, (()=>"DISPLAYED: " + this.displayedMemory.getDisplayText(!0))),
      this.outputDataUpdate())
  }
  ccRCL() {
    this.logger.log(2, "RCL - Resume Caption Loading"),
      this.setMode("MODE_POP-ON")
  }
  ccBS() {
    this.logger.log(2, "BS - BackSpace"),
    "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(),
    this.writeScreen === this.displayedMemory && this.outputDataUpdate())
  }
  ccAOF() {}
  ccAON() {}
  ccDER() {
    this.logger.log(2, "DER- Delete to End of Row"),
      this.writeScreen.clearToEndOfRow(),
      this.outputDataUpdate()
  }
  ccRU(e) {
    this.logger.log(2, "RU(" + e + ") - Roll Up"),
      this.writeScreen = this.displayedMemory,
      this.setMode("MODE_ROLL-UP"),
      this.writeScreen.setRollUpRows(e)
  }
  ccFON() {
    this.logger.log(2, "FON - Flash On"),
      this.writeScreen.setPen({
        flash: !0
      })
  }
  ccRDC() {
    this.logger.log(2, "RDC - Resume Direct Captioning"),
      this.setMode("MODE_PAINT-ON")
  }
  ccTR() {
    this.logger.log(2, "TR"),
      this.setMode("MODE_TEXT")
  }
  ccRTD() {
    this.logger.log(2, "RTD"),
      this.setMode("MODE_TEXT")
  }
  ccEDM() {
    this.logger.log(2, "EDM - Erase Displayed Memory"),
      this.displayedMemory.reset(),
      this.outputDataUpdate(!0)
  }
  ccCR() {
    this.logger.log(2, "CR - Carriage Return"),
      this.writeScreen.rollUp(),
      this.outputDataUpdate(!0)
  }
  ccENM() {
    this.logger.log(2, "ENM - Erase Non-displayed Memory"),
      this.nonDisplayedMemory.reset()
  }
  ccEOC() {
    if (this.logger.log(2, "EOC - End Of Caption"),
    "MODE_POP-ON" === this.mode) {
      const e = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory,
        this.nonDisplayedMemory = e,
        this.writeScreen = this.nonDisplayedMemory,
        this.logger.log(1, (()=>"DISP: " + this.displayedMemory.getDisplayText()))
    }
    this.outputDataUpdate(!0)
  }
  ccTO(e) {
    this.logger.log(2, "TO(" + e + ") - Tab Offset"),
      this.writeScreen.moveCursor(e)
  }
  ccMIDROW(e) {
    const t = {
      flash: !1
    };
    if (t.underline = e % 2 == 1,
      t.italics = e >= 46,
      t.italics)
      t.foreground = "white";
    else {
      const n = Math.floor(e / 2) - 16
        , r = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
      t.foreground = r[n]
    }
    this.logger.log(2, "MIDROW: " + JSON.stringify(t)),
      this.writeScreen.setPen(t)
  }
  outputDataUpdate(e=!1) {
    const t = this.logger.time;
    null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen),
    e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(),
      this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t,
      this.lastOutputScreen.copy(this.displayedMemory))
  }
  cueSplitAtTime(e) {
    this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory),
      this.cueStartTime = e))
  }
}
class zdt {
  constructor(e, t, n) {
    this.channels = void 0,
      this.currentChannel = 0,
      this.cmdHistory = void 0,
      this.logger = void 0;
    const r = new Ndt;
    this.channels = [null, new Hdt(e,t,r), new Hdt(e + 1,n,r)],
      this.cmdHistory = {
        a: null,
        b: null
      },
      this.logger = r
  }
  getHandler(e) {
    return this.channels[e].getHandler()
  }
  setHandler(e, t) {
    this.channels[e].setHandler(t)
  }
  addData(e, t) {
    let n, r, o, a = !1;
    this.logger.time = e;
    for (let i = 0; i < t.length; i += 2)
      if (r = 127 & t[i],
        o = 127 & t[i + 1],
      0 !== r || 0 !== o) {
        if (this.logger.log(3, "[" + Mdt([t[i], t[i + 1]]) + "] -> (" + Mdt([r, o]) + ")"),
          n = this.parseCmd(r, o),
        n || (n = this.parseMidrow(r, o)),
        n || (n = this.parsePAC(r, o)),
        n || (n = this.parseBackgroundAttributes(r, o)),
        !n && (a = this.parseChars(r, o),
          a)) {
          const e = this.currentChannel;
          if (e && e > 0) {
            this.channels[e].insertChars(a)
          } else
            this.logger.log(2, "No channel found yet. TEXT-MODE?")
        }
        n || a || this.logger.log(2, "Couldn't parse cleaned data " + Mdt([r, o]) + " orig: " + Mdt([t[i], t[i + 1]]))
      }
  }
  parseCmd(e, t) {
    const {cmdHistory: n} = this;
    if (!((20 === e || 28 === e || 21 === e || 29 === e) && t >= 32 && t <= 47) && !((23 === e || 31 === e) && t >= 33 && t <= 35))
      return !1;
    if (Wdt(e, t, n))
      return Kdt(null, null, n),
        this.logger.log(3, "Repeated command (" + Mdt([e, t]) + ") is dropped"),
        !0;
    const r = 20 === e || 21 === e || 23 === e ? 1 : 2
      , o = this.channels[r];
    return 20 === e || 21 === e || 28 === e || 29 === e ? 32 === t ? o.ccRCL() : 33 === t ? o.ccBS() : 34 === t ? o.ccAOF() : 35 === t ? o.ccAON() : 36 === t ? o.ccDER() : 37 === t ? o.ccRU(2) : 38 === t ? o.ccRU(3) : 39 === t ? o.ccRU(4) : 40 === t ? o.ccFON() : 41 === t ? o.ccRDC() : 42 === t ? o.ccTR() : 43 === t ? o.ccRTD() : 44 === t ? o.ccEDM() : 45 === t ? o.ccCR() : 46 === t ? o.ccENM() : 47 === t && o.ccEOC() : o.ccTO(t - 32),
      Kdt(e, t, n),
      this.currentChannel = r,
      !0
  }
  parseMidrow(e, t) {
    let n = 0;
    if ((17 === e || 25 === e) && t >= 32 && t <= 47) {
      if (n = 17 === e ? 1 : 2,
      n !== this.currentChannel)
        return this.logger.log(0, "Mismatch channel in midrow parsing"),
          !1;
      const r = this.channels[n];
      return !!r && (r.ccMIDROW(t),
        this.logger.log(3, "MIDROW (" + Mdt([e, t]) + ")"),
        !0)
    }
    return !1
  }
  parsePAC(e, t) {
    let n;
    const r = this.cmdHistory;
    if (!((e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127) && !((16 === e || 24 === e) && t >= 64 && t <= 95))
      return !1;
    if (Wdt(e, t, r))
      return Kdt(null, null, r),
        !0;
    const o = e <= 23 ? 1 : 2;
    n = t >= 64 && t <= 95 ? 1 === o ? Ldt[e] : Pdt[e] : 1 === o ? Idt[e] : Fdt[e];
    const a = this.channels[o];
    return !!a && (a.setPAC(this.interpretPAC(n, t)),
      Kdt(e, t, r),
      this.currentChannel = o,
      !0)
  }
  interpretPAC(e, t) {
    let n;
    const r = {
      color: null,
      italics: !1,
      indent: null,
      underline: !1,
      row: e
    };
    return n = t > 95 ? t - 96 : t - 64,
      r.underline = 1 == (1 & n),
      n <= 13 ? r.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(n / 2)] : n <= 15 ? (r.italics = !0,
        r.color = "white") : r.indent = 4 * Math.floor((n - 16) / 2),
      r
  }
  parseChars(e, t) {
    let n, r = null, o = null;
    if (e >= 25 ? (n = 2,
      o = e - 8) : (n = 1,
      o = e),
    o >= 17 && o <= 19) {
      let e;
      e = 17 === o ? t + 80 : 18 === o ? t + 112 : t + 144,
        this.logger.log(2, "Special char '" + Odt(e) + "' in channel " + n),
        r = [e]
    } else
      e >= 32 && e <= 127 && (r = 0 === t ? [e] : [e, t]);
    if (r) {
      const n = Mdt(r);
      this.logger.log(3, "Char codes =  " + n.join(",")),
        Kdt(e, t, this.cmdHistory)
    }
    return r
  }
  parseBackgroundAttributes(e, t) {
    if (!((16 === e || 24 === e) && t >= 32 && t <= 47) && !((23 === e || 31 === e) && t >= 45 && t <= 47))
      return !1;
    let n;
    const r = {};
    16 === e || 24 === e ? (n = Math.floor((t - 32) / 2),
      r.background = Bdt[n],
    t % 2 == 1 && (r.background = r.background + "_semi")) : 45 === t ? r.background = "transparent" : (r.foreground = "black",
    47 === t && (r.underline = !0));
    const o = e <= 23 ? 1 : 2;
    return this.channels[o].setBkgData(r),
      Kdt(e, t, this.cmdHistory),
      !0
  }
  reset() {
    for (let e = 0; e < Object.keys(this.channels).length; e++) {
      const t = this.channels[e];
      t && t.reset()
    }
    this.cmdHistory = {
      a: null,
      b: null
    }
  }
  cueSplitAtTime(e) {
    for (let t = 0; t < this.channels.length; t++) {
      const n = this.channels[t];
      n && n.cueSplitAtTime(e)
    }
  }
}
function Kdt(e, t, n) {
  n.a = e,
    n.b = t
}
function Wdt(e, t, n) {
  return n.a === e && n.b === t
}
class Gdt {
  constructor(e, t) {
    this.timelineController = void 0,
      this.cueRanges = [],
      this.trackName = void 0,
      this.startTime = null,
      this.endTime = null,
      this.screen = null,
      this.timelineController = e,
      this.trackName = t
  }
  dispatchCue() {
    null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges),
      this.startTime = null)
  }
  newCue(e, t, n) {
    (null === this.startTime || this.startTime > e) && (this.startTime = e),
      this.endTime = t,
      this.screen = n,
      this.timelineController.createCaptionsTrack(this.trackName)
  }
  reset() {
    this.cueRanges = [],
      this.startTime = null
  }
}
var qdt = function() {
  if ("undefined" != typeof self && self.VTTCue)
    return self.VTTCue;
  const e = ["", "lr", "rl"]
    , t = ["start", "middle", "end", "left", "right"];
  function n(e, t) {
    if ("string" != typeof t)
      return !1;
    if (!Array.isArray(e))
      return !1;
    const n = t.toLowerCase();
    return !!~e.indexOf(n) && n
  }
  function r(e) {
    return n(t, e)
  }
  function o(e, ...t) {
    let n = 1;
    for (; n < arguments.length; n++) {
      const t = arguments[n];
      for (const n in t)
        e[n] = t[n]
    }
    return e
  }
  function a(t, a, i) {
    const s = this
      , l = {
      enumerable: !0
    };
    s.hasBeenReset = !1;
    let u = ""
      , c = !1
      , d = t
      , f = a
      , p = i
      , h = null
      , v = ""
      , g = !0
      , m = "auto"
      , y = "start"
      , b = 50
      , w = "middle"
      , x = 50
      , S = "middle";
    Object.defineProperty(s, "id", o({}, l, {
      get: function() {
        return u
      },
      set: function(e) {
        u = "" + e
      }
    })),
      Object.defineProperty(s, "pauseOnExit", o({}, l, {
        get: function() {
          return c
        },
        set: function(e) {
          c = !!e
        }
      })),
      Object.defineProperty(s, "startTime", o({}, l, {
        get: function() {
          return d
        },
        set: function(e) {
          if ("number" != typeof e)
            throw new TypeError("Start time must be set to a number.");
          d = e,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "endTime", o({}, l, {
        get: function() {
          return f
        },
        set: function(e) {
          if ("number" != typeof e)
            throw new TypeError("End time must be set to a number.");
          f = e,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "text", o({}, l, {
        get: function() {
          return p
        },
        set: function(e) {
          p = "" + e,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "region", o({}, l, {
        get: function() {
          return h
        },
        set: function(e) {
          h = e,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "vertical", o({}, l, {
        get: function() {
          return v
        },
        set: function(t) {
          const r = function(t) {
            return n(e, t)
          }(t);
          if (!1 === r)
            throw new SyntaxError("An invalid or illegal string was specified.");
          v = r,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "snapToLines", o({}, l, {
        get: function() {
          return g
        },
        set: function(e) {
          g = !!e,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "line", o({}, l, {
        get: function() {
          return m
        },
        set: function(e) {
          if ("number" != typeof e && "auto" !== e)
            throw new SyntaxError("An invalid number or illegal string was specified.");
          m = e,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "lineAlign", o({}, l, {
        get: function() {
          return y
        },
        set: function(e) {
          const t = r(e);
          if (!t)
            throw new SyntaxError("An invalid or illegal string was specified.");
          y = t,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "position", o({}, l, {
        get: function() {
          return b
        },
        set: function(e) {
          if (e < 0 || e > 100)
            throw new Error("Position must be between 0 and 100.");
          b = e,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "positionAlign", o({}, l, {
        get: function() {
          return w
        },
        set: function(e) {
          const t = r(e);
          if (!t)
            throw new SyntaxError("An invalid or illegal string was specified.");
          w = t,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "size", o({}, l, {
        get: function() {
          return x
        },
        set: function(e) {
          if (e < 0 || e > 100)
            throw new Error("Size must be between 0 and 100.");
          x = e,
            this.hasBeenReset = !0
        }
      })),
      Object.defineProperty(s, "align", o({}, l, {
        get: function() {
          return S
        },
        set: function(e) {
          const t = r(e);
          if (!t)
            throw new SyntaxError("An invalid or illegal string was specified.");
          S = t,
            this.hasBeenReset = !0
        }
      })),
      s.displayState = void 0
  }
  return a.prototype.getCueAsHTML = function() {
    return self.WebVTT.convertCueToDOMTree(self, this.text)
  }
    ,
    a
}();
class Ydt {
  decode(e, t) {
    if (!e)
      return "";
    if ("string" != typeof e)
      throw new Error("Error - expected string data.");
    return decodeURIComponent(encodeURIComponent(e))
  }
}
function Xdt(e) {
  function t(e, t, n, r) {
    return 3600 * (0 | e) + 60 * (0 | t) + (0 | n) + parseFloat(r || 0)
  }
  const n = e.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
  return n ? parseFloat(n[2]) > 59 ? t(n[2], n[3], 0, n[4]) : t(n[1], n[2], n[3], n[4]) : null
}
class Qdt {
  constructor() {
    this.values = Object.create(null)
  }
  set(e, t) {
    this.get(e) || "" === t || (this.values[e] = t)
  }
  get(e, t, n) {
    return n ? this.has(e) ? this.values[e] : t[n] : this.has(e) ? this.values[e] : t
  }
  has(e) {
    return e in this.values
  }
  alt(e, t, n) {
    for (let r = 0; r < n.length; ++r)
      if (t === n[r]) {
        this.set(e, t);
        break
      }
  }
  integer(e, t) {
    /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
  }
  percent(e, t) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
      const n = parseFloat(t);
      if (n >= 0 && n <= 100)
        return this.set(e, n),
          !0
    }
    return !1
  }
}
function Jdt(e, t, n, r) {
  const o = r ? e.split(r) : [e];
  for (const a in o) {
    if ("string" != typeof o[a])
      continue;
    const e = o[a].split(n);
    if (2 !== e.length)
      continue;
    t(e[0], e[1])
  }
}
const Zdt = new qdt(0,0,"")
  , eft = "middle" === Zdt.align ? "middle" : "center";
function tft(e, t, n) {
  const r = e;
  function o() {
    const t = Xdt(e);
    if (null === t)
      throw new Error("Malformed timestamp: " + r);
    return e = e.replace(/^[^\sa-zA-Z-]+/, ""),
      t
  }
  function a() {
    e = e.replace(/^\s+/, "")
  }
  if (a(),
    t.startTime = o(),
    a(),
  "--\x3e" !== e.slice(0, 3))
    throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + r);
  e = e.slice(3),
    a(),
    t.endTime = o(),
    a(),
    function(e, t) {
      const r = new Qdt;
      Jdt(e, (function(e, t) {
          let o;
          switch (e) {
            case "region":
              for (let o = n.length - 1; o >= 0; o--)
                if (n[o].id === t) {
                  r.set(e, n[o].region);
                  break
                }
              break;
            case "vertical":
              r.alt(e, t, ["rl", "lr"]);
              break;
            case "line":
              o = t.split(","),
                r.integer(e, o[0]),
              r.percent(e, o[0]) && r.set("snapToLines", !1),
                r.alt(e, o[0], ["auto"]),
              2 === o.length && r.alt("lineAlign", o[1], ["start", eft, "end"]);
              break;
            case "position":
              o = t.split(","),
                r.percent(e, o[0]),
              2 === o.length && r.alt("positionAlign", o[1], ["start", eft, "end", "line-left", "line-right", "auto"]);
              break;
            case "size":
              r.percent(e, t);
              break;
            case "align":
              r.alt(e, t, ["start", eft, "end", "left", "right"])
          }
        }
      ), /:/, /\s/),
        t.region = r.get("region", null),
        t.vertical = r.get("vertical", "");
      let o = r.get("line", "auto");
      "auto" === o && -1 === Zdt.line && (o = -1),
        t.line = o,
        t.lineAlign = r.get("lineAlign", "start"),
        t.snapToLines = r.get("snapToLines", !0),
        t.size = r.get("size", 100),
        t.align = r.get("align", eft);
      let a = r.get("position", "auto");
      "auto" === a && 50 === Zdt.position && (a = "start" === t.align || "left" === t.align ? 0 : "end" === t.align || "right" === t.align ? 100 : 50),
        t.position = a
    }(e, t)
}
function nft(e) {
  return e.replace(/<br(?: \/)?>/gi, "\n")
}
class rft {
  constructor() {
    this.state = "INITIAL",
      this.buffer = "",
      this.decoder = new Ydt,
      this.regionList = [],
      this.cue = null,
      this.oncue = void 0,
      this.onparsingerror = void 0,
      this.onflush = void 0
  }
  parse(e) {
    const t = this;
    function n() {
      let e = t.buffer
        , n = 0;
      for (e = nft(e); n < e.length && "\r" !== e[n] && "\n" !== e[n]; )
        ++n;
      const r = e.slice(0, n);
      return "\r" === e[n] && ++n,
      "\n" === e[n] && ++n,
        t.buffer = e.slice(n),
        r
    }
    e && (t.buffer += t.decoder.decode(e, {
      stream: !0
    }));
    try {
      let e = "";
      if ("INITIAL" === t.state) {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        e = n();
        const r = e.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
        if (null == r || !r[0])
          throw new Error("Malformed WebVTT signature.");
        t.state = "HEADER"
      }
      let r = !1;
      for (; t.buffer; ) {
        if (!/\r\n|\n/.test(t.buffer))
          return this;
        switch (r ? r = !1 : e = n(),
          t.state) {
          case "HEADER":
            /:/.test(e) ? Jdt(e, (function(e, t) {}
            ), /:/) : e || (t.state = "ID");
            continue;
          case "NOTE":
            e || (t.state = "ID");
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(e)) {
              t.state = "NOTE";
              break
            }
            if (!e)
              continue;
            if (t.cue = new qdt(0,0,""),
              t.state = "CUE",
            -1 === e.indexOf("--\x3e")) {
              t.cue.id = e;
              continue
            }
          case "CUE":
            if (!t.cue) {
              t.state = "BADCUE";
              continue
            }
            try {
              tft(e, t.cue, t.regionList)
            } catch (Y_) {
              t.cue = null,
                t.state = "BADCUE";
              continue
            }
            t.state = "CUETEXT";
            continue;
          case "CUETEXT":
          {
            const n = -1 !== e.indexOf("--\x3e");
            if (!e || n && (r = !0)) {
              t.oncue && t.cue && t.oncue(t.cue),
                t.cue = null,
                t.state = "ID";
              continue
            }
            if (null === t.cue)
              continue;
            t.cue.text && (t.cue.text += "\n"),
              t.cue.text += e
          }
            continue;
          case "BADCUE":
            e || (t.state = "ID")
        }
      }
    } catch (Y_) {
      "CUETEXT" === t.state && t.cue && t.oncue && t.oncue(t.cue),
        t.cue = null,
        t.state = "INITIAL" === t.state ? "BADWEBVTT" : "BADCUE"
    }
    return this
  }
  flush() {
    const e = this;
    try {
      if ((e.cue || "HEADER" === e.state) && (e.buffer += "\n\n",
        e.parse()),
      "INITIAL" === e.state || "BADWEBVTT" === e.state)
        throw new Error("Malformed WebVTT signature.")
    } catch (Y_) {
      e.onparsingerror && e.onparsingerror(Y_)
    }
    return e.onflush && e.onflush(),
      this
  }
}
const oft = /\r\n|\n\r|\n|\r/g
  , aft = function(e, t, n=0) {
  return e.slice(n, n + t.length) === t
}
  , ift = function(e) {
  let t = 5381
    , n = e.length;
  for (; n; )
    t = 33 * t ^ e.charCodeAt(--n);
  return (t >>> 0).toString()
};
function sft(e, t, n) {
  return ift(e.toString()) + ift(t.toString()) + ift(n)
}
function lft(e, t, n, r, o, a, i) {
  const s = new rft
    , l = _st(new Uint8Array(e)).trim().replace(oft, "\n").split("\n")
    , u = []
    , c = t ? function(e, t=1) {
    return qct(e, Gct, 1 / t)
  }(t.baseTime, t.timescale) : 0;
  let d, f = "00:00.000", p = 0, h = 0, v = !0;
  s.oncue = function(e) {
    const a = n[r];
    let i = n.ccOffset;
    const s = (p - c) / 9e4;
    if (null != a && a.new && (void 0 !== h ? i = n.ccOffset = a.start : function(e, t, n) {
      let r = e[t]
        , o = e[r.prevCC];
      if (!o || !o.new && r.new)
        return e.ccOffset = e.presentationOffset = r.start,
          void (r.new = !1);
      for (; null != (a = o) && a.new; ) {
        var a;
        e.ccOffset += r.start - o.start,
          r.new = !1,
          r = o,
          o = e[r.prevCC]
      }
      e.presentationOffset = n
    }(n, r, s)),
      s) {
      if (!t)
        return void (d = new Error("Missing initPTS for VTT MPEGTS"));
      i = s - n.presentationOffset
    }
    const l = e.endTime - e.startTime
      , f = edt(9e4 * (e.startTime + i - h), 9e4 * o) / 9e4;
    e.startTime = Math.max(f, 0),
      e.endTime = Math.max(f + l, 0);
    const v = e.text.trim();
    e.text = decodeURIComponent(encodeURIComponent(v)),
    e.id || (e.id = sft(e.startTime, e.endTime, v)),
    e.endTime > 0 && u.push(e)
  }
    ,
    s.onparsingerror = function(e) {
      d = e
    }
    ,
    s.onflush = function() {
      d ? i(d) : a(u)
    }
    ,
    l.forEach((e=>{
        if (v) {
          if (aft(e, "X-TIMESTAMP-MAP=")) {
            v = !1,
              e.slice(16).split(",").forEach((e=>{
                  aft(e, "LOCAL:") ? f = e.slice(6) : aft(e, "MPEGTS:") && (p = parseInt(e.slice(7)))
                }
              ));
            try {
              h = function(e) {
                let t = parseInt(e.slice(-3));
                const n = parseInt(e.slice(-6, -4))
                  , r = parseInt(e.slice(-9, -7))
                  , o = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
                if (!(Fit(t) && Fit(n) && Fit(r) && Fit(o)))
                  throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
                return t += 1e3 * n,
                  t += 6e4 * r,
                  t += 36e5 * o,
                  t
              }(f) / 1e3
            } catch (t) {
              d = t
            }
            return
          }
          "" === e && (v = !1)
        }
        s.parse(e + "\n")
      }
    )),
    s.flush()
}
const uft = "stpp.ttml.im1t"
  , cft = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/
  , dft = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/
  , fft = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
function pft(e, t, n, r) {
  const o = Ust(new Uint8Array(e), ["mdat"]);
  if (0 === o.length)
    return void r(new Error("Could not parse IMSC1 mdat"));
  const a = o.map((e=>_st(e)))
    , i = function(e, t, n=1, r=!1) {
    return qct(e, t, 1 / n, r)
  }(t.baseTime, 1, t.timescale);
  try {
    a.forEach((e=>n(function(e, t) {
      const n = (new DOMParser).parseFromString(e, "text/xml")
        , r = n.getElementsByTagName("tt")[0];
      if (!r)
        throw new Error("Invalid ttml");
      const o = {
        frameRate: 30,
        subFrameRate: 1,
        frameRateMultiplier: 0,
        tickRate: 0
      }
        , a = Object.keys(o).reduce(((e,t)=>(e[t] = r.getAttribute(`ttp:${t}`) || o[t],
        e)), {})
        , i = "preserve" !== r.getAttribute("xml:space")
        , s = vft(hft(r, "styling", "style"))
        , l = vft(hft(r, "layout", "region"))
        , u = hft(r, "body", "[begin]");
      return [].map.call(u, (e=>{
          const n = gft(e, i);
          if (!n || !e.hasAttribute("begin"))
            return null;
          const r = bft(e.getAttribute("begin"), a)
            , o = bft(e.getAttribute("dur"), a);
          let u = bft(e.getAttribute("end"), a);
          if (null === r)
            throw yft(e);
          if (null === u) {
            if (null === o)
              throw yft(e);
            u = r + o
          }
          const c = new qdt(r - t,u - t,n);
          c.id = sft(c.startTime, c.endTime, c.text);
          const d = function(e, t, n) {
            const r = "http://www.w3.org/ns/ttml#styling";
            let o = null;
            const a = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"]
              , i = null != e && e.hasAttribute("style") ? e.getAttribute("style") : null;
            i && n.hasOwnProperty(i) && (o = n[i]);
            return a.reduce(((n,a)=>{
                const i = mft(t, r, a) || mft(e, r, a) || mft(o, r, a);
                return i && (n[a] = i),
                  n
              }
            ), {})
          }(l[e.getAttribute("region")], s[e.getAttribute("style")], s)
            , {textAlign: f} = d;
          if (f) {
            const e = fft[f];
            e && (c.lineAlign = e),
              c.align = f
          }
          return Pit(c, d),
            c
        }
      )).filter((e=>null !== e))
    }(e, i))))
  } catch (s) {
    r(s)
  }
}
function hft(e, t, n) {
  const r = e.getElementsByTagName(t)[0];
  return r ? [].slice.call(r.querySelectorAll(n)) : []
}
function vft(e) {
  return e.reduce(((e,t)=>{
      const n = t.getAttribute("xml:id");
      return n && (e[n] = t),
        e
    }
  ), {})
}
function gft(e, t) {
  return [].slice.call(e.childNodes).reduce(((e,n,r)=>{
      var o;
      return "br" === n.nodeName && r ? e + "\n" : null != (o = n.childNodes) && o.length ? gft(n, t) : t ? e + n.textContent.trim().replace(/\s+/g, " ") : e + n.textContent
    }
  ), "")
}
function mft(e, t, n) {
  return e && e.hasAttributeNS(t, n) ? e.getAttributeNS(t, n) : null
}
function yft(e) {
  return new Error(`Could not parse ttml timestamp ${e}`)
}
function bft(e, t) {
  if (!e)
    return null;
  let n = Xdt(e);
  return null === n && (cft.test(e) ? n = function(e, t) {
    const n = cft.exec(e)
      , r = (0 | n[4]) + (0 | n[5]) / t.subFrameRate;
    return 3600 * (0 | n[1]) + 60 * (0 | n[2]) + (0 | n[3]) + r / t.frameRate
  }(e, t) : dft.test(e) && (n = function(e, t) {
    const n = dft.exec(e)
      , r = Number(n[1]);
    switch (n[2]) {
      case "h":
        return 3600 * r;
      case "m":
        return 60 * r;
      case "ms":
        return 1e3 * r;
      case "f":
        return r / t.frameRate;
      case "t":
        return r / t.tickRate
    }
    return r
  }(e, t))),
    n
}
function wft(e, t) {
  return !!e && e.label === t.name && !(e.textTrack1 || e.textTrack2)
}
class xft {
  constructor(e) {
    this.hls = void 0,
      this.autoLevelCapping = void 0,
      this.firstLevel = void 0,
      this.media = void 0,
      this.restrictedLevels = void 0,
      this.timer = void 0,
      this.clientRect = void 0,
      this.streamController = void 0,
      this.hls = e,
      this.autoLevelCapping = Number.POSITIVE_INFINITY,
      this.firstLevel = -1,
      this.media = null,
      this.restrictedLevels = [],
      this.timer = void 0,
      this.clientRect = null,
      this.registerListeners()
  }
  setStreamController(e) {
    this.streamController = e
  }
  destroy() {
    this.unregisterListener(),
    this.hls.config.capLevelToPlayerSize && this.stopCapping(),
      this.media = null,
      this.clientRect = null,
      this.hls = this.streamController = null
  }
  registerListeners() {
    const {hls: e} = this;
    e.on(Bit.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
      e.on(Bit.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.on(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on(Bit.BUFFER_CODECS, this.onBufferCodecs, this),
      e.on(Bit.MEDIA_DETACHING, this.onMediaDetaching, this)
  }
  unregisterListener() {
    const {hls: e} = this;
    e.off(Bit.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
      e.off(Bit.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.off(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off(Bit.BUFFER_CODECS, this.onBufferCodecs, this),
      e.off(Bit.MEDIA_DETACHING, this.onMediaDetaching, this)
  }
  onFpsDropLevelCapping(e, t) {
    const n = this.hls.levels[t.droppedLevel];
    this.isLevelAllowed(n) && this.restrictedLevels.push({
      bitrate: n.bitrate,
      height: n.height,
      width: n.width
    })
  }
  onMediaAttaching(e, t) {
    this.media = t.media instanceof HTMLVideoElement ? t.media : null,
      this.clientRect = null
  }
  onManifestParsed(e, t) {
    const n = this.hls;
    this.restrictedLevels = [],
      this.firstLevel = t.firstLevel,
    n.config.capLevelToPlayerSize && t.video && this.startCapping()
  }
  onBufferCodecs(e, t) {
    this.hls.config.capLevelToPlayerSize && t.video && this.startCapping()
  }
  onMediaDetaching() {
    this.stopCapping()
  }
  detectPlayerSize() {
    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
      const e = this.hls.levels;
      if (e.length) {
        const t = this.hls;
        t.autoLevelCapping = this.getMaxLevel(e.length - 1),
        t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(),
          this.autoLevelCapping = t.autoLevelCapping
      }
    }
  }
  getMaxLevel(e) {
    const t = this.hls.levels;
    if (!t.length)
      return -1;
    const n = t.filter(((t,n)=>this.isLevelAllowed(t) && n <= e));
    return this.clientRect = null,
      xft.getMaxLevelByMediaSize(n, this.mediaWidth, this.mediaHeight)
  }
  startCapping() {
    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY,
      this.hls.firstLevel = this.getMaxLevel(this.firstLevel),
      self.clearInterval(this.timer),
      this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3),
      this.detectPlayerSize())
  }
  stopCapping() {
    this.restrictedLevels = [],
      this.firstLevel = -1,
      this.autoLevelCapping = Number.POSITIVE_INFINITY,
    this.timer && (self.clearInterval(this.timer),
      this.timer = void 0)
  }
  getDimensions() {
    if (this.clientRect)
      return this.clientRect;
    const e = this.media
      , t = {
      width: 0,
      height: 0
    };
    if (e) {
      const n = e.getBoundingClientRect();
      t.width = n.width,
        t.height = n.height,
      t.width || t.height || (t.width = n.right - n.left || e.width || 0,
        t.height = n.bottom - n.top || e.height || 0)
    }
    return this.clientRect = t,
      t
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor
  }
  get contentScaleFactor() {
    let e = 1;
    if (!this.hls.config.ignoreDevicePixelRatio)
      try {
        e = self.devicePixelRatio
      } catch (Y_) {}
    return e
  }
  isLevelAllowed(e) {
    return !this.restrictedLevels.some((t=>e.bitrate === t.bitrate && e.width === t.width && e.height === t.height))
  }
  static getMaxLevelByMediaSize(e, t, n) {
    if (null == e || !e.length)
      return -1;
    let r = e.length - 1;
    for (let i = 0; i < e.length; i += 1) {
      const s = e[i];
      if ((s.width >= t || s.height >= n) && (o = s,
      !(a = e[i + 1]) || o.width !== a.width || o.height !== a.height)) {
        r = i;
        break
      }
    }
    var o, a;
    return r
  }
}
const Sft = "[eme]";
class Eft {
  constructor(e) {
    this.hls = void 0,
      this.config = void 0,
      this.media = null,
      this.keyFormatPromise = null,
      this.keySystemAccessPromises = {},
      this._requestLicenseFailureCount = 0,
      this.mediaKeySessions = [],
      this.keyIdToKeySessionPromise = {},
      this.setMediaKeysQueue = Eft.CDMCleanupPromise ? [Eft.CDMCleanupPromise] : [],
      this.onMediaEncrypted = this._onMediaEncrypted.bind(this),
      this.onWaitingForKey = this._onWaitingForKey.bind(this),
      this.debug = Hit.debug.bind(Hit, Sft),
      this.log = Hit.log.bind(Hit, Sft),
      this.warn = Hit.warn.bind(Hit, Sft),
      this.error = Hit.error.bind(Hit, Sft),
      this.hls = e,
      this.config = e.config,
      this.registerListeners()
  }
  destroy() {
    this.unregisterListeners(),
      this.onMediaDetached();
    const e = this.config;
    e.requestMediaKeySystemAccessFunc = null,
      e.licenseXhrSetup = e.licenseResponseCallback = void 0,
      e.drmSystems = e.drmSystemOptions = {},
      this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null,
      this.config = null
  }
  registerListeners() {
    this.hls.on(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
      this.hls.on(Bit.MEDIA_DETACHED, this.onMediaDetached, this),
      this.hls.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      this.hls.on(Bit.MANIFEST_LOADED, this.onManifestLoaded, this)
  }
  unregisterListeners() {
    this.hls.off(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
      this.hls.off(Bit.MEDIA_DETACHED, this.onMediaDetached, this),
      this.hls.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
      this.hls.off(Bit.MANIFEST_LOADED, this.onManifestLoaded, this)
  }
  getLicenseServerUrl(e) {
    const {drmSystems: t, widevineLicenseUrl: n} = this.config
      , r = t[e];
    if (r)
      return r.licenseUrl;
    if (e === ist.WIDEVINE && n)
      return n;
    throw new Error(`no license server URL configured for key-system "${e}"`)
  }
  getServerCertificateUrl(e) {
    const {drmSystems: t} = this.config
      , n = t[e];
    if (n)
      return n.serverCertificateUrl;
    this.log(`No Server Certificate in config.drmSystems["${e}"]`)
  }
  attemptKeySystemAccess(e) {
    const t = this.hls.levels
      , n = (e,t,n)=>!!e && n.indexOf(e) === t
      , r = t.map((e=>e.audioCodec)).filter(n)
      , o = t.map((e=>e.videoCodec)).filter(n);
    return r.length + o.length === 0 && o.push("avc1.42e01e"),
      new Promise(((t,n)=>{
          const a = e=>{
              const i = e.shift();
              this.getMediaKeysPromise(i, r, o).then((e=>t({
                keySystem: i,
                mediaKeys: e
              }))).catch((t=>{
                  e.length ? a(e) : n(t instanceof Aft ? t : new Aft({
                    type: Nit.KEY_SYSTEM_ERROR,
                    details: Mit.KEY_SYSTEM_NO_ACCESS,
                    error: t,
                    fatal: !0
                  },t.message))
                }
              ))
            }
          ;
          a(e)
        }
      ))
  }
  requestMediaKeySystemAccess(e, t) {
    const {requestMediaKeySystemAccessFunc: n} = this.config;
    if ("function" != typeof n) {
      let e = `Configured requestMediaKeySystemAccess is not a function ${n}`;
      return null === vst && "http:" === self.location.protocol && (e = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`),
        Promise.reject(new Error(e))
    }
    return n(e, t)
  }
  getMediaKeysPromise(e, t, n) {
    const r = function(e, t, n, r) {
      let o;
      switch (e) {
        case ist.FAIRPLAY:
          o = ["cenc", "sinf"];
          break;
        case ist.WIDEVINE:
        case ist.PLAYREADY:
          o = ["cenc"];
          break;
        case ist.CLEARKEY:
          o = ["cenc", "keyids"];
          break;
        default:
          throw new Error(`Unknown key-system: ${e}`)
      }
      return function(e, t, n, r) {
        return [{
          initDataTypes: e,
          persistentState: r.persistentState || "not-allowed",
          distinctiveIdentifier: r.distinctiveIdentifier || "not-allowed",
          sessionTypes: r.sessionTypes || [r.sessionType || "temporary"],
          audioCapabilities: t.map((e=>({
            contentType: `audio/mp4; codecs="${e}"`,
            robustness: r.audioRobustness || "",
            encryptionScheme: r.audioEncryptionScheme || null
          }))),
          videoCapabilities: n.map((e=>({
            contentType: `video/mp4; codecs="${e}"`,
            robustness: r.videoRobustness || "",
            encryptionScheme: r.videoEncryptionScheme || null
          })))
        }]
      }(o, t, n, r)
    }(e, t, n, this.config.drmSystemOptions)
      , o = this.keySystemAccessPromises[e];
    let a = null == o ? void 0 : o.keySystemAccess;
    if (!a) {
      this.log(`Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(r)}`),
        a = this.requestMediaKeySystemAccess(e, r);
      const t = this.keySystemAccessPromises[e] = {
        keySystemAccess: a
      };
      return a.catch((t=>{
          this.log(`Failed to obtain access to key-system "${e}": ${t}`)
        }
      )),
        a.then((n=>{
            this.log(`Access for key-system "${n.keySystem}" obtained`);
            const r = this.fetchServerCertificate(e);
            return this.log(`Create media-keys for "${e}"`),
              t.mediaKeys = n.createMediaKeys().then((t=>(this.log(`Media-keys created for "${e}"`),
                r.then((n=>n ? this.setMediaKeysServerCertificate(t, e, n) : t))))),
              t.mediaKeys.catch((t=>{
                  this.error(`Failed to create media-keys for "${e}"}: ${t}`)
                }
              )),
              t.mediaKeys
          }
        ))
    }
    return a.then((()=>o.mediaKeys))
  }
  createMediaKeySessionContext({decryptdata: e, keySystem: t, mediaKeys: n}) {
    this.log(`Creating key-system session "${t}" keyId: ${Lst(e.keyId || [])}`);
    const r = n.createSession()
      , o = {
      decryptdata: e,
      keySystem: t,
      mediaKeys: n,
      mediaKeysSession: r,
      keyStatus: "status-pending"
    };
    return this.mediaKeySessions.push(o),
      o
  }
  renewKeySession(e) {
    const t = e.decryptdata;
    if (t.pssh) {
      const n = this.createMediaKeySessionContext(e)
        , r = this.getKeyIdString(t)
        , o = "cenc";
      this.keyIdToKeySessionPromise[r] = this.generateRequestWithPreferredKeySession(n, o, t.pssh, "expired")
    } else
      this.warn("Could not renew expired session. Missing pssh initData.");
    this.removeSession(e)
  }
  getKeyIdString(e) {
    if (!e)
      throw new Error("Could not read keyId of undefined decryptdata");
    if (null === e.keyId)
      throw new Error("keyId is null");
    return Lst(e.keyId)
  }
  updateKeySession(e, t) {
    var n;
    const r = e.mediaKeysSession;
    return this.log(`Updating key-session "${r.sessionId}" for keyID ${Lst((null == (n = e.decryptdata) ? void 0 : n.keyId) || [])}\n      } (data length: ${t ? t.byteLength : t})`),
      r.update(t)
  }
  selectKeySystemFormat(e) {
    const t = Object.keys(e.levelkeys || {});
    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`),
      this.keyFormatPromise = this.getKeyFormatPromise(t)),
      this.keyFormatPromise
  }
  getKeyFormatPromise(e) {
    return new Promise(((t,n)=>{
        const r = hst(this.config)
          , o = e.map(dst).filter((e=>!!e && -1 !== r.indexOf(e)));
        return this.getKeySystemSelectionPromise(o).then((({keySystem: e})=>{
            const r = pst(e);
            r ? t(r) : n(new Error(`Unable to find format for key-system "${e}"`))
          }
        )).catch(n)
      }
    ))
  }
  loadKey(e) {
    const t = e.keyInfo.decryptdata
      , n = this.getKeyIdString(t)
      , r = `(keyId: ${n} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
    this.log(`Starting session for key ${r}`);
    let o = this.keyIdToKeySessionPromise[n];
    return o || (o = this.keyIdToKeySessionPromise[n] = this.getKeySystemForKeyPromise(t).then((({keySystem: n, mediaKeys: o})=>(this.throwIfDestroyed(),
      this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${r}`),
      this.attemptSetMediaKeys(n, o).then((()=>{
          this.throwIfDestroyed();
          const e = this.createMediaKeySessionContext({
            keySystem: n,
            mediaKeys: o,
            decryptdata: t
          });
          return this.generateRequestWithPreferredKeySession(e, "cenc", t.pssh, "playlist-key")
        }
      ))))),
      o.catch((e=>this.handleError(e)))),
      o
  }
  throwIfDestroyed(e="Invalid state") {
    if (!this.hls)
      throw new Error("invalid state")
  }
  handleError(e) {
    this.hls && (this.error(e.message),
      e instanceof Aft ? this.hls.trigger(Bit.ERROR, e.data) : this.hls.trigger(Bit.ERROR, {
        type: Nit.KEY_SYSTEM_ERROR,
        details: Mit.KEY_SYSTEM_NO_KEYS,
        error: e,
        fatal: !0
      }))
  }
  getKeySystemForKeyPromise(e) {
    const t = this.getKeyIdString(e)
      , n = this.keyIdToKeySessionPromise[t];
    if (!n) {
      const t = dst(e.keyFormat)
        , n = t ? [t] : hst(this.config);
      return this.attemptKeySystemAccess(n)
    }
    return n
  }
  getKeySystemSelectionPromise(e) {
    if (e.length || (e = hst(this.config)),
    0 === e.length)
      throw new Aft({
        type: Nit.KEY_SYSTEM_ERROR,
        details: Mit.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
        fatal: !0
      },`Missing key-system license configuration options ${JSON.stringify({
        drmSystems: this.config.drmSystems
      })}`);
    return this.attemptKeySystemAccess(e)
  }
  _onMediaEncrypted(e) {
    const {initDataType: t, initData: n} = e;
    if (this.debug(`"${e.type}" event: init data type: "${t}"`),
    null === n)
      return;
    let r, o;
    if ("sinf" === t && this.config.drmSystems[ist.FAIRPLAY]) {
      const e = Bst(new Uint8Array(n));
      try {
        const t = rst(JSON.parse(e).sinf)
          , n = zst(new Uint8Array(t));
        if (!n)
          return;
        r = n.subarray(8, 24),
          o = ist.FAIRPLAY
      } catch (u) {
        return void this.warn('Failed to parse sinf "encrypted" event message initData')
      }
    } else {
      const e = function(e) {
        if (!(e instanceof ArrayBuffer) || e.byteLength < 32)
          return null;
        const t = {
          version: 0,
          systemId: "",
          kids: null,
          data: null
        }
          , n = new DataView(e)
          , r = n.getUint32(0);
        if (e.byteLength !== r && r > 44)
          return null;
        if (1886614376 !== n.getUint32(4))
          return null;
        if (t.version = n.getUint32(8) >>> 24,
        t.version > 1)
          return null;
        t.systemId = Lst(new Uint8Array(e,12,16));
        const o = n.getUint32(28);
        if (0 === t.version) {
          if (r - 32 < o)
            return null;
          t.data = new Uint8Array(e,32,o)
        } else if (1 === t.version) {
          t.kids = [];
          for (let n = 0; n < o; n++)
            t.kids.push(new Uint8Array(e,32 + 16 * n,16))
        }
        return t
      }(n);
      if (null === e)
        return;
      0 === e.version && e.systemId === fst && e.data && (r = e.data.subarray(8, 24)),
        o = function(e) {
          if (e === fst)
            return ist.WIDEVINE
        }(e.systemId)
    }
    if (!o || !r)
      return;
    const a = Lst(r)
      , {keyIdToKeySessionPromise: i, mediaKeySessions: s} = this;
    let l = i[a];
    for (let c = 0; c < s.length; c++) {
      const e = s[c]
        , o = e.decryptdata;
      if (o.pssh || !o.keyId)
        continue;
      const u = Lst(o.keyId);
      if (a === u || -1 !== o.uri.replace(/-/g, "").indexOf(a)) {
        l = i[u],
          delete i[u],
          o.pssh = new Uint8Array(n),
          o.keyId = r,
          l = i[a] = l.then((()=>this.generateRequestWithPreferredKeySession(e, t, n, "encrypted-event-key-match")));
        break
      }
    }
    l || (l = i[a] = this.getKeySystemSelectionPromise([o]).then((({keySystem: e, mediaKeys: o})=>{
        var i;
        this.throwIfDestroyed();
        const s = new Zst("ISO-23001-7",a,null != (i = pst(e)) ? i : "");
        return s.pssh = new Uint8Array(n),
          s.keyId = r,
          this.attemptSetMediaKeys(e, o).then((()=>{
              this.throwIfDestroyed();
              const r = this.createMediaKeySessionContext({
                decryptdata: s,
                keySystem: e,
                mediaKeys: o
              });
              return this.generateRequestWithPreferredKeySession(r, t, n, "encrypted-event-no-match")
            }
          ))
      }
    ))),
      l.catch((e=>this.handleError(e)))
  }
  _onWaitingForKey(e) {
    this.log(`"${e.type}" event`)
  }
  attemptSetMediaKeys(e, t) {
    const n = this.setMediaKeysQueue.slice();
    this.log(`Setting media-keys for "${e}"`);
    const r = Promise.all(n).then((()=>{
        if (!this.media)
          throw new Error("Attempted to set mediaKeys without media element attached");
        return this.media.setMediaKeys(t)
      }
    ));
    return this.setMediaKeysQueue.push(r),
      r.then((()=>{
          this.log(`Media-keys set for "${e}"`),
            n.push(r),
            this.setMediaKeysQueue = this.setMediaKeysQueue.filter((e=>-1 === n.indexOf(e)))
        }
      ))
  }
  generateRequestWithPreferredKeySession(e, t, n, r) {
    var o, a;
    const i = null == (o = this.config.drmSystems) || null == (a = o[e.keySystem]) ? void 0 : a.generateRequest;
    if (i)
      try {
        const r = i.call(this.hls, t, n, e);
        if (!r)
          throw new Error("Invalid response from configured generateRequest filter");
        t = r.initDataType,
          n = e.decryptdata.pssh = r.initData ? new Uint8Array(r.initData) : null
      } catch (d) {
        var s;
        if (this.warn(d.message),
        null != (s = this.hls) && s.config.debug)
          throw d
      }
    if (null === n)
      return this.log(`Skipping key-session request for "${r}" (no initData)`),
        Promise.resolve(e);
    const l = this.getKeyIdString(e.decryptdata);
    this.log(`Generating key-session request for "${r}": ${l} (init data type: ${t} length: ${n ? n.byteLength : null})`);
    const u = new pdt;
    e.mediaKeysSession.onmessage = t=>{
      const n = e.mediaKeysSession;
      if (!n)
        return void u.emit("error", new Error("invalid state"));
      const {messageType: r, message: o} = t;
      this.log(`"${r}" message event for session "${n.sessionId}" message size: ${o.byteLength}`),
        "license-request" === r || "license-renewal" === r ? this.renewLicense(e, o).catch((e=>{
            this.handleError(e),
              u.emit("error", e)
          }
        )) : "license-release" === r ? e.keySystem === ist.FAIRPLAY && (this.updateKeySession(e, ast("acknowledged")),
          this.removeSession(e)) : this.warn(`unhandled media key message type "${r}"`)
    }
      ,
      e.mediaKeysSession.onkeystatuseschange = t=>{
        if (!e.mediaKeysSession)
          return void u.emit("error", new Error("invalid state"));
        this.onKeyStatusChange(e);
        const n = e.keyStatus;
        u.emit("keyStatus", n),
        "expired" === n && (this.warn(`${e.keySystem} expired for key ${l}`),
          this.renewKeySession(e))
      }
    ;
    const c = new Promise(((e,t)=>{
        u.on("error", t),
          u.on("keyStatus", (n=>{
              n.startsWith("usable") ? e() : "output-restricted" === n ? t(new Aft({
                type: Nit.KEY_SYSTEM_ERROR,
                details: Mit.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                fatal: !1
              },"HDCP level output restricted")) : "internal-error" === n ? t(new Aft({
                type: Nit.KEY_SYSTEM_ERROR,
                details: Mit.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                fatal: !0
              },`key status changed to "${n}"`)) : "expired" === n ? t(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${n}"`)
            }
          ))
      }
    ));
    return e.mediaKeysSession.generateRequest(t, n).then((()=>{
        var t;
        this.log(`Request generated for key-session "${null == (t = e.mediaKeysSession) ? void 0 : t.sessionId}" keyId: ${l}`)
      }
    )).catch((e=>{
        throw new Aft({
          type: Nit.KEY_SYSTEM_ERROR,
          details: Mit.KEY_SYSTEM_NO_SESSION,
          error: e,
          fatal: !1
        },`Error generating key-session request: ${e}`)
      }
    )).then((()=>c)).catch((t=>{
        throw u.removeAllListeners(),
          this.removeSession(e),
          t
      }
    )).then((()=>(u.removeAllListeners(),
      e)))
  }
  onKeyStatusChange(e) {
    e.mediaKeysSession.keyStatuses.forEach(((t,n)=>{
        this.log(`key status change "${t}" for keyStatuses keyId: ${Lst("buffer"in n ? new Uint8Array(n.buffer,n.byteOffset,n.byteLength) : new Uint8Array(n))} session keyId: ${Lst(new Uint8Array(e.decryptdata.keyId || []))} uri: ${e.decryptdata.uri}`),
          e.keyStatus = t
      }
    ))
  }
  fetchServerCertificate(e) {
    const t = this.config
      , n = new (0,
      t.loader)(t)
      , r = this.getServerCertificateUrl(e);
    return r ? (this.log(`Fetching serverCertificate for "${e}"`),
      new Promise(((o,a)=>{
          const i = {
            responseType: "arraybuffer",
            url: r
          }
            , s = t.certLoadPolicy.default
            , l = {
            loadPolicy: s,
            timeout: s.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0
          }
            , u = {
            onSuccess: (e,t,n,r)=>{
              o(e.data)
            }
            ,
            onError: (t,n,o,s)=>{
              a(new Aft({
                type: Nit.KEY_SYSTEM_ERROR,
                details: Mit.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                fatal: !0,
                networkDetails: o,
                response: Lit({
                  url: i.url,
                  data: void 0
                }, t)
              },`"${e}" certificate request failed (${r}). Status: ${t.code} (${t.text})`))
            }
            ,
            onTimeout: (t,n,o)=>{
              a(new Aft({
                type: Nit.KEY_SYSTEM_ERROR,
                details: Mit.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                fatal: !0,
                networkDetails: o,
                response: {
                  url: i.url,
                  data: void 0
                }
              },`"${e}" certificate request timed out (${r})`))
            }
            ,
            onAbort: (e,t,n)=>{
              a(new Error("aborted"))
            }
          };
          n.load(i, l, u)
        }
      ))) : Promise.resolve()
  }
  setMediaKeysServerCertificate(e, t, n) {
    return new Promise(((r,o)=>{
        e.setServerCertificate(n).then((o=>{
            this.log(`setServerCertificate ${o ? "success" : "not supported by CDM"} (${null == n ? void 0 : n.byteLength}) on "${t}"`),
              r(e)
          }
        )).catch((e=>{
            o(new Aft({
              type: Nit.KEY_SYSTEM_ERROR,
              details: Mit.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
              error: e,
              fatal: !0
            },e.message))
          }
        ))
      }
    ))
  }
  renewLicense(e, t) {
    return this.requestLicense(e, new Uint8Array(t)).then((t=>this.updateKeySession(e, new Uint8Array(t)).catch((e=>{
        throw new Aft({
          type: Nit.KEY_SYSTEM_ERROR,
          details: Mit.KEY_SYSTEM_SESSION_UPDATE_FAILED,
          error: e,
          fatal: !0
        },e.message)
      }
    ))))
  }
  setupLicenseXHR(e, t, n, r) {
    const o = this.config.licenseXhrSetup;
    return o ? Promise.resolve().then((()=>{
        if (!n.decryptdata)
          throw new Error("Key removed");
        return o.call(this.hls, e, t, n, r)
      }
    )).catch((a=>{
        if (!n.decryptdata)
          throw a;
        return e.open("POST", t, !0),
          o.call(this.hls, e, t, n, r)
      }
    )).then((n=>{
        e.readyState || e.open("POST", t, !0);
        return {
          xhr: e,
          licenseChallenge: n || r
        }
      }
    )) : (e.open("POST", t, !0),
      Promise.resolve({
        xhr: e,
        licenseChallenge: r
      }))
  }
  requestLicense(e, t) {
    const n = this.config.keyLoadPolicy.default;
    return new Promise(((r,o)=>{
        const a = this.getLicenseServerUrl(e.keySystem);
        this.log(`Sending license request to URL: ${a}`);
        const i = new XMLHttpRequest;
        i.responseType = "arraybuffer",
          i.onreadystatechange = ()=>{
            if (!this.hls || !e.mediaKeysSession)
              return o(new Error("invalid state"));
            if (4 === i.readyState)
              if (200 === i.status) {
                this._requestLicenseFailureCount = 0;
                let t = i.response;
                this.log(`License received ${tinstanceof ArrayBuffer ? t.byteLength : t}`);
                const n = this.config.licenseResponseCallback;
                if (n)
                  try {
                    t = n.call(this.hls, i, a, e)
                  } catch (s) {
                    this.error(s)
                  }
                r(t)
              } else {
                const s = n.errorRetry
                  , l = s ? s.maxNumRetry : 0;
                if (this._requestLicenseFailureCount++,
                this._requestLicenseFailureCount > l || i.status >= 400 && i.status < 500)
                  o(new Aft({
                    type: Nit.KEY_SYSTEM_ERROR,
                    details: Mit.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                    fatal: !0,
                    networkDetails: i,
                    response: {
                      url: a,
                      data: void 0,
                      code: i.status,
                      text: i.statusText
                    }
                  },`License Request XHR failed (${a}). Status: ${i.status} (${i.statusText})`));
                else {
                  const n = l - this._requestLicenseFailureCount + 1;
                  this.warn(`Retrying license request, ${n} attempts left`),
                    this.requestLicense(e, t).then(r, o)
                }
              }
          }
          ,
        e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(),
          e.licenseXhr = i,
          this.setupLicenseXHR(i, a, e, t).then((({xhr: e, licenseChallenge: t})=>{
              e.send(t)
            }
          ))
      }
    ))
  }
  onMediaAttached(e, t) {
    if (!this.config.emeEnabled)
      return;
    const n = t.media;
    this.media = n,
      n.addEventListener("encrypted", this.onMediaEncrypted),
      n.addEventListener("waitingforkey", this.onWaitingForKey)
  }
  onMediaDetached() {
    const e = this.media
      , t = this.mediaKeySessions;
    e && (e.removeEventListener("encrypted", this.onMediaEncrypted),
      e.removeEventListener("waitingforkey", this.onWaitingForKey),
      this.media = null),
      this._requestLicenseFailureCount = 0,
      this.setMediaKeysQueue = [],
      this.mediaKeySessions = [],
      this.keyIdToKeySessionPromise = {},
      Zst.clearKeyUriToKeyIdMap();
    const n = t.length;
    Eft.CDMCleanupPromise = Promise.all(t.map((e=>this.removeSession(e))).concat(null == e ? void 0 : e.setMediaKeys(null).catch((t=>{
        this.log(`Could not clear media keys: ${t}. media.src: ${null == e ? void 0 : e.src}`)
      }
    )))).then((()=>{
        n && (this.log("finished closing key sessions and clearing media keys"),
          t.length = 0)
      }
    )).catch((t=>{
        this.log(`Could not close sessions and clear media keys: ${t}. media.src: ${null == e ? void 0 : e.src}`)
      }
    ))
  }
  onManifestLoading() {
    this.keyFormatPromise = null
  }
  onManifestLoaded(e, {sessionKeys: t}) {
    if (t && this.config.emeEnabled && !this.keyFormatPromise) {
      const e = t.reduce(((e,t)=>(-1 === e.indexOf(t.keyFormat) && e.push(t.keyFormat),
        e)), []);
      this.log(`Selecting key-system from session-keys ${e.join(", ")}`),
        this.keyFormatPromise = this.getKeyFormatPromise(e)
    }
  }
  removeSession(e) {
    const {mediaKeysSession: t, licenseXhr: n} = e;
    if (t) {
      this.log(`Remove licenses and keys and close session ${t.sessionId}`),
        t.onmessage = null,
        t.onkeystatuseschange = null,
      n && n.readyState !== XMLHttpRequest.DONE && n.abort(),
        e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
      const r = this.mediaKeySessions.indexOf(e);
      return r > -1 && this.mediaKeySessions.splice(r, 1),
        t.remove().catch((e=>{
            this.log(`Could not remove session: ${e}`)
          }
        )).then((()=>t.close())).catch((e=>{
            this.log(`Could not close session: ${e}`)
          }
        ))
    }
  }
}
Eft.CDMCleanupPromise = void 0;
class Aft extends Error {
  constructor(e, t) {
    super(t),
      this.data = void 0,
    e.error || (e.error = new Error(t)),
      this.data = e,
      e.err = e.error
  }
}
var Cft = "m"
  , kft = "a"
  , Tft = "v"
  , Dft = "av"
  , Oft = "i"
  , _ft = "tt";
class Rft {
  constructor(e) {
    this.hls = void 0,
      this.config = void 0,
      this.media = void 0,
      this.sid = void 0,
      this.cid = void 0,
      this.useHeaders = !1,
      this.initialized = !1,
      this.starved = !1,
      this.buffering = !0,
      this.audioBuffer = void 0,
      this.videoBuffer = void 0,
      this.onWaiting = ()=>{
        this.initialized && (this.starved = !0),
          this.buffering = !0
      }
      ,
      this.onPlaying = ()=>{
        this.initialized || (this.initialized = !0),
          this.buffering = !1
      }
      ,
      this.applyPlaylistData = e=>{
        try {
          this.apply(e, {
            ot: Cft,
            su: !this.initialized
          })
        } catch (t) {
          Hit.warn("Could not generate manifest CMCD data.", t)
        }
      }
      ,
      this.applyFragmentData = e=>{
        try {
          const t = e.frag
            , n = this.hls.levels[t.level]
            , r = this.getObjectType(t)
            , o = {
            d: 1e3 * t.duration,
            ot: r
          };
          r !== Tft && r !== kft && r != Dft || (o.br = n.bitrate / 1e3,
            o.tb = this.getTopBandwidth(r) / 1e3,
            o.bl = this.getBufferLength(r)),
            this.apply(e, o)
        } catch (t) {
          Hit.warn("Could not generate segment CMCD data.", t)
        }
      }
      ,
      this.hls = e;
    const t = this.config = e.config
      , {cmcd: n} = t;
    null != n && (t.pLoader = this.createPlaylistLoader(),
      t.fLoader = this.createFragmentLoader(),
      this.sid = n.sessionId || Rft.uuid(),
      this.cid = n.contentId,
      this.useHeaders = !0 === n.useHeaders,
      this.registerListeners())
  }
  registerListeners() {
    const e = this.hls;
    e.on(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on(Bit.MEDIA_DETACHED, this.onMediaDetached, this),
      e.on(Bit.BUFFER_CREATED, this.onBufferCreated, this)
  }
  unregisterListeners() {
    const e = this.hls;
    e.off(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off(Bit.MEDIA_DETACHED, this.onMediaDetached, this),
      e.off(Bit.BUFFER_CREATED, this.onBufferCreated, this)
  }
  destroy() {
    this.unregisterListeners(),
      this.onMediaDetached(),
      this.hls = this.config = this.audioBuffer = this.videoBuffer = null
  }
  onMediaAttached(e, t) {
    this.media = t.media,
      this.media.addEventListener("waiting", this.onWaiting),
      this.media.addEventListener("playing", this.onPlaying)
  }
  onMediaDetached() {
    this.media && (this.media.removeEventListener("waiting", this.onWaiting),
      this.media.removeEventListener("playing", this.onPlaying),
      this.media = null)
  }
  onBufferCreated(e, t) {
    var n, r;
    this.audioBuffer = null == (n = t.tracks.audio) ? void 0 : n.buffer,
      this.videoBuffer = null == (r = t.tracks.video) ? void 0 : r.buffer
  }
  createData() {
    var e;
    return {
      v: 1,
      sf: "h",
      sid: this.sid,
      cid: this.cid,
      pr: null == (e = this.media) ? void 0 : e.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1e3
    }
  }
  apply(e, t={}) {
    Pit(t, this.createData());
    const n = t.ot === Oft || t.ot === Tft || t.ot === Dft;
    if (this.starved && n && (t.bs = !0,
      t.su = !0,
      this.starved = !1),
    null == t.su && (t.su = this.buffering),
      this.useHeaders) {
      const n = Rft.toHeaders(t);
      if (!Object.keys(n).length)
        return;
      e.headers || (e.headers = {}),
        Pit(e.headers, n)
    } else {
      const n = Rft.toQuery(t);
      if (!n)
        return;
      e.url = Rft.appendQueryToUri(e.url, n)
    }
  }
  getObjectType(e) {
    const {type: t} = e;
    return "subtitle" === t ? _ft : "initSegment" === e.sn ? Oft : "audio" === t ? kft : "main" === t ? this.hls.audioTracks.length ? Tft : Dft : void 0
  }
  getTopBandwidth(e) {
    let t, n = 0;
    const r = this.hls;
    if (e === kft)
      t = r.audioTracks;
    else {
      const e = r.maxAutoLevel
        , n = e > -1 ? e + 1 : r.levels.length;
      t = r.levels.slice(0, n)
    }
    for (const o of t)
      o.bitrate > n && (n = o.bitrate);
    return n > 0 ? n : NaN
  }
  getBufferLength(e) {
    const t = this.hls.media
      , n = e === kft ? this.audioBuffer : this.videoBuffer;
    if (!n || !t)
      return NaN;
    return 1e3 * Vut.bufferInfo(n, t.currentTime, this.config.maxBufferHole).len
  }
  createPlaylistLoader() {
    const {pLoader: e} = this.config
      , t = this.applyPlaylistData
      , n = e || this.config.loader;
    return class {
      constructor(e) {
        this.loader = void 0,
          this.loader = new n(e)
      }
      get stats() {
        return this.loader.stats
      }
      get context() {
        return this.loader.context
      }
      destroy() {
        this.loader.destroy()
      }
      abort() {
        this.loader.abort()
      }
      load(e, n, r) {
        t(e),
          this.loader.load(e, n, r)
      }
    }
  }
  createFragmentLoader() {
    const {fLoader: e} = this.config
      , t = this.applyFragmentData
      , n = e || this.config.loader;
    return class {
      constructor(e) {
        this.loader = void 0,
          this.loader = new n(e)
      }
      get stats() {
        return this.loader.stats
      }
      get context() {
        return this.loader.context
      }
      destroy() {
        this.loader.destroy()
      }
      abort() {
        this.loader.abort()
      }
      load(e, n, r) {
        t(e),
          this.loader.load(e, n, r)
      }
    }
  }
  static uuid() {
    const e = URL.createObjectURL(new Blob)
      , t = e.toString();
    return URL.revokeObjectURL(e),
      t.slice(t.lastIndexOf("/") + 1)
  }
  static serialize(e) {
    const t = []
      , n = e=>!Number.isNaN(e) && null != e && "" !== e && !1 !== e
      , r = e=>Math.round(e)
      , o = e=>100 * r(e / 100)
      , a = {
      br: r,
      d: r,
      bl: o,
      dl: o,
      mtp: o,
      nor: e=>encodeURIComponent(e),
      rtp: o,
      tb: r
    }
      , i = Object.keys(e || {}).sort();
    for (const s of i) {
      let r = e[s];
      if (!n(r))
        continue;
      if ("v" === s && 1 === r)
        continue;
      if ("pr" == s && 1 === r)
        continue;
      const o = a[s];
      o && (r = o(r));
      const i = typeof r;
      let l;
      l = "ot" === s || "sf" === s || "st" === s ? `${s}=${r}` : "boolean" === i ? s : "number" === i ? `${s}=${r}` : `${s}=${JSON.stringify(r)}`,
        t.push(l)
    }
    return t.join(",")
  }
  static toHeaders(e) {
    const t = Object.keys(e)
      , n = {}
      , r = ["Object", "Request", "Session", "Status"]
      , o = [{}, {}, {}, {}]
      , a = {
      br: 0,
      d: 0,
      ot: 0,
      tb: 0,
      bl: 1,
      dl: 1,
      mtp: 1,
      nor: 1,
      nrr: 1,
      su: 1,
      cid: 2,
      pr: 2,
      sf: 2,
      sid: 2,
      st: 2,
      v: 2,
      bs: 3,
      rtp: 3
    };
    for (const i of t) {
      o[null != a[i] ? a[i] : 1][i] = e[i]
    }
    for (let i = 0; i < o.length; i++) {
      const e = Rft.serialize(o[i]);
      e && (n[`CMCD-${r[i]}`] = e)
    }
    return n
  }
  static toQuery(e) {
    return `CMCD=${encodeURIComponent(Rft.serialize(e))}`
  }
  static appendQueryToUri(e, t) {
    if (!t)
      return e;
    const n = e.includes("?") ? "&" : "?";
    return `${e}${n}${t}`
  }
}
function Lft(e, t, n, r) {
  e && Object.keys(t).forEach((o=>{
      const a = e.filter((e=>e.groupId === o)).map((e=>{
          const a = Pit({}, e);
          return a.details = void 0,
            a.attrs = new Wit(a.attrs),
            a.url = a.attrs.URI = Ift(e.url, e.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", n),
            a.groupId = a.attrs["GROUP-ID"] = t[o],
            a.attrs["PATHWAY-ID"] = r,
            a
        }
      ));
      e.push(...a)
    }
  ))
}
function Ift(e, t, n, r) {
  const {HOST: o, PARAMS: a, [n]: i} = r;
  let s;
  t && (s = null == i ? void 0 : i[t],
  s && (e = s));
  const l = new self.URL(e);
  return o && !s && (l.host = o),
  a && Object.keys(a).sort().forEach((e=>{
      e && l.searchParams.set(e, a[e])
    }
  )),
    l.href
}
const Pft = /^age:\s*[\d.]+\s*$/im;
class Fft {
  constructor(e) {
    this.xhrSetup = void 0,
      this.requestTimeout = void 0,
      this.retryTimeout = void 0,
      this.retryDelay = void 0,
      this.config = null,
      this.callbacks = null,
      this.context = void 0,
      this.loader = null,
      this.stats = void 0,
      this.xhrSetup = e && e.xhrSetup || null,
      this.stats = new Yit,
      this.retryDelay = 0
  }
  destroy() {
    this.callbacks = null,
      this.abortInternal(),
      this.loader = null,
      this.config = null
  }
  abortInternal() {
    const e = this.loader;
    self.clearTimeout(this.requestTimeout),
      self.clearTimeout(this.retryTimeout),
    e && (e.onreadystatechange = null,
      e.onprogress = null,
    4 !== e.readyState && (this.stats.aborted = !0,
      e.abort()))
  }
  abort() {
    var e;
    this.abortInternal(),
    null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
  }
  load(e, t, n) {
    if (this.stats.loading.start)
      throw new Error("Loader can only be used once.");
    this.stats.loading.start = self.performance.now(),
      this.context = e,
      this.config = t,
      this.callbacks = n,
      this.loadInternal()
  }
  loadInternal() {
    const {config: e, context: t} = this;
    if (!e)
      return;
    const n = this.loader = new self.XMLHttpRequest
      , r = this.stats;
    r.loading.first = 0,
      r.loaded = 0,
      r.aborted = !1;
    const o = this.xhrSetup;
    o ? Promise.resolve().then((()=>{
        if (!this.stats.aborted)
          return o(n, t.url)
      }
    )).catch((e=>(n.open("GET", t.url, !0),
      o(n, t.url)))).then((()=>{
        this.stats.aborted || this.openAndSendXhr(n, t, e)
      }
    )).catch((e=>{
        this.callbacks.onError({
          code: n.status,
          text: e.message
        }, t, n, r)
      }
    )) : this.openAndSendXhr(n, t, e)
  }
  openAndSendXhr(e, t, n) {
    e.readyState || e.open("GET", t.url, !0);
    const r = this.context.headers
      , {maxTimeToFirstByteMs: o, maxLoadTimeMs: a} = n.loadPolicy;
    if (r)
      for (const i in r)
        e.setRequestHeader(i, r[i]);
    t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)),
      e.onreadystatechange = this.readystatechange.bind(this),
      e.onprogress = this.loadprogress.bind(this),
      e.responseType = t.responseType,
      self.clearTimeout(this.requestTimeout),
      n.timeout = o && Fit(o) ? o : a,
      this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), n.timeout),
      e.send()
  }
  readystatechange() {
    const {context: e, loader: t, stats: n} = this;
    if (!e || !t)
      return;
    const r = t.readyState
      , o = this.config;
    if (!n.aborted && r >= 2 && (0 === n.loading.first && (n.loading.first = Math.max(self.performance.now(), n.loading.start),
    o.timeout !== o.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout),
      o.timeout = o.loadPolicy.maxLoadTimeMs,
      this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), o.loadPolicy.maxLoadTimeMs - (n.loading.first - n.loading.start)))),
    4 === r)) {
      self.clearTimeout(this.requestTimeout),
        t.onreadystatechange = null,
        t.onprogress = null;
      const r = t.status
        , a = "text" !== t.responseType;
      if (r >= 200 && r < 300 && (a && t.response || null !== t.responseText)) {
        n.loading.end = Math.max(self.performance.now(), n.loading.first);
        const o = a ? t.response : t.responseText
          , i = "arraybuffer" === t.responseType ? o.byteLength : o.length;
        if (n.loaded = n.total = i,
          n.bwEstimate = 8e3 * n.total / (n.loading.end - n.loading.first),
          !this.callbacks)
          return;
        const s = this.callbacks.onProgress;
        if (s && s(n, e, o, t),
          !this.callbacks)
          return;
        const l = {
          url: t.responseURL,
          data: o,
          code: r
        };
        this.callbacks.onSuccess(l, n, e, t)
      } else {
        const a = o.loadPolicy.errorRetry;
        lut(a, n.retry, !1, r) ? this.retry(a) : (Hit.error(`${r} while loading ${e.url}`),
          this.callbacks.onError({
            code: r,
            text: t.statusText
          }, e, t, n))
      }
    }
  }
  loadtimeout() {
    var e;
    const t = null == (e = this.config) ? void 0 : e.loadPolicy.timeoutRetry;
    if (lut(t, this.stats.retry, !0))
      this.retry(t);
    else {
      Hit.warn(`timeout while loading ${this.context.url}`);
      const e = this.callbacks;
      e && (this.abortInternal(),
        e.onTimeout(this.stats, this.context, this.loader))
    }
  }
  retry(e) {
    const {context: t, stats: n} = this;
    this.retryDelay = iut(e, n.retry),
      n.retry++,
      Hit.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${t.url}, retrying ${n.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`),
      this.abortInternal(),
      this.loader = null,
      self.clearTimeout(this.retryTimeout),
      this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay)
  }
  loadprogress(e) {
    const t = this.stats;
    t.loaded = e.loaded,
    e.lengthComputable && (t.total = e.total)
  }
  getCacheAge() {
    let e = null;
    if (this.loader && Pft.test(this.loader.getAllResponseHeaders())) {
      const t = this.loader.getResponseHeader("age");
      e = t ? parseFloat(t) : null
    }
    return e
  }
  getResponseHeader(e) {
    return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`,"im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null
  }
}
const Bft = /(\d+)-(\d+)\/(\d+)/;
class Nft {
  constructor(e) {
    this.fetchSetup = void 0,
      this.requestTimeout = void 0,
      this.request = void 0,
      this.response = void 0,
      this.controller = void 0,
      this.context = void 0,
      this.config = null,
      this.callbacks = null,
      this.stats = void 0,
      this.loader = null,
      this.fetchSetup = e.fetchSetup || Mft,
      this.controller = new self.AbortController,
      this.stats = new Yit
  }
  destroy() {
    this.loader = this.callbacks = null,
      this.abortInternal()
  }
  abortInternal() {
    const e = this.response;
    null != e && e.ok || (this.stats.aborted = !0,
      this.controller.abort())
  }
  abort() {
    var e;
    this.abortInternal(),
    null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
  }
  load(e, t, n) {
    const r = this.stats;
    if (r.loading.start)
      throw new Error("Loader can only be used once.");
    r.loading.start = self.performance.now();
    const o = function(e, t) {
      const n = {
        method: "GET",
        mode: "cors",
        credentials: "same-origin",
        signal: t,
        headers: new self.Headers(Pit({}, e.headers))
      };
      e.rangeEnd && n.headers.set("Range", "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1));
      return n
    }(e, this.controller.signal)
      , a = n.onProgress
      , i = "arraybuffer" === e.responseType
      , s = i ? "byteLength" : "length"
      , {maxTimeToFirstByteMs: l, maxLoadTimeMs: u} = t.loadPolicy;
    this.context = e,
      this.config = t,
      this.callbacks = n,
      this.request = this.fetchSetup(e, o),
      self.clearTimeout(this.requestTimeout),
      t.timeout = l && Fit(l) ? l : u,
      this.requestTimeout = self.setTimeout((()=>{
          this.abortInternal(),
            n.onTimeout(r, e, this.response)
        }
      ), t.timeout),
      self.fetch(this.request).then((o=>{
          this.response = this.loader = o;
          const s = Math.max(self.performance.now(), r.loading.start);
          if (self.clearTimeout(this.requestTimeout),
            t.timeout = u,
            this.requestTimeout = self.setTimeout((()=>{
                this.abortInternal(),
                  n.onTimeout(r, e, this.response)
              }
            ), u - (s - r.loading.start)),
            !o.ok) {
            const {status: e, statusText: t} = o;
            throw new jft(t || "fetch, bad network response",e,o)
          }
          return r.loading.first = s,
            r.total = function(e) {
              const t = e.get("Content-Range");
              if (t) {
                const e = function(e) {
                  const t = Bft.exec(e);
                  if (t)
                    return parseInt(t[2]) - parseInt(t[1]) + 1
                }(t);
                if (Fit(e))
                  return e
              }
              const n = e.get("Content-Length");
              if (n)
                return parseInt(n)
            }(o.headers) || r.total,
            a && Fit(t.highWaterMark) ? this.loadProgressively(o, r, e, t.highWaterMark, a) : i ? o.arrayBuffer() : "json" === e.responseType ? o.json() : o.text()
        }
      )).then((o=>{
          const {response: i} = this;
          self.clearTimeout(this.requestTimeout),
            r.loading.end = Math.max(self.performance.now(), r.loading.first);
          const l = o[s];
          l && (r.loaded = r.total = l);
          const u = {
            url: i.url,
            data: o,
            code: i.status
          };
          a && !Fit(t.highWaterMark) && a(r, e, o, i),
            n.onSuccess(u, r, e, i)
        }
      )).catch((t=>{
          if (self.clearTimeout(this.requestTimeout),
            r.aborted)
            return;
          const o = t && t.code || 0
            , a = t ? t.message : null;
          n.onError({
            code: o,
            text: a
          }, e, t ? t.details : null, r)
        }
      ))
  }
  getCacheAge() {
    let e = null;
    if (this.response) {
      const t = this.response.headers.get("age");
      e = t ? parseFloat(t) : null
    }
    return e
  }
  getResponseHeader(e) {
    return this.response ? this.response.headers.get(e) : null
  }
  loadProgressively(e, t, n, r=0, o) {
    const a = new wdt
      , i = e.body.getReader()
      , s = ()=>i.read().then((i=>{
        if (i.done)
          return a.dataLength && o(t, n, a.flush(), e),
            Promise.resolve(new ArrayBuffer(0));
        const l = i.value
          , u = l.length;
        return t.loaded += u,
          u < r || a.dataLength ? (a.push(l),
          a.dataLength >= r && o(t, n, a.flush(), e)) : o(t, n, l, e),
          s()
      }
    )).catch((()=>Promise.reject()));
    return s()
  }
}
function Mft(e, t) {
  return new self.Request(e.url,t)
}
class jft extends Error {
  constructor(e, t, n) {
    super(e),
      this.code = void 0,
      this.details = void 0,
      this.code = t,
      this.details = n
  }
}
const Vft = /\s/
  , Uft = {
  newCue(e, t, n, r) {
    const o = [];
    let a, i, s, l, u;
    const c = self.VTTCue || self.TextTrackCue;
    for (let f = 0; f < r.rows.length; f++)
      if (a = r.rows[f],
        s = !0,
        l = 0,
        u = "",
        !a.isEmpty()) {
        var d;
        for (let e = 0; e < a.chars.length; e++)
          Vft.test(a.chars[e].uchar) && s ? l++ : (u += a.chars[e].uchar,
            s = !1);
        a.cueStartTime = t,
        t === n && (n += 1e-4),
          l >= 16 ? l-- : l++;
        const r = nft(u.trim())
          , p = sft(t, n, r);
        null != e && null != (d = e.cues) && d.getCueById(p) || (i = new c(t,n,r),
          i.id = p,
          i.line = f + 1,
          i.align = "left",
          i.position = 10 + Math.min(80, 10 * Math.floor(8 * l / 32)),
          o.push(i))
      }
    return e && o.length && (o.sort(((e,t)=>"auto" === e.line || "auto" === t.line ? 0 : e.line > 8 && t.line > 8 ? t.line - e.line : e.line - t.line)),
      o.forEach((t=>Plt(e, t)))),
      o
  }
}
  , $ft = Lit(Lit({
  autoStartLoad: !0,
  startPosition: -1,
  defaultAudioCodec: void 0,
  debug: !1,
  capLevelOnFPSDrop: !1,
  capLevelToPlayerSize: !1,
  ignoreDevicePixelRatio: !1,
  initialLiveManifestSize: 1,
  maxBufferLength: 30,
  backBufferLength: 1 / 0,
  maxBufferSize: 6e7,
  maxBufferHole: .1,
  highBufferWatchdogPeriod: 2,
  nudgeOffset: .1,
  nudgeMaxRetry: 3,
  maxFragLookUpTolerance: .25,
  liveSyncDurationCount: 3,
  liveMaxLatencyDurationCount: 1 / 0,
  liveSyncDuration: void 0,
  liveMaxLatencyDuration: void 0,
  maxLiveSyncPlaybackRate: 1,
  liveDurationInfinity: !1,
  liveBackBufferLength: null,
  maxMaxBufferLength: 600,
  enableWorker: !0,
  workerPath: null,
  enableSoftwareAES: !0,
  startLevel: void 0,
  startFragPrefetch: !1,
  fpsDroppedMonitoringPeriod: 5e3,
  fpsDroppedMonitoringThreshold: .2,
  appendErrorMaxRetry: 3,
  loader: Fft,
  fLoader: void 0,
  pLoader: void 0,
  xhrSetup: void 0,
  licenseXhrSetup: void 0,
  licenseResponseCallback: void 0,
  abrController: class {
    constructor(e) {
      this.hls = void 0,
        this.lastLevelLoadSec = 0,
        this.lastLoadedFragLevel = 0,
        this._nextAutoLevel = -1,
        this.timer = -1,
        this.onCheck = this._abandonRulesCheck.bind(this),
        this.fragCurrent = null,
        this.partCurrent = null,
        this.bitrateTestDelay = 0,
        this.bwEstimator = void 0,
        this.hls = e;
      const t = e.config;
      this.bwEstimator = new bdt(t.abrEwmaSlowVoD,t.abrEwmaFastVoD,t.abrEwmaDefaultEstimate),
        this.registerListeners()
    }
    registerListeners() {
      const {hls: e} = this;
      e.on(Bit.FRAG_LOADING, this.onFragLoading, this),
        e.on(Bit.FRAG_LOADED, this.onFragLoaded, this),
        e.on(Bit.FRAG_BUFFERED, this.onFragBuffered, this),
        e.on(Bit.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.on(Bit.LEVEL_LOADED, this.onLevelLoaded, this)
    }
    unregisterListeners() {
      const {hls: e} = this;
      e.off(Bit.FRAG_LOADING, this.onFragLoading, this),
        e.off(Bit.FRAG_LOADED, this.onFragLoaded, this),
        e.off(Bit.FRAG_BUFFERED, this.onFragBuffered, this),
        e.off(Bit.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.off(Bit.LEVEL_LOADED, this.onLevelLoaded, this)
    }
    destroy() {
      this.unregisterListeners(),
        this.clearTimer(),
        this.hls = this.onCheck = null,
        this.fragCurrent = this.partCurrent = null
    }
    onFragLoading(e, t) {
      var n;
      const r = t.frag;
      this.ignoreFragment(r) || (this.fragCurrent = r,
        this.partCurrent = null != (n = t.part) ? n : null,
        this.clearTimer(),
        this.timer = self.setInterval(this.onCheck, 100))
    }
    onLevelSwitching(e, t) {
      this.clearTimer()
    }
    getTimeToLoadFrag(e, t, n, r) {
      return e + n / t + (r ? this.lastLevelLoadSec : 0)
    }
    onLevelLoaded(e, t) {
      const n = this.hls.config
        , {total: r, bwEstimate: o} = t.stats;
      Fit(r) && Fit(o) && (this.lastLevelLoadSec = 8 * r / o),
        t.details.live ? this.bwEstimator.update(n.abrEwmaSlowLive, n.abrEwmaFastLive) : this.bwEstimator.update(n.abrEwmaSlowVoD, n.abrEwmaFastVoD)
    }
    _abandonRulesCheck() {
      const {fragCurrent: e, partCurrent: t, hls: n} = this
        , {autoLevelEnabled: r, media: o} = n;
      if (!e || !o)
        return;
      const a = performance.now()
        , i = t ? t.stats : e.stats
        , s = t ? t.duration : e.duration
        , l = a - i.loading.start;
      if (i.aborted || i.loaded && i.loaded === i.total || 0 === e.level)
        return this.clearTimer(),
          void (this._nextAutoLevel = -1);
      if (!r || o.paused || !o.playbackRate || !o.readyState)
        return;
      const u = n.mainForwardBufferInfo;
      if (null === u)
        return;
      const c = this.bwEstimator.getEstimateTTFB()
        , d = Math.abs(o.playbackRate);
      if (l <= Math.max(c, s / (2 * d) * 1e3))
        return;
      const f = u.len / d;
      if (f >= 2 * s / d)
        return;
      const p = i.loading.first ? i.loading.first - i.loading.start : -1
        , h = i.loaded && p > -1
        , v = this.bwEstimator.getEstimate()
        , {levels: g, minAutoLevel: m} = n
        , y = g[e.level]
        , b = i.total || Math.max(i.loaded, Math.round(s * y.maxBitrate / 8));
      let w = l - p;
      w < 1 && h && (w = Math.min(l, 8 * i.loaded / v));
      const x = h ? 1e3 * i.loaded / w : 0
        , S = x ? (b - i.loaded) / x : 8 * b / v + c / 1e3;
      if (S <= f)
        return;
      const E = x ? 8 * x : v;
      let A, C = Number.POSITIVE_INFINITY;
      for (A = e.level - 1; A > m; A--) {
        const e = g[A].maxBitrate;
        if (C = this.getTimeToLoadFrag(c / 1e3, E, s * e, !g[A].details),
        C < f)
          break
      }
      C >= S || C > 10 * s || (n.nextLoadLevel = A,
        h ? this.bwEstimator.sample(l - Math.min(c, p), i.loaded) : this.bwEstimator.sampleTTFB(l),
        this.clearTimer(),
        Hit.warn(`[abr] Fragment ${e.sn}${t ? " part " + t.index : ""} of level ${e.level} is loading too slowly;\n      Time to underbuffer: ${f.toFixed(3)} s\n      Estimated load time for current fragment: ${S.toFixed(3)} s\n      Estimated load time for down switch fragment: ${C.toFixed(3)} s\n      TTFB estimate: ${p}\n      Current BW estimate: ${Fit(v) ? (v / 1024).toFixed(3) : "Unknown"} Kb/s\n      New BW estimate: ${(this.bwEstimator.getEstimate() / 1024).toFixed(3)} Kb/s\n      Aborting and switching to level ${A}`),
      e.loader && (this.fragCurrent = this.partCurrent = null,
        e.abortRequests()),
        n.trigger(Bit.FRAG_LOAD_EMERGENCY_ABORTED, {
          frag: e,
          part: t,
          stats: i
        }))
    }
    onFragLoaded(e, {frag: t, part: n}) {
      const r = n ? n.stats : t.stats;
      if (t.type === Tlt && this.bwEstimator.sampleTTFB(r.loading.first - r.loading.start),
        !this.ignoreFragment(t)) {
        if (this.clearTimer(),
          this.lastLoadedFragLevel = t.level,
          this._nextAutoLevel = -1,
          this.hls.config.abrMaxWithRealBitrate) {
          const e = n ? n.duration : t.duration
            , o = this.hls.levels[t.level]
            , a = (o.loaded ? o.loaded.bytes : 0) + r.loaded
            , i = (o.loaded ? o.loaded.duration : 0) + e;
          o.loaded = {
            bytes: a,
            duration: i
          },
            o.realBitrate = Math.round(8 * a / i)
        }
        if (t.bitrateTest) {
          const e = {
            stats: r,
            frag: t,
            part: n,
            id: t.type
          };
          this.onFragBuffered(Bit.FRAG_BUFFERED, e),
            t.bitrateTest = !1
        }
      }
    }
    onFragBuffered(e, t) {
      const {frag: n, part: r} = t
        , o = null != r && r.stats.loaded ? r.stats : n.stats;
      if (o.aborted)
        return;
      if (this.ignoreFragment(n))
        return;
      const a = o.parsing.end - o.loading.start - Math.min(o.loading.first - o.loading.start, this.bwEstimator.getEstimateTTFB());
      this.bwEstimator.sample(a, o.loaded),
        o.bwEstimate = this.bwEstimator.getEstimate(),
        n.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0
    }
    ignoreFragment(e) {
      return e.type !== Tlt || "initSegment" === e.sn
    }
    clearTimer() {
      self.clearInterval(this.timer)
    }
    get nextAutoLevel() {
      const e = this._nextAutoLevel
        , t = this.bwEstimator;
      if (-1 !== e && !t.canEstimate())
        return e;
      let n = this.getNextABRAutoLevel();
      if (-1 !== e) {
        const t = this.hls.levels;
        if (t.length > Math.max(e, n) && t[e].loadError <= t[n].loadError)
          return e
      }
      return -1 !== e && (n = Math.min(e, n)),
        n
    }
    getNextABRAutoLevel() {
      const {fragCurrent: e, partCurrent: t, hls: n} = this
        , {maxAutoLevel: r, config: o, minAutoLevel: a, media: i} = n
        , s = t ? t.duration : e ? e.duration : 0
        , l = i && 0 !== i.playbackRate ? Math.abs(i.playbackRate) : 1
        , u = this.bwEstimator ? this.bwEstimator.getEstimate() : o.abrEwmaDefaultEstimate
        , c = n.mainForwardBufferInfo
        , d = (c ? c.len : 0) / l;
      let f = this.findBestLevel(u, a, r, d, o.abrBandWidthFactor, o.abrBandWidthUpFactor);
      if (f >= 0)
        return f;
      Hit.trace(`[abr] ${d ? "rebuffering expected" : "buffer is empty"}, finding optimal quality level`);
      let p = s ? Math.min(s, o.maxStarvationDelay) : o.maxStarvationDelay
        , h = o.abrBandWidthFactor
        , v = o.abrBandWidthUpFactor;
      if (!d) {
        const e = this.bitrateTestDelay;
        if (e) {
          p = (s ? Math.min(s, o.maxLoadingDelay) : o.maxLoadingDelay) - e,
            Hit.trace(`[abr] bitrate test took ${Math.round(1e3 * e)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * p)} ms`),
            h = v = 1
        }
      }
      return f = this.findBestLevel(u, a, r, d + p, h, v),
        Math.max(f, 0)
    }
    findBestLevel(e, t, n, r, o, a) {
      var i;
      const {fragCurrent: s, partCurrent: l, lastLoadedFragLevel: u} = this
        , {levels: c} = this.hls
        , d = c[u]
        , f = !(null == d || null == (i = d.details) || !i.live)
        , p = null == d ? void 0 : d.codecSet
        , h = l ? l.duration : s ? s.duration : 0
        , v = this.bwEstimator.getEstimateTTFB() / 1e3;
      let g = t
        , m = -1;
      for (let y = n; y >= t; y--) {
        const t = c[y];
        if (!t || p && t.codecSet !== p) {
          t && (g = Math.min(y, g),
            m = Math.max(y, m));
          continue
        }
        -1 !== m && Hit.trace(`[abr] Skipped level(s) ${g}-${m} with CODECS:"${c[m].attrs.CODECS}"; not compatible with "${d.attrs.CODECS}"`);
        const n = t.details
          , i = (l ? null == n ? void 0 : n.partTarget : null == n ? void 0 : n.averagetargetduration) || h;
        let s;
        s = y <= u ? o * e : a * e;
        const b = c[y].maxBitrate
          , w = this.getTimeToLoadFrag(v, s, b * i, void 0 === n);
        if (Hit.trace(`[abr] level:${y} adjustedbw-bitrate:${Math.round(s - b)} avgDuration:${i.toFixed(1)} maxFetchDuration:${r.toFixed(1)} fetchDuration:${w.toFixed(1)}`),
        s > b && (0 === w || !Fit(w) || f && !this.bitrateTestDelay || w < r))
          return y
      }
      return -1
    }
    set nextAutoLevel(e) {
      this._nextAutoLevel = e
    }
  }
  ,
  bufferController: class {
    constructor(e) {
      this.details = null,
        this._objectUrl = null,
        this.operationQueue = void 0,
        this.listeners = void 0,
        this.hls = void 0,
        this.bufferCodecEventsExpected = 0,
        this._bufferCodecEventsTotal = 0,
        this.media = null,
        this.mediaSource = null,
        this.lastMpegAudioChunk = null,
        this.appendError = 0,
        this.tracks = {},
        this.pendingTracks = {},
        this.sourceBuffer = void 0,
        this._onMediaSourceOpen = ()=>{
          const {media: e, mediaSource: t} = this;
          Hit.log("[buffer-controller]: Media source opened"),
          e && (e.removeEventListener("emptied", this._onMediaEmptied),
            this.updateMediaElementDuration(),
            this.hls.trigger(Bit.MEDIA_ATTACHED, {
              media: e
            })),
          t && t.removeEventListener("sourceopen", this._onMediaSourceOpen),
            this.checkPendingTracks()
        }
        ,
        this._onMediaSourceClose = ()=>{
          Hit.log("[buffer-controller]: Media source closed")
        }
        ,
        this._onMediaSourceEnded = ()=>{
          Hit.log("[buffer-controller]: Media source ended")
        }
        ,
        this._onMediaEmptied = ()=>{
          const {media: e, _objectUrl: t} = this;
          e && e.src !== t && Hit.error(`Media element src was set while attaching MediaSource (${t} > ${e.src})`)
        }
        ,
        this.hls = e,
        this._initSourceBuffer(),
        this.registerListeners()
    }
    hasSourceTypes() {
      return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
    }
    destroy() {
      this.unregisterListeners(),
        this.details = null,
        this.lastMpegAudioChunk = null
    }
    registerListeners() {
      const {hls: e} = this;
      e.on(Bit.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(Bit.BUFFER_RESET, this.onBufferReset, this),
        e.on(Bit.BUFFER_APPENDING, this.onBufferAppending, this),
        e.on(Bit.BUFFER_CODECS, this.onBufferCodecs, this),
        e.on(Bit.BUFFER_EOS, this.onBufferEos, this),
        e.on(Bit.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.on(Bit.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.on(Bit.FRAG_PARSED, this.onFragParsed, this),
        e.on(Bit.FRAG_CHANGED, this.onFragChanged, this)
    }
    unregisterListeners() {
      const {hls: e} = this;
      e.off(Bit.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(Bit.BUFFER_RESET, this.onBufferReset, this),
        e.off(Bit.BUFFER_APPENDING, this.onBufferAppending, this),
        e.off(Bit.BUFFER_CODECS, this.onBufferCodecs, this),
        e.off(Bit.BUFFER_EOS, this.onBufferEos, this),
        e.off(Bit.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.off(Bit.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.off(Bit.FRAG_PARSED, this.onFragParsed, this),
        e.off(Bit.FRAG_CHANGED, this.onFragChanged, this)
    }
    _initSourceBuffer() {
      this.sourceBuffer = {},
        this.operationQueue = new Cdt(this.sourceBuffer),
        this.listeners = {
          audio: [],
          video: [],
          audiovideo: []
        },
        this.lastMpegAudioChunk = null
    }
    onManifestLoading() {
      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0,
        this.details = null
    }
    onManifestParsed(e, t) {
      let n = 2;
      (t.audio && !t.video || !t.altAudio) && (n = 1),
        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = n,
        Hit.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`)
    }
    onMediaAttaching(e, t) {
      const n = this.media = t.media;
      if (n && kdt) {
        const e = this.mediaSource = new kdt;
        e.addEventListener("sourceopen", this._onMediaSourceOpen),
          e.addEventListener("sourceended", this._onMediaSourceEnded),
          e.addEventListener("sourceclose", this._onMediaSourceClose),
          n.src = self.URL.createObjectURL(e),
          this._objectUrl = n.src,
          n.addEventListener("emptied", this._onMediaEmptied)
      }
    }
    onMediaDetaching() {
      const {media: e, mediaSource: t, _objectUrl: n} = this;
      if (t) {
        if (Hit.log("[buffer-controller]: media source detaching"),
        "open" === t.readyState)
          try {
            t.endOfStream()
          } catch (ubt) {
            Hit.warn(`[buffer-controller]: onMediaDetaching: ${ubt.message} while calling endOfStream`)
          }
        this.onBufferReset(),
          t.removeEventListener("sourceopen", this._onMediaSourceOpen),
          t.removeEventListener("sourceended", this._onMediaSourceEnded),
          t.removeEventListener("sourceclose", this._onMediaSourceClose),
        e && (e.removeEventListener("emptied", this._onMediaEmptied),
        n && self.URL.revokeObjectURL(n),
          e.src === n ? (e.removeAttribute("src"),
            e.load()) : Hit.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")),
          this.mediaSource = null,
          this.media = null,
          this._objectUrl = null,
          this.bufferCodecEventsExpected = this._bufferCodecEventsTotal,
          this.pendingTracks = {},
          this.tracks = {}
      }
      this.hls.trigger(Bit.MEDIA_DETACHED, void 0)
    }
    onBufferReset() {
      this.getSourceBufferTypes().forEach((e=>{
          const t = this.sourceBuffer[e];
          try {
            t && (this.removeBufferListeners(e),
            this.mediaSource && this.mediaSource.removeSourceBuffer(t),
              this.sourceBuffer[e] = void 0)
          } catch (ubt) {
            Hit.warn(`[buffer-controller]: Failed to reset the ${e} buffer`, ubt)
          }
        }
      )),
        this._initSourceBuffer()
    }
    onBufferCodecs(e, t) {
      const n = this.getSourceBufferTypes().length;
      Object.keys(t).forEach((e=>{
          if (n) {
            const n = this.tracks[e];
            if (n && "function" == typeof n.buffer.changeType) {
              const {id: r, codec: o, levelCodec: a, container: i, metadata: s} = t[e]
                , l = (n.levelCodec || n.codec).replace(Tdt, "$1")
                , u = (a || o).replace(Tdt, "$1");
              if (l !== u) {
                const t = `${i};codecs=${a || o}`;
                this.appendChangeType(e, t),
                  Hit.log(`[buffer-controller]: switching codec ${l} to ${u}`),
                  this.tracks[e] = {
                    buffer: n.buffer,
                    codec: o,
                    container: i,
                    levelCodec: a,
                    metadata: s,
                    id: r
                  }
              }
            }
          } else
            this.pendingTracks[e] = t[e]
        }
      )),
      n || (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0),
      this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks())
    }
    appendChangeType(e, t) {
      const {operationQueue: n} = this
        , r = {
        execute: ()=>{
          const r = this.sourceBuffer[e];
          r && (Hit.log(`[buffer-controller]: changing ${e} sourceBuffer type to ${t}`),
            r.changeType(t)),
            n.shiftAndExecuteNext(e)
        }
        ,
        onStart: ()=>{}
        ,
        onComplete: ()=>{}
        ,
        onError: t=>{
          Hit.warn(`[buffer-controller]: Failed to change ${e} SourceBuffer type`, t)
        }
      };
      n.append(r, e)
    }
    onBufferAppending(e, t) {
      const {hls: n, operationQueue: r, tracks: o} = this
        , {data: a, type: i, frag: s, part: l, chunkMeta: u} = t
        , c = u.buffering[i]
        , d = self.performance.now();
      c.start = d;
      const f = s.stats.buffering
        , p = l ? l.stats.buffering : null;
      0 === f.start && (f.start = d),
      p && 0 === p.start && (p.start = d);
      const h = o.audio;
      let v = !1;
      "audio" === i && "audio/mpeg" === (null == h ? void 0 : h.container) && (v = !this.lastMpegAudioChunk || 1 === u.id || this.lastMpegAudioChunk.sn !== u.sn,
        this.lastMpegAudioChunk = u);
      const g = s.start
        , m = {
        execute: ()=>{
          if (c.executeStart = self.performance.now(),
            v) {
            const e = this.sourceBuffer[i];
            if (e) {
              const t = g - e.timestampOffset;
              Math.abs(t) >= .1 && (Hit.log(`[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${g} (delta: ${t}) sn: ${s.sn})`),
                e.timestampOffset = g)
            }
          }
          this.appendExecutor(a, i)
        }
        ,
        onStart: ()=>{}
        ,
        onComplete: ()=>{
          const e = self.performance.now();
          c.executeEnd = c.end = e,
          0 === f.first && (f.first = e),
          p && 0 === p.first && (p.first = e);
          const {sourceBuffer: t} = this
            , n = {};
          for (const r in t)
            n[r] = Vut.getBuffered(t[r]);
          this.appendError = 0,
            this.hls.trigger(Bit.BUFFER_APPENDED, {
              type: i,
              frag: s,
              part: l,
              chunkMeta: u,
              parent: s.type,
              timeRanges: n
            })
        }
        ,
        onError: e=>{
          Hit.error(`[buffer-controller]: Error encountered while trying to append to the ${i} SourceBuffer`, e);
          const t = {
            type: Nit.MEDIA_ERROR,
            parent: s.type,
            details: Mit.BUFFER_APPEND_ERROR,
            frag: s,
            part: l,
            chunkMeta: u,
            error: e,
            err: e,
            fatal: !1
          };
          e.code === DOMException.QUOTA_EXCEEDED_ERR ? t.details = Mit.BUFFER_FULL_ERROR : (this.appendError++,
            t.details = Mit.BUFFER_APPEND_ERROR,
          this.appendError > n.config.appendErrorMaxRetry && (Hit.error(`[buffer-controller]: Failed ${n.config.appendErrorMaxRetry} times to append segment in sourceBuffer`),
            t.fatal = !0)),
            n.trigger(Bit.ERROR, t)
        }
      };
      r.append(m, i)
    }
    onBufferFlushing(e, t) {
      const {operationQueue: n} = this
        , r = e=>({
        execute: this.removeExecutor.bind(this, e, t.startOffset, t.endOffset),
        onStart: ()=>{}
        ,
        onComplete: ()=>{
          this.hls.trigger(Bit.BUFFER_FLUSHED, {
            type: e
          })
        }
        ,
        onError: t=>{
          Hit.warn(`[buffer-controller]: Failed to remove from ${e} SourceBuffer`, t)
        }
      });
      t.type ? n.append(r(t.type), t.type) : this.getSourceBufferTypes().forEach((e=>{
          n.append(r(e), e)
        }
      ))
    }
    onFragParsed(e, t) {
      const {frag: n, part: r} = t
        , o = []
        , a = r ? r.elementaryStreams : n.elementaryStreams;
      a[Jit] ? o.push("audiovideo") : (a[Xit] && o.push("audio"),
      a[Qit] && o.push("video"));
      0 === o.length && Hit.warn(`Fragments must have at least one ElementaryStreamType set. type: ${n.type} level: ${n.level} sn: ${n.sn}`),
        this.blockBuffers((()=>{
            const e = self.performance.now();
            n.stats.buffering.end = e,
            r && (r.stats.buffering.end = e);
            const t = r ? r.stats : n.stats;
            this.hls.trigger(Bit.FRAG_BUFFERED, {
              frag: n,
              part: r,
              stats: t,
              id: n.type
            })
          }
        ), o)
    }
    onFragChanged(e, t) {
      this.flushBackBuffer()
    }
    onBufferEos(e, t) {
      this.getSourceBufferTypes().reduce(((e,n)=>{
          const r = this.sourceBuffer[n];
          return !r || t.type && t.type !== n || (r.ending = !0,
          r.ended || (r.ended = !0,
            Hit.log(`[buffer-controller]: ${n} sourceBuffer now EOS`))),
          e && !(r && !r.ended)
        }
      ), !0) && (Hit.log("[buffer-controller]: Queueing mediaSource.endOfStream()"),
        this.blockBuffers((()=>{
            this.getSourceBufferTypes().forEach((e=>{
                const t = this.sourceBuffer[e];
                t && (t.ending = !1)
              }
            ));
            const {mediaSource: e} = this;
            e && "open" === e.readyState ? (Hit.log("[buffer-controller]: Calling mediaSource.endOfStream()"),
              e.endOfStream()) : e && Hit.info(`[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: ${e.readyState}`)
          }
        )))
    }
    onLevelUpdated(e, {details: t}) {
      t.fragments.length && (this.details = t,
        this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
    }
    flushBackBuffer() {
      const {hls: e, details: t, media: n, sourceBuffer: r} = this;
      if (!n || null === t)
        return;
      const o = this.getSourceBufferTypes();
      if (!o.length)
        return;
      const a = t.live && null !== e.config.liveBackBufferLength ? e.config.liveBackBufferLength : e.config.backBufferLength;
      if (!Fit(a) || a < 0)
        return;
      const i = n.currentTime
        , s = t.levelTargetDuration
        , l = Math.max(a, s)
        , u = Math.floor(i / s) * s - l;
      o.forEach((n=>{
          const o = r[n];
          if (o) {
            const r = Vut.getBuffered(o);
            if (r.length > 0 && u > r.start(0)) {
              if (e.trigger(Bit.BACK_BUFFER_REACHED, {
                bufferEnd: u
              }),
                t.live)
                e.trigger(Bit.LIVE_BACK_BUFFER_REACHED, {
                  bufferEnd: u
                });
              else if (o.ended && r.end(r.length - 1) - i < 2 * s)
                return void Hit.info(`[buffer-controller]: Cannot flush ${n} back buffer while SourceBuffer is in ended state`);
              e.trigger(Bit.BUFFER_FLUSHING, {
                startOffset: 0,
                endOffset: u,
                type: n
              })
            }
          }
        }
      ))
    }
    updateMediaElementDuration() {
      if (!this.details || !this.media || !this.mediaSource || "open" !== this.mediaSource.readyState)
        return;
      const {details: e, hls: t, media: n, mediaSource: r} = this
        , o = e.fragments[0].start + e.totalduration
        , a = n.duration
        , i = Fit(r.duration) ? r.duration : 0;
      e.live && t.config.liveDurationInfinity ? (Hit.log("[buffer-controller]: Media Source duration is set to Infinity"),
        r.duration = 1 / 0,
        this.updateSeekableRange(e)) : (o > i && o > a || !Fit(a)) && (Hit.log(`[buffer-controller]: Updating Media Source duration to ${o.toFixed(3)}`),
        r.duration = o)
    }
    updateSeekableRange(e) {
      const t = this.mediaSource
        , n = e.fragments;
      if (n.length && e.live && null != t && t.setLiveSeekableRange) {
        const r = Math.max(0, n[0].start)
          , o = Math.max(r, r + e.totalduration);
        t.setLiveSeekableRange(r, o)
      }
    }
    checkPendingTracks() {
      const {bufferCodecEventsExpected: e, operationQueue: t, pendingTracks: n} = this
        , r = Object.keys(n).length;
      if (r && !e || 2 === r) {
        this.createSourceBuffers(n),
          this.pendingTracks = {};
        const e = this.getSourceBufferTypes();
        if (e.length)
          this.hls.trigger(Bit.BUFFER_CREATED, {
            tracks: this.tracks
          }),
            e.forEach((e=>{
                t.executeNext(e)
              }
            ));
        else {
          const e = new Error("could not create source buffer for media codec(s)");
          this.hls.trigger(Bit.ERROR, {
            type: Nit.MEDIA_ERROR,
            details: Mit.BUFFER_INCOMPATIBLE_CODECS_ERROR,
            fatal: !0,
            error: e,
            reason: e.message
          })
        }
      }
    }
    createSourceBuffers(e) {
      const {sourceBuffer: t, mediaSource: n} = this;
      if (!n)
        throw Error("createSourceBuffers called when mediaSource was null");
      for (const r in e)
        if (!t[r]) {
          const o = e[r];
          if (!o)
            throw Error(`source buffer exists for track ${r}, however track does not`);
          const a = o.levelCodec || o.codec
            , i = `${o.container};codecs=${a}`;
          Hit.log(`[buffer-controller]: creating sourceBuffer(${i})`);
          try {
            const e = t[r] = n.addSourceBuffer(i)
              , s = r;
            this.addBufferListener(s, "updatestart", this._onSBUpdateStart),
              this.addBufferListener(s, "updateend", this._onSBUpdateEnd),
              this.addBufferListener(s, "error", this._onSBUpdateError),
              this.tracks[r] = {
                buffer: e,
                codec: a,
                container: o.container,
                levelCodec: o.levelCodec,
                metadata: o.metadata,
                id: o.id
              }
          } catch (ubt) {
            Hit.error(`[buffer-controller]: error while trying to add sourceBuffer: ${ubt.message}`),
              this.hls.trigger(Bit.ERROR, {
                type: Nit.MEDIA_ERROR,
                details: Mit.BUFFER_ADD_CODEC_ERROR,
                fatal: !1,
                error: ubt,
                mimeType: i
              })
          }
        }
    }
    _onSBUpdateStart(e) {
      const {operationQueue: t} = this;
      t.current(e).onStart()
    }
    _onSBUpdateEnd(e) {
      const {operationQueue: t} = this;
      t.current(e).onComplete(),
        t.shiftAndExecuteNext(e)
    }
    _onSBUpdateError(e, t) {
      const n = new Error(`${e} SourceBuffer error`);
      Hit.error(`[buffer-controller]: ${n}`, t),
        this.hls.trigger(Bit.ERROR, {
          type: Nit.MEDIA_ERROR,
          details: Mit.BUFFER_APPENDING_ERROR,
          error: n,
          fatal: !1
        });
      const r = this.operationQueue.current(e);
      r && r.onError(t)
    }
    removeExecutor(e, t, n) {
      const {media: r, mediaSource: o, operationQueue: a, sourceBuffer: i} = this
        , s = i[e];
      if (!r || !o || !s)
        return Hit.warn(`[buffer-controller]: Attempting to remove from the ${e} SourceBuffer, but it does not exist`),
          void a.shiftAndExecuteNext(e);
      const l = Fit(r.duration) ? r.duration : 1 / 0
        , u = Fit(o.duration) ? o.duration : 1 / 0
        , c = Math.max(0, t)
        , d = Math.min(n, l, u);
      d > c && !s.ending ? (s.ended = !1,
        Hit.log(`[buffer-controller]: Removing [${c},${d}] from the ${e} SourceBuffer`),
        s.remove(c, d)) : a.shiftAndExecuteNext(e)
    }
    appendExecutor(e, t) {
      const {operationQueue: n, sourceBuffer: r} = this
        , o = r[t];
      if (!o)
        return Hit.warn(`[buffer-controller]: Attempting to append to the ${t} SourceBuffer, but it does not exist`),
          void n.shiftAndExecuteNext(t);
      o.ended = !1,
        o.appendBuffer(e)
    }
    blockBuffers(e, t=this.getSourceBufferTypes()) {
      if (!t.length)
        return Hit.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"),
          void Promise.resolve().then(e);
      const {operationQueue: n} = this
        , r = t.map((e=>n.appendBlocker(e)));
      Promise.all(r).then((()=>{
          e(),
            t.forEach((e=>{
                const t = this.sourceBuffer[e];
                null != t && t.updating || n.shiftAndExecuteNext(e)
              }
            ))
        }
      ))
    }
    getSourceBufferTypes() {
      return Object.keys(this.sourceBuffer)
    }
    addBufferListener(e, t, n) {
      const r = this.sourceBuffer[e];
      if (!r)
        return;
      const o = n.bind(this, e);
      this.listeners[e].push({
        event: t,
        listener: o
      }),
        r.addEventListener(t, o)
    }
    removeBufferListeners(e) {
      const t = this.sourceBuffer[e];
      t && this.listeners[e].forEach((e=>{
          t.removeEventListener(e.event, e.listener)
        }
      ))
    }
  }
  ,
  capLevelController: xft,
  errorController: class {
    constructor(e) {
      this.hls = void 0,
        this.playlistError = 0,
        this.penalizedRenditions = {},
        this.log = void 0,
        this.warn = void 0,
        this.error = void 0,
        this.hls = e,
        this.log = Hit.log.bind(Hit, "[info]:"),
        this.warn = Hit.warn.bind(Hit, "[warning]:"),
        this.error = Hit.error.bind(Hit, "[error]:"),
        this.registerListeners()
    }
    registerListeners() {
      const e = this.hls;
      e.on(Bit.ERROR, this.onError, this),
        e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Bit.LEVEL_UPDATED, this.onLevelUpdated, this)
    }
    unregisterListeners() {
      const e = this.hls;
      e && (e.off(Bit.ERROR, this.onError, this),
        e.off(Bit.ERROR, this.onErrorOut, this),
        e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Bit.LEVEL_UPDATED, this.onLevelUpdated, this))
    }
    destroy() {
      this.unregisterListeners(),
        this.hls = null,
        this.penalizedRenditions = {}
    }
    startLoad(e) {
      this.playlistError = 0
    }
    stopLoad() {}
    getVariantLevelIndex(e) {
      return (null == e ? void 0 : e.type) === Tlt ? e.level : this.hls.loadLevel
    }
    onManifestLoading() {
      this.playlistError = 0,
        this.penalizedRenditions = {}
    }
    onLevelUpdated() {
      this.playlistError = 0
    }
    onError(e, t) {
      var n, r;
      if (t.fatal)
        return;
      const o = this.hls
        , a = t.context;
      switch (t.details) {
        case Mit.FRAG_LOAD_ERROR:
        case Mit.FRAG_LOAD_TIMEOUT:
        case Mit.KEY_LOAD_ERROR:
        case Mit.KEY_LOAD_TIMEOUT:
          return void (t.errorAction = this.getFragRetryOrSwitchAction(t));
        case Mit.FRAG_PARSING_ERROR:
          if (null != (n = t.frag) && n.gap)
            return void (t.errorAction = {
              action: put,
              flags: gut
            });
        case Mit.FRAG_GAP:
        case Mit.FRAG_DECRYPT_ERROR:
          return t.errorAction = this.getFragRetryOrSwitchAction(t),
            void (t.errorAction.action = hut);
        case Mit.LEVEL_EMPTY_ERROR:
        case Mit.LEVEL_PARSING_ERROR:
        {
          var i, s;
          const e = t.parent === Tlt ? t.level : o.loadLevel;
          t.details === Mit.LEVEL_EMPTY_ERROR && null != (i = t.context) && null != (s = i.levelDetails) && s.live ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, e) : (t.levelRetry = !1,
            t.errorAction = this.getLevelSwitchAction(t, e))
        }
          return;
        case Mit.LEVEL_LOAD_ERROR:
        case Mit.LEVEL_LOAD_TIMEOUT:
          return void ("number" == typeof (null == a ? void 0 : a.level) && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, a.level)));
        case Mit.AUDIO_TRACK_LOAD_ERROR:
        case Mit.AUDIO_TRACK_LOAD_TIMEOUT:
        case Mit.SUBTITLE_LOAD_ERROR:
        case Mit.SUBTITLE_TRACK_LOAD_TIMEOUT:
          if (a) {
            const e = o.levels[o.loadLevel];
            if (e && (a.type === Clt && a.groupId === e.audioGroupId || a.type === klt && a.groupId === e.textGroupId))
              return t.errorAction = this.getPlaylistRetryOrSwitchAction(t, o.loadLevel),
                t.errorAction.action = hut,
                void (t.errorAction.flags = mut)
          }
          return;
        case Mit.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
        {
          const e = o.levels[o.loadLevel]
            , n = null == e ? void 0 : e.attrs["HDCP-LEVEL"];
          n && (t.errorAction = {
            action: hut,
            flags: yut,
            hdcpLevel: n
          })
        }
          return;
        case Mit.BUFFER_ADD_CODEC_ERROR:
        case Mit.REMUX_ALLOC_ERROR:
          return void (t.errorAction = this.getLevelSwitchAction(t, null != (r = t.level) ? r : o.loadLevel));
        case Mit.INTERNAL_EXCEPTION:
        case Mit.BUFFER_APPENDING_ERROR:
        case Mit.BUFFER_APPEND_ERROR:
        case Mit.BUFFER_FULL_ERROR:
        case Mit.LEVEL_SWITCH_ERROR:
        case Mit.BUFFER_STALLED_ERROR:
        case Mit.BUFFER_SEEK_OVER_HOLE:
        case Mit.BUFFER_NUDGE_ON_STALL:
          return void (t.errorAction = {
            action: put,
            flags: gut
          })
      }
      if (t.type === Nit.KEY_SYSTEM_ERROR) {
        const e = this.getVariantLevelIndex(t.frag);
        return t.levelRetry = !1,
          void (t.errorAction = this.getLevelSwitchAction(t, e))
      }
    }
    getPlaylistRetryOrSwitchAction(e, t) {
      var n;
      const r = aut(this.hls.config.playlistLoadPolicy, e)
        , o = this.playlistError++
        , a = null == (n = e.response) ? void 0 : n.code;
      if (lut(r, o, out(e), a))
        return {
          action: vut,
          flags: gut,
          retryConfig: r,
          retryCount: o
        };
      const i = this.getLevelSwitchAction(e, t);
      return r && (i.retryConfig = r,
        i.retryCount = o),
        i
    }
    getFragRetryOrSwitchAction(e) {
      const t = this.hls
        , n = this.getVariantLevelIndex(e.frag)
        , r = t.levels[n]
        , {fragLoadPolicy: o, keyLoadPolicy: a} = t.config
        , i = aut(e.details.startsWith("key") ? a : o, e)
        , s = t.levels.reduce(((e,t)=>e + t.fragmentError), 0);
      if (r) {
        var l;
        e.details !== Mit.FRAG_GAP && r.fragmentError++;
        const t = null == (l = e.response) ? void 0 : l.code;
        if (lut(i, s, out(e), t))
          return {
            action: vut,
            flags: gut,
            retryConfig: i,
            retryCount: s
          }
      }
      const u = this.getLevelSwitchAction(e, n);
      return i && (u.retryConfig = i,
        u.retryCount = s),
        u
    }
    getLevelSwitchAction(e, t) {
      const n = this.hls;
      null == t && (t = n.loadLevel);
      const r = this.hls.levels[t];
      if (r && (r.loadError++,
        n.autoLevelEnabled)) {
        var o, a;
        let t = -1;
        const {levels: i, loadLevel: s, minAutoLevel: l, maxAutoLevel: u} = n
          , c = null == (o = e.frag) ? void 0 : o.type
          , {type: d, groupId: f} = null != (a = e.context) ? a : {};
        for (let n = i.length; n--; ) {
          const o = (n + s) % i.length;
          if (o !== s && o >= l && o <= u && 0 === i[o].loadError) {
            const n = i[o];
            if (e.details === Mit.FRAG_GAP && e.frag) {
              const t = i[o].details;
              if (t) {
                const n = cut(e.frag, t.fragments, e.frag.start);
                if (null != n && n.gap)
                  continue
              }
            } else {
              if (d === Clt && f === n.audioGroupId || d === klt && f === n.textGroupId)
                continue;
              if (c === Dlt && r.audioGroupId === n.audioGroupId || c === Olt && r.textGroupId === n.textGroupId)
                continue
            }
            t = o;
            break
          }
        }
        if (t > -1 && n.loadLevel !== t)
          return e.levelRetry = !0,
            this.playlistError = 0,
            {
              action: hut,
              flags: gut,
              nextAutoLevel: t
            }
      }
      return {
        action: hut,
        flags: mut
      }
    }
    onErrorOut(e, t) {
      var n;
      switch (null == (n = t.errorAction) ? void 0 : n.action) {
        case put:
          break;
        case hut:
          this.sendAlternateToPenaltyBox(t),
          t.errorAction.resolved || t.details === Mit.FRAG_GAP || (t.fatal = !0)
      }
      t.fatal && this.hls.stopLoad()
    }
    sendAlternateToPenaltyBox(e) {
      const t = this.hls
        , n = e.errorAction;
      if (!n)
        return;
      const {flags: r, hdcpLevel: o, nextAutoLevel: a} = n;
      switch (r) {
        case gut:
          this.switchLevel(e, a);
          break;
        case mut:
          n.resolved || (n.resolved = this.redundantFailover(e));
          break;
        case yut:
          o && (t.maxHdcpLevel = Klt[Klt.indexOf(o) - 1],
            n.resolved = !0),
            this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`)
      }
      n.resolved || this.switchLevel(e, a)
    }
    switchLevel(e, t) {
      void 0 !== t && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`),
        this.hls.nextAutoLevel = t,
        e.errorAction.resolved = !0,
        this.hls.nextLoadLevel = this.hls.nextAutoLevel)
    }
    redundantFailover(e) {
      const {hls: t, penalizedRenditions: n} = this
        , r = e.parent === Tlt ? e.level : t.loadLevel
        , o = t.levels[r]
        , a = o.url.length
        , i = e.frag ? e.frag.urlId : o.urlId;
      o.urlId !== i || e.frag && !o.details || this.penalizeRendition(o, e);
      for (let s = 1; s < a; s++) {
        const l = (i + s) % a
          , u = n[l];
        if (!u || but(u, e, n[i]))
          return this.warn(`Switching to Redundant Stream ${l + 1}/${a}: "${o.url[l]}" after ${e.details}`),
            this.playlistError = 0,
            t.levels.forEach((e=>{
                e.urlId = l
              }
            )),
            t.nextLoadLevel = r,
            !0
      }
      return !1
    }
    penalizeRendition(e, t) {
      const {penalizedRenditions: n} = this
        , r = n[e.urlId] || {
        lastErrorPerfMs: 0,
        errors: [],
        details: void 0
      };
      r.lastErrorPerfMs = performance.now(),
        r.errors.push(t),
        r.details = e.details,
        n[e.urlId] = r
    }
  }
  ,
  fpsController: class {
    constructor(e) {
      this.hls = void 0,
        this.isVideoPlaybackQualityAvailable = !1,
        this.timer = void 0,
        this.media = null,
        this.lastTime = void 0,
        this.lastDroppedFrames = 0,
        this.lastDecodedFrames = 0,
        this.streamController = void 0,
        this.hls = e,
        this.registerListeners()
    }
    setStreamController(e) {
      this.streamController = e
    }
    registerListeners() {
      this.hls.on(Bit.MEDIA_ATTACHING, this.onMediaAttaching, this)
    }
    unregisterListeners() {
      this.hls.off(Bit.MEDIA_ATTACHING, this.onMediaAttaching, this)
    }
    destroy() {
      this.timer && clearInterval(this.timer),
        this.unregisterListeners(),
        this.isVideoPlaybackQualityAvailable = !1,
        this.media = null
    }
    onMediaAttaching(e, t) {
      const n = this.hls.config;
      if (n.capLevelOnFPSDrop) {
        const e = t.media instanceof self.HTMLVideoElement ? t.media : null;
        this.media = e,
        e && "function" == typeof e.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0),
          self.clearInterval(this.timer),
          this.timer = self.setInterval(this.checkFPSInterval.bind(this), n.fpsDroppedMonitoringPeriod)
      }
    }
    checkFPS(e, t, n) {
      const r = performance.now();
      if (t) {
        if (this.lastTime) {
          const e = r - this.lastTime
            , o = n - this.lastDroppedFrames
            , a = t - this.lastDecodedFrames
            , i = 1e3 * o / e
            , s = this.hls;
          if (s.trigger(Bit.FPS_DROP, {
            currentDropped: o,
            currentDecoded: a,
            totalDroppedFrames: n
          }),
          i > 0 && o > s.config.fpsDroppedMonitoringThreshold * a) {
            let e = s.currentLevel;
            Hit.warn("drop FPS ratio greater than max allowed value for currentLevel: " + e),
            e > 0 && (-1 === s.autoLevelCapping || s.autoLevelCapping >= e) && (e -= 1,
              s.trigger(Bit.FPS_DROP_LEVEL_CAPPING, {
                level: e,
                droppedLevel: s.currentLevel
              }),
              s.autoLevelCapping = e,
              this.streamController.nextLevelSwitch())
          }
        }
        this.lastTime = r,
          this.lastDroppedFrames = n,
          this.lastDecodedFrames = t
      }
    }
    checkFPSInterval() {
      const e = this.media;
      if (e)
        if (this.isVideoPlaybackQualityAvailable) {
          const t = e.getVideoPlaybackQuality();
          this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)
        } else
          this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
    }
  }
  ,
  stretchShortVideoTrack: !1,
  maxAudioFramesDrift: 1,
  forceKeyFrameOnDiscontinuity: !0,
  abrEwmaFastLive: 3,
  abrEwmaSlowLive: 9,
  abrEwmaFastVoD: 3,
  abrEwmaSlowVoD: 9,
  abrEwmaDefaultEstimate: 5e5,
  abrBandWidthFactor: .95,
  abrBandWidthUpFactor: .7,
  abrMaxWithRealBitrate: !1,
  maxStarvationDelay: 4,
  maxLoadingDelay: 4,
  minAutoBitrate: 0,
  emeEnabled: !1,
  widevineLicenseUrl: void 0,
  drmSystems: {},
  drmSystemOptions: {},
  requestMediaKeySystemAccessFunc: vst,
  testBandwidth: !0,
  progressive: !1,
  lowLatencyMode: !0,
  cmcd: void 0,
  enableDateRangeMetadataCues: !0,
  enableEmsgMetadataCues: !0,
  enableID3MetadataCues: !0,
  certLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 8e3,
      maxLoadTimeMs: 2e4,
      timeoutRetry: null,
      errorRetry: null
    }
  },
  keyLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 8e3,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      },
      errorRetry: {
        maxNumRetry: 8,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      }
    }
  },
  manifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1 / 0,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  playlistLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 2,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  fragLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 12e4,
      timeoutRetry: {
        maxNumRetry: 4,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 6,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  steeringManifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  manifestLoadingTimeOut: 1e4,
  manifestLoadingMaxRetry: 1,
  manifestLoadingRetryDelay: 1e3,
  manifestLoadingMaxRetryTimeout: 64e3,
  levelLoadingTimeOut: 1e4,
  levelLoadingMaxRetry: 4,
  levelLoadingRetryDelay: 1e3,
  levelLoadingMaxRetryTimeout: 64e3,
  fragLoadingTimeOut: 2e4,
  fragLoadingMaxRetry: 6,
  fragLoadingRetryDelay: 1e3,
  fragLoadingMaxRetryTimeout: 64e3
}, {
  cueHandler: Uft,
  enableWebVTT: !0,
  enableIMSC1: !0,
  enableCEA708Captions: !0,
  captionsTextTrack1Label: "English",
  captionsTextTrack1LanguageCode: "en",
  captionsTextTrack2Label: "Spanish",
  captionsTextTrack2LanguageCode: "es",
  captionsTextTrack3Label: "Unknown CC",
  captionsTextTrack3LanguageCode: "",
  captionsTextTrack4Label: "Unknown CC",
  captionsTextTrack4LanguageCode: "",
  renderTextTracksNatively: !0
}), {}, {
  subtitleStreamController: class extends cct {
    constructor(e, t, n) {
      super(e, t, n, "[subtitle-stream-controller]", Olt),
        this.levels = [],
        this.currentTrackId = -1,
        this.tracksBuffered = [],
        this.mainDetails = null,
        this._registerListeners()
    }
    onHandlerDestroying() {
      this._unregisterListeners(),
        this.mainDetails = null
    }
    _registerListeners() {
      const {hls: e} = this;
      e.on(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Bit.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(Bit.ERROR, this.onError, this),
        e.on(Bit.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.on(Bit.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
        e.on(Bit.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.on(Bit.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this),
        e.on(Bit.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.on(Bit.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    _unregisterListeners() {
      const {hls: e} = this;
      e.off(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Bit.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(Bit.ERROR, this.onError, this),
        e.off(Bit.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.off(Bit.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
        e.off(Bit.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.off(Bit.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this),
        e.off(Bit.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.off(Bit.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    startLoad(e) {
      this.stopLoad(),
        this.state = Zut,
        this.setInterval(500),
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e,
        this.tick()
    }
    onManifestLoading() {
      this.mainDetails = null,
        this.fragmentTracker.removeAllFragments()
    }
    onMediaDetaching() {
      this.tracksBuffered = [],
        super.onMediaDetaching()
    }
    onLevelLoaded(e, t) {
      this.mainDetails = t.details
    }
    onSubtitleFragProcessed(e, t) {
      const {frag: n, success: r} = t;
      if (this.fragPrevious = n,
        this.state = Zut,
        !r)
        return;
      const o = this.tracksBuffered[this.currentTrackId];
      if (!o)
        return;
      let a;
      const i = n.start;
      for (let l = 0; l < o.length; l++)
        if (i >= o[l].start && i <= o[l].end) {
          a = o[l];
          break
        }
      const s = n.start + n.duration;
      a ? a.end = s : (a = {
        start: i,
        end: s
      },
        o.push(a)),
        this.fragmentTracker.fragBuffered(n)
    }
    onBufferFlushing(e, t) {
      const {startOffset: n, endOffset: r} = t;
      if (0 === n && r !== Number.POSITIVE_INFINITY) {
        const e = r - 1;
        if (e <= 0)
          return;
        t.endOffsetSubtitles = Math.max(0, e),
          this.tracksBuffered.forEach((t=>{
              for (let n = 0; n < t.length; )
                if (t[n].end <= e)
                  t.shift();
                else {
                  if (!(t[n].start < e))
                    break;
                  t[n].start = e,
                    n++
                }
            }
          )),
          this.fragmentTracker.removeFragmentsInRange(n, e, Olt)
      }
    }
    onFragBuffered(e, t) {
      var n;
      this.loadedmetadata || t.frag.type !== Tlt || null != (n = this.media) && n.buffered.length && (this.loadedmetadata = !0)
    }
    onError(e, t) {
      const n = t.frag;
      (null == n ? void 0 : n.type) === Olt && (this.fragCurrent && this.fragCurrent.abortRequests(),
      this.state !== Jut && (this.state = Zut))
    }
    onSubtitleTracksUpdated(e, {subtitleTracks: t}) {
      xdt(this.levels, t) ? this.levels = t.map((e=>new Xlt(e))) : (this.tracksBuffered = [],
        this.levels = t.map((e=>{
            const t = new Xlt(e);
            return this.tracksBuffered[t.id] = [],
              t
          }
        )),
        this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, Olt),
        this.fragPrevious = null,
        this.mediaBuffer = null)
    }
    onSubtitleTrackSwitch(e, t) {
      if (this.currentTrackId = t.id,
      !this.levels.length || -1 === this.currentTrackId)
        return void this.clearInterval();
      const n = this.levels[this.currentTrackId];
      null != n && n.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null,
      n && this.setInterval(500)
    }
    onSubtitleTrackLoaded(e, t) {
      var n;
      const {details: r, id: o} = t
        , {currentTrackId: a, levels: i} = this;
      if (!i.length)
        return;
      const s = i[a];
      if (o >= i.length || o !== a || !s)
        return;
      this.mediaBuffer = this.mediaBufferTimeRanges;
      let l = 0;
      if (r.live || null != (n = s.details) && n.live) {
        const e = this.mainDetails;
        if (r.deltaUpdateFailed || !e)
          return;
        const t = e.fragments[0];
        s.details ? (l = this.alignPlaylists(r, s.details),
        0 === l && t && (l = t.start,
          tut(r, l))) : r.hasProgramDateTime && e.hasProgramDateTime ? (Wut(r, e),
          l = r.fragments[0].start) : t && (l = t.start,
          tut(r, l))
      }
      if (s.details = r,
        this.levelLastLoaded = o,
      this.startFragRequested || !this.mainDetails && r.live || this.setStartPosition(s.details, l),
        this.tick(),
      r.live && !this.fragCurrent && this.media && this.state === Zut) {
        cut(null, r.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"),
          s.details = void 0)
      }
    }
    _handleFragmentLoadComplete(e) {
      const {frag: t, payload: n} = e
        , r = t.decryptdata
        , o = this.hls;
      if (!this.fragContextChanged(t) && n && n.byteLength > 0 && r && r.key && r.iv && "AES-128" === r.method) {
        const e = performance.now();
        this.decrypter.decrypt(new Uint8Array(n), r.key.buffer, r.iv.buffer).catch((e=>{
            throw o.trigger(Bit.ERROR, {
              type: Nit.MEDIA_ERROR,
              details: Mit.FRAG_DECRYPT_ERROR,
              fatal: !1,
              error: e,
              reason: e.message,
              frag: t
            }),
              e
          }
        )).then((n=>{
            const r = performance.now();
            o.trigger(Bit.FRAG_DECRYPTED, {
              frag: t,
              payload: n,
              stats: {
                tstart: e,
                tdecrypt: r
              }
            })
          }
        )).catch((e=>{
            this.warn(`${e.name}: ${e.message}`),
              this.state = Zut
          }
        ))
      }
    }
    doTick() {
      if (this.media) {
        if (this.state === Zut) {
          const {currentTrackId: e, levels: t} = this
            , n = t[e];
          if (!t.length || !n || !n.details)
            return;
          const {config: r} = this
            , o = this.getLoadPosition()
            , a = Vut.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], o, r.maxBufferHole)
            , {end: i, len: s} = a
            , l = this.getFwdBufferInfo(this.media, Tlt)
            , u = n.details;
          if (s > this.getMaxBufferLength(null == l ? void 0 : l.len) + u.levelTargetDuration)
            return;
          const c = u.fragments
            , d = c.length
            , f = u.edge;
          let p = null;
          const h = this.fragPrevious;
          if (i < f) {
            const e = r.maxFragLookUpTolerance
              , t = i > f - e ? 0 : e;
            p = cut(h, c, Math.max(c[0].start, i), t),
            !p && h && h.start < c[0].start && (p = c[0])
          } else
            p = c[d - 1];
          if (!p)
            return;
          if (p = this.mapToInitFragWhenRequired(p),
          "initSegment" !== p.sn) {
            const e = c[p.sn - u.startSN - 1];
            e && e.cc === p.cc && this.fragmentTracker.getState(e) === Cut && (p = e)
          }
          this.fragmentTracker.getState(p) === Cut && this.loadFragment(p, n, i)
        }
      } else
        this.state = Zut
    }
    getMaxBufferLength(e) {
      const t = super.getMaxBufferLength();
      return e ? Math.max(t, e) : t
    }
    loadFragment(e, t, n) {
      this.fragCurrent = e,
        "initSegment" === e.sn ? this._loadInitSegment(e, t) : (this.startFragRequested = !0,
          super.loadFragment(e, t, n))
    }
    get mediaBufferTimeRanges() {
      return new Edt(this.tracksBuffered[this.currentTrackId] || [])
    }
  }
  ,
  subtitleTrackController: class extends wut {
    constructor(e) {
      super(e, "[subtitle-track-controller]"),
        this.media = null,
        this.tracks = [],
        this.groupId = null,
        this.tracksInGroup = [],
        this.trackId = -1,
        this.selectDefaultTrack = !0,
        this.queuedDefaultTrack = -1,
        this.trackChangeListener = ()=>this.onTextTracksChanged(),
        this.asyncPollTrackChange = ()=>this.pollTrackChange(0),
        this.useTextTrackPolling = !1,
        this.subtitlePollingInterval = -1,
        this._subtitleDisplay = !0,
        this.registerListeners()
    }
    destroy() {
      this.unregisterListeners(),
        this.tracks.length = 0,
        this.tracksInGroup.length = 0,
        this.trackChangeListener = this.asyncPollTrackChange = null,
        super.destroy()
    }
    get subtitleDisplay() {
      return this._subtitleDisplay
    }
    set subtitleDisplay(e) {
      this._subtitleDisplay = e,
      this.trackId > -1 && this.toggleTrackModes(this.trackId)
    }
    registerListeners() {
      const {hls: e} = this;
      e.on(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(Bit.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(Bit.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.on(Bit.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.on(Bit.ERROR, this.onError, this)
    }
    unregisterListeners() {
      const {hls: e} = this;
      e.off(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(Bit.LEVEL_LOADING, this.onLevelLoading, this),
        e.off(Bit.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.off(Bit.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.off(Bit.ERROR, this.onError, this)
    }
    onMediaAttached(e, t) {
      this.media = t.media,
      this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack,
        this.queuedDefaultTrack = -1),
        this.useTextTrackPolling = !(this.media.textTracks && "onchange"in this.media.textTracks),
        this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
    }
    pollTrackChange(e) {
      self.clearInterval(this.subtitlePollingInterval),
        this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, e)
    }
    onMediaDetaching() {
      if (!this.media)
        return;
      self.clearInterval(this.subtitlePollingInterval),
      this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange),
      this.trackId > -1 && (this.queuedDefaultTrack = this.trackId);
      Adt(this.media.textTracks).forEach((e=>{
          Flt(e)
        }
      )),
        this.subtitleTrack = -1,
        this.media = null
    }
    onManifestLoading() {
      this.tracks = [],
        this.groupId = null,
        this.tracksInGroup = [],
        this.trackId = -1,
        this.selectDefaultTrack = !0
    }
    onManifestParsed(e, t) {
      this.tracks = t.subtitleTracks
    }
    onSubtitleTrackLoaded(e, t) {
      const {id: n, details: r} = t
        , {trackId: o} = this
        , a = this.tracksInGroup[o];
      if (!a)
        return void this.warn(`Invalid subtitle track id ${n}`);
      const i = a.details;
      a.details = t.details,
        this.log(`subtitle track ${n} loaded [${r.startSN}-${r.endSN}]`),
      n === this.trackId && this.playlistLoaded(n, t, i)
    }
    onLevelLoading(e, t) {
      this.switchLevel(t.level)
    }
    onLevelSwitching(e, t) {
      this.switchLevel(t.level)
    }
    switchLevel(e) {
      const t = this.hls.levels[e];
      if (null == t || !t.textGroupIds)
        return;
      const n = t.textGroupIds[t.urlId]
        , r = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
      if (this.groupId !== n) {
        const e = this.tracks.filter((e=>!n || e.groupId === n));
        this.tracksInGroup = e;
        const t = this.findTrackId(null == r ? void 0 : r.name) || this.findTrackId();
        this.groupId = n || null;
        const o = {
          subtitleTracks: e
        };
        this.log(`Updating subtitle tracks, ${e.length} track(s) found in "${n}" group-id`),
          this.hls.trigger(Bit.SUBTITLE_TRACKS_UPDATED, o),
        -1 !== t && this.setSubtitleTrack(t, r)
      } else
        this.shouldReloadPlaylist(r) && this.setSubtitleTrack(this.trackId, r)
    }
    findTrackId(e) {
      const t = this.tracksInGroup;
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if ((!this.selectDefaultTrack || r.default) && (!e || e === r.name))
          return r.id
      }
      return -1
    }
    onError(e, t) {
      !t.fatal && t.context && t.context.type === klt && t.context.id === this.trackId && t.context.groupId === this.groupId && this.checkRetry(t)
    }
    get subtitleTracks() {
      return this.tracksInGroup
    }
    get subtitleTrack() {
      return this.trackId
    }
    set subtitleTrack(e) {
      this.selectDefaultTrack = !1;
      const t = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
      this.setSubtitleTrack(e, t)
    }
    loadPlaylist(e) {
      super.loadPlaylist();
      const t = this.tracksInGroup[this.trackId];
      if (this.shouldLoadPlaylist(t)) {
        const r = t.id
          , o = t.groupId;
        let a = t.url;
        if (e)
          try {
            a = e.addDirectives(a)
          } catch (n) {
            this.warn(`Could not construct new URL with HLS Delivery Directives: ${n}`)
          }
        this.log(`Loading subtitle playlist for id ${r}`),
          this.hls.trigger(Bit.SUBTITLE_TRACK_LOADING, {
            url: a,
            id: r,
            groupId: o,
            deliveryDirectives: e || null
          })
      }
    }
    toggleTrackModes(e) {
      const {media: t, trackId: n} = this;
      if (!t)
        return;
      const r = Adt(t.textTracks)
        , o = r.filter((e=>e.groupId === this.groupId));
      if (-1 === e)
        [].slice.call(r).forEach((e=>{
            e.mode = "disabled"
          }
        ));
      else {
        const e = o[n];
        e && (e.mode = "disabled")
      }
      const a = o[e];
      a && (a.mode = this.subtitleDisplay ? "showing" : "hidden")
    }
    setSubtitleTrack(e, t) {
      var n;
      const r = this.tracksInGroup;
      if (!this.media)
        return void (this.queuedDefaultTrack = e);
      if (this.trackId !== e && this.toggleTrackModes(e),
      this.trackId === e && (-1 === e || null != (n = r[e]) && n.details) || e < -1 || e >= r.length)
        return;
      this.clearTimer();
      const o = r[e];
      if (this.log(`Switching to subtitle-track ${e}` + (o ? ` "${o.name}" lang:${o.lang} group:${o.groupId}` : "")),
        this.trackId = e,
        o) {
        const {id: e, groupId: n="", name: r, type: a, url: i} = o;
        this.hls.trigger(Bit.SUBTITLE_TRACK_SWITCH, {
          id: e,
          groupId: n,
          name: r,
          type: a,
          url: i
        });
        const s = this.switchParams(o.url, null == t ? void 0 : t.details);
        this.loadPlaylist(s)
      } else
        this.hls.trigger(Bit.SUBTITLE_TRACK_SWITCH, {
          id: e
        })
    }
    onTextTracksChanged() {
      if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval),
      !this.media || !this.hls.config.renderTextTracksNatively)
        return;
      let e = -1;
      const t = Adt(this.media.textTracks);
      for (let n = 0; n < t.length; n++)
        if ("hidden" === t[n].mode)
          e = n;
        else if ("showing" === t[n].mode) {
          e = n;
          break
        }
      this.subtitleTrack !== e && (this.subtitleTrack = e)
    }
  }
  ,
  timelineController: class {
    constructor(e) {
      if (this.hls = void 0,
        this.media = null,
        this.config = void 0,
        this.enabled = !0,
        this.Cues = void 0,
        this.textTracks = [],
        this.tracks = [],
        this.initPTS = [],
        this.unparsedVttFrags = [],
        this.captionsTracks = {},
        this.nonNativeCaptionsTracks = {},
        this.cea608Parser1 = void 0,
        this.cea608Parser2 = void 0,
        this.lastSn = -1,
        this.lastPartIndex = -1,
        this.prevCC = -1,
        this.vttCCs = {
          ccOffset: 0,
          presentationOffset: 0,
          0: {
            start: 0,
            prevCC: -1,
            new: !0
          }
        },
        this.captionsProperties = void 0,
        this.hls = e,
        this.config = e.config,
        this.Cues = e.config.cueHandler,
        this.captionsProperties = {
          textTrack1: {
            label: this.config.captionsTextTrack1Label,
            languageCode: this.config.captionsTextTrack1LanguageCode
          },
          textTrack2: {
            label: this.config.captionsTextTrack2Label,
            languageCode: this.config.captionsTextTrack2LanguageCode
          },
          textTrack3: {
            label: this.config.captionsTextTrack3Label,
            languageCode: this.config.captionsTextTrack3LanguageCode
          },
          textTrack4: {
            label: this.config.captionsTextTrack4Label,
            languageCode: this.config.captionsTextTrack4LanguageCode
          }
        },
        this.config.enableCEA708Captions) {
        const e = new Gdt(this,"textTrack1")
          , t = new Gdt(this,"textTrack2")
          , n = new Gdt(this,"textTrack3")
          , r = new Gdt(this,"textTrack4");
        this.cea608Parser1 = new zdt(1,e,t),
          this.cea608Parser2 = new zdt(3,n,r)
      }
      e.on(Bit.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Bit.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(Bit.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.on(Bit.FRAG_LOADING, this.onFragLoading, this),
        e.on(Bit.FRAG_LOADED, this.onFragLoaded, this),
        e.on(Bit.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
        e.on(Bit.FRAG_DECRYPTED, this.onFragDecrypted, this),
        e.on(Bit.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.on(Bit.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this),
        e.on(Bit.BUFFER_FLUSHING, this.onBufferFlushing, this)
    }
    destroy() {
      const {hls: e} = this;
      e.off(Bit.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Bit.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(Bit.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.off(Bit.FRAG_LOADING, this.onFragLoading, this),
        e.off(Bit.FRAG_LOADED, this.onFragLoaded, this),
        e.off(Bit.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
        e.off(Bit.FRAG_DECRYPTED, this.onFragDecrypted, this),
        e.off(Bit.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.off(Bit.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this),
        e.off(Bit.BUFFER_FLUSHING, this.onBufferFlushing, this),
        this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null
    }
    addCues(e, t, n, r, o) {
      let a = !1;
      for (let c = o.length; c--; ) {
        const e = o[c]
          , r = (i = e[0],
          s = e[1],
          l = t,
          u = n,
        Math.min(s, u) - Math.max(i, l));
        if (r >= 0 && (e[0] = Math.min(e[0], t),
          e[1] = Math.max(e[1], n),
          a = !0,
        r / (n - t) > .5))
          return
      }
      var i, s, l, u;
      if (a || o.push([t, n]),
        this.config.renderTextTracksNatively) {
        const o = this.captionsTracks[e];
        this.Cues.newCue(o, t, n, r)
      } else {
        const o = this.Cues.newCue(null, t, n, r);
        this.hls.trigger(Bit.CUES_PARSED, {
          type: "captions",
          cues: o,
          track: e
        })
      }
    }
    onInitPtsFound(e, {frag: t, id: n, initPTS: r, timescale: o}) {
      const {unparsedVttFrags: a} = this;
      "main" === n && (this.initPTS[t.cc] = {
        baseTime: r,
        timescale: o
      }),
      a.length && (this.unparsedVttFrags = [],
        a.forEach((e=>{
            this.onFragLoaded(Bit.FRAG_LOADED, e)
          }
        )))
    }
    getExistingTrack(e) {
      const {media: t} = this;
      if (t)
        for (let n = 0; n < t.textTracks.length; n++) {
          const r = t.textTracks[n];
          if (r[e])
            return r
        }
      return null
    }
    createCaptionsTrack(e) {
      this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e)
    }
    createNativeTrack(e) {
      if (this.captionsTracks[e])
        return;
      const {captionsProperties: t, captionsTracks: n, media: r} = this
        , {label: o, languageCode: a} = t[e]
        , i = this.getExistingTrack(e);
      if (i)
        n[e] = i,
          Flt(n[e]),
          Ilt(n[e], r);
      else {
        const t = this.createTextTrack("captions", o, a);
        t && (t[e] = !0,
          n[e] = t)
      }
    }
    createNonNativeTrack(e) {
      if (this.nonNativeCaptionsTracks[e])
        return;
      const t = this.captionsProperties[e];
      if (!t)
        return;
      const n = {
        _id: e,
        label: t.label,
        kind: "captions",
        default: !!t.media && !!t.media.default,
        closedCaptions: t.media
      };
      this.nonNativeCaptionsTracks[e] = n,
        this.hls.trigger(Bit.NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: [n]
        })
    }
    createTextTrack(e, t, n) {
      const r = this.media;
      if (r)
        return r.addTextTrack(e, t, n)
    }
    onMediaAttaching(e, t) {
      this.media = t.media,
        this._cleanTracks()
    }
    onMediaDetaching() {
      const {captionsTracks: e} = this;
      Object.keys(e).forEach((t=>{
          Flt(e[t]),
            delete e[t]
        }
      )),
        this.nonNativeCaptionsTracks = {}
    }
    onManifestLoading() {
      this.lastSn = -1,
        this.lastPartIndex = -1,
        this.prevCC = -1,
        this.vttCCs = {
          ccOffset: 0,
          presentationOffset: 0,
          0: {
            start: 0,
            prevCC: -1,
            new: !0
          }
        },
        this._cleanTracks(),
        this.tracks = [],
        this.captionsTracks = {},
        this.nonNativeCaptionsTracks = {},
        this.textTracks = [],
        this.unparsedVttFrags = [],
        this.initPTS = [],
      this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(),
        this.cea608Parser2.reset())
    }
    _cleanTracks() {
      const {media: e} = this;
      if (!e)
        return;
      const t = e.textTracks;
      if (t)
        for (let n = 0; n < t.length; n++)
          Flt(t[n])
    }
    onSubtitleTracksUpdated(e, t) {
      const n = t.subtitleTracks || []
        , r = n.some((e=>e.textCodec === uft));
      if (this.config.enableWebVTT || r && this.config.enableIMSC1) {
        if (xdt(this.tracks, n))
          return void (this.tracks = n);
        if (this.textTracks = [],
          this.tracks = n,
          this.config.renderTextTracksNatively) {
          const e = this.media ? this.media.textTracks : null;
          this.tracks.forEach(((t,n)=>{
              let r;
              if (e && n < e.length) {
                let n = null;
                for (let r = 0; r < e.length; r++)
                  if (wft(e[r], t)) {
                    n = e[r];
                    break
                  }
                n && (r = n)
              }
              if (r)
                Flt(r);
              else {
                const e = this._captionsOrSubtitlesFromCharacteristics(t);
                r = this.createTextTrack(e, t.name, t.lang),
                r && (r.mode = "disabled")
              }
              r && (r.groupId = t.groupId,
                this.textTracks.push(r))
            }
          ))
        } else if (this.tracks.length) {
          const e = this.tracks.map((e=>({
            label: e.name,
            kind: e.type.toLowerCase(),
            default: e.default,
            subtitleTrack: e
          })));
          this.hls.trigger(Bit.NON_NATIVE_TEXT_TRACKS_FOUND, {
            tracks: e
          })
        }
      }
    }
    _captionsOrSubtitlesFromCharacteristics(e) {
      if (e.attrs.CHARACTERISTICS) {
        const t = /transcribes-spoken-dialog/gi.test(e.attrs.CHARACTERISTICS)
          , n = /describes-music-and-sound/gi.test(e.attrs.CHARACTERISTICS);
        if (t && n)
          return "captions"
      }
      return "subtitles"
    }
    onManifestLoaded(e, t) {
      this.config.enableCEA708Captions && t.captions && t.captions.forEach((e=>{
          const t = /(?:CC|SERVICE)([1-4])/.exec(e.instreamId);
          if (!t)
            return;
          const n = `textTrack${t[1]}`
            , r = this.captionsProperties[n];
          r && (r.label = e.name,
          e.lang && (r.languageCode = e.lang),
            r.media = e)
        }
      ))
    }
    closedCaptionsForLevel(e) {
      const t = this.hls.levels[e.level];
      return null == t ? void 0 : t.attrs["CLOSED-CAPTIONS"]
    }
    onFragLoading(e, t) {
      const {cea608Parser1: n, cea608Parser2: r, lastSn: o, lastPartIndex: a} = this;
      if (this.enabled && n && r && t.frag.type === Tlt) {
        var i, s;
        const e = t.frag.sn
          , l = null != (i = null == t || null == (s = t.part) ? void 0 : s.index) ? i : -1;
        e === o + 1 || e === o && l === a + 1 || (n.reset(),
          r.reset()),
          this.lastSn = e,
          this.lastPartIndex = l
      }
    }
    onFragLoaded(e, t) {
      const {frag: n, payload: r} = t;
      if (n.type === Olt)
        if (r.byteLength) {
          const e = n.decryptdata
            , o = "stats"in t;
          if (null == e || !e.encrypted || o) {
            const e = this.tracks[n.level]
              , o = this.vttCCs;
            o[n.cc] || (o[n.cc] = {
              start: n.start,
              prevCC: this.prevCC,
              new: !0
            },
              this.prevCC = n.cc),
              e && e.textCodec === uft ? this._parseIMSC1(n, r) : this._parseVTTs(t)
          }
        } else
          this.hls.trigger(Bit.SUBTITLE_FRAG_PROCESSED, {
            success: !1,
            frag: n,
            error: new Error("Empty subtitle payload")
          })
    }
    _parseIMSC1(e, t) {
      const n = this.hls;
      pft(t, this.initPTS[e.cc], (t=>{
          this._appendCues(t, e.level),
            n.trigger(Bit.SUBTITLE_FRAG_PROCESSED, {
              success: !0,
              frag: e
            })
        }
      ), (t=>{
          Hit.log(`Failed to parse IMSC1: ${t}`),
            n.trigger(Bit.SUBTITLE_FRAG_PROCESSED, {
              success: !1,
              frag: e,
              error: t
            })
        }
      ))
    }
    _parseVTTs(e) {
      var t;
      const {frag: n, payload: r} = e
        , {initPTS: o, unparsedVttFrags: a} = this
        , i = o.length - 1;
      if (!o[n.cc] && -1 === i)
        return void a.push(e);
      const s = this.hls;
      lft(null != (t = n.initSegment) && t.data ? Wst(n.initSegment.data, new Uint8Array(r)) : r, this.initPTS[n.cc], this.vttCCs, n.cc, n.start, (e=>{
          this._appendCues(e, n.level),
            s.trigger(Bit.SUBTITLE_FRAG_PROCESSED, {
              success: !0,
              frag: n
            })
        }
      ), (t=>{
          const o = "Missing initPTS for VTT MPEGTS" === t.message;
          o ? a.push(e) : this._fallbackToIMSC1(n, r),
            Hit.log(`Failed to parse VTT cue: ${t}`),
          o && i > n.cc || s.trigger(Bit.SUBTITLE_FRAG_PROCESSED, {
            success: !1,
            frag: n,
            error: t
          })
        }
      ))
    }
    _fallbackToIMSC1(e, t) {
      const n = this.tracks[e.level];
      n.textCodec || pft(t, this.initPTS[e.cc], (()=>{
          n.textCodec = uft,
            this._parseIMSC1(e, t)
        }
      ), (()=>{
          n.textCodec = "wvtt"
        }
      ))
    }
    _appendCues(e, t) {
      const n = this.hls;
      if (this.config.renderTextTracksNatively) {
        const n = this.textTracks[t];
        if (!n || "disabled" === n.mode)
          return;
        e.forEach((e=>Plt(n, e)))
      } else {
        const r = this.tracks[t];
        if (!r)
          return;
        const o = r.default ? "default" : "subtitles" + t;
        n.trigger(Bit.CUES_PARSED, {
          type: "subtitles",
          cues: e,
          track: o
        })
      }
    }
    onFragDecrypted(e, t) {
      const {frag: n} = t;
      n.type === Olt && this.onFragLoaded(Bit.FRAG_LOADED, t)
    }
    onSubtitleTracksCleared() {
      this.tracks = [],
        this.captionsTracks = {}
    }
    onFragParsingUserdata(e, t) {
      const {cea608Parser1: n, cea608Parser2: r} = this;
      if (!this.enabled || !n || !r)
        return;
      const {frag: o, samples: a} = t;
      if (o.type !== Tlt || "NONE" !== this.closedCaptionsForLevel(o))
        for (let i = 0; i < a.length; i++) {
          const e = a[i].bytes;
          if (e) {
            const t = this.extractCea608Data(e);
            n.addData(a[i].pts, t[0]),
              r.addData(a[i].pts, t[1])
          }
        }
    }
    onBufferFlushing(e, {startOffset: t, endOffset: n, endOffsetSubtitles: r, type: o}) {
      const {media: a} = this;
      if (a && !(a.currentTime < n)) {
        if (!o || "video" === o) {
          const {captionsTracks: e} = this;
          Object.keys(e).forEach((r=>Blt(e[r], t, n)))
        }
        if (this.config.renderTextTracksNatively && 0 === t && void 0 !== r) {
          const {textTracks: e} = this;
          Object.keys(e).forEach((n=>Blt(e[n], t, r)))
        }
      }
    }
    extractCea608Data(e) {
      const t = [[], []]
        , n = 31 & e[0];
      let r = 2;
      for (let o = 0; o < n; o++) {
        const n = e[r++]
          , o = 127 & e[r++]
          , a = 127 & e[r++];
        if (0 === o && 0 === a)
          continue;
        if (0 != (4 & n)) {
          const e = 3 & n;
          0 !== e && 1 !== e || (t[e].push(o),
            t[e].push(a))
        }
      }
      return t
    }
  }
  ,
  audioStreamController: class extends cct {
    constructor(e, t, n) {
      super(e, t, n, "[audio-stream-controller]", Dlt),
        this.videoBuffer = null,
        this.videoTrackCC = -1,
        this.waitingVideoCC = -1,
        this.bufferedTrack = null,
        this.switchingTrack = null,
        this.trackId = -1,
        this.waitingData = null,
        this.mainDetails = null,
        this.bufferFlushed = !1,
        this.cachedTrackLoadedData = null,
        this._registerListeners()
    }
    onHandlerDestroying() {
      this._unregisterListeners(),
        this.mainDetails = null,
        this.bufferedTrack = null,
        this.switchingTrack = null
    }
    _registerListeners() {
      const {hls: e} = this;
      e.on(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Bit.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(Bit.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
        e.on(Bit.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.on(Bit.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.on(Bit.ERROR, this.onError, this),
        e.on(Bit.BUFFER_RESET, this.onBufferReset, this),
        e.on(Bit.BUFFER_CREATED, this.onBufferCreated, this),
        e.on(Bit.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.on(Bit.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.on(Bit.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    _unregisterListeners() {
      const {hls: e} = this;
      e.off(Bit.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(Bit.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Bit.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(Bit.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
        e.off(Bit.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.off(Bit.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.off(Bit.ERROR, this.onError, this),
        e.off(Bit.BUFFER_RESET, this.onBufferReset, this),
        e.off(Bit.BUFFER_CREATED, this.onBufferCreated, this),
        e.off(Bit.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.off(Bit.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.off(Bit.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    onInitPtsFound(e, {frag: t, id: n, initPTS: r, timescale: o}) {
      if ("main" === n) {
        const e = t.cc;
        this.initPTS[t.cc] = {
          baseTime: r,
          timescale: o
        },
          this.log(`InitPTS for cc: ${e} found from main: ${r}`),
          this.videoTrackCC = e,
        this.state === lct && this.tick()
      }
    }
    startLoad(e) {
      if (!this.levels)
        return this.startPosition = e,
          void (this.state = Jut);
      const t = this.lastCurrentTime;
      this.stopLoad(),
        this.setInterval(100),
        t > 0 && -1 === e ? (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`),
          e = t,
          this.state = Zut) : (this.loadedmetadata = !1,
          this.state = rct),
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e,
        this.tick()
    }
    doTick() {
      switch (this.state) {
        case Zut:
          this.doTickIdle();
          break;
        case rct:
        {
          var e;
          const {levels: t, trackId: n} = this
            , r = null == t || null == (e = t[n]) ? void 0 : e.details;
          if (r) {
            if (this.waitForCdnTuneIn(r))
              break;
            this.state = lct
          }
          break
        }
        case nct:
        {
          var t;
          const e = performance.now()
            , n = this.retryDate;
          (!n || e >= n || null != (t = this.media) && t.seeking) && (this.log("RetryDate reached, switch back to IDLE state"),
            this.resetStartWhenNotLoaded(this.trackId),
            this.state = Zut);
          break
        }
        case lct:
        {
          const e = this.waitingData;
          if (e) {
            const {frag: t, part: n, cache: r, complete: o} = e;
            if (void 0 !== this.initPTS[t.cc]) {
              this.waitingData = null,
                this.waitingVideoCC = -1,
                this.state = tct;
              const e = {
                frag: t,
                part: n,
                payload: r.flush(),
                networkDetails: null
              };
              this._handleFragmentLoadProgress(e),
              o && super._handleFragmentLoadComplete(e)
            } else if (this.videoTrackCC !== this.waitingVideoCC)
              this.log(`Waiting fragment cc (${t.cc}) cancelled because video is at cc ${this.videoTrackCC}`),
                this.clearWaitingFragment();
            else {
              const e = this.getLoadPosition()
                , n = Vut.bufferInfo(this.mediaBuffer, e, this.config.maxBufferHole);
              dut(n.end, this.config.maxFragLookUpTolerance, t) < 0 && (this.log(`Waiting fragment cc (${t.cc}) @ ${t.start} cancelled because another fragment at ${n.end} is needed`),
                this.clearWaitingFragment())
            }
          } else
            this.state = Zut
        }
      }
      this.onTickEnd()
    }
    clearWaitingFragment() {
      const e = this.waitingData;
      e && (this.fragmentTracker.removeFragment(e.frag),
        this.waitingData = null,
        this.waitingVideoCC = -1,
        this.state = Zut)
    }
    resetLoadingState() {
      this.clearWaitingFragment(),
        super.resetLoadingState()
    }
    onTickEnd() {
      const {media: e} = this;
      null != e && e.readyState && (this.lastCurrentTime = e.currentTime)
    }
    doTickIdle() {
      const {hls: e, levels: t, media: n, trackId: r} = this
        , o = e.config;
      if (null == t || !t[r])
        return;
      if (!n && (this.startFragRequested || !o.startFragPrefetch))
        return;
      const a = t[r]
        , i = a.details;
      if (!i || i.live && this.levelLastLoaded !== r || this.waitForCdnTuneIn(i))
        return void (this.state = rct);
      const s = this.mediaBuffer ? this.mediaBuffer : this.media;
      this.bufferFlushed && s && (this.bufferFlushed = !1,
        this.afterBufferFlushed(s, Xit, Dlt));
      const l = this.getFwdBufferInfo(s, Dlt);
      if (null === l)
        return;
      const {bufferedTrack: u, switchingTrack: c} = this;
      if (!c && this._streamEnded(l, i))
        return e.trigger(Bit.BUFFER_EOS, {
          type: "audio"
        }),
          void (this.state = ict);
      const d = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, Tlt)
        , f = l.len
        , p = this.getMaxBufferLength(null == d ? void 0 : d.len);
      if (f >= p && !c)
        return;
      const h = i.fragments[0].start;
      let v = l.end;
      if (c && n) {
        const e = this.getLoadPosition();
        u && c.attrs !== u.attrs && (v = e),
        i.PTSKnown && e < h && (l.end > h || l.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"),
          n.currentTime = h + .05)
      }
      let g = this.getNextFragment(v, i)
        , m = !1;
      if (g && this.isLoopLoading(g, v) && (m = !!g.gap,
        g = this.getNextFragmentLoopLoading(g, i, l, Tlt, p)),
        !g)
        return void (this.bufferFlushed = !0);
      const y = d && g.start > d.end + i.targetduration;
      if (y || (null == d || !d.len) && l.len) {
        const e = this.getAppendedFrag(g.start, Tlt);
        if (null === e)
          return;
        if (m || (m = !!e.gap || !!y && 0 === d.len),
        y && !m || m && l.nextStart && l.nextStart < e.end)
          return
      }
      this.loadFragment(g, a, v)
    }
    getMaxBufferLength(e) {
      const t = super.getMaxBufferLength();
      return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t
    }
    onMediaDetaching() {
      this.videoBuffer = null,
        super.onMediaDetaching()
    }
    onAudioTracksUpdated(e, {audioTracks: t}) {
      this.resetTransmuxer(),
        this.levels = t.map((e=>new Xlt(e)))
    }
    onAudioTrackSwitching(e, t) {
      const n = !!t.url;
      this.trackId = t.id;
      const {fragCurrent: r} = this;
      r && (r.abortRequests(),
        this.removeUnbufferedFrags(r.start)),
        this.resetLoadingState(),
        n ? this.setInterval(100) : this.resetTransmuxer(),
        n ? (this.switchingTrack = t,
          this.state = Zut) : (this.switchingTrack = null,
          this.bufferedTrack = t,
          this.state = Jut),
        this.tick()
    }
    onManifestLoading() {
      this.fragmentTracker.removeAllFragments(),
        this.startPosition = this.lastCurrentTime = 0,
        this.bufferFlushed = !1,
        this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null,
        this.startFragRequested = !1,
        this.trackId = this.videoTrackCC = this.waitingVideoCC = -1
    }
    onLevelLoaded(e, t) {
      this.mainDetails = t.details,
      null !== this.cachedTrackLoadedData && (this.hls.trigger(Bit.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData),
        this.cachedTrackLoadedData = null)
    }
    onAudioTrackLoaded(e, t) {
      var n;
      if (null == this.mainDetails)
        return void (this.cachedTrackLoadedData = t);
      const {levels: r} = this
        , {details: o, id: a} = t;
      if (!r)
        return void this.warn(`Audio tracks were reset while loading level ${a}`);
      this.log(`Track ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""},duration:${o.totalduration}`);
      const i = r[a];
      let s = 0;
      if (o.live || null != (n = i.details) && n.live) {
        const e = this.mainDetails;
        if (o.fragments[0] || (o.deltaUpdateFailed = !0),
        o.deltaUpdateFailed || !e)
          return;
        !i.details && o.hasProgramDateTime && e.hasProgramDateTime ? (Wut(o, e),
          s = o.fragments[0].start) : s = this.alignPlaylists(o, i.details)
      }
      i.details = o,
        this.levelLastLoaded = a,
      this.startFragRequested || !this.mainDetails && o.live || this.setStartPosition(i.details, s),
      this.state !== rct || this.waitForCdnTuneIn(o) || (this.state = Zut),
        this.tick()
    }
    _handleFragmentLoadProgress(e) {
      var t;
      const {frag: n, part: r, payload: o} = e
        , {config: a, trackId: i, levels: s} = this;
      if (!s)
        return void this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
      const l = s[i];
      if (!l)
        return void this.warn("Audio track is undefined on fragment load progress");
      const u = l.details;
      if (!u)
        return this.warn("Audio track details undefined on fragment load progress"),
          void this.removeUnbufferedFrags(n.start);
      const c = a.defaultAudioCodec || l.audioCodec || "mp4a.40.2";
      let d = this.transmuxer;
      d || (d = this.transmuxer = new vdt(this.hls,Dlt,this._handleTransmuxComplete.bind(this),this._handleTransmuxerFlush.bind(this)));
      const f = this.initPTS[n.cc]
        , p = null == (t = n.initSegment) ? void 0 : t.data;
      if (void 0 !== f) {
        const e = !1
          , t = r ? r.index : -1
          , a = -1 !== t
          , i = new Uut(n.level,n.sn,n.stats.chunkCount,o.byteLength,t,a);
        d.push(o, p, c, "", n, r, u.totalduration, e, i, f)
      } else {
        this.log(`Unknown video PTS for cc ${n.cc}, waiting for video PTS before demuxing audio frag ${n.sn} of [${u.startSN} ,${u.endSN}],track ${i}`);
        const {cache: e} = this.waitingData = this.waitingData || {
          frag: n,
          part: r,
          cache: new wdt,
          complete: !1
        };
        e.push(new Uint8Array(o)),
          this.waitingVideoCC = this.videoTrackCC,
          this.state = lct
      }
    }
    _handleFragmentLoadComplete(e) {
      this.waitingData ? this.waitingData.complete = !0 : super._handleFragmentLoadComplete(e)
    }
    onBufferReset() {
      this.mediaBuffer = this.videoBuffer = null,
        this.loadedmetadata = !1
    }
    onBufferCreated(e, t) {
      const n = t.tracks.audio;
      n && (this.mediaBuffer = n.buffer || null),
      t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null)
    }
    onFragBuffered(e, t) {
      const {frag: n, part: r} = t;
      if (n.type === Dlt)
        if (this.fragContextChanged(n))
          this.warn(`Fragment ${n.sn}${r ? " p: " + r.index : ""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
        else {
          if ("initSegment" !== n.sn) {
            this.fragPrevious = n;
            const e = this.switchingTrack;
            e && (this.bufferedTrack = e,
              this.switchingTrack = null,
              this.hls.trigger(Bit.AUDIO_TRACK_SWITCHED, Lit({}, e)))
          }
          this.fragBufferedComplete(n, r)
        }
      else if (!this.loadedmetadata && n.type === Tlt) {
        const e = this.videoBuffer || this.media;
        if (e) {
          Vut.getBuffered(e).length && (this.loadedmetadata = !0)
        }
      }
    }
    onError(e, t) {
      var n;
      if (t.fatal)
        this.state = sct;
      else
        switch (t.details) {
          case Mit.FRAG_GAP:
          case Mit.FRAG_PARSING_ERROR:
          case Mit.FRAG_DECRYPT_ERROR:
          case Mit.FRAG_LOAD_ERROR:
          case Mit.FRAG_LOAD_TIMEOUT:
          case Mit.KEY_LOAD_ERROR:
          case Mit.KEY_LOAD_TIMEOUT:
            this.onFragmentOrKeyLoadError(Dlt, t);
            break;
          case Mit.AUDIO_TRACK_LOAD_ERROR:
          case Mit.AUDIO_TRACK_LOAD_TIMEOUT:
          case Mit.LEVEL_PARSING_ERROR:
            t.levelRetry || this.state !== rct || (null == (n = t.context) ? void 0 : n.type) !== Clt || (this.state = Zut);
            break;
          case Mit.BUFFER_FULL_ERROR:
            if (!t.parent || "audio" !== t.parent)
              return;
            this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null,
              super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
            break;
          case Mit.INTERNAL_EXCEPTION:
            this.recoverWorkerError(t)
        }
    }
    onBufferFlushed(e, {type: t}) {
      t === Xit && (this.bufferFlushed = !0,
      this.state === ict && (this.state = Zut))
    }
    _handleTransmuxComplete(e) {
      var t;
      const n = "audio"
        , {hls: r} = this
        , {remuxResult: o, chunkMeta: a} = e
        , i = this.getCurrentContext(a);
      if (!i)
        return void this.resetWhenMissingContext(a);
      const {frag: s, part: l, level: u} = i
        , {details: c} = u
        , {audio: d, text: f, id3: p, initSegment: h} = o;
      if (!this.fragContextChanged(s) && c) {
        if (this.state = oct,
        this.switchingTrack && d && this.completeAudioSwitch(this.switchingTrack),
        null != h && h.tracks) {
          const e = s.initSegment || s;
          this._bufferInitSegment(h.tracks, e, a),
            r.trigger(Bit.FRAG_PARSING_INIT_SEGMENT, {
              frag: e,
              id: n,
              tracks: h.tracks
            })
        }
        if (d) {
          const {startPTS: e, endPTS: t, startDTS: n, endDTS: r} = d;
          l && (l.elementaryStreams[Xit] = {
            startPTS: e,
            endPTS: t,
            startDTS: n,
            endDTS: r
          }),
            s.setElementaryStreamInfo(Xit, e, t, n, r),
            this.bufferFragmentData(d, s, l, a)
        }
        if (null != p && null != (t = p.samples) && t.length) {
          const e = Pit({
            id: n,
            frag: s,
            details: c
          }, p);
          r.trigger(Bit.FRAG_PARSING_METADATA, e)
        }
        if (f) {
          const e = Pit({
            id: n,
            frag: s,
            details: c
          }, f);
          r.trigger(Bit.FRAG_PARSING_USERDATA, e)
        }
      } else
        this.fragmentTracker.removeFragment(s)
    }
    _bufferInitSegment(e, t, n) {
      if (this.state !== oct)
        return;
      e.video && delete e.video;
      const r = e.audio;
      if (!r)
        return;
      r.levelCodec = r.codec,
        r.id = "audio",
        this.log(`Init audio buffer, container:${r.container}, codecs[parsed]=[${r.codec}]`),
        this.hls.trigger(Bit.BUFFER_CODECS, e);
      const o = r.initSegment;
      if (null != o && o.byteLength) {
        const e = {
          type: "audio",
          frag: t,
          part: null,
          chunkMeta: n,
          parent: t.type,
          data: o
        };
        this.hls.trigger(Bit.BUFFER_APPENDING, e)
      }
      this.tick()
    }
    loadFragment(e, t, n) {
      const r = this.fragmentTracker.getState(e);
      var o;
      (this.fragCurrent = e,
      this.switchingTrack || r === Cut || r === Tut) ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : null != (o = t.details) && o.live && !this.initPTS[e.cc] ? (this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`),
        this.state = lct) : (this.startFragRequested = !0,
        super.loadFragment(e, t, n)) : this.clearTrackerIfNeeded(e)
    }
    completeAudioSwitch(e) {
      const {hls: t, media: n, bufferedTrack: r} = this
        , o = null == r ? void 0 : r.attrs
        , a = e.attrs;
      n && o && (o.CHANNELS !== a.CHANNELS || o.NAME !== a.NAME || o.LANGUAGE !== a.LANGUAGE) && (this.log("Switching audio track : flushing all audio"),
        super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio")),
        this.bufferedTrack = e,
        this.switchingTrack = null,
        t.trigger(Bit.AUDIO_TRACK_SWITCHED, Lit({}, e))
    }
  }
  ,
  audioTrackController: class extends wut {
    constructor(e) {
      super(e, "[audio-track-controller]"),
        this.tracks = [],
        this.groupId = null,
        this.tracksInGroup = [],
        this.trackId = -1,
        this.currentTrack = null,
        this.selectDefaultTrack = !0,
        this.registerListeners()
    }
    registerListeners() {
      const {hls: e} = this;
      e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(Bit.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(Bit.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.on(Bit.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.on(Bit.ERROR, this.onError, this)
    }
    unregisterListeners() {
      const {hls: e} = this;
      e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(Bit.LEVEL_LOADING, this.onLevelLoading, this),
        e.off(Bit.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.off(Bit.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.off(Bit.ERROR, this.onError, this)
    }
    destroy() {
      this.unregisterListeners(),
        this.tracks.length = 0,
        this.tracksInGroup.length = 0,
        this.currentTrack = null,
        super.destroy()
    }
    onManifestLoading() {
      this.tracks = [],
        this.groupId = null,
        this.tracksInGroup = [],
        this.trackId = -1,
        this.currentTrack = null,
        this.selectDefaultTrack = !0
    }
    onManifestParsed(e, t) {
      this.tracks = t.audioTracks || []
    }
    onAudioTrackLoaded(e, t) {
      const {id: n, groupId: r, details: o} = t
        , a = this.tracksInGroup[n];
      if (!a || a.groupId !== r)
        return void this.warn(`Track with id:${n} and group:${r} not found in active group ${a.groupId}`);
      const i = a.details;
      a.details = t.details,
        this.log(`audio-track ${n} "${a.name}" lang:${a.lang} group:${r} loaded [${o.startSN}-${o.endSN}]`),
      n === this.trackId && this.playlistLoaded(n, t, i)
    }
    onLevelLoading(e, t) {
      this.switchLevel(t.level)
    }
    onLevelSwitching(e, t) {
      this.switchLevel(t.level)
    }
    switchLevel(e) {
      const t = this.hls.levels[e];
      if (null == t || !t.audioGroupIds)
        return;
      const n = t.audioGroupIds[t.urlId];
      if (this.groupId !== n) {
        this.groupId = n || null;
        const e = this.tracks.filter((e=>!n || e.groupId === n));
        this.selectDefaultTrack && !e.some((e=>e.default)) && (this.selectDefaultTrack = !1),
          this.tracksInGroup = e;
        const t = {
          audioTracks: e
        };
        this.log(`Updating audio tracks, ${e.length} track(s) found in group:${n}`),
          this.hls.trigger(Bit.AUDIO_TRACKS_UPDATED, t),
          this.selectInitialTrack()
      } else
        this.shouldReloadPlaylist(this.currentTrack) && this.setAudioTrack(this.trackId)
    }
    onError(e, t) {
      !t.fatal && t.context && t.context.type === Clt && t.context.id === this.trackId && t.context.groupId === this.groupId && (this.requestScheduled = -1,
        this.checkRetry(t))
    }
    get audioTracks() {
      return this.tracksInGroup
    }
    get audioTrack() {
      return this.trackId
    }
    set audioTrack(e) {
      this.selectDefaultTrack = !1,
        this.setAudioTrack(e)
    }
    setAudioTrack(e) {
      const t = this.tracksInGroup;
      if (e < 0 || e >= t.length)
        return void this.warn("Invalid id passed to audio-track controller");
      this.clearTimer();
      const n = this.currentTrack;
      t[this.trackId];
      const r = t[e]
        , {groupId: o, name: a} = r;
      if (this.log(`Switching to audio-track ${e} "${a}" lang:${r.lang} group:${o}`),
        this.trackId = e,
        this.currentTrack = r,
        this.selectDefaultTrack = !1,
        this.hls.trigger(Bit.AUDIO_TRACK_SWITCHING, Lit({}, r)),
      r.details && !r.details.live)
        return;
      const i = this.switchParams(r.url, null == n ? void 0 : n.details);
      this.loadPlaylist(i)
    }
    selectInitialTrack() {
      const e = this.tracksInGroup
        , t = this.findTrackId(this.currentTrack) | this.findTrackId(null);
      if (-1 !== t)
        this.setAudioTrack(t);
      else {
        const t = new Error(`No track found for running audio group-ID: ${this.groupId} track count: ${e.length}`);
        this.warn(t.message),
          this.hls.trigger(Bit.ERROR, {
            type: Nit.MEDIA_ERROR,
            details: Mit.AUDIO_TRACK_LOAD_ERROR,
            fatal: !0,
            error: t
          })
      }
    }
    findTrackId(e) {
      const t = this.tracksInGroup;
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (!this.selectDefaultTrack || r.default) {
          if (!e || void 0 !== e.attrs["STABLE-RENDITION-ID"] && e.attrs["STABLE-RENDITION-ID"] === r.attrs["STABLE-RENDITION-ID"])
            return r.id;
          if (e.name === r.name && e.lang === r.lang)
            return r.id
        }
      }
      return -1
    }
    loadPlaylist(e) {
      super.loadPlaylist();
      const t = this.tracksInGroup[this.trackId];
      if (this.shouldLoadPlaylist(t)) {
        const r = t.id
          , o = t.groupId;
        let a = t.url;
        if (e)
          try {
            a = e.addDirectives(a)
          } catch (n) {
            this.warn(`Could not construct new URL with HLS Delivery Directives: ${n}`)
          }
        this.log(`loading audio-track playlist ${r} "${t.name}" lang:${t.lang} group:${o}`),
          this.clearTimer(),
          this.hls.trigger(Bit.AUDIO_TRACK_LOADING, {
            url: a,
            id: r,
            groupId: o,
            deliveryDirectives: e || null
          })
      }
    }
  }
  ,
  emeController: Eft,
  cmcdController: Rft,
  contentSteeringController: class {
    constructor(e) {
      this.hls = void 0,
        this.log = void 0,
        this.loader = null,
        this.uri = null,
        this.pathwayId = ".",
        this.pathwayPriority = null,
        this.timeToLoad = 300,
        this.reloadTimer = -1,
        this.updated = 0,
        this.started = !1,
        this.enabled = !0,
        this.levels = null,
        this.audioTracks = null,
        this.subtitleTracks = null,
        this.penalizedPathways = {},
        this.hls = e,
        this.log = Hit.log.bind(Hit, "[content-steering]:"),
        this.registerListeners()
    }
    registerListeners() {
      const e = this.hls;
      e.on(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(Bit.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(Bit.ERROR, this.onError, this)
    }
    unregisterListeners() {
      const e = this.hls;
      e && (e.off(Bit.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(Bit.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(Bit.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(Bit.ERROR, this.onError, this))
    }
    startLoad() {
      if (this.started = !0,
        self.clearTimeout(this.reloadTimer),
      this.enabled && this.uri)
        if (this.updated) {
          const e = Math.max(1e3 * this.timeToLoad - (performance.now() - this.updated), 0);
          this.scheduleRefresh(this.uri, e)
        } else
          this.loadSteeringManifest(this.uri)
    }
    stopLoad() {
      this.started = !1,
      this.loader && (this.loader.destroy(),
        this.loader = null),
        self.clearTimeout(this.reloadTimer)
    }
    destroy() {
      this.unregisterListeners(),
        this.stopLoad(),
        this.hls = null,
        this.levels = this.audioTracks = this.subtitleTracks = null
    }
    removeLevel(e) {
      const t = this.levels;
      t && (this.levels = t.filter((t=>t !== e)))
    }
    onManifestLoading() {
      this.stopLoad(),
        this.enabled = !0,
        this.timeToLoad = 300,
        this.updated = 0,
        this.uri = null,
        this.pathwayId = ".",
        this.levels = this.audioTracks = this.subtitleTracks = null
    }
    onManifestLoaded(e, t) {
      const {contentSteering: n} = t;
      null !== n && (this.pathwayId = n.pathwayId,
        this.uri = n.uri,
      this.started && this.startLoad())
    }
    onManifestParsed(e, t) {
      this.audioTracks = t.audioTracks,
        this.subtitleTracks = t.subtitleTracks
    }
    onError(e, t) {
      const {errorAction: n} = t;
      if ((null == n ? void 0 : n.action) === hut && n.flags === mut) {
        let e = this.pathwayPriority;
        const t = this.pathwayId;
        this.penalizedPathways[t] || (this.penalizedPathways[t] = performance.now()),
        !e && this.levels && (e = this.levels.reduce(((e,t)=>(-1 === e.indexOf(t.pathwayId) && e.push(t.pathwayId),
          e)), [])),
        e && e.length > 1 && (this.updatePathwayPriority(e),
          n.resolved = this.pathwayId !== t)
      }
    }
    filterParsedLevels(e) {
      this.levels = e;
      let t = this.getLevelsForPathway(this.pathwayId);
      if (0 === t.length) {
        const n = e[0].pathwayId;
        this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${n}"`),
          t = this.getLevelsForPathway(n),
          this.pathwayId = n
      }
      return t.length !== e.length ? (this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`),
        t) : e
    }
    getLevelsForPathway(e) {
      return null === this.levels ? [] : this.levels.filter((t=>e === t.pathwayId))
    }
    updatePathwayPriority(e) {
      let t;
      this.pathwayPriority = e;
      const n = this.penalizedPathways
        , r = performance.now();
      Object.keys(n).forEach((e=>{
          r - n[e] > 3e5 && delete n[e]
        }
      ));
      for (let o = 0; o < e.length; o++) {
        const r = e[o];
        if (n[r])
          continue;
        if (r === this.pathwayId)
          return;
        const a = this.hls.nextLoadLevel
          , i = this.hls.levels[a];
        if (t = this.getLevelsForPathway(r),
        t.length > 0) {
          this.log(`Setting Pathway to "${r}"`),
            this.pathwayId = r,
            this.hls.trigger(Bit.LEVELS_UPDATED, {
              levels: t
            });
          const e = this.hls.levels[a];
          i && e && this.levels && (e.attrs["STABLE-VARIANT-ID"] !== i.attrs["STABLE-VARIANT-ID"] && e.bitrate !== i.bitrate && this.log(`Unstable Pathways change from bitrate ${i.bitrate} to ${e.bitrate}`),
            this.hls.nextLoadLevel = a);
          break
        }
      }
    }
    clonePathways(e) {
      const t = this.levels;
      if (!t)
        return;
      const n = {}
        , r = {};
      e.forEach((e=>{
          const {ID: o, "BASE-ID": a, "URI-REPLACEMENT": i} = e;
          if (t.some((e=>e.pathwayId === o)))
            return;
          const s = this.getLevelsForPathway(a).map((e=>{
              const t = Pit({}, e);
              t.details = void 0,
                t.url = Ift(e.uri, e.attrs["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", i);
              const a = new Wit(e.attrs);
              a["PATHWAY-ID"] = o;
              const s = a.AUDIO && `${a.AUDIO}_clone_${o}`
                , l = a.SUBTITLES && `${a.SUBTITLES}_clone_${o}`;
              s && (n[a.AUDIO] = s,
                a.AUDIO = s),
              l && (r[a.SUBTITLES] = l,
                a.SUBTITLES = l),
                t.attrs = a;
              const u = new Xlt(t);
              return Eut(u, "audio", s),
                Eut(u, "text", l),
                u
            }
          ));
          t.push(...s),
            Lft(this.audioTracks, n, i, o),
            Lft(this.subtitleTracks, r, i, o)
        }
      ))
    }
    loadSteeringManifest(e) {
      const t = this.hls.config
        , n = t.loader;
      let r;
      this.loader && this.loader.destroy(),
        this.loader = new n(t);
      try {
        r = new self.URL(e)
      } catch (u) {
        return this.enabled = !1,
          void this.log(`Failed to parse Steering Manifest URI: ${e}`)
      }
      if ("data:" !== r.protocol) {
        const e = 0 | (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate);
        r.searchParams.set("_HLS_pathway", this.pathwayId),
          r.searchParams.set("_HLS_throughput", "" + e)
      }
      const o = {
        responseType: "json",
        url: r.href
      }
        , a = t.steeringManifestLoadPolicy.default
        , i = a.errorRetry || a.timeoutRetry || {}
        , s = {
        loadPolicy: a,
        timeout: a.maxLoadTimeMs,
        maxRetry: i.maxNumRetry || 0,
        retryDelay: i.retryDelayMs || 0,
        maxRetryDelay: i.maxRetryDelayMs || 0
      }
        , l = {
        onSuccess: (e,t,n,o)=>{
          this.log(`Loaded steering manifest: "${r}"`);
          const a = e.data;
          if (1 !== a.VERSION)
            return void this.log(`Steering VERSION ${a.VERSION} not supported!`);
          this.updated = performance.now(),
            this.timeToLoad = a.TTL;
          const {"RELOAD-URI": i, "PATHWAY-CLONES": s, "PATHWAY-PRIORITY": l} = a;
          if (i)
            try {
              this.uri = new self.URL(i,r).href
            } catch (u) {
              return this.enabled = !1,
                void this.log(`Failed to parse Steering Manifest RELOAD-URI: ${i}`)
            }
          this.scheduleRefresh(this.uri || n.url),
          s && this.clonePathways(s),
          l && this.updatePathwayPriority(l)
        }
        ,
        onError: (e,t,n,r)=>{
          if (this.log(`Error loading steering manifest: ${e.code} ${e.text} (${t.url})`),
            this.stopLoad(),
          410 === e.code)
            return this.enabled = !1,
              void this.log(`Steering manifest ${t.url} no longer available`);
          let o = 1e3 * this.timeToLoad;
          if (429 !== e.code)
            this.scheduleRefresh(this.uri || t.url, o);
          else {
            const e = this.loader;
            if ("function" == typeof (null == e ? void 0 : e.getResponseHeader)) {
              const t = e.getResponseHeader("Retry-After");
              t && (o = 1e3 * parseFloat(t))
            }
            this.log(`Steering manifest ${t.url} rate limited`)
          }
        }
        ,
        onTimeout: (e,t,n)=>{
          this.log(`Timeout loading steering manifest (${t.url})`),
            this.scheduleRefresh(this.uri || t.url)
        }
      };
      this.log(`Requesting steering manifest: ${r}`),
        this.loader.load(o, s, l)
    }
    scheduleRefresh(e, t=1e3 * this.timeToLoad) {
      self.clearTimeout(this.reloadTimer),
        this.reloadTimer = self.setTimeout((()=>{
            this.loadSteeringManifest(e)
          }
        ), t)
    }
  }
});
function Hft(e) {
  return e && "object" == typeof e ? Array.isArray(e) ? e.map(Hft) : Object.keys(e).reduce(((t,n)=>(t[n] = Hft(e[n]),
    t)), {}) : e
}
function zft(e) {
  const t = e.loader;
  if (t !== Nft && t !== Fft)
    Hit.log("[config]: Custom loader detected, cannot enable progressive streaming"),
      e.progressive = !1;
  else {
    (function() {
        if (self.fetch && self.AbortController && self.ReadableStream && self.Request)
          try {
            return new self.ReadableStream({}),
              !0
          } catch (Y_) {}
        return !1
      }
    )() && (e.loader = Nft,
      e.progressive = !0,
      e.enableSoftwareAES = !0,
      Hit.log("[config]: Progressive streaming enabled, using FetchLoader"))
  }
}
class Kft {
  static get version() {
    return "1.4.10"
  }
  static isSupported() {
    return function() {
      const e = ilt();
      if (!e)
        return !1;
      const t = dct()
        , n = e && "function" == typeof e.isTypeSupported && e.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"')
        , r = !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove;
      return !!n && !!r
    }()
  }
  static get Events() {
    return Bit
  }
  static get ErrorTypes() {
    return Nit
  }
  static get ErrorDetails() {
    return Mit
  }
  static get DefaultConfig() {
    return Kft.defaultConfig ? Kft.defaultConfig : $ft
  }
  static set DefaultConfig(e) {
    Kft.defaultConfig = e
  }
  constructor(e={}) {
    this.config = void 0,
      this.userConfig = void 0,
      this.coreComponents = void 0,
      this.networkControllers = void 0,
      this._emitter = new pdt,
      this._autoLevelCapping = void 0,
      this._maxHdcpLevel = null,
      this.abrController = void 0,
      this.bufferController = void 0,
      this.capLevelController = void 0,
      this.latencyController = void 0,
      this.levelController = void 0,
      this.streamController = void 0,
      this.audioTrackController = void 0,
      this.subtitleTrackController = void 0,
      this.emeController = void 0,
      this.cmcdController = void 0,
      this._media = null,
      this.url = null,
      function(e, t) {
        if (self.console && !0 === e || "object" == typeof e) {
          $it(e, "debug", "log", "info", "warn", "error");
          try {
            Uit.log(`Debug logs enabled for "${t}" in hls.js version 1.4.10`)
          } catch (Y_) {
            Uit = Vit
          }
        } else
          Uit = Vit
      }(e.debug || !1, "Hls instance");
    const t = this.config = function(e, t) {
      if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration))
        throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
      if (void 0 !== t.liveMaxLatencyDurationCount && (void 0 === t.liveSyncDurationCount || t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount))
        throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
      if (void 0 !== t.liveMaxLatencyDuration && (void 0 === t.liveSyncDuration || t.liveMaxLatencyDuration <= t.liveSyncDuration))
        throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
      const n = Hft(e)
        , r = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
      return ["manifest", "level", "frag"].forEach((e=>{
          const o = `${"level" === e ? "playlist" : e}LoadPolicy`
            , a = void 0 === t[o]
            , i = [];
          r.forEach((r=>{
              const s = `${e}Loading${r}`
                , l = t[s];
              if (void 0 !== l && a) {
                i.push(s);
                const e = n[o].default;
                switch (t[o] = {
                  default: e
                },
                  r) {
                  case "TimeOut":
                    e.maxLoadTimeMs = l,
                      e.maxTimeToFirstByteMs = l;
                    break;
                  case "MaxRetry":
                    e.errorRetry.maxNumRetry = l,
                      e.timeoutRetry.maxNumRetry = l;
                    break;
                  case "RetryDelay":
                    e.errorRetry.retryDelayMs = l,
                      e.timeoutRetry.retryDelayMs = l;
                    break;
                  case "MaxRetryTimeout":
                    e.errorRetry.maxRetryDelayMs = l,
                      e.timeoutRetry.maxRetryDelayMs = l
                }
              }
            }
          )),
          i.length && Hit.warn(`hls.js config: "${i.join('", "')}" setting(s) are deprecated, use "${o}": ${JSON.stringify(t[o])}`)
        }
      )),
        Lit(Lit({}, n), t)
    }(Kft.DefaultConfig, e);
    this.userConfig = e,
      this._autoLevelCapping = -1,
    t.progressive && zft(t);
    const {abrController: n, bufferController: r, capLevelController: o, errorController: a, fpsController: i} = t
      , s = new a(this)
      , l = this.abrController = new n(this)
      , u = this.bufferController = new r(this)
      , c = this.capLevelController = new o(this)
      , d = new i(this)
      , f = new Llt(this)
      , p = new Hlt(this)
      , h = t.contentSteeringController
      , v = h ? new h(this) : null
      , g = this.levelController = new Sut(this,v)
      , m = new Out(this)
      , y = new Nut(this.config)
      , b = this.streamController = new mdt(this,m,y);
    c.setStreamController(b),
      d.setStreamController(b);
    const w = [f, g, b];
    v && w.splice(1, 0, v),
      this.networkControllers = w;
    const x = [l, u, c, d, p, m];
    this.audioTrackController = this.createController(t.audioTrackController, w);
    const S = t.audioStreamController;
    S && w.push(new S(this,m,y)),
      this.subtitleTrackController = this.createController(t.subtitleTrackController, w);
    const E = t.subtitleStreamController;
    E && w.push(new E(this,m,y)),
      this.createController(t.timelineController, x),
      y.emeController = this.emeController = this.createController(t.emeController, x),
      this.cmcdController = this.createController(t.cmcdController, x),
      this.latencyController = this.createController(zlt, x),
      this.coreComponents = x,
      w.push(s);
    const A = s.onErrorOut;
    "function" == typeof A && this.on(Bit.ERROR, A, s)
  }
  createController(e, t) {
    if (e) {
      const n = new e(this);
      return t && t.push(n),
        n
    }
    return null
  }
  on(e, t, n=this) {
    this._emitter.on(e, t, n)
  }
  once(e, t, n=this) {
    this._emitter.once(e, t, n)
  }
  removeAllListeners(e) {
    this._emitter.removeAllListeners(e)
  }
  off(e, t, n=this, r) {
    this._emitter.off(e, t, n, r)
  }
  listeners(e) {
    return this._emitter.listeners(e)
  }
  emit(e, t, n) {
    return this._emitter.emit(e, t, n)
  }
  trigger(e, t) {
    if (this.config.debug)
      return this.emit(e, e, t);
    try {
      return this.emit(e, e, t)
    } catch (Y_) {
      Hit.error("An internal error happened while handling event " + e + '. Error message: "' + Y_.message + '". Here is a stacktrace:', Y_),
        this.trigger(Bit.ERROR, {
          type: Nit.OTHER_ERROR,
          details: Mit.INTERNAL_EXCEPTION,
          fatal: !1,
          event: e,
          error: Y_
        })
    }
    return !1
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e)
  }
  destroy() {
    Hit.log("destroy"),
      this.trigger(Bit.DESTROYING, void 0),
      this.detachMedia(),
      this.removeAllListeners(),
      this._autoLevelCapping = -1,
      this.url = null,
      this.networkControllers.forEach((e=>e.destroy())),
      this.networkControllers.length = 0,
      this.coreComponents.forEach((e=>e.destroy())),
      this.coreComponents.length = 0;
    const e = this.config;
    e.xhrSetup = e.fetchSetup = void 0,
      this.userConfig = null
  }
  attachMedia(e) {
    Hit.log("attachMedia"),
      this._media = e,
      this.trigger(Bit.MEDIA_ATTACHING, {
        media: e
      })
  }
  detachMedia() {
    Hit.log("detachMedia"),
      this.trigger(Bit.MEDIA_DETACHING, void 0),
      this._media = null
  }
  loadSource(e) {
    this.stopLoad();
    const t = this.media
      , n = this.url
      , r = this.url = _it.buildAbsoluteURL(self.location.href, e, {
      alwaysNormalize: !0
    });
    Hit.log(`loadSource:${r}`),
    t && n && (n !== r || this.bufferController.hasSourceTypes()) && (this.detachMedia(),
      this.attachMedia(t)),
      this.trigger(Bit.MANIFEST_LOADING, {
        url: e
      })
  }
  startLoad(e=-1) {
    Hit.log(`startLoad(${e})`),
      this.networkControllers.forEach((t=>{
          t.startLoad(e)
        }
      ))
  }
  stopLoad() {
    Hit.log("stopLoad"),
      this.networkControllers.forEach((e=>{
          e.stopLoad()
        }
      ))
  }
  swapAudioCodec() {
    Hit.log("swapAudioCodec"),
      this.streamController.swapAudioCodec()
  }
  recoverMediaError() {
    Hit.log("recoverMediaError");
    const e = this._media;
    this.detachMedia(),
    e && this.attachMedia(e)
  }
  removeLevel(e, t=0) {
    this.levelController.removeLevel(e, t)
  }
  get levels() {
    const e = this.levelController.levels;
    return e || []
  }
  get currentLevel() {
    return this.streamController.currentLevel
  }
  set currentLevel(e) {
    Hit.log(`set currentLevel:${e}`),
      this.loadLevel = e,
      this.abrController.clearTimer(),
      this.streamController.immediateLevelSwitch()
  }
  get nextLevel() {
    return this.streamController.nextLevel
  }
  set nextLevel(e) {
    Hit.log(`set nextLevel:${e}`),
      this.levelController.manualLevel = e,
      this.streamController.nextLevelSwitch()
  }
  get loadLevel() {
    return this.levelController.level
  }
  set loadLevel(e) {
    Hit.log(`set loadLevel:${e}`),
      this.levelController.manualLevel = e
  }
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel
  }
  set nextLoadLevel(e) {
    this.levelController.nextLoadLevel = e
  }
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel)
  }
  set firstLevel(e) {
    Hit.log(`set firstLevel:${e}`),
      this.levelController.firstLevel = e
  }
  get startLevel() {
    return this.levelController.startLevel
  }
  set startLevel(e) {
    Hit.log(`set startLevel:${e}`),
    -1 !== e && (e = Math.max(e, this.minAutoLevel)),
      this.levelController.startLevel = e
  }
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize
  }
  set capLevelToPlayerSize(e) {
    const t = !!e;
    t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(),
      this.autoLevelCapping = -1,
      this.streamController.nextLevelSwitch()),
      this.config.capLevelToPlayerSize = t)
  }
  get autoLevelCapping() {
    return this._autoLevelCapping
  }
  get bandwidthEstimate() {
    const {bwEstimator: e} = this.abrController;
    return e ? e.getEstimate() : NaN
  }
  get ttfbEstimate() {
    const {bwEstimator: e} = this.abrController;
    return e ? e.getEstimateTTFB() : NaN
  }
  set autoLevelCapping(e) {
    this._autoLevelCapping !== e && (Hit.log(`set autoLevelCapping:${e}`),
      this._autoLevelCapping = e)
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel
  }
  set maxHdcpLevel(e) {
    Klt.indexOf(e) > -1 && (this._maxHdcpLevel = e)
  }
  get autoLevelEnabled() {
    return -1 === this.levelController.manualLevel
  }
  get manualLevel() {
    return this.levelController.manualLevel
  }
  get minAutoLevel() {
    const {levels: e, config: {minAutoBitrate: t}} = this;
    if (!e)
      return 0;
    const n = e.length;
    for (let r = 0; r < n; r++)
      if (e[r].maxBitrate >= t)
        return r;
    return 0
  }
  get maxAutoLevel() {
    const {levels: e, autoLevelCapping: t, maxHdcpLevel: n} = this;
    let r;
    if (r = -1 === t && e && e.length ? e.length - 1 : t,
      n)
      for (let o = r; o--; ) {
        const t = e[o].attrs["HDCP-LEVEL"];
        if (t && t <= n)
          return o
      }
    return r
  }
  get nextAutoLevel() {
    return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
  }
  set nextAutoLevel(e) {
    this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e)
  }
  get playingDate() {
    return this.streamController.currentProgramDateTime
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo()
  }
  get audioTracks() {
    const e = this.audioTrackController;
    return e ? e.audioTracks : []
  }
  get audioTrack() {
    const e = this.audioTrackController;
    return e ? e.audioTrack : -1
  }
  set audioTrack(e) {
    const t = this.audioTrackController;
    t && (t.audioTrack = e)
  }
  get subtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTracks : []
  }
  get subtitleTrack() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTrack : -1
  }
  get media() {
    return this._media
  }
  set subtitleTrack(e) {
    const t = this.subtitleTrackController;
    t && (t.subtitleTrack = e)
  }
  get subtitleDisplay() {
    const e = this.subtitleTrackController;
    return !!e && e.subtitleDisplay
  }
  set subtitleDisplay(e) {
    const t = this.subtitleTrackController;
    t && (t.subtitleDisplay = e)
  }
  get lowLatencyMode() {
    return this.config.lowLatencyMode
  }
  set lowLatencyMode(e) {
    this.config.lowLatencyMode = e
  }
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition
  }
  get latency() {
    return this.latencyController.latency
  }
  get maxLatency() {
    return this.latencyController.maxLatency
  }
  get targetLatency() {
    return this.latencyController.targetLatency
  }
  get drift() {
    return this.latencyController.drift
  }
  get forceStartLoad() {
    return this.streamController.forceStartLoad
  }
}
Kft.defaultConfig = void 0;
const Wft = {
  name: "d-icon"
}
  , Gft = AQ(Object.assign(Wft, {
  props: {
    icon: String,
    size: [Number, String]
  },
  setup(e) {
    const t = e
      , n = yi((()=>({
      fontSize: /^\d+$/.test(t.size) ? t.size + "px" : t.size
    })));
    return (t,r)=>(Ca(),
      _a("i", {
        class: Y(["d-icon iconfont", e.icon]),
        style: z(n.value)
      }, null, 6))
  }
}), [["__scopeId", "data-v-50238f2c"]])
  , qft = {
  class: "d-player-top"
}
  , Yft = {
  class: "top-title"
}
  , Xft = {
  class: "top-title"
}
  , Qft = {
  __name: "d-player-top",
  props: {
    title: {
      default: ""
    }
  },
  setup(e) {
    Date.prototype.format = function(e) {
      let t = {
        "h+": this.getHours(),
        "m+": this.getMinutes(),
        "s+": this.getSeconds()
      };
      for (var n in t)
        new RegExp("(" + n + ")").test(e) && (e = e.replace(RegExp.$1, 1 == RegExp.$1.length ? t[n] : ("00" + t[n]).substr(("" + t[n]).length)));
      return e
    }
    ;
    let t = Ft("00:00:00");
    t.value = (new Date).format("hh:mm:ss");
    let n = null;
    return n = setInterval((()=>{
        t.value = (new Date).format("hh:mm:ss")
      }
    ), 1e3),
      Br((()=>{
          clearInterval(n)
        }
      )),
      (n,r)=>(Ca(),
        _a("div", qft, [Ma("p", Yft, te(e.title || ""), 1), Ma("p", Xft, te(Vt(t)), 1)]))
  }
}
  , Jft = AQ(Qft, [["__scopeId", "data-v-05a662dc"]])
  , Zft = {
  class: "d-status"
}
  , ept = {
  class: "d-flex-center"
}
  , tpt = {
  class: "d-flex-center"
}
  , npt = AQ(vr({
  __name: "d-status",
  props: ["state"],
  setup: e=>(t,n)=>rr((Ca(),
    _a("div", Zft, [rr(Ma("li", ept, [ja(Gft, {
      size: "18",
      class: "d-status-icon",
      icon: "icon-volume-" + (0 == e.state.volume ? "mute" : e.state.volume > .5 ? "up" : "down")
    }, null, 8, ["icon"]), $a(" " + te(~~(100 * e.state.volume)) + "% ", 1)], 512), [[$s, "volume" == e.state.handleType]]), rr(Ma("li", tpt, [ja(Gft, {
      size: "12",
      icon: "icon-play"
    }), ja(Gft, {
      size: "12",
      icon: "icon-play",
      style: {
        "margin-right": "5px"
      }
    }), $a("5X速播放中 ")], 512), [[$s, "playbackRate" == e.state.handleType || e.state.isMultiplesPlay]])], 512)), [[$s, e.state.handleType || e.state.isMultiplesPlay]])
}), [["__scopeId", "data-v-07b06c9c"]])
  , rpt = e=>(Ln("data-v-bfc4b33d"),
  e = e(),
  In(),
  e)
  , opt = ["checked", "true-value", "false-value"]
  , apt = rpt((()=>Ma("span", {
  class: "d-switch_action"
}, null, -1)))
  , ipt = AQ(vr({
  __name: "d-switch",
  props: {
    modelValue: {
      type: [Number, String, Boolean]
    },
    width: {
      type: String,
      default: "40px"
    },
    trueValue: {
      type: [Number, String, Boolean],
      default: !0
    },
    falseValue: {
      type: [Number, String, Boolean],
      default: !0
    },
    activeColor: {
      type: [String],
      default: "#409EFF"
    }
  },
  emits: ["update:modelValue", "change"],
  setup(e, {emit: t}) {
    const n = e;
    Yi((t=>({
      c962cece: e.width,
      d2b616e0: e.activeColor
    })));
    const r = Ft(null)
      , o = yi((()=>n.modelValue === n.trueValue))
      , a = ()=>{
        hn((()=>{
            const e = r.value.checked;
            t("update:modelValue", e),
              t("change", e)
          }
        ))
      }
    ;
    return (t,n)=>(Ca(),
      _a("div", {
        class: Y(["d-switch", {
          "is-checked": o.value
        }])
      }, [Ma("input", {
        class: "d-switch__input",
        ref_key: "input",
        ref: r,
        type: "checkbox",
        checked: o.value,
        onChange: a,
        "true-value": e.trueValue,
        "false-value": e.falseValue
      }, null, 40, opt), apt], 2))
  }
}), [["__scopeId", "data-v-bfc4b33d"]])
  , spt = e=>(Ln("data-v-e57d328d"),
  e = e(),
  In(),
  e)
  , lpt = {
  key: 0
}
  , upt = spt((()=>Ma("i", {
  class: "rotating iconfont icon-loading f50"
}, null, -1)))
  , cpt = [spt((()=>Ma("i", {
  class: "rotating iconfont icon-loading f50"
}, null, -1))), spt((()=>Ma("p", null, "正在缓冲...", -1)))]
  , dpt = spt((()=>Ma("i", {
  class: "iconfont icon-replay f24 mr5"
}, null, -1)))
  , fpt = AQ(vr({
  __name: "d-loading",
  props: {
    loadType: String,
    text: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const t = e
      , {proxy: n} = ei()
      , r = ["loadstart", "waiting", "ended", "error", "stalled"]
      , o = ()=>{
      n.$parent.play()
    }
      , a = yi((()=>{
        let e = "background: rgba(0, 0, 0, .1);z-index:1";
        return "loadstart" == t.loadType && (e = "background: rgba(0, 0, 0, 1);;z-index:3"),
          e
      }
    ));
    return (t,n)=>rr((Ca(),
      _a("div", {
        class: "d-loading",
        style: z(a.value)
      }, [Ma("div", null, ["loadstart" == e.loadType ? (Ca(),
        _a("span", lpt, [upt, Ma("p", null, te(e.text), 1)])) : za("", !0), rr(Ma("span", null, cpt, 512), [[$s, "waiting" == e.loadType]]), rr(Ma("span", null, [Ma("p", {
        onClick: o,
        class: "d-flex-x d-pointer"
      }, [dpt, $a("重新播放 ")])], 512), [[$s, "ended" == e.loadType]]), rr(Ma("span", null, [Ma("p", {
        onClick: o,
        class: "d-flex-x d-pointer"
      })], 512), [[$s, "error" == e.loadType || "stalled" == e.loadType]])])], 4)), [[$s, r.includes(e.loadType)]])
  }
}), [["__scopeId", "data-v-e57d328d"]])
  , ppt = function(e, t, n, r=!1) {
  e && t && n && e.addEventListener(t, n, r)
}
  , hpt = function(e, t, n, r=!1) {
  e && t && n && e.removeEventListener(t, n, r)
}
  , vpt = ["onMousedown"]
  , gpt = AQ(vr({
  name: "DSlider",
  props: {
    modelValue: {
      required: !0,
      type: Number,
      default: 0
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    vertical: {
      type: Boolean,
      default: !1
    },
    hover: {
      type: Boolean,
      default: !0
    },
    hoverText: {
      type: String,
      default: ""
    },
    preload: {
      type: Number,
      default: 0
    },
    size: {
      type: String,
      default: "10px"
    }
  },
  emits: ["update:modelValue", "change", "onMousemove"],
  setup(e, {emit: t}) {
    const n = e;
    Yi((t=>({
      "33237a2c": e.size
    })));
    const r = Ft(null)
      , o = Ft(null)
      , a = bt({
        dragging: !1,
        hoverPosition: 0,
        hoverTipsLeft: "50%"
      })
      , i = yi((()=>{
          let e = n.modelValue < 0 ? 0 : n.modelValue > 1 ? 1 : n.modelValue;
          return n.vertical ? `height:${100 * e}%` : `width:${100 * e}%`
        }
      ))
      , s = yi((()=>{
          let e = n.preload < 0 ? 0 : n.preload > 1 ? 1 : n.preload;
          return n.vertical ? `height:${100 * e}%` : `width:${100 * e}%`
        }
      ))
      , l = yi((()=>{
          let e = a.hoverPosition < 0 ? 0 : a.hoverPosition > 1 ? 1 : a.hoverPosition;
          return n.vertical ? `bottom:${100 * e}%` : `left:${100 * e}%`
        }
      ))
      , u = e=>{
        e.preventDefault()
      }
      , c = e=>{
        n.disabled || (e.preventDefault(),
          a.dragging = !0,
          f(e),
          ppt(window, "mousemove", h),
          ppt(window, "touchmove", h),
          ppt(window, "mouseup", v),
          ppt(window, "touchend", v))
      }
      , d = e=>{
        if (!n.hover)
          return;
        let i = p(e);
        if (t("onMousemove", e, i),
          a.hoverPosition = i,
          n.vertical)
          return;
        let s = r.value
          , l = o.value.clientWidth / 2
          , u = e.clientX - s.getBoundingClientRect().left;
        u < l ? a.hoverTipsLeft = l - u + "px" : s.clientWidth - u < l ? a.hoverTipsLeft = s.clientWidth - u - l + "px" : a.hoverTipsLeft = "50%"
      }
      , f = e=>{
        let n = p(e);
        t("update:modelValue", n),
          t("change", e, n)
      }
      , p = e=>{
        let t = r.value
          , o = 0;
        if (n.vertical) {
          let n = t.clientHeight;
          o = (t.getBoundingClientRect().bottom - e.clientY) / n
        } else
          o = (e.clientX - t.getBoundingClientRect().left) / t.clientWidth;
        return o < 0 ? 0 : o > 1 ? 1 : o
      }
      , h = e=>{
        f(e)
      }
      , v = e=>{
        a.dragging && (hpt(window, "mousemove", h),
          hpt(window, "touchmove", h),
          hpt(window, "mouseup", v),
          hpt(window, "touchend", v),
          hpt(window, "contextmenu", v),
          setTimeout((()=>{
              a.dragging = !1
            }
          ), 0))
      }
    ;
    return (e,t)=>(Ca(),
      _a("div", {
        ref_key: "refSlider",
        ref: r,
        class: Y(["d-slider", {
          "is-vertical": n.vertical
        }]),
        onMousedown: js(c, ["stop"]),
        onContextmenu: u
      }, [Ma("div", {
        class: "d-slider__runway",
        onMousemove: d
      }, [rr(Ma("div", {
        class: "d-slider__cursor",
        style: z(l.value)
      }, [rr(Ma("div", {
        class: "d-slider__tips",
        ref_key: "refTips",
        ref: o,
        style: z({
          left: a.hoverTipsLeft
        })
      }, te(n.hoverText), 5), [[$s, n.hoverText]])], 4), [[$s, n.hover]]), Ma("div", {
        class: "d-slider__preload",
        style: z(s.value)
      }, null, 4), Ma("div", {
        class: "d-slider__bar",
        style: z(i.value)
      }, null, 4)], 32)], 42, vpt))
  }
}), [["__scopeId", "data-v-881ecf40"]])
  , mpt = ()=>({
  downloadFile: (e,t)=>{
    MW({
      type: "warning",
      message: "视频下载中"
    });
    let n = e.substring(e.lastIndexOf("."));
    qq({
      method: "get",
      url: e,
      responseType: "blob",
      onDownloadProgress(e) {
        (t = t || {}).onDownloadProgress && t.onDownloadProgress(e)
      }
    }).then((e=>{
        if (!e)
          return;
        let r = (t = t || {}).fileName || (new Date).getTime()
          , o = window.URL.createObjectURL(e.data)
          , a = document.createElement("a");
        document.body.appendChild(a),
          a.style.display = "none",
          a.href = o,
          a.download = r + n,
          a.click(),
          document.body.removeChild(a),
          window.URL.revokeObjectURL(o),
          MW({
            type: "success",
            message: "视频下载成功"
          })
      }
    ))
  }
})
  , ypt = e=>{
  let t = ~~(e / 3600)
    , n = ~~(e % 3600 / 60)
    , r = ~~(e % 60);
  return t = t < 10 ? "0" + t : t,
    n = n < 10 ? "0" + n : n,
    r = r < 10 ? "0" + r : r,
    `${t}:${n}:${r}`
}
  , bpt = !!("ontouchstart"in window)
  , wpt = ["loadstart", "play", "pause", "playing", "seeking", "seeked", "waiting", "durationchange", "progress", "canplay", "timeupdate", "ended", "error", "stalled"]
  , xpt = {
  width: {
    type: String,
    default: "800px"
  },
  height: {
    type: String,
    default: "450px"
  },
  color: {
    type: String,
    default: "#409eff"
  },
  src: {
    required: !0,
    type: String,
    default: ""
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    default: "video/mp4"
  },
  poster: {
    type: String,
    default: ""
  },
  webFullScreen: {
    type: Boolean,
    default: !1
  },
  speed: {
    type: Boolean,
    default: !0
  },
  currentTime: {
    type: Number,
    default: 0
  },
  playsinline: {
    type: Boolean,
    default: !1
  },
  muted: {
    type: Boolean,
    default: !1
  },
  speedRate: {
    type: Array,
    default: ()=>["2.0", "1.5", "1.25", "1.0", "0.75", "0.5"]
  },
  autoPlay: {
    type: Boolean,
    default: !1
  },
  loop: {
    type: Boolean,
    default: !1
  },
  mirror: {
    type: Boolean,
    default: !1
  },
  ligthOff: {
    type: Boolean,
    default: !1
  },
  volume: {
    type: [String, Number],
    default: .3
  },
  control: {
    type: Boolean,
    default: !0
  },
  controlBtns: {
    type: Array,
    default: ["audioTrack", "quality", "speedRate", "volume", "setting", "pip", "pageFullScreen", "fullScreen"]
  },
  preload: {
    type: String,
    default: "auto"
  }
}
  , Spt = e=>(Ln("data-v-b23a7076"),
  e = e(),
  In(),
  e)
  , Ept = {
  class: "d-player-video",
  id: "dPlayerVideo"
}
  , Apt = ["controls", "webkit-playsinline", "playsinline", "volume", "muted", "loop", "preload", "src", "poster"]
  , Cpt = {
  class: "d-player-lightoff"
}
  , kpt = {
  key: 1,
  class: "d-player-state"
}
  , Tpt = {
  class: "d-play-btn"
}
  , Dpt = ["onKeyup", "onKeydown"]
  , Opt = {
  class: "d-control-progress"
}
  , _pt = {
  class: "d-tool-bar"
}
  , Rpt = {
  key: 0,
  class: "d-tool-item d-tool-time audioTrack-btn"
}
  , Lpt = Spt((()=>Ma("span", {
  style: {
    margin: "0 3px"
  }
}, "/", -1)))
  , Ipt = {
  class: "total-time"
}
  , Ppt = {
  class: "d-tool-bar"
}
  , Fpt = {
  key: 0,
  class: "d-tool-item quality-btn"
}
  , Bpt = {
  class: "d-tool-item-main"
}
  , Npt = {
  class: "speed-main",
  style: {
    "text-align": "center"
  }
}
  , Mpt = ["onClick"]
  , jpt = {
  class: "d-tool-item-main"
}
  , Vpt = {
  key: 1,
  class: "d-tool-item speedRate-btn"
}
  , Upt = {
  class: "d-tool-item-main"
}
  , $pt = {
  class: "speed-main"
}
  , Hpt = ["onClick"]
  , zpt = {
  key: 2,
  class: "d-tool-item volume-btn"
}
  , Kpt = {
  class: "d-tool-item-main volume-box",
  style: {
    width: "52px"
  }
}
  , Wpt = {
  class: "volume-text-size"
}
  , Gpt = {
  key: 3,
  class: "d-tool-item setting-btn"
}
  , qpt = {
  class: "d-tool-item-main"
}
  , Ypt = {
  class: "speed-main"
}
  , Xpt = Spt((()=>Ma("div", {
  class: "d-tool-item-main"
}, "画中画", -1)))
  , Qpt = Spt((()=>Ma("div", {
  class: "d-tool-item-main"
}, "网页全屏", -1)))
  , Jpt = Spt((()=>Ma("div", {
  class: "d-tool-item-main"
}, "全屏", -1)))
  , Zpt = AQ(vr({
  name: "vue3VideoPlay",
  inheritAttrs: !1,
  props: xpt,
  emits: [...wpt, "mirrorChange", "loopChange", "lightOffChange"],
  setup(e, {expose: t, emit: n}) {
    const r = e;
    Yi((e=>({
      "53b94c45": Vt(v),
      "7738343a": e.width,
      "55ff5933": e.height
    })));
    const o = new Kft({
      fragLoadingTimeOut: 2e3
    })
      , a = mpt()
      , i = Ft(null)
      , s = Ft(null)
      , l = Ft(null)
      , u = Ft(null)
      , c = Ft(!1)
      , d = bt({
      dVideo: null,
      ...r,
      muted: r.muted,
      playBtnState: r.autoPlay ? "pause" : "play",
      loadStateType: "loadstart",
      fullScreen: !1,
      handleType: "",
      currentTime: "00:00:00",
      preloadBar: 0,
      totalTime: "00:00:00",
      isVideoHovering: !0,
      speedActive: "1.0",
      playProgress: 0,
      isMultiplesPlay: !1,
      longPressTimeout: null,
      progressCursorTime: "00:00:00",
      qualityLevels: [],
      currentLevel: 0
    })
      , f = (...e)=>t=>e.reverse().reduce(((e,t)=>t(e)), t)
      , p = wpt.reduce(((e,t)=>{
        var r;
        return e[`on${r = t,
        r.charAt(0).toUpperCase() + r.slice(1)}`] = e=>{
          d.loadStateType = t,
            n(t, e)
        }
          ,
          e
      }
    ), {});
    p.onCanplay = f(p.onCanplay, (()=>{
        "play" != d.playBtnState && d.dVideo.play(),
        d.autoPlay && (d.dVideo.play(),
          d.playBtnState = "pause")
      }
    )),
      p.onEnded = f(p.onEnded, (()=>{
          d.playBtnState = "replay"
        }
      )),
      p.onDurationchange = e=>{
        n("durationchange", e),
        0 != r.currentTime && (d.dVideo.currentTime = r.currentTime),
          p.onTimeupdate(e)
      }
      ,
      p.onProgress = e=>{
        console.log("缓冲中..."),
          n("progress", e);
        let t = e.target.duration
          , r = e.target.buffered
          , o = e.target.buffered.length && e.target.buffered.end(r - 1);
        d.preloadBar = o / t
      }
      ,
      p.onTimeupdate = e=>{
        n("timeupdate", e);
        let t = e.duration || e.target.duration || 0
          , r = e.currentTime || e.target.currentTime;
        d.playProgress = r / t,
          d.currentTime = ypt(r),
          d.totalTime = ypt(t)
      }
      ,
      p.onError = f(p.onError, (()=>{
          d.playBtnState = "replay"
        }
      ));
    let h = ho();
    for (let B in h)
      p[B] = h[B];
    const v = (g = d.color,
      `${parseInt("0x" + g.slice(1, 3))},${parseInt("0x" + g.slice(3, 5))},${parseInt("0x" + g.slice(5, 7))}`);
    var g;
    const m = Sit(500, (()=>{
          d.handleType = ""
        }
      ))
      , y = e=>{
        e.preventDefault(),
          "ArrowUp" == e.code ? d.volume = d.volume + .1 > 1 ? 1 : d.volume + .1 : d.volume = d.volume - .1 < 0 ? 0 : d.volume - .1,
          d.muted = !1,
          d.handleType = "volume",
          m()
      }
      , b = e=>{
        r.speed && (d.dVideo.currentTime = d.dVideo.currentTime < 10 ? .1 : d.dVideo.currentTime - 10,
          p.onTimeupdate(d.dVideo),
          E())
      }
      , w = e=>{
        e.preventDefault();
        let t = e.type;
        if ("ArrowRight" == e.key)
          if (E(),
          "keyup" == t) {
            if (clearTimeout(d.longPressTimeout),
            !r.speed && !d.longPressTimeout)
              return;
            d.isMultiplesPlay ? (d.dVideo.playbackRate = d.speedActive,
              d.isMultiplesPlay = !1) : (d.dVideo.currentTime = d.dVideo.currentTime + 10,
              p.onTimeupdate(d.dVideo))
          } else if ("keydown" == t) {
            if (!r.speed)
              return;
            d.isMultiplesPlay && clearTimeout(d.longPressTimeout),
              d.longPressTimeout = setTimeout((()=>{
                  d.isMultiplesPlay = !0,
                    d.dVideo.playbackRate = 5,
                    d.handleType = "playbackRate",
                    m()
                }
              ), 500)
          }
      }
      , x = ()=>{
        bpt || u.value.focus()
      }
      , S = ()=>{
        r.src && a.downloadFile(r.src, {
          onDownloadProgress(e) {
            c.value = e.loaded !== e.total
          }
        })
      }
      , E = ()=>{
        d.loadStateType = "play",
          d.dVideo.play().catch((()=>{
              setTimeout((()=>{
                  d.playBtnState = "replay",
                    d.loadStateType = "error"
                }
              ), 500)
            }
          )),
          d.playBtnState = "pause"
      }
      , A = ()=>{
        d.dVideo.pause(),
          d.playBtnState = "play"
      }
      , C = e=>{
        e && e.preventDefault(),
          "play" == d.playBtnState || "replay" == d.playBtnState ? E() : "pause" == d.playBtnState && A()
      }
      , k = ()=>{
        d.muted = !d.muted,
        0 == d.volume && (d.volume = .05)
      }
      , T = (e,t)=>{
        let n = d.dVideo.duration || d.dVideo.target.duration;
        d.dVideo.currentTime = n * t,
        "play" == d.playBtnState && (d.dVideo.play(),
          d.playBtnState = "pause")
      }
      , D = (e,t)=>{
        d.progressCursorTime = ypt(d.dVideo.duration * t)
      }
      , O = Sit(2500, (()=>{
          d.isVideoHovering = !1
        }
      ))
      , _ = e=>{
        d.isVideoHovering = !0,
          O()
      }
      , R = e=>{
        n("mirrorChange", e, d.dVideo)
      }
      , L = e=>{
        n("loopChange", e, d.dVideo)
      }
      , I = e=>{
        n("lightOffChange", e, d.dVideo)
      }
      , P = ()=>{
        var e;
        e = d.dVideo,
          document.pictureInPictureElement ? document.exitPictureInPicture().catch((e=>{
              console.log(e, "Video failed to leave Picture-in-Picture mode.")
            }
          )) : e.requestPictureInPicture().catch((e=>{
              console.log(e, "Video failed to enter Picture-in-Picture mode.")
            }
          ))
      }
      , F = ()=>{
        d.fullScreen = (e=>{
            let t = document
              , n = t.webkitIsFullScreen || t.fullscreen;
            n ? (document.exitFullscreen || t.webkitExitFullScreen).call(t) : (e.requestFullscreen || e.webkitRequestFullScreen).call(e);
            return !n
          }
        )(i.value)
      }
    ;
    return Jn((()=>r.src), (()=>{
        hn((()=>{
            d.dVideo.canPlayType(r.type) || d.dVideo.canPlayType("application/vnd.apple.mpegurl") ? d.muted = r.autoPlay : Kft.isSupported() && (o.detachMedia(),
              o.attachMedia(d.dVideo),
              o.on(Kft.Events.MEDIA_ATTACHED, (()=>{
                  o.loadSource(r.src),
                    o.on("hlsManifestParsed", ((e,t)=>{
                        console.log(t),
                          d.currentLevel = t.level,
                          d.qualityLevels = t.levels || []
                      }
                    ))
                }
              )),
              o.on("hlsLevelSwitching", ((e,t)=>{
                  console.log(t),
                    console.log("LEVEL_SWITCHING")
                }
              )),
              o.on("hlsLevelSwitched", ((e,t)=>{
                  d.currentLevel = t.level,
                    console.log("LEVEL_SWITCHED")
                }
              )))
          }
        ))
      }
    ), {
      immediate: !0
    }),
      Lr((()=>{
          d.dVideo = s,
            x()
        }
      )),
      t({
        play: E,
        pause: A,
        togglePlay: C
      }),
      (e,t)=>{
        const n = sS;
        return Ca(),
          _a("div", {
            ref_key: "refPlayerWrap",
            ref: i,
            id: "refPlayerWrap",
            class: Y(["d-player-wrap", {
              "web-full-screen": d.webFullScreen,
              "is-lightoff": d.lightOff,
              "d-player-wrap-hover": "play" == d.playBtnState || d.isVideoHovering
            }]),
            onMousemove: _
          }, [Ma("div", Ept, [Ma("video", qa({
            ref_key: "refdVideo",
            ref: s,
            class: ["d-player-video-main", {
              "video-mirror": d.mirror
            }],
            id: "dPlayerVideoMain",
            controls: !(!Vt(bpt) || !d.speed),
            "webkit-playsinline": r.playsinline,
            playsinline: r.playsinline
          }, Vt(p), {
            volume: d.volume,
            muted: d.muted,
            loop: d.loop,
            preload: e.preload,
            width: "100%",
            height: "100%",
            src: r.src,
            poster: r.poster
          }), "您的浏览器不支持Video标签。", 16, Apt)]), ja(es, {
            name: "d-fade-in"
          }, {
            default: Fn((()=>[rr(Ma("div", Cpt, null, 512), [[$s, d.lightOff]])])),
            _: 1
          }), d.fullScreen ? (Ca(),
            Ra(Jft, {
              key: 0,
              title: r.title
            }, null, 8, ["title"])) : za("", !0), Vt(bpt) ? za("", !0) : (Ca(),
            _a("div", kpt, [ja(es, {
              name: "d-scale-out"
            }, {
              default: Fn((()=>[rr(Ma("div", Tpt, [ja(Gft, {
                icon: "icon-play",
                size: 40
              })], 512), [[$s, "play" == d.playBtnState]])])),
              _: 1
            }), ja(npt, {
              state: d
            }, null, 8, ["state"])])), Vt(bpt) ? za("", !0) : (Ca(),
            _a("input", {
              key: 2,
              type: "input",
              readonly: "readonly",
              ref_key: "refInput",
              ref: u,
              onDblclick: F,
              onKeyup: [Us(F, ["f"]), t[0] || (t[0] = Us((e=>d.webFullScreen = !1), ["esc"])), w],
              onClick: C,
              onKeydown: [Us(C, ["space"]), Us(b, ["arrow-left"]), Us(y, ["arrow-up", "arrow-down"]), w],
              class: "d-player-input",
              maxlength: "0"
            }, null, 40, Dpt)), ja(fpt, {
            loadType: d.loadStateType
          }, null, 8, ["loadType"]), !Vt(bpt) && d.control ? (Ca(),
            _a("div", {
              key: 3,
              class: "d-player-control",
              ref_key: "refPlayerControl",
              ref: l
            }, [Ma("div", Opt, [ja(gpt, {
              class: "d-progress-bar",
              onOnMousemove: D,
              onChange: T,
              disabled: !d.speed,
              hoverText: d.progressCursorTime,
              modelValue: d.playProgress,
              "onUpdate:modelValue": t[1] || (t[1] = e=>d.playProgress = e),
              preload: d.preloadBar
            }, null, 8, ["disabled", "hoverText", "modelValue", "preload"])]), Ma("div", {
              class: "d-control-tool",
              onClick: x
            }, [Ma("div", _pt, [Ma("div", {
              class: "d-tool-item",
              onClick: C
            }, [ja(Gft, {
              size: "24",
              icon: `icon-${d.playBtnState}`
            }, null, 8, ["icon"])]), r.controlBtns.includes("audioTrack") ? (Ca(),
              _a("div", Rpt, [Ma("span", null, te(d.currentTime), 1), Lpt, Ma("span", Ipt, te(d.totalTime), 1)])) : za("", !0)]), Ma("div", Ppt, [d.qualityLevels.length && r.controlBtns.includes("quality") ? (Ca(),
              _a("div", Fpt, [$a(te(d.qualityLevels.length && (d.qualityLevels[d.currentLevel] || {}).height) + "P ", 1), Ma("div", Bpt, [Ma("ul", Npt, [(Ca(!0),
                _a(ba, null, Yr(d.qualityLevels, ((e,t)=>(Ca(),
                  _a("li", {
                    class: Y({
                      "speed-active": d.currentLevel == t
                    }),
                    onClick: e=>((e,t)=>{
                        o.currentLevel = t,
                          d.currentLevel = t
                      }
                    )(0, t),
                    key: e
                  }, te(e.height) + "P", 11, Mpt)))), 128))])])])) : za("", !0), Ma("div", {
              style: z({
                pointerEvents: c.value ? "none" : "auto"
              }),
              class: "d-tool-item fullScreen-btn",
              onClick: S
            }, [Ma("div", jpt, te(c.value ? "正在下载" : "视频下载"), 1), ja(n, {
              size: "20"
            }, {
              default: Fn((()=>[ja(Vt(Im))])),
              _: 1
            })], 4), r.controlBtns.includes("speedRate") ? (Ca(),
              _a("div", Vpt, [$a(te("1.0" == d.speedActive ? "倍速" : d.speedActive + "x") + " ", 1), Ma("div", Upt, [Ma("ul", $pt, [(Ca(!0),
                _a(ba, null, Yr(d.speedRate, (e=>(Ca(),
                  _a("li", {
                    class: Y({
                      "speed-active": d.speedActive == e
                    }),
                    onClick: t=>(e=>{
                        d.speedActive = e,
                          d.dVideo.playbackRate = e
                      }
                    )(e),
                    key: e
                  }, te(e) + "x", 11, Hpt)))), 128))])])])) : za("", !0), r.controlBtns.includes("volume") ? (Ca(),
              _a("div", zpt, [Ma("div", Kpt, [Ma("div", {
                class: Y(["volume-main", {
                  "is-muted": d.muted
                }])
              }, [Ma("span", Wpt, te(d.muted ? 0 : ~~(100 * d.volume)) + "%", 1), ja(gpt, {
                onChange: t[2] || (t[2] = e=>d.muted = !1),
                hover: !1,
                size: "5px",
                vertical: !0,
                modelValue: d.volume,
                "onUpdate:modelValue": t[3] || (t[3] = e=>d.volume = e)
              }, null, 8, ["modelValue"])], 2)]), Ma("span", {
                onClick: k,
                style: {
                  display: "flex"
                }
              }, [ja(Gft, {
                size: "20",
                icon: "icon-volume-" + (0 == d.volume || d.muted ? "mute" : d.volume > .5 ? "up" : "down")
              }, null, 8, ["icon"])])])) : za("", !0), r.controlBtns.includes("setting") ? (Ca(),
              _a("div", Gpt, [ja(Gft, {
                size: "20",
                class: "rotateHover",
                icon: "icon-settings"
              }), Ma("div", qpt, [Ma("ul", Ypt, [Ma("li", null, [$a(" 镜像画面 "), ja(ipt, {
                onChange: R,
                modelValue: d.mirror,
                "onUpdate:modelValue": t[4] || (t[4] = e=>d.mirror = e)
              }, null, 8, ["modelValue"])]), Ma("li", null, [$a(" 循环播放 "), ja(ipt, {
                onChange: L,
                modelValue: d.loop,
                "onUpdate:modelValue": t[5] || (t[5] = e=>d.loop = e)
              }, null, 8, ["modelValue"])]), Ma("li", null, [$a(" 关灯模式 "), ja(ipt, {
                onChange: I,
                modelValue: d.lightOff,
                "onUpdate:modelValue": t[6] || (t[6] = e=>d.lightOff = e)
              }, null, 8, ["modelValue"])])])])])) : za("", !0), r.controlBtns.includes("pip") ? (Ca(),
              _a("div", {
                key: 4,
                class: "d-tool-item pip-btn",
                onClick: P
              }, [ja(Gft, {
                size: "20",
                icon: "icon-pip"
              }), Xpt])) : za("", !0), r.controlBtns.includes("pageFullScreen") ? (Ca(),
              _a("div", {
                key: 5,
                class: "d-tool-item pip-btn",
                onClick: t[7] || (t[7] = e=>d.webFullScreen = !d.webFullScreen)
              }, [ja(Gft, {
                size: "20",
                icon: "icon-web-screen"
              }), Qpt])) : za("", !0), r.controlBtns.includes("fullScreen") ? (Ca(),
              _a("div", {
                key: 6,
                class: "d-tool-item fullScreen-btn",
                onClick: F
              }, [Jpt, ja(Gft, {
                size: "20",
                icon: "icon-screen"
              })])) : za("", !0)])])], 512)) : za("", !0)], 34)
      }
  }
}), [["__scopeId", "data-v-b23a7076"]]);
Zpt.install = function(e) {
  e.component(Zpt.name, Zpt)
}
;
const eht = e=>(Ln("data-v-1efd16bf"),
  e = e(),
  In(),
  e)
  , tht = {
  key: 0,
  class: "box"
}
  , nht = eht((()=>Ma("svg", {
  viewBox: "64 64 896 896",
  focusable: "false",
  "data-icon": "close",
  width: "1em",
  height: "1em",
  fill: "currentColor",
  "aria-hidden": "true"
}, [Ma("path", {
  d: "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z"
})], -1)))
  , rht = {
  "element-loading-text": "视频生成中",
  style: {
    width: "100%",
    height: "100%"
  }
}
  , oht = AQ(vr({
  __name: "yunboVideoPlay",
  props: {
    showCloseIcon: {
      type: Boolean,
      default: !0
    },
    src: {
      type: String,
      default: ""
    },
    autoPlay: {
      type: Boolean,
      default: !1
    },
    poster: {
      type: String,
      default: ""
    },
    show: {
      type: Boolean,
      default: !1
    },
    loading: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["close"],
  setup(e, {emit: t}) {
    const n = e
      , r = ()=>{
      t("close")
    }
      , o = po()
      , a = yi((()=>({
      height: `calc(100% - ${o.header ? "62px" : "0px"})`
    })))
      , i = yi((()=>n.src));
    Jn(i, (()=>{
        l.src = i.value
      }
    ));
    const s = yi({
      get: ()=>n.show,
      set() {
        t("close")
      }
    })
      , l = bt({
      width: "100%",
      height: "100%",
      color: "#409eff",
      title: "",
      src: i.value,
      muted: !1,
      speedRate: ["0.5", "1.0", "1.5", "2.0"],
      autoPlay: !1,
      loop: !1,
      mirror: !1,
      ligthOff: !1,
      volume: .3,
      control: !0,
      controlBtns: ["audioTrack", "quality", "speedRate", "volume", "setting", "fullScreen"]
    });
    return (e,t)=>{
      const o = WC
        , i = YL
        , u = EW;
      return Ca(),
        _a("div", {
          class: Y(s.value ? "show" : "hide")
        }, [ja(i, {
          modelValue: s.value,
          "onUpdate:modelValue": t[0] || (t[0] = e=>s.value = e),
          width: "100%",
          fullscreen: !0,
          "show-close": !1,
          "modal-class": "videobox-modal"
        }, {
          default: Fn((()=>[s.value ? (Ca(),
            _a("div", tht, [Qr(e.$slots, "header", {}, void 0, !0), Ma("div", {
              class: "video-container",
              style: z(a.value)
            }, [n.showCloseIcon ? (Ca(),
              Ra(o, {
                key: 0,
                class: "closeIcon",
                onClick: r
              }, {
                default: Fn((()=>[nht])),
                _: 1
              })) : za("", !0), rr((Ca(),
              _a("div", rht, [ja(Vt(Zpt), qa(l, {
                poster: n.poster
              }), null, 16, ["poster"])])), [[u, n.loading]]), Qr(e.$slots, "default", {}, void 0, !0)], 4)])) : za("", !0)])),
          _: 3
        }, 8, ["modelValue"])], 2)
    }
  }
}), [["__scopeId", "data-v-1efd16bf"]])
  , aht = {
  class: "time-block"
}
  , iht = AQ(vr({
  __name: "pauseSetting",
  props: {
    time: {
      type: String,
      default: ""
    }
  },
  emits: ["updateTime"],
  setup(e, {emit: t}) {
    const n = e
      , r = e=>{
        t("updateTime", e)
      }
    ;
    return (e,t)=>{
      const o = WC;
      return Ca(),
        _a("div", aht, [ja(o, {
          size: "small",
          class: "insert-button",
          type: "0.5s" === n.time ? "primary" : "default",
          onClick: t[0] || (t[0] = e=>r(.5))
        }, {
          default: Fn((()=>[$a("停顿0.5s")])),
          _: 1
        }, 8, ["type"]), ja(o, {
          size: "small",
          class: "insert-button",
          type: "1s" === n.time ? "primary" : "default",
          onClick: t[1] || (t[1] = e=>r(1))
        }, {
          default: Fn((()=>[$a("停顿1s")])),
          _: 1
        }, 8, ["type"]), ja(o, {
          size: "small",
          class: "insert-button",
          type: "2s" === n.time ? "primary" : "default",
          onClick: t[2] || (t[2] = e=>r(2))
        }, {
          default: Fn((()=>[$a("停顿2s")])),
          _: 1
        }, 8, ["type"]), ja(o, {
          size: "small",
          class: "insert-button",
          onClick: t[3] || (t[3] = e=>r(0))
        }, {
          default: Fn((()=>[$a("取消设置")])),
          _: 1
        })])
    }
  }
}), [["__scopeId", "data-v-0cdf8659"]])
  , sht = e=>(Ln("data-v-22611284"),
  e = e(),
  In(),
  e)
  , lht = {
  class: "time-block"
}
  , uht = sht((()=>Ma("li", {
  class: "insert-button"
}, "取消", -1)))
  , cht = AQ(vr({
  __name: "voiceSetting",
  props: {
    current: {
      type: String,
      default: ""
    }
  },
  emits: ["updateValue"],
  setup(e, {emit: t}) {
    const n = e=>{
        t("updateValue", e)
      }
    ;
    return (e,t)=>(Ca(),
      _a("div", lht, [Ma("ul", null, [Ma("li", {
        class: "insert-button",
        onClick: t[0] || (t[0] = e=>n("da1"))
      }, "da1"), Ma("li", {
        class: "insert-button",
        onClick: t[1] || (t[1] = e=>n("da2"))
      }, "da2"), Ma("li", {
        class: "insert-button",
        onClick: t[2] || (t[2] = e=>n("da3"))
      }, "da3"), uht])]))
  }
}), [["__scopeId", "data-v-22611284"]])
  , dht = e=>(Ln("data-v-6674cc68"),
  e = e(),
  In(),
  e)
  , fht = {
  class: "content"
}
  , pht = dht((()=>Ma("div", {
  class: "box"
}, [Ma("div", {
  class: "align-center"
}, " 生成后，将替换之前的字幕内容 ")], -1)))
  , hht = {
  class: "footer"
}
  , vht = AQ(vr({
  __name: "resetFontLayers",
  props: ["show"],
  emits: ["close", "ok"],
  setup(e, {emit: t}) {
    const n = e
      , r = yi({
        get: ()=>n.show,
        set(e) {
          t("close", e)
        }
      })
      , o = ()=>{
        t("ok")
      }
    ;
    return (e,t)=>{
      const n = WC
        , a = YL;
      return Ca(),
        Ra(a, {
          modelValue: r.value,
          "onUpdate:modelValue": t[1] || (t[1] = e=>r.value = e),
          title: "确定要重新生成字幕吗？",
          class: "font-small",
          width: "322px",
          center: ""
        }, {
          default: Fn((()=>[Ma("div", fht, [pht, Ma("div", hht, [ja(n, {
            style: {
              width: "88px"
            },
            onClick: t[0] || (t[0] = e=>r.value = !1)
          }, {
            default: Fn((()=>[$a("取消")])),
            _: 1
          }), ja(n, {
            style: {
              width: "88px"
            },
            type: "primary",
            onClick: o
          }, {
            default: Fn((()=>[$a("确定")])),
            _: 1
          })])])])),
          _: 1
        }, 8, ["modelValue"])
    }
  }
}), [["__scopeId", "data-v-6674cc68"]])
  , ght = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAiCAYAAAA3WXuFAAAAAXNSR0IArs4c6QAABCFJREFUWEe1mGuoZXMYxn+P+wy5RSG3KLeJyG2MjEtukVxnUuKD5gvJpYxcookyMYRmyPWDXEbkAyOM5BOFSDNhEEUhPpgZI5TbYz27/z7ts8/ae6+1z5x/nTqt8/+/6/k/7/s877uOGHPZ3hK4HrgI2G3MMBuBN4B7JP2ZGBozELavBq4b93zfuZWSlkwX0CrgIOBa4K0xgR0JvFAxvVHS8dMF9C6wOzBf0s9jAgrTX3aASAfPOCDbJwJbAe9J+qcO9IwBsr0tcEnfS28CtgOWAZ2iLetNSb/k95kEtDPwQcPUXSzp06GAbO8C7NowYLY9W/Z3asj2LCCM1K09gNOAf4EXgccl/VgLyHZA3F8pZV4LML1bpxS17ZMrS9ggaW156cPA6cDLkm7tPTwlZbbvA84rOf6pBah9gZjjJEC2zwfuBb4ppnkq8GDF3h/A2f2KrAOUvCf/Z0r6rikg27Wyt70N8ApwALC6+jkB2BG4U9Jz/fHrAKW4tq7oPLyi86/pAiopimG+VBSWR+9UzFzVSPa2hwIqN55Tgq2R9F956UBjrMpgh8rFnwc6Zlel9i5JEcGU1Zoh26cAj5VICyWtGQaoiOTJiqFc4vfKg7aP3QBLJT097ZTZvgO4rARaIWn5IEC248qvAgcCqccri7puLo18SdUiVo5S2aiUvQ3sU4KslbRgBEOLgHOBRT1ufAFwAxCGJ/W9VimzvX9Ryq/VzBLjCwPzJG0YpLICdlZ3vumyEePsfzbIGAcyZPsK4DbgNSBOnmZ5o6RVwwA1Veo4gFKcJ5WWEEC3pEYkLbYdjwmDC7qO3AZID3OTx49BsredLh3TTBcPMzuVcXN9aTO3l2JPF/++BZjVXWEUhtZVprnFxDw0BFCYCUNpiF+UF3b9KGPGt6UHpm+1WYl3oaQOM7Y/TwtqAii1kxqqWw9JeqQETHOOzGN8v/VYRN25y5Piam5K3S4EYrK5rCUdkgMawlDm5P0qc1tcGmX2H1UxllR9IunSnjpIfb3fOxvXobEdk4xA9qqs5Ckgl/oY2CTp2IGAbMd34j+bgLmSQnPonQ18mJynaUqKHeR5I0Bl79EVo8+USSGXmAuskxSvqmfIdrpzzG22pNxkYtm+BsiY8rqkjBStAJX95wB3F2/Lo+WSVgxNWZsqbcNQT5r3rIb/M0rdxUo6WUgNfVYceM6gL4NR4GzPB56I8iSdNWr/sL8HUEd21ax7WE+thM5OThuunM96VNIDDc/UbusFdGhmHdvHFAm3+cxOcWdKXNZmyKtDFEAZxOPGRxT1JHDkHklmOB+5xk31IEATk1/xnAz8X2VAl/T3SDSbeUMYiiccV/rR3uXrIA3z6838rkbhAij/31ladv+Qzi7po0anZ2BTp3Btp5Pn82V9V2kz8K5GIf8HJncoQRf9tmAAAAAASUVORK5CYII="
  , mht = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABDdJREFUWEfFl2mol1UQxn9PG6220mZBH4roQ0RIGVFiGESlES1IkWnZAmVYhi1CiAVFhGFp222zEutDgq1UFBURlNEeKBQkCEmRFC222vQ+f+aVc9/7/pfrDRr4cy/vmTPnOXNmnpkRA0pE7ACcAEwBDgf2z58tfJe/r4A3gPck/T2IafVTioj9gKuBs4Dd++nn+i/A88B9kr7vtacrgIjYCbgSmA3sUhhZC6wBvs1be8neOAA4Hjiq0N0MPAY8JOnPNiCtAPLWy4Bjc9PPaWi1pG963SgiDgbOBi4F9kjdj4E5bd4YASAijgAerlAflJtXAEsl/Tig+ztqEbEXcA1wUe7bCFwu6cvSzjAAefNn8/DfgQWSXhrNwU3diDgTuB3YuXpSgziv9MRWAPnmT6bbffgsSXbdmCUi/JTLE4RtXlzHRAnA7pqTp80b6827eOLu/L5M0lL/3wGQrn89o32FpNvGfO0WAxFxS8bEb8CpfooawELgQsDR7oVRBdygYDMwfVFnx0pJixQRO5q5kmTukXR/aTAiJlROMsDdgCWSXuiThtOAa4FfKw8vkvRhw95VwFzAZDXRAE4CHk2lU5p5HhFvAwfmuul1kqRNbSDyKa1v2rZslDS5AcA88WZ+m20AtfvXSjKBbJWI2B74FLCXapnazOV6ITnkxUL3L+AYSVsadlcnY640gKeSQp+Q5HwdJhExH7gsP76TZBJdPOCYMomdnOuPSLqrxeYCYKYp3QBerXL0sCoD7pRk3h4hEXF0xsAaSf+06RResNeOcwxI+ryLPdP0jRXXrDcAE8OuVQZcL6l0X69zxrQWEVOrTFgMbP5fAJToB3qCbbluREwy7wN7Z9l+sC14BwnCGU49YJ0ku62vRMR2wOPZQdX6yyXd0dzcMw2tHBEmDZPHJkkndjs9IvZMvfXZttWZUG5ZBTgwzQUmtS2DEJEP9W0s50v6rEtkm8xMaoPKkD3apGKjeqC0kM3oa1V+jwfcTJzTbK8iwq2Y+aQpJiCzplu2prhFmzxQMYqI04B708IHwM2SNtQWI+LcbDrKQz5yR+SKlww5lK6vdf4AZgxcjiNiXjapNuBy+m4V5V/UHqsq3RLg9ALBMMqOCHfVJSsuljTUrSG5TtLLTZ9FxAUVw5maXRk7IulI/20A9KcJklzxOtLyTHMlvdKrJZtZFadPWkDs4zjI1BwvaUpE+I2fBg4p9BdKeqYAcCswvVh/H7iiX1Pqtx7hiRZQnh1uaHx3ABrAuswOx1FTZv0nbXlywFtZU1rOaf3kjJo2msHEef5ct8EkIs7IAvNDNUfs2wOFRzWPeNMlrdvW0czv1xnNygoaEeMk/ZRtuNNuXAHka09LvkCt1wnifv7qN5zWWdASFzcBlxTf50vywDpM+gIootht2cTmeC6pnh+HGY4IT0KHFtVwQ7M184Z/AbrF0X3PgP1nAAAAAElFTkSuQmCC"
  , yht = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAkCAYAAACNBsqdAAAAAXNSR0IArs4c6QAAA09JREFUSEu9llvIZ2MUxn8PIpEcSkQhklNp5sIISSEXg0kzJS5IThkNciw5hVHjYggXDs1MDVHkcDFcKHK8IELjOCinlJwJic9jP1/v/nrt77//e/ddWHf7Xet93rXX4VlLDIjtk4AzgUOA7YAvgWeB+yX90XddfQrbOwE3Aif32HwOXC3p7Un6acD3ACdWl/5sgH4HdqnOfgWWSvqmCz4R2PZSYG0x/gW4GXhG0oztA4BbgUVF/6KkC8YCPw4cVowvkvR8fdH2jsAmYM9yvkTST7VNn8cfAtF9Jen4STG0fQlwcdGdKumjqcC2twI+KEavSTqrB3g5cFvRrZC0eYzH7zVx3Ab4HjhG0j9dcNvXAmeX8yTwkzHA64Gji+EaSfmeE9t7lxhv35SkgcWSUjFz0hfjw4FHgK3LxQeBp4AkaAlwJbBbQdkoafWoqoiR7aua5J03Kb7V2RdAEjevA6c1SHRJ3BWllbtvPAdcLyl5mCe9wK2l7dTqccB+TRVsC6TLXpf05rS/GQQeCEWv+v8Btp3+PwdIVYRshh5Oqf0IvANskPRW+wuzF22nGVYB55cSW0gEZoAHmjK8W9LfLfDlwIUFLQbhik+BeR3XeTHtvz9wUOXQfZLWyvahwGNF8VnTBJdJarlilOe2DwbuBPZtSjCOrQhweDf8+1cTq9MkfTwKrWNk+8AmN08Wjnk6wC8DuwOvSDp3IaBVza8LaaXWA/x+CcN6SWuGgG2nYq4B9ijcsaklKdtnlHE2E+CWoO+VdMcI4Iyp0yu7rzNwJf32H3YbAra9QynFxP7IkM6Ex8PfGWc7AxkObwx6bPsuILvFWPkOWDYVuMTz0bGIld26IeCVTcte2gFOLG9oGO+Fpo33aRJ/S9MH6YVatgwBZ4I8lNFT3VotaWOHVrMepAsjaZATxsQ4Iz6jvpXlkt6t3bMd4L3K2ZaGq08ZA9wWfYt1naRQwKzYDgu+WnFFOvjYoVBk5mX21fJD+CRTpHTs7aUMa5vNAb6pnLw0YZXKRJ6LZ+eBDNCM/0ny8BCR51c3NPvwUT0Ak46zgS4bA7wrkK0nm84R1SJTg2YNyJKYeM/++SBw16WKZlvVt7MedtaAhQDH6+zHYbefgScmkde/xRlM1CU0aiEAAAAASUVORK5CYII="
  , bht = {
  class: "select-header"
}
  , wht = {
  class: "option"
}
  , xht = {
  class: "option-label"
}
  , Sht = vr({
  __name: "YbMutipleSelect",
  props: ["list", "modelValue", "selectClass", "placeholder", "maxCollapseTags"],
  emits: ["update:modelValue"],
  setup(e, {emit: t}) {
    const n = e
      , r = Ft([])
      , o = Ft(!1)
      , a = Ft(!1);
    Jn(r, (e=>{
        0 === e.length ? (o.value = !1,
          a.value = !1) : e.length === s.value.length ? (o.value = !0,
          a.value = !1) : a.value = !0;
        for (let t = 0; t < s.value.length; t++)
          s.value[t].checked = -1 !== r.value.indexOf(s.value[t].microsoftName);
        t("update:modelValue", r.value)
      }
    )),
      Jn(n, (()=>{
          r.value = n.modelValue
        }
      ));
    const i = e=>{
      a.value = !1,
        r.value = e ? s.value.map((e=>e.microsoftName)) : []
    }
      , s = yi((()=>n.list));
    return (e,t)=>{
      const l = AD
        , u = rB
        , c = nB;
      return Ca(),
        Ra(c, {
          modelValue: r.value,
          "onUpdate:modelValue": t[1] || (t[1] = e=>r.value = e),
          class: Y(n.selectClass),
          placeholder: n.placeholder,
          "popper-class": "VoiceSelectModal",
          multiple: "",
          "collapse-tags": "",
          "max-collapse-tags": n.maxCollapseTags
        }, {
          header: Fn((()=>[Ma("div", bht, [ja(l, {
            modelValue: o.value,
            "onUpdate:modelValue": t[0] || (t[0] = e=>o.value = e),
            indeterminate: a.value,
            onChange: i
          }, {
            default: Fn((()=>[$a(" 全选 ")])),
            _: 1
          }, 8, ["modelValue", "indeterminate"]), Ma("span", null, "已选" + te(r.value.length) + "项", 1)])])),
          default: Fn((()=>[(Ca(!0),
            _a(ba, null, Yr(s.value, (e=>(Ca(),
              Ra(u, {
                key: e.microsoftName,
                label: e.name,
                value: e.microsoftName
              }, {
                default: Fn((()=>[Ma("div", wht, [ja(l, {
                  modelValue: e.checked,
                  "onUpdate:modelValue": t=>e.checked = t,
                  onChange: t=>(e=>{
                      e.checked = !e.checked
                    }
                  )(e)
                }, null, 8, ["modelValue", "onUpdate:modelValue", "onChange"]), Ma("span", xht, te(e.name), 1)])])),
                _: 2
              }, 1032, ["label", "value"])))), 128))])),
          _: 1
        }, 8, ["modelValue", "class", "placeholder", "max-collapse-tags"])
    }
  }
})
  , Eht = {
  class: "yb-select"
}
  , Aht = {
  class: "select-label"
}
  , Cht = {
  class: "option"
}
  , kht = {
  class: "option-label"
}
  , Tht = AQ(vr({
  __name: "AiVoicePlaySelect",
  props: ["list", "modelValue", "selectClass", "placeholder"],
  emits: ["update:modelValue", "updatePlayState"],
  setup(e, {emit: t}) {
    const n = e
      , r = Ft(n.modelValue)
      , o = ()=>{
        t("update:modelValue", r.value)
      }
    ;
    return (a,i)=>{
      const s = rB
        , l = nB;
      return Ca(),
        _a("div", Eht, [Ma("label", Aht, [Qr(a.$slots, "icon", {}, void 0, !0)]), ja(l, {
          "popper-class": "VoiceSelectModal",
          class: Y(n.selectClass),
          modelValue: r.value,
          "onUpdate:modelValue": i[0] || (i[0] = e=>r.value = e),
          onChange: o
        }, {
          default: Fn((()=>[(Ca(!0),
            _a(ba, null, Yr(e.list, (e=>(Ca(),
              Ra(s, {
                value: e.microsoftName,
                label: e.name
              }, {
                default: Fn((()=>[Ma("div", Cht, [ja(LJ, {
                  bindMediaSrc: e.auditionUrl,
                  onTogglePlayState: n=>(e=>{
                      t("updatePlayState", e.auditionUrl)
                    }
                  )(e)
                }, null, 8, ["bindMediaSrc", "onTogglePlayState"]), Ma("span", kht, te(e.name), 1)])])),
                _: 2
              }, 1032, ["value", "label"])))), 256))])),
          _: 1
        }, 8, ["class", "modelValue"])])
    }
  }
}), [["__scopeId", "data-v-b9821501"]])
  , Dht = e=>(Ln("data-v-fd2bb744"),
  e = e(),
  In(),
  e)
  , Oht = {
  class: "content"
}
  , _ht = {
  class: "search-box"
}
  , Rht = {
  class: "form-inline"
}
  , Lht = {
  class: "form-item"
}
  , Iht = Dht((()=>Ma("label", null, "声音名:", -1)))
  , Pht = {
  class: "form-item"
}
  , Fht = Dht((()=>Ma("label", null, "性别:", -1)))
  , Bht = {
  class: "form-item"
}
  , Nht = Dht((()=>Ma("label", null, "语言:", -1)))
  , Mht = {
  class: "form-item"
}
  , jht = Dht((()=>Ma("label", null, "说话风格:", -1)))
  , Vht = {
  class: "card-list",
  "element-loading-text": "努力搜索中..."
}
  , Uht = ["onClick"]
  , $ht = {
  class: "card-left"
}
  , Hht = {
  class: "head-img"
}
  , zht = ["src"]
  , Kht = {
  class: "card-right"
}
  , Wht = {
  class: "name"
}
  , Ght = {
  class: "is-selected"
}
  , qht = {
  class: "tag-list"
}
  , Yht = {
  class: "tag"
}
  , Xht = {
  class: "tag"
}
  , Qht = {
  class: "tag"
}
  , Jht = Dht((()=>Ma("img", {
  class: "icon",
  src: ght,
  alt: ""
}, null, -1)))
  , Zht = {
  class: "tag"
}
  , evt = Dht((()=>Ma("img", {
  class: "icon",
  src: mht,
  alt: ""
}, null, -1)))
  , tvt = {
  class: "tag"
}
  , nvt = Dht((()=>Ma("img", {
  class: "icon",
  src: yht,
  alt: ""
}, null, -1)))
  , rvt = {
  class: "description"
}
  , ovt = {
  class: "selection"
}
  , avt = Dht((()=>Ma("img", {
  class: "icon",
  src: ght,
  alt: ""
}, null, -1)))
  , ivt = Dht((()=>Ma("img", {
  class: "icon",
  src: mht,
  alt: ""
}, null, -1)))
  , svt = Dht((()=>Ma("img", {
  class: "icon",
  src: yht,
  alt: ""
}, null, -1)))
  , lvt = {
  class: "footer",
  id: "footer"
}
  , uvt = vr({
  __name: "VoiceSelectModal",
  props: ["show", "currentValue"],
  emits: ["close", "ok"],
  setup(e, {emit: t}) {
    const n = e
      , r = TJ()
      , {togglePlayState: o, stopPlay: a} = IJ()
      , i = Ft("")
      , s = Ft(!1)
      , l = Ft({})
      , u = yi({
      get: ()=>n.show,
      set(e) {
        t("close", e)
      }
    })
      , c = bt({
      name: "",
      filter_sex: [],
      filter_lang: [],
      filter_style: []
    })
      , d = ()=>{
      c.name = "",
        c.filter_sex = [],
        c.filter_lang = [],
        c.filter_style = []
    }
      , f = Ft([])
      , p = Ft([])
      , h = e=>{
      let t = []
        , n = {};
      for (let r = 0; r < f.value.length; r++) {
        let o = f.value[r];
        for (let r = 0; r < o[e].length; r++) {
          let a = o[e][r];
          n.hasOwnProperty(a.microsoftName) || (t.push({
            microsoftName: a.microsoftName,
            name: a.name,
            checked: !1
          }),
            n[a.microsoftName] = !0)
        }
      }
      return t
    }
      , v = Ft([{
      name: "男",
      microsoftName: "男",
      checked: !1
    }, {
      name: "女",
      microsoftName: "女",
      checked: !1
    }])
      , g = yi((()=>h("langList")))
      , m = yi((()=>h("styleList")))
      , y = e=>{
      b.value && clearTimeout(b.value),
        b.value = setTimeout((()=>{
            p.value = f.value.filter((e=>{
                let t = !0;
                return c.name && (t = !(!e.name || -1 === e.name.indexOf(c.name))),
                t && c.filter_sex.length > 0 && (t = -1 !== c.filter_sex.indexOf(e.sex)),
                t && c.filter_lang.length > 0 && (t = !!e.langList.find((e=>c.filter_lang.find((t=>t === e.microsoftName))))),
                t && c.filter_style.length > 0 && (t = !!e.styleList.find((e=>c.filter_style.find((t=>t === e.microsoftName))))),
                  t
              }
            )).sort(((e,t)=>"minimax" === e.source ? -1 : 1)),
              s.value = !1
          }
        ), e)
    }
      , b = Ft();
    Jn(c, (()=>{
        s.value = !0,
          y(500)
      }
    ));
    const w = e=>["一", "二", "三", "四", "五", "六", "七", "八", "九"][e - 1] || ""
      , x = e=>{
        f.value = f.value.map((e=>{
            var t, n, r, o;
            let a = {};
            if (l.value.model_audio_code === e.model_audio_code)
              a = {
                _checked_role: l.value._checked_role,
                _checked_lang: l.value._checked_lang,
                _checked_style: l.value._checked_style
              };
            else {
              let {roleList: i, langList: s, styleList: l} = e;
              a = {
                _checked_role: (null == (t = null == i ? void 0 : i[0]) ? void 0 : t.microsoftName) || "",
                _checked_lang: (null == (n = null == s ? void 0 : s.find((e=>"zh-CN" === e.microsoftName))) ? void 0 : n.microsoftName) || (null == (r = null == s ? void 0 : s[0]) ? void 0 : r.microsoftName) || "",
                _checked_style: (null == (o = null == l ? void 0 : l[0]) ? void 0 : o.microsoftName) || ""
              }
            }
            return Object.assign(e, a)
          }
        )),
          l.value = f.value.find((e=>l.value.model_audio_code === e.model_audio_code)) || l.value,
          y(e)
      }
      , S = e=>{
        o(e, "videoVoiceSelectModal")
      }
    ;
    Jn(u, (()=>{
        if (u.value) {
          p.value = [];
          let e = JSON.parse(JSON.stringify(n.currentValue));
          i.value = n.currentValue.model_audio_code,
            l.value = e,
            hn((()=>{
                s.value = !0,
                  0 === f.value.length ? oY.worker.getAudioList().then((e=>{
                      f.value = e.data || [],
                        x(300)
                    }
                  )) : x(20)
              }
            ))
        } else
          a("videoVoiceSelectModal")
      }
    ));
    const E = e=>{
        l.value.template ? (t("ok", {
          name: "1" === e ? "chooseVoice" : "chooseVoiceUsingAll",
          value: {
            item: l.value,
            type: "tts",
            subtitle: []
          }
        }),
          t("close")) : MW({
          type: "error",
          message: "请选择合成音"
        })
      }
      , A = e=>{
        E(e)
      }
    ;
    return (e,t)=>{
      const n = yE
        , o = WC
        , a = ZI
        , f = eP
        , h = JI
        , y = YL
        , b = EW;
      return Ca(),
        Ra(y, {
          modelValue: u.value,
          "onUpdate:modelValue": t[6] || (t[6] = e=>u.value = e),
          title: "Al合成音",
          width: "830px",
          center: ""
        }, {
          default: Fn((()=>[Ma("div", Oht, [Ma("div", _ht, [Ma("div", Rht, [Ma("div", Lht, [Iht, ja(n, {
            modelValue: c.name,
            "onUpdate:modelValue": t[0] || (t[0] = e=>c.name = e),
            class: "voice-name",
            placeholder: "输入名称",
            "suffix-icon": Vt(qm)
          }, null, 8, ["modelValue", "suffix-icon"])]), Ma("div", Pht, [Fht, ja(Sht, {
            selectClass: "voice-sex-lang",
            list: v.value,
            modelValue: c.filter_sex,
            "onUpdate:modelValue": t[1] || (t[1] = e=>c.filter_sex = e),
            placeholder: "全部",
            "max-collapse-tags": 2
          }, null, 8, ["list", "modelValue"])]), Ma("div", Bht, [Nht, ja(Sht, {
            selectClass: "voice-sex-lang",
            list: g.value,
            modelValue: c.filter_lang,
            "onUpdate:modelValue": t[2] || (t[2] = e=>c.filter_lang = e),
            placeholder: "全部",
            "max-collapse-tags": 0
          }, null, 8, ["list", "modelValue"])]), Ma("div", Mht, [jht, ja(Sht, {
            selectClass: "voice-style",
            list: m.value,
            modelValue: c.filter_style,
            "onUpdate:modelValue": t[3] || (t[3] = e=>c.filter_style = e),
            placeholder: "全部",
            "max-collapse-tags": 0
          }, null, 8, ["list", "modelValue"])])]), ja(o, {
            class: "btn-reset",
            onClick: d
          }, {
            default: Fn((()=>[$a("重置")])),
            _: 1
          })]), rr((Ca(),
            _a("div", Vht, [(Ca(!0),
              _a(ba, null, Yr(p.value, (e=>{
                  var t;
                  return Ca(),
                    _a("div", {
                      class: Y(["card", {
                        active: l.value.model_audio_code === e.model_audio_code
                      }]),
                      onClick: t=>{
                        return n = e,
                          void (l.value = n);
                        var n
                      }
                    }, [Ma("div", {
                      class: Y(["is-use", i.value === e.model_audio_code ? "show" : "hide"])
                    }, "应用中", 2), Ma("div", $ht, [Ma("div", Hht, [Ma("img", {
                      src: e.cover,
                      alt: ""
                    }, null, 8, zht), Ma("div", {
                      class: Y(["header-audio-player", {
                        hover: Vt(r).playState && Vt(r).src === encodeURI(e.preview)
                      }])
                    }, [ja(LJ, {
                      bindMediaSrc: e.preview,
                      circleRadius: 20,
                      onTogglePlayState: t=>S(e.preview)
                    }, null, 8, ["bindMediaSrc", "onTogglePlayState"])], 2)])]), Ma("div", Kht, [Ma("div", Wht, [$a(te(e.name) + " ", 1), rr(Ma("span", Ght, "精选", 512), [[$s, "minimax" === e.source]])]), Ma("ul", qht, [Ma("li", Yht, [Ma("span", null, te(e.sex), 1)]), rr(Ma("li", Xht, [Ma("span", null, te(e.langList.length > 1 ? "多语言" : null == (t = e.langList[0]) ? void 0 : t.name), 1)], 512), [[$s, e.langList.length > 0]]), rr(Ma("li", Qht, [Jht, Ma("span", null, te(w(e.langList.length)) + "种", 1)], 512), [[$s, e.langList.length > 1]]), rr(Ma("li", Zht, [evt, Ma("span", null, te(w(e.styleList.length)) + "种", 1)], 512), [[$s, e.langList.length <= 1 && e.styleList.length > 1]]), rr(Ma("li", tvt, [nvt, Ma("span", null, te(w(e.roleList.length)) + "种", 1)], 512), [[$s, e.langList.length <= 1 && e.roleList.length > 1]])]), Ma("p", rvt, te(e.description), 1), Ma("div", ovt, [e.langList.length > 1 ? (Ca(),
                      Ra(Tht, {
                        key: 0,
                        modelValue: e._checked_lang,
                        "onUpdate:modelValue": t=>e._checked_lang = t,
                        onUpdatePlayState: S,
                        selectClass: "voice-play-select",
                        list: e.langList
                      }, {
                        icon: Fn((()=>[avt])),
                        _: 2
                      }, 1032, ["modelValue", "onUpdate:modelValue", "list"])) : za("", !0), e.styleList.length > 1 ? (Ca(),
                      Ra(Tht, {
                        key: 1,
                        modelValue: e._checked_style,
                        "onUpdate:modelValue": t=>e._checked_style = t,
                        onUpdatePlayState: S,
                        selectClass: "voice-play-select",
                        list: e.styleList
                      }, {
                        icon: Fn((()=>[ivt])),
                        _: 2
                      }, 1032, ["modelValue", "onUpdate:modelValue", "list"])) : za("", !0), e.roleList.length > 1 ? (Ca(),
                      Ra(Tht, {
                        key: 2,
                        modelValue: e._checked_role,
                        "onUpdate:modelValue": t=>e._checked_role = t,
                        onUpdatePlayState: S,
                        selectClass: "voice-play-select",
                        list: e.roleList
                      }, {
                        icon: Fn((()=>[svt])),
                        _: 2
                      }, 1032, ["modelValue", "onUpdate:modelValue", "list"])) : za("", !0)])])], 10, Uht)
                }
              )), 256))])), [[b, s.value]]), Ma("div", lvt, [ja(o, {
            style: {
              width: "88px",
              "margin-right": "10px"
            },
            onClick: t[4] || (t[4] = e=>u.value = !1)
          }, {
            default: Fn((()=>[$a("取消")])),
            _: 1
          }), ja(h, {
            class: "yb-dropdown",
            teleported: !1,
            trigger: "click",
            type: "primary",
            "split-button": "",
            onClick: t[5] || (t[5] = e=>E("1")),
            onCommand: A
          }, {
            dropdown: Fn((()=>[ja(f, null, {
              default: Fn((()=>[ja(a, {
                command: "1"
              }, {
                default: Fn((()=>[$a("应用")])),
                _: 1
              }), ja(a, {
                command: "2"
              }, {
                default: Fn((()=>[$a("应用到全部")])),
                _: 1
              })])),
              _: 1
            })])),
            default: Fn((()=>[ja(o, {
              type: "primary"
            }, {
              default: Fn((()=>[$a("应用")])),
              _: 1
            })])),
            _: 1
          })])])])),
          _: 1
        }, 8, ["modelValue"])
    }
  }
})
  , cvt = AQ(uvt, [["__scopeId", "data-v-fd2bb744"]])
  , dvt = ml("worker", (()=>{
    const e = Ft({
      person: {
        model_person_code: "",
        cover: ""
      },
      audio: {},
      size: "16:9",
      video_code: ""
    });
    return {
      chooseParams: e,
      setPerson: t=>{
        e.value.person = t
      }
      ,
      setAudio: t=>{
        e.value.audio = t
      }
      ,
      setSize: t=>{
        e.value.size = t
      }
      ,
      setVideoCode: t=>{
        e.value.video_code = t
      }
      ,
      $reset: ()=>{
        e.value = {
          person: {
            model_person_code: "",
            cover: ""
          },
          audio: {},
          size: "16:9",
          video_code: ""
        }
      }
    }
  }
), {
  persist: !0
})
  , fvt = vr({
  __name: "LayerContextmenu",
  props: ["layerType"],
  setup(e) {
    const t = e
      , n = Ft([{
      text: "应用至全局",
      icon: "",
      action: "applyAll",
      fastCode: "Shift + G",
      belongTypes: ["person"]
    }, {
      text: "复制",
      icon: "",
      action: "copy",
      fastCode: "Ctrl + C",
      belongTypes: ["sucai"]
    }, {
      text: "粘贴",
      icon: "",
      action: "paste",
      fastCode: "Ctrl + V",
      belongTypes: ["sucai"]
    }, {
      text: "上传替换",
      icon: "",
      action: "uploadReplace",
      fastCode: "",
      belongTypes: ["sucai"]
    }, {
      text: "删除",
      icon: "",
      action: "delete",
      fastCode: "Delete",
      belongTypes: ["person", "sucai"]
    }, {
      text: "置顶",
      icon: "",
      action: "moveFirst",
      fastCode: "",
      belongTypes: ["person", "sucai"]
    }, {
      text: "置底",
      icon: "",
      action: "moveLast",
      fastCode: "",
      belongTypes: ["person", "sucai"]
    }, {
      text: "上移一层",
      icon: "",
      action: "toPrev",
      fastCode: "",
      belongTypes: ["person", "sucai"]
    }, {
      text: "下移一层",
      icon: "",
      action: "toNext",
      fastCode: "",
      belongTypes: ["person", "sucai"]
    }]);
    return yi((()=>n.value.filter((e=>-1 !== e.belongTypes.indexOf(t.layerType))))),
      (e,t)=>(Ca(),
        _a("div"))
  }
})
  , pvt = "/tabs/image-line@2x.png"
  , hvt = "/tabs/image-2-fill@2x.png"
  , vvt = "/tabs/user-5-line@2x.png"
  , gvt = "/tabs/user-5-fill@2x.png";
const mvt = e=>{
  Lr((()=>{
      e && Object.keys(e).forEach((t=>{
          n.audio.addEventListener(t, e[t])
        }
      ))
    }
  )),
    Fr((()=>{
        e && Object.keys(e).forEach((t=>{
            n.audio.removeEventListener(t, e[t])
          }
        ));
        let t = n.audio.parentNode;
        t && t.removeChild(n.audio)
      }
    ));
  const n = new class {
      constructor() {
        t(this, "audio");
        let e = document.createElement("audio");
        e.id = "yb-audio",
          e.style.width = "0",
          e.style.height = "0",
          e.style.opacity = "0",
          e.style.overflow = "hidden",
          document.body.appendChild(e),
          this.audio = e
      }
      play(e) {
        this.audio.src !== e && (this.audio.currentTime = 0,
          this.audio.src = e),
          this.audio.play()
      }
      pause() {
        this.audio.pause()
      }
      updateCurrentTime(e) {
        this.audio.currentTime = e
      }
      setPlaybackRate(e) {
        this.audio.playbackRate = e
      }
      setVolume(e) {
        this.audio.volume = e
      }
    }
  ;
  return n
}
  , yvt = e=>(Ln("data-v-6a6a21a9"),
  e = e(),
  In(),
  e)
  , bvt = {
  class: "content"
}
  , wvt = {
  class: "box"
}
  , xvt = {
  class: "flexbox align-center"
}
  , Svt = yvt((()=>Ma("span", {
  class: "label"
}, "生成方式: ", -1)))
  , Evt = {
  class: "flexbox"
}
  , Avt = yvt((()=>Ma("span", {
  class: "label"
}, "链接: ", -1)))
  , Cvt = {
  class: "footer"
}
  , kvt = AQ(vr({
  __name: "ContentFromDy",
  props: ["show"],
  emits: ["close", "ok"],
  setup(e, {emit: t}) {
    const n = e
      , r = Ft(["链接转文字"])
      , o = Ft([{
        label: "链接转文字",
        value: "parse_to_text"
      }, {
        label: "链接转录音",
        value: "parse_to_video"
      }])
      , a = yi((()=>r.value.map((e=>{
          var t;
          return null == (t = o.value.find((t=>t.label === e))) ? void 0 : t.value
        }
      ))))
      , i = Ft("")
      , s = yi({
        get: ()=>n.show,
        set(e) {
          t("close", e)
        }
      })
      , l = ()=>{
        if (/^https?/g.test(i.value)) {
          let e = i.value;
          t("ok", {
            url: e,
            tranTypes: a.value
          }),
            i.value = ""
        } else
          MW({
            message: "链接格式错误",
            type: "error"
          })
      }
    ;
    return (e,t)=>{
      const n = AD
        , u = kD
        , c = yE
        , d = WC
        , f = YL;
      return Ca(),
        Ra(f, {
          modelValue: s.value,
          "onUpdate:modelValue": t[3] || (t[3] = e=>s.value = e),
          title: "生成内容",
          width: "500px",
          center: ""
        }, {
          default: Fn((()=>[Ma("div", bvt, [Ma("div", wvt, [Ma("div", xvt, [Svt, Ma("div", null, [ja(u, {
            modelValue: r.value,
            "onUpdate:modelValue": t[0] || (t[0] = e=>r.value = e)
          }, {
            default: Fn((()=>[(Ca(!0),
              _a(ba, null, Yr(o.value, (e=>(Ca(),
                Ra(n, {
                  label: e.label,
                  "model-value": e.value,
                  size: "large"
                }, null, 8, ["label", "model-value"])))), 256))])),
            _: 1
          }, 8, ["modelValue"])])]), Ma("div", Evt, [Avt, ja(c, {
            modelValue: i.value,
            "onUpdate:modelValue": t[1] || (t[1] = e=>i.value = e),
            rows: 7,
            type: "textarea",
            resize: "none",
            placeholder: "仅支持解析抖音短视频链接"
          }, null, 8, ["modelValue"])])]), Ma("div", Cvt, [ja(d, {
            style: {
              width: "88px"
            },
            onClick: t[2] || (t[2] = e=>s.value = !1)
          }, {
            default: Fn((()=>[$a("取消")])),
            _: 1
          }), ja(d, {
            style: {
              width: "88px"
            },
            disabled: 0 === a.value.length || "" === i.value,
            onClick: l
          }, {
            default: Fn((()=>[$a("开始生成")])),
            _: 1
          }, 8, ["disabled"])])])])),
          _: 1
        }, 8, ["modelValue"])
    }
  }
}), [["__scopeId", "data-v-6a6a21a9"]])
  , Tvt = e=>(Ln("data-v-459b0fac"),
  e = e(),
  In(),
  e)
  , Dvt = {
  class: "content"
}
  , Ovt = {
  class: "box"
}
  , _vt = {
  class: "flexbox align-center"
}
  , Rvt = Tvt((()=>Ma("span", {
  class: "label"
}, "视频名称: ", -1)))
  , Lvt = {
  class: "inp-value"
}
  , Ivt = {
  class: "flexbox align-center"
}
  , Pvt = Tvt((()=>Ma("span", {
  class: "label"
}, "分辨率: ", -1)))
  , Fvt = {
  class: "inp-value"
}
  , Bvt = {
  class: "flexbox align-center"
}
  , Nvt = Tvt((()=>Ma("span", {
  class: "label"
}, "时长: ", -1)))
  , Mvt = {
  class: "inp-value"
}
  , jvt = {
  class: "flexbox align-center"
}
  , Vvt = Tvt((()=>Ma("span", {
  class: "label"
}, "本次生成消耗: ", -1)))
  , Uvt = {
  class: "inp-value"
}
  , $vt = Tvt((()=>Ma("div", {
  style: {
    display: "flex",
    "align-items": "center",
    "justify-content": "center",
    position: "relative",
    bottom: "-1px"
  }
}, [Ma("img", {
  src: cG,
  width: "21",
  alt: ""
})], -1)))
  , Hvt = {
  class: "footer"
}
  , zvt = AQ(vr({
  __name: "CreateConfirm",
  props: ["show", "duration", "videoName"],
  emits: ["close", "confirm"],
  setup(e, {emit: t}) {
    const n = e
      , {globalData: r} = NX()
      , o = Ft(n.videoName)
      , a = Ft("720p")
      , i = Ft([{
        label: "480P",
        value: "480p"
      }, {
        label: "720P",
        value: "720p"
      }, {
        label: "1080P",
        value: "1080p"
      }])
      , s = yi((()=>{
          let e = n.duration;
          return {
            hours: Math.floor(e / 3600),
            minute: Math.floor(e % 3600 / 60),
            second: Math.ceil(e % 60)
          }
        }
      ))
      , l = yi({
        get: ()=>(o.value = n.videoName,
          n.show),
        set(e) {
          t("close", e)
        }
      })
      , u = ()=>{
        t("confirm", {
          name: o.value,
          resolution: a.value
        })
      }
    ;
    return (e,t)=>{
      const c = yE
        , d = rB
        , f = nB
        , p = WC
        , h = YL;
      return Ca(),
        Ra(h, {
          modelValue: l.value,
          "onUpdate:modelValue": t[3] || (t[3] = e=>l.value = e),
          title: "生成视频",
          width: "400px",
          center: ""
        }, {
          default: Fn((()=>[Ma("div", Dvt, [Ma("div", Ovt, [Ma("div", _vt, [Rvt, Ma("div", Lvt, [ja(c, {
            modelValue: o.value,
            "onUpdate:modelValue": t[0] || (t[0] = e=>o.value = e),
            placeholder: "请输入作品名称",
            clearable: ""
          }, null, 8, ["modelValue"])])]), Ma("div", Ivt, [Pvt, Ma("div", Fvt, [ja(f, {
            modelValue: a.value,
            "onUpdate:modelValue": t[1] || (t[1] = e=>a.value = e),
            placeholder: "请选择分辨率",
            style: {
              width: "100%"
            }
          }, {
            default: Fn((()=>[(Ca(!0),
              _a(ba, null, Yr(i.value, (e=>(Ca(),
                Ra(d, {
                  key: e.value,
                  label: e.label,
                  value: e.value
                }, null, 8, ["label", "value"])))), 128))])),
            _: 1
          }, 8, ["modelValue"])])]), Ma("div", Bvt, [Nvt, Ma("div", Mvt, [$a(" 预计 "), rr(Ma("span", null, te(s.value.hours) + "小时", 513), [[$s, 0 !== s.value.hours]]), rr(Ma("span", null, te(s.value.minute) + "分", 513), [[$s, 0 !== s.value.minute]]), Ma("span", null, te(s.value.second) + "秒", 1)])]), Ma("div", jvt, [Vvt, Ma("div", Uvt, [$a(te(Math.ceil(Math.ceil(n.duration) * Vt(r).unit_price)) + "  ", 1), $vt])])]), Ma("div", Hvt, [ja(p, {
            style: {
              width: "88px"
            },
            onClick: t[2] || (t[2] = e=>l.value = !1)
          }, {
            default: Fn((()=>[$a("取消")])),
            _: 1
          }), ja(p, {
            style: {
              width: "88px",
              "margin-left": "24px"
            },
            type: "primary",
            onClick: u
          }, {
            default: Fn((()=>[$a("确定")])),
            _: 1
          })])])])),
          _: 1
        }, 8, ["modelValue"])
    }
  }
}), [["__scopeId", "data-v-459b0fac"]]);
function Kvt(e, t, n, r, o) {
  return {
    sel: e,
    data: t,
    children: n,
    text: r,
    elm: o,
    key: void 0 === t ? void 0 : t.key
  }
}
const Wvt = Array.isArray;
function Gvt(e) {
  return "string" == typeof e || "number" == typeof e || e instanceof String || e instanceof Number
}
function qvt(e, t, n) {
  if (e.ns = "http://www.w3.org/2000/svg",
  "foreignObject" !== n && void 0 !== t)
    for (let r = 0; r < t.length; ++r) {
      const e = t[r];
      if ("string" == typeof e)
        continue;
      const n = e.data;
      void 0 !== n && qvt(n, e.children, e.sel)
    }
}
function Yvt(e, t, n) {
  let r, o, a, i = {};
  if (void 0 !== n ? (null !== t && (i = t),
    Wvt(n) ? r = n : Gvt(n) ? o = n.toString() : n && n.sel && (r = [n])) : null != t && (Wvt(t) ? r = t : Gvt(t) ? o = t.toString() : t && t.sel ? r = [t] : i = t),
  void 0 !== r)
    for (a = 0; a < r.length; ++a)
      Gvt(r[a]) && (r[a] = Kvt(void 0, void 0, void 0, r[a], void 0));
  return "s" !== e[0] || "v" !== e[1] || "g" !== e[2] || 3 !== e.length && "." !== e[3] && "#" !== e[3] || qvt(i, r, e),
    Kvt(e, i, r, o, void 0)
}
const Xvt = ()=>{
  const e = Bt()
    , t = bt({
    show: !1,
    time: "",
    style: {
      position: "absolute",
      top: "",
      left: "",
      right: "",
      zIndex: 9999999
    }
  })
    , n = bt({
    show: !1,
    list: [],
    current: "",
    style: {
      position: "absolute",
      top: "",
      bottom: "",
      left: "",
      right: "",
      zIndex: 9999999
    }
  });
  Zat.registerPlugin((e=>{
      const {isInline: t, isVoid: n} = e
        , r = e;
      return r.isInline = e=>{
        const n = qme.getNodeType(e);
        return "insert-pause" === n || ("voice-select" === n || t(e))
      }
        ,
        r.isVoid = e=>{
          const t = qme.getNodeType(e);
          return "insert-pause" === t || ("voice-select" === t || n(e))
        }
        ,
        r
    }
  )),
    Zat.registerRenderElem({
      type: "insert-pause",
      renderElem(e, t, n) {
        const o = e.children[0].text;
        return Yvt("span", {
          className: "insert-pause",
          title: "停顿" + o,
          props: {
            contentEditable: !1
          },
          on: {
            click() {
              r(e, o)
            }
          }
        }, [o])
      }
    }),
    Zat.registerRenderElem({
      type: "voice-select",
      renderElem(t, r, o) {
        const a = t.children[0].text;
        return Yvt("span", {
          className: "voice-select",
          title: a,
          props: {
            contentEditable: !1
          },
          on: {
            click() {
              let r = e.value.getNodePosition(t);
              if (n.style.left = "",
                n.style.right = "",
                n.style.bottom = "",
                console.log(r),
                n.style.top = r.top,
                r.left,
                r.left) {
                let e = parseFloat(r.left);
                n.style.left = e + 16 + "px"
              } else if (r.right) {
                let e = parseFloat(r.right);
                n.style.right = e + "px"
              }
              n.current = a,
                n.show = !0
            }
          }
        }, [a])
      }
    }),
    Zat.registerElemToHtml({
      type: "insert-pause",
      elemToHtml: (e,t)=>`<span data-w-e-type="insert-pause" data-w-e-is-void data-w-e-is-inline>${e.children[0].text}</span>`
    }),
    Zat.registerElemToHtml({
      type: "voice-select",
      elemToHtml: (e,t)=>`<span data-w-e-type="voice-select" data-w-e-is-void data-w-e-is-inline>${e.children[0].text}</span>`
    });
  Zat.registerParseElemHtml({
    selector: 'span[data-w-e-type="insert-pause"]',
    parseElemHtml: (e,t,n)=>({
      type: "insert-pause",
      children: [{
        text: e.innerHTML || ""
      }]
    })
  }),
    Zat.registerParseElemHtml({
      selector: 'span[data-w-e-type="voice-select"]',
      parseElemHtml: (e,t,n)=>({
        type: "voice-select",
        children: [{
          text: e.innerHTML || ""
        }]
      })
    });
  const r = (n,r)=>{
      let o = e.value.getNodePosition(n)
        , a = parseFloat(o.top) + e.value.getEditableContainer().getBoundingClientRect().top;
      if (t.style.top = a + 10 + "px",
        t.style.left = "",
        t.style.right = "",
        o.left,
        o.left) {
        let r = parseFloat(o.left) + e.value.getEditableContainer().getBoundingClientRect().left;
        "0.5s" === n.children[0].text ? t.style.left = r - 25 + "px" : t.style.left = r - 20 + "px"
      } else if (o.right) {
        let e = parseFloat(o.right);
        "0.5s" === n.children[0].text ? t.style.right = e - 40 + "px" : t.style.right = e - 36 + "px"
      }
      t.time = r,
        t.show = !0
    }
    , o = t=>{
      const n = {
        type: "insert-pause",
        children: [{
          text: t
        }]
      };
      e.value.insertNode(n)
    }
  ;
  return {
    editorRef: e,
    insertPause: o,
    showSelectVoiceBox: ()=>{
      let t = e.value.getSelectionPosition();
      if (n.style.left = "",
        n.style.right = "",
        n.style.top = t.top || "",
        n.style.bottom = t.bottom || "",
        t.left,
        t.left) {
        let e = parseFloat(t.left);
        n.style.left = e + 16 + "px"
      } else if (t.right) {
        let e = parseFloat(t.right);
        n.style.right = e + "px"
      }
      n.show = !0
    }
    ,
    updateTime: n=>{
      e.value.deleteForward(),
      0 !== n && o(n + "s"),
        t.show = !1
    }
    ,
    updateVoice: t=>{
      e.value.restoreSelection();
      let r = e.value.getSelectionText() || n.current.split(" ")[0];
      r && (e.value.deleteForward(),
        (t=>{
            const n = {
              type: "voice-select",
              children: [{
                text: t
              }]
            };
            e.value.insertNode(n)
          }
        )(r + " " + t)),
        n.show = !1,
        n.current = ""
    }
    ,
    pauseSettingObj: t,
    voiceSettingObj: n,
    getEditorText: ()=>e.value ? e.value.getText().replace(/(\r\n|\n|\r)/gm, "") : "",
    handleBlur: ()=>{
      t.show = !1,
        n.show = !1
    }
    ,
    parserEditorValueHtml: e=>{
      let t = document.createElement("div");
      t.innerHTML = e.replace(/<br>/g, "").replaceAll("&nbsp;", " ");
      let n = [];
      [].map.call(t.children, (e=>{
          let t = e.innerHTML.replace(/([。；！;!])/g, "$1\n").trim().split("\n");
          n = n.concat(t.join(""))
        }
      ));
      for (let r, o = 0; o < n.length; o++) {
        r = n[o];
        let e = /(<span\s+[^>]*>\d?\.?\ds<\/span>)/g;
        e.test(r) ? n[o] = n[o].split(e).map((e=>{
            let t = /<span\s+[^>]*>(\d?\.?\ds)<\/span>/g;
            return t.test(e) ? {
              type: "insert-pause",
              value: e.replace(t, "$1")
            } : {
              type: "text",
              value: e
            }
          }
        )) : n[o] = [{
          type: "text",
          value: r
        }]
      }
      for (let r = 0; r < n.length; r++)
        for (let e = 0; e < n[r].length; e++) {
          let t = /<span\s+[^>]*>([^<]*)<\/span>/g
            , o = /(<span\s+[^>]*>[^<]*<\/span>)/g;
          "text" === n[r][e].type && t.test(n[r][e].value) && n[r].splice(e, 1, ...n[r][e].value.split(o).filter((e=>"" !== e)).map((e=>o.test(e) ? {
            type: "voice-select",
            value: e.replace(t, "$1")
          } : {
            type: "text",
            value: e
          })))
        }
      return n
    }
  }
}
  , Qvt = e=>(Ln("data-v-0f5087d7"),
  e = e(),
  In(),
  e)
  , Jvt = {
  class: "video",
  "element-loading-text": "页面资源加载中"
}
  , Zvt = {
  class: "arrowLeft"
}
  , egt = Qvt((()=>Ma("span", null, "返回首页", -1)))
  , tgt = {
  class: "mid",
  style: {
    display: "flex",
    "align-items": "center",
    "justify-content": "center"
  }
}
  , ngt = {
  style: {
    position: "relative"
  }
}
  , rgt = {
  for: "videoName"
}
  , ogt = {
  class: "edit-box-end"
}
  , agt = {
  class: "last-save"
}
  , igt = Qvt((()=>Ma("div", {
  class: "right"
}, null, -1)))
  , sgt = {
  class: "leftbar"
}
  , lgt = {
  class: "stage-add"
}
  , ugt = {
  class: "stage-pages text-center"
}
  , cgt = {
  class: "left-stage"
}
  , dgt = {
  class: "stageList"
}
  , fgt = ["onClick"]
  , pgt = {
  class: "stage-menu"
}
  , hgt = ["onClick"]
  , vgt = [Qvt((()=>Ma("img", {
  src: cJ,
  alt: ""
}, null, -1)))]
  , ggt = ["onClick"]
  , mgt = [Qvt((()=>Ma("img", {
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAAXNSR0IArs4c6QAAAhlJREFUWEftl0tOwzAQhv0gba5RqRdALBALEHdAggUnZAW3AIEEUvc8rlElnqCJPNXUclrbSUgrXCmy85p+/v17xpHiyH7yyHhFBh57xrLCWWFHgWyJbIlsibE98EcKdy3mpu/4hswSsbGS4GP/ZJdAPFaIwpMC+2BdaALkoNHQQylMcbCVAPCIU6GUurFTwmGx74MPsndfYFdZAl5Z4FNGgZBgYTk0PhKsdCqw+x6eK1QXWwD4aJpGaq3PGDDBui1Xdi/4EMCtqhYYoZUx5h0ptNbnzBII6h7RSvcFJlhstYXWxpg3AJBFUVx4gI0Fx5aAgz2dAswXmACAJyHEsjVi07T3lFIL7Btjvvl8A8DnfD6/FUIQNCnOfbzTFn2BKSMsCRaV1VovkKCu6x8CllI2xpivsizvLDBCR6vcG5h5Fy1xgtaoquoZBzCbza4tMClZW0hq6XpwqvuXwLTgUOH2qKrqxSp8xRYdWcBtoxZeX4XbNebYAoFf8UZRFJeOJTgsT3GjLjoMvlWK7fkmra3X6wdUuCzL+0NIaxyY+luFgylOA6OyPHnh2GQtXppZ5dtKw7ZQTFKaOSjv8zLt215Otvlxt4I+T3PrHMz2sktp1+ddWWDv7qxLGfd6yrnvq8ON0+trw6dCCqhP5ZA40eoODcwhuwpSEmRI4BCFJnkmpTRPAprqu0lhx/TwaAPLlhhNWhs4Kzy2wr8OJe8tfmzuqQAAAABJRU5ErkJggg==",
  alt: ""
}, null, -1)))]
  , ygt = ["disabled", "onClick"]
  , bgt = [Qvt((()=>Ma("img", {
  src: dJ,
  alt: ""
}, null, -1)))]
  , wgt = ["src"]
  , xgt = {
  class: "stage-canvas"
}
  , Sgt = ["id", "width", "height"]
  , Egt = {
  class: "left-layers"
}
  , Agt = Qvt((()=>Ma("div", {
  class: "layers-title"
}, "图层", -1)))
  , Cgt = ["onClick"]
  , kgt = {
  class: "layer-image"
}
  , Tgt = ["src"]
  , Dgt = Qvt((()=>Ma("div", {
  class: "layer-name"
}, "数字人", -1)))
  , Ogt = ["onClick"]
  , _gt = [Qvt((()=>Ma("svg", {
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: "false",
  "aria-hidden": "true"
}, [Ma("path", {
  d: "M16.5 5C16.5 3.89543 15.6046 3 14.5 3H9.5C8.39543 3 7.5 3.89543 7.5 5V7H6H4C3.44772 7 3 7.44772 3 8C3 8.55228 3.44772 9 4 9H5.07692L6 21C6 21.5523 6.44772 22 7 22H17C17.5523 22 18 21.5523 18 21L18.9231 9H20C20.5523 9 21 8.55228 21 8C21 7.44772 20.5523 7 20 7H18H16.5V5ZM14.5 7H9.5V5.5C9.5 5.22386 9.72386 5 10 5H14C14.2761 5 14.5 5.22386 14.5 5.5V7ZM17 9L16 20H8L7 9H9.5H14.5H17Z",
  fill: "currentColor"
})], -1)))]
  , Rgt = {
  class: "no-layer"
}
  , Lgt = {
  class: "videobar"
}
  , Igt = {
  class: "viewcontent",
  id: "videoView"
}
  , Pgt = {
  style: {
    position: "relative"
  }
}
  , Fgt = ["src"]
  , Bgt = {
  class: "viewbox videoView"
}
  , Ngt = ["width", "height"]
  , Mgt = {
  class: "progressWrap"
}
  , jgt = {
  class: "timeRate"
}
  , Vgt = {
  class: "audioCurrentTime"
}
  , Ugt = Qvt((()=>Ma("span", null, " / ", -1)))
  , $gt = {
  class: "audioDurationTime"
}
  , Hgt = ["src"]
  , zgt = ["element-loading-text"]
  , Kgt = {
  class: "info-header"
}
  , Wgt = {
  class: "info-left"
}
  , Ggt = Qvt((()=>Ma("span", {
  class: "textPrimary",
  style: {
    "font-size": "14px"
  }
}, "讲解内容", -1)))
  , qgt = {
  class: "info-right"
}
  , Ygt = {
  key: 0,
  class: "select-vioce"
}
  , Xgt = ["src"]
  , Qgt = {
  key: 1
}
  , Jgt = {
  style: {
    padding: "7px"
  }
}
  , Zgt = {
  class: "voice-setting"
}
  , emt = Qvt((()=>Ma("div", {
  class: "settings-name"
}, "语速:", -1)))
  , tmt = {
  class: "settings-comp"
}
  , nmt = {
  class: "voice-setting"
}
  , rmt = Qvt((()=>Ma("div", {
  class: "settings-name"
}, "音量:", -1)))
  , omt = {
  class: "settings-comp"
}
  , amt = {
  class: "volume-number"
}
  , imt = Qvt((()=>Ma("span", {
  class: "split-line",
  style: {
    "margin-left": "0"
  }
}, null, -1)))
  , smt = {
  class: "info-body"
}
  , lmt = {
  class: "info-content"
}
  , umt = {
  class: "txtBox"
}
  , cmt = Qvt((()=>Ma("div", {
  class: "tips"
}, [Ma("span", {
  class: "tip-icon"
}, [Ma("img", {
  width: "14",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAAl5JREFUSEu91snrzWEUx/HXz6zMZUwiIUrIyrRC2QgphaQMKVmQhX+BhVhIKZSEUkI2EivTSkgREknGMpd56Pw6V1+/7u9+vzc3z+5+n3Oe93OeM3xum/+82v4zTzPA7hiNUeibF/2Ax3iEb1UuXwXYDTMwE707OfQTruAqvjcClwEHYBlGFA75ghf5eyh6Fvae4jjedgZtBOyDtRiYzvFsZxP2K7+Ff0AX5HPH5zc4gI/1oI2AqzEmnc7gWkmOpmNh2jzEoWaAk/Ipw+cSzlcpCMzHrLSNp73d0a+zCGvRPcN+/KgI7Ir1GIa6UdYD9sI22lvmXFZfRV67WUQYkUaed+Bz0bkeMPpsTRrtQ0TZzBqODelwMPv0j3894AQsT4vtHW9YgRy9Gi8U6xjulkU4FqvSaC9eVoAUTYZgY344jAdlwP7YkkZHca9J4HisSJ9deFcGjP3NiClzEyebBC7BlJw2u6u2xRzMxc9sixhZtTWokOPI0evCXozAdeiCC7hYFRitEXnol6Mqqi2UIVYxR8Uch4JEdccofI/Y+6slwrnRaIviWZm3fZ7zMSSoHjCkK+ZuNHy8ypGOxVKLtEwtpmJxGscsjZlaDxgzNGZprFO40Vney4DhNw+z84A9GXGt7OPZIqJNuV86d6sAQ4C3pvhGIUQjF4ExKKLAQoR3/qsA114mcjmupD3uZ+4amlWJMA4I1Q/JarRCikKSWgp8kv9biofG/52RqX0tAy7FZLyqI6oR+WDcwolWRTgNi0oOO43rrQJGrkNYJ6JHh0O/4g4up+i2JIdlF6+8/xuH63QdT7wirQAAAABJRU5ErkJggg==",
  alt: ""
})]), $a(" 读法不正确？试试选中单个文字或数字组 ")], -1)))
  , dmt = {
  class: "bgbar"
}
  , fmt = {
  key: 0,
  style: {
    height: "100%",
    margin: "0 -15px",
    "margin-top": "-10px"
  }
}
  , pmt = {
  class: "stage-setting-title",
  style: {
    margin: "0",
    border: "none",
    padding: "0",
    height: "100%",
    display: "flex",
    "flex-direction": "column"
  }
}
  , hmt = {
  class: "fontLayerList"
}
  , vmt = {
  class: "fontLayer",
  style: {
    "margin-bottom": "15px"
  }
}
  , gmt = {
  class: "font-time"
}
  , mmt = {
  class: "fontStyle"
}
  , ymt = {
  class: "font-use-all"
}
  , bmt = Qvt((()=>Ma("span", null, "位置", -1)))
  , wmt = {
  class: "input-group",
  style: {
    "justify-content": "space-between"
  }
}
  , xmt = {
  class: "flex-box"
}
  , Smt = Qvt((()=>Ma("span", {
  style: {
    "margin-right": "8px",
    width: "10px"
  }
}, "X", -1)))
  , Emt = {
  class: "flex-box"
}
  , Amt = Qvt((()=>Ma("span", {
  style: {
    "margin-right": "8px",
    width: "10px"
  }
}, "Y", -1)))
  , Cmt = {
  class: "m-t-base colorPicker"
}
  , kmt = Qvt((()=>Ma("span", {
  class: "name"
}, "字体", -1)))
  , Tmt = {
  class: "flexbox font-select"
}
  , Dmt = {
  class: "flex-box m-t-base"
}
  , Omt = {
  class: "colorPicker",
  style: {
    "margin-right": "14px",
    width: "96px"
  }
}
  , _mt = Qvt((()=>Ma("span", {
  class: "name"
}, "字号", -1)))
  , Rmt = {
  class: "colorPicker",
  style: {
    "margin-right": "14px",
    flex: "1"
  }
}
  , Lmt = Qvt((()=>Ma("span", {
  class: "name"
}, "颜色", -1)))
  , Imt = {
  class: "input-picker"
}
  , Pmt = ["value"]
  , Fmt = {
  class: "colorPicker",
  style: {
    flex: "1"
  }
}
  , Bmt = Qvt((()=>Ma("span", {
  class: "name"
}, "描边", -1)))
  , Nmt = {
  class: "input-picker"
}
  , Mmt = ["value"]
  , jmt = {
  class: "m-t-base"
}
  , Vmt = {
  class: "flex-box fontface"
}
  , Umt = {
  width: "14",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAUVJREFUWEft1rErhVEcxvHPlSgrWRgsDMpskUGUv0FRTDaTyGQSmWwmivI3KDLIYlYGFgOLWBUJHZ1bN91733PdWy/1nu3t/M7z+57nOaf3lOQ8Sjn3VwCkOHAUY7rETmJkSxiNtTP11hQAhQOFA4UDhQP/woF9dOIG64n/glA3hFfMN/sv2EYf3rCAjwyINuyhAw9YbhZgDtNRZBfnGQDjWIw1xzhoFqAfW3w/Xl6whscaor3YQBc+sYL7ZgHC+pDjVBQKEGFXFxVxBNvHENwKzcM4QTg/dUfKLQgC7VjFcIVaOBN38XsgZl6evsYm3lsFUIaYxWSMo5p2sP0UhynNg0CqA5XNwpmYwAh64sQTrnCWlflP6t8AZLna0PyfBRhEd0NbyS5+xm1qBJXP6mzptIqqz/paEeQOkHsEaaa2oCr3W/AFqrtSIehnhksAAAAASUVORK5CYII=",
  alt: ""
}
  , $mt = {
  width: "14",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAWRJREFUWEftlkErRFEYhp+XspCRP0DZUmqsFCsL5QewUixsNBb4IcyCbCwoK36AsrCirCjFVvEHhCwUn47O1DRd95zbTN1R5+xu33fe77nve273iJKXSp5PAgg6YGbmYzqVtBgTmZmdAAuuV1LujASQHEgOJAeSA//CgTdgALiSNBP5L7gEpoF3SZW8PTEO3ANjwAcwKOkrT9DMeoFXoB94kDTeLsAOsOFFViQdBQCWgUPfU5e02S6Ae4M7oAd4ASYlPWaJmtkocAMMAd/AhCTn4J8rGIHbaWa7QM2rOAjnyHEjDm/7ElD3w13rnqT10JmJBegDzoDZJkF3Jm79c9Vn3ihfAPOSPjsC4F1wENvAmo8jS9vZvg9sxQz/vTGFCFvrZubOxCowB4z4+hNwDhyEMm/VKwxQFDjU350AZjYFDIfoC9afJV1HRdB8rS44JK8981qfGUE3AJQbQQdtD0qV/hX8ADo3zSFYm0D1AAAAAElFTkSuQmCC",
  alt: ""
}
  , Hmt = {
  width: "14",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAYFJREFUWEft1rFLXEEQx/HPiYUoCGk1/gEWFoK2AVvJH5DCIqWdhagIkjaoKRIINrGx0MLKJgFBsLFRQQtBLCSpghAisRKMRMPCHhyHd2/f8XyH4Ct3dub3fbMzs1vR5q/SZn3PAE8iA1MZdXKP3/iOQ/zLU1cpGdjIETCArOAs1adogKB7i0WcpkDkAdjHpweCdqAPr/Eq2n9hFn+zIIoAqNWYrIH4iIOyAV5iKYpuY61sgG6sRtFdfCkbYAjzUXQLm2UC9OAdBqLoQpwNTRnyFOE5vjXpgjG8iPYjfMj6+2DPA5ASr7rnPU5SHB4LIAyj0IbHWRB5ABodQVUjpH8Eg3HhGnO4bAaRB6DRJKyPP4HxuPgV62UDdOIzenGB6bIBgl6YBWEmhLvgbTsAltGPn5gpG2C4RnQvvg8aMhRZhKELRvEGXbiLkzG8lAoByGrpenvhd0EqwE1svZ0Uh5QjyHqUVnWu8COO4D8p4ql3QWqslvalZKClwKlOzwBtz8B/MENUIcUdzLQAAAAASUVORK5CYII=",
  alt: ""
}
  , zmt = {
  width: "14",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAaRJREFUWEftlrFLllEUh58nwUUKp8D8B8rSqaHRwQJdChOniIZwbUjHtsBFGtqkoaGtwEEwiBxEGhpy06ChoYJaE6QcxBMX7gcin773ta/3a/CO99xzfs973nPPPdLlZZf1OQX4/zMQES8r6mQf+Ap8AJbUvTp1VZmBiIgaAb8Ad9R3pT6dBki6u8C4ulYCUQfglTp9OGhEnAEuAbPAvWz/DFxRE8yx668BDkaPiOcHIG6rS00DXAY2s+hT9UHTAOeA7Sz6TJ1pGmAMeJtFH6uPGgOIiH5gHRjOolfVjU4CvAeetAnYA1wE7gOD2b6s3qwST/Y6t6AkXuvMdXW1xOFfAfwGptTXVRB1AI76BS2NC8AtYDRv/ARG1G/HQdQBaNsJ23TGBeBh3l9Q55oG6AXSV58HPqmpQI9cHc9AUoqIN8AN4Jfa1w2ALWAI+Kim9txcBiJiAljJii/Uu40ARMQAMAnMA2eBNBldq+qGdWqg6koftnf8LSgF2EnDibpY4lCSgaqhtKXzA0iPz6r6vUS86C0oDXTSc5UZOGngUr9TgK5n4A+Qbrohs7NxGwAAAABJRU5ErkJggg==",
  alt: ""
}
  , Kmt = {
  width: "14",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAUBJREFUWEft1j0sBUEUhuHnKuiolSIqUaKkFK1ORKHwUyEqEZXQSaj8FAoSnRYlJTWViFJNR4HMzRQbze7sxt5I7kmm2Tlzvvd8MzuZhhZHo8X62gD/0oHlgufmCZd5uWUcOM8rGufvsJ+X+y8Bsk114YTm33SPvbyOf8+XcSBbox9b8cMFwkiKqgDjmI+KofvgQlJUBZjFRFRcw2uSety71DXZ/A0M4hNz+EotVtWBQ3TjBQEmOaoA9OAgKt7iKFm94hYMYT2KnuGqboBJzETRHTzUDbCAsSi6hLe6AbbRh3cslhEPa8oewo54BXfiEQGmVJQF6MVuVLzGaSn1Cg6MYCWKHuOmboAphBFiE891A6xiGN/xCv74a4DwDBstKDJdMK+ZVvQQthwg3HoDBTvLfQdm6xR1oKB2eloboO3ADyGFKyHq4AdRAAAAAElFTkSuQmCC",
  alt: ""
}
  , Wmt = {
  width: "14",
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAU5JREFUWEftlk0uBUEURs8xlJiyAlaAxJgV+JtjA94KsAFsAHPCBjCWYAWswJtKDF25SUnkTbq7JM1L3jfsul3fqZsvt0r+WP6xPxOA8etARFy2zM2DetJU27kDERFNm5b1K3W7qXb8AH6eKCKmgXdgCrhWN5tOPLreuQMjAEvAY/l2qB71DbALnBXTDfWmb4BM+X4xXVBf+wa4A1aBD2BG/ewb4A2YBZ7VzENnVYcwItI4AVIXauahs34DsAbcFseBetrZHepvw4gYAMfFdE297xvgHNgppnPqsG+AJ2ARGKpzNeb5T1UGIiJHb47gHMX3auahSrUA88BLcTxVMw9VqgVYz8unOO6pmYcq1QIcAIfFcVnNPFSpFiBPn13I0ZsjOEdxlVoBlGfYVhsHtdWe33u1Kv4PAJnylZYdaHwH/tynVQfaGNfWTAAmHfgCgsZtIVHIgYAAAAAASUVORK5CYII=",
  alt: ""
}
  , Gmt = {
  class: "m-t-base colorPicker"
}
  , qmt = Qvt((()=>Ma("span", {
  class: "name"
}, "对齐方式", -1)))
  , Ymt = {
  class: "flex-box"
}
  , Xmt = {
  class: "m-t-base flex-box"
}
  , Qmt = {
  class: "m-t-base"
}
  , Jmt = {
  key: 1
}
  , Zmt = Qvt((()=>Ma("div", {
  class: "stage-setting-title"
}, "数字人设置", -1)))
  , eyt = {
  class: "m-t-base"
}
  , tyt = Qvt((()=>Ma("div", null, "位置", -1)))
  , nyt = {
  class: "input-group"
}
  , ryt = Qvt((()=>Ma("span", null, "X", -1)))
  , oyt = {
  class: "input-group"
}
  , ayt = Qvt((()=>Ma("span", null, "Y", -1)))
  , iyt = {
  class: "m-t-base"
}
  , syt = Qvt((()=>Ma("div", null, "大小", -1)))
  , lyt = {
  class: "input-group"
}
  , uyt = Qvt((()=>Ma("span", null, "W", -1)))
  , cyt = {
  class: "input-group"
}
  , dyt = Qvt((()=>Ma("span", null, "H", -1)))
  , fyt = {
  class: "input-group"
}
  , pyt = {
  style: {
    width: "180px"
  }
}
  , hyt = {
  key: 2
}
  , vyt = Qvt((()=>Ma("div", {
  class: "stage-setting-title"
}, "场景设置", -1)))
  , gyt = {
  class: "stage-setting"
}
  , myt = Qvt((()=>Ma("div", null, "背景", -1)))
  , yyt = {
  class: "stage-bg-view"
}
  , byt = ["src"]
  , wyt = {
  class: "btn-box"
}
  , xyt = {
  class: "rightbar"
}
  , Syt = ["onClick"]
  , Eyt = ["src"]
  , Ayt = {
  style: {
    "margin-top": "5px"
  }
}
  , Cyt = {
  class: "video-header"
}
  , kyt = {
  class: "arrowLeft"
}
  , Tyt = Qvt((()=>Ma("span", {
  style: {
    "margin-left": "5px"
  }
}, "返回首页", -1)))
  , Dyt = {
  class: "work-info"
}
  , Oyt = Qvt((()=>Ma("div", {
  class: "header"
}, "作品信息", -1)))
  , _yt = {
  class: "info-con"
}
  , Ryt = {
  class: "info-item"
}
  , Lyt = Qvt((()=>Ma("span", {
  class: "label"
}, "作品名称", -1)))
  , Iyt = {
  class: "info-text"
}
  , Pyt = {
  class: "info-item"
}
  , Fyt = Qvt((()=>Ma("span", {
  class: "label"
}, "作品时长", -1)))
  , Byt = {
  class: "info-text"
}
  , Nyt = {
  class: "info-item"
}
  , Myt = Qvt((()=>Ma("span", {
  class: "label"
}, "分辨率", -1)))
  , jyt = {
  class: "info-text"
}
  , Vyt = {
  class: "info-item"
}
  , Uyt = Qvt((()=>Ma("span", {
  class: "label"
}, "宽高比", -1)))
  , $yt = {
  class: "info-text"
}
  , Hyt = {
  class: "text-center"
}
  , zyt = vr({
  __name: "Video",
  setup(e) {
    const n = Ft(0)
      , {globalData: r} = NX()
      , o = Ft(!1)
      , {editorRef: a, updateTime: i, updateVoice: s, insertPause: l, showSelectVoiceBox: u, pauseSettingObj: c, voiceSettingObj: d, getEditorText: f, handleBlur: p, parserEditorValueHtml: h} = Xvt()
      , v = Ft(0)
      , g = Ft(!1)
      , m = Zu()
      , y = Ft(0)
      , b = Ft(!1)
      , w = Ft(!1)
      , x = pG()
      , {tabList: S, showTab: E} = function() {
      const e = Ft({
        current: {
          name: "",
          value: "",
          icon: "",
          activeIcon: ""
        },
        list: [{
          name: "背景",
          value: "background",
          icon: pvt,
          activeIcon: hvt
        }, {
          name: "数字人",
          value: "vPersonList",
          icon: vvt,
          activeIcon: gvt,
          children: [{
            name: "公共",
            value: "free"
          }, {
            name: "定制",
            value: "customize"
          }]
        }, {
          name: "录音",
          value: "music",
          icon: "/tabs/voiceprint-line@2x.png",
          activeIcon: "/tabs/voiceprint-fill@2x.png",
          children: [{
            name: "旁白",
            value: "music1"
          }, {
            name: "背景音",
            value: "music2"
          }]
        }]
      });
      return {
        tabList: e,
        showTab: t=>{
          e.value.current = t
        }
      }
    }()
      , A = Ft("style")
      , C = dvt()
      , k = mpt()
      , T = Ju()
      , D = Ft("未命名视频")
      , O = Ft("")
      , _ = Ft()
      , R = Ft()
      , L = Ft("160,90")
      , I = Ft(!1)
      , P = Ft("录音内容识别中")
      , F = Ft({})
      , B = Ft(!1)
      , N = Ft(!1)
      , M = Ft()
      , j = Ft({
      top: "0",
      left: "0",
      width: "0",
      height: "0"
    })
      , V = Ft([{
      microsoft_name: "zh-CN",
      name: "普通话"
    }])
      , U = Ft({
      "speed-setting": !1,
      "insert-pause": !1
    })
      , $ = e=>{
      U.value[e] = !U.value[e]
    }
      , H = bt({
      isPreview: !1,
      data: {
        assets_url: "",
        name: "",
        duration: "",
        resolution: "",
        align: "",
        cover: ""
      },
      loading: !1,
      show: !1
    })
      , K = Ft(0)
      , W = ()=>(new Date).getTime() + "_" + K.value++
      , G = Ft([{
      name: "思源宋体",
      font: "SiYuan SimSun",
      value: "https://digital-person-daily.oss-cn-hangzhou.aliyuncs.com/common/font/ttf/SiYuanSongTi.ttf"
    }, {
      name: "思源黑体",
      font: "SiYuan Heiti",
      value: "https://digital-person-daily.oss-cn-hangzhou.aliyuncs.com/common/font/ttf/SiYuanHeiTi.ttf"
    }, {
      name: "微软雅黑",
      font: "Microsoft YaHei",
      value: "https://digital-person-daily.oss-cn-hangzhou.aliyuncs.com/common/font/ttf/yahei.ttf"
    }, {
      name: "圆体简常规体",
      font: "Yuanti SC",
      value: "https://digital-person-daily.oss-cn-hangzhou.aliyuncs.com/common/font/ttf/Yuanti.ttc"
    }, {
      name: "阿里巴巴普惠体",
      font: "AlibabaPuHuiTi",
      value: "https://digital-person-daily.oss-cn-hangzhou.aliyuncs.com/common/font/ttf/Alibaba-PuHuiTi-Regular.ttf"
    }, {
      name: "楷体",
      font: "KaiTi",
      value: "https://digital-person-daily.oss-cn-hangzhou.aliyuncs.com/common/font/ttf/KaiTi.ttf"
    }, {
      name: "宋体",
      font: "SimSun",
      value: "https://digital-person-daily.oss-cn-hangzhou.aliyuncs.com/common/font/ttf/SimSun.ttf"
    }])
      , q = yi((()=>{
        let e = new Map;
        for (let t = 0; t < G.value.length; t++)
          e.set(G.value[t].font, G.value[t].value);
        return e
      }
    ));
    class X {
      constructor(e, n) {
        if (t(this, "$id"),
          t(this, "type"),
          t(this, "text"),
          t(this, "textWidth"),
          t(this, "textHeight"),
          t(this, "image"),
          t(this, "boxPosition", [0, 0, 0, 0]),
          t(this, "padding", 0),
          t(this, "timelineIn", 0),
          t(this, "timelineOut", 0),
          t(this, "font", "AlibabaPuHuiTi"),
          t(this, "fontSize", 0),
          t(this, "fontFace", {
            underline: !1,
            bold: !1,
            italic: !1
          }),
          t(this, "fontColor", "#FFFFFF"),
          t(this, "strokeColor", "#000000"),
          n = n || {},
          this.type = e,
          this.image = n.image || new Image,
          this.$id = e + "_layer_" + W(),
          this.text = n.text || "",
          this.textWidth = 0,
          this.textHeight = 0,
          this.timelineIn = n.timelineIn || 0,
          this.timelineOut = n.timelineOut || 0,
        "font" === e)
          this.padding = 10,
            this.fontSize = 60 * y.value,
            this.fontLayerInitPosition();
        else if ("font" !== e && n.image) {
          this.padding = 0;
          let e = n.image.width
            , t = n.image.height
            , r = (this.boxPosition[3] = Math.round(.9 * R.value.height)) / t;
          this.boxPosition[2] = Math.round(e * r),
            this.imageLayerInitPosition()
        }
      }
      fontLayerInitPosition() {
        let e = R.value.getContext("2d");
        e.font = `${this.fontSize}px '${this.font}'`;
        let t = e.measureText(this.text)
          , n = t.width
          , r = t.actualBoundingBoxAscent + t.actualBoundingBoxDescent
          , o = R.value.width
          , a = R.value.height;
        this.boxPosition[0] = o / 2 - n / 2,
          this.boxPosition[1] = a - r - this.padding - 80,
          this.textWidth = n,
          this.textHeight = r
      }
      imageLayerInitPosition() {
        let e = parseFloat(getComputedStyle(R.value).width)
          , t = parseFloat(getComputedStyle(R.value).height)
          , n = this.boxPosition[2]
          , r = this.boxPosition[3];
        this.boxPosition[0] = e / 2 - n / 2,
          this.boxPosition[1] = Math.max(t - r, 0)
      }
      draw() {
        if (R.value) {
          let e = R.value.getContext("2d");
          if (this.image.src) {
            let[t,n,r,o] = this.boxPosition;
            e.drawImage(this.image, t, n, r, o);
            let a = document.getElementById("stageCanvas-" + se.activeIndex);
            if (a && this.image.src) {
              a.getContext("2d").drawImage(this.image, t, n, r, o)
            }
          } else
            "font" === this.type && le.value.currentShowFontLayerId === this.$id && "" !== this.text && this.drawSubtitle();
          le.value.activeLayerId === this.$id && ("font" === this.type && "" !== this.text || "font" !== this.type) && Me(this)
        }
      }
      drawSubtitle() {
        let e = R.value.getContext("2d")
          , t = `${this.fontSize}px "${this.font}"`;
        this.fontFace.bold && (t = "bold " + t),
        this.fontFace.italic && (t = "italic " + t),
          e.font = t;
        let n = e.measureText(this.text)
          , r = n.actualBoundingBoxAscent + n.actualBoundingBoxDescent
          , o = n.width;
        this.boxPosition[2] = o + 2 * this.padding,
          this.boxPosition[3] = r + 2 * this.padding,
          this.textWidth = o,
          this.textHeight = r;
        let {x: a, y: i} = this.calcFontRealPosition(e);
        e.save();
        let s = le.value.chooseParams.font.bgColor;
        if ("" !== s && (e.fillStyle = s,
          e.fillRect(a - this.padding, i - this.padding - n.actualBoundingBoxAscent, this.boxPosition[2], this.boxPosition[3])),
          e.fillStyle = this.fontColor,
          e.strokeStyle = this.strokeColor,
          e.lineCap = "round",
          e.lineJoin = "round",
          e.lineWidth = Math.floor(this.fontSize / 5),
          e.strokeText(this.text, a, i),
          e.fillText(this.text, a, i),
          this.fontFace.underline) {
          e.beginPath();
          let t = i - n.actualBoundingBoxAscent + r + e.lineWidth / 2;
          e.moveTo(a, t),
            e.lineWidth = 2,
            e.lineTo(a + o, t),
            e.stroke(),
            e.closePath()
        }
        e.restore()
      }
      calcFontRealPosition(e) {
        let t = e.measureText(this.text);
        return {
          x: this.boxPosition[0],
          y: this.boxPosition[1] + t.actualBoundingBoxAscent
        }
      }
    }
    class Q {
      constructor() {
        t(this, "$id"),
          t(this, "lang"),
          t(this, "chooseParams", {
            person: {
              image: new Image,
              data: {}
            },
            background: {
              itemObj: {},
              imgObj: {},
              type: "",
              align: ""
            },
            voice: {
              data: {},
              type: "",
              subtitle: []
            },
            font: {
              bgColor: ""
            }
          }),
          t(this, "activeLayerId", -1),
          t(this, "currentShowFontLayerId", -1),
          t(this, "layers", []),
          t(this, "audioTrack", {
            voiceSpeed: 1,
            durationList: [],
            duration: 0,
            url: ""
          }),
          t(this, "volume", 50),
          t(this, "lastVideoComposeParams", ""),
          t(this, "editorValueHtml", ""),
          t(this, "audioPlayState", !1),
          t(this, "audioCurrentTime", 0),
          this.$id = "stage_" + W(),
          this.lang = "zh-CN"
      }
      onCurrentChange(e) {
        let t = e * le.value.audioTrack.voiceSpeed;
        le.value.audioCurrentTime = e,
          Z.updateCurrentTime(t);
        let n = le.value.layers.filter((e=>"font" === e.type)).find((e=>e.timelineIn <= t && e.timelineOut >= t));
        n && ("font" === ie.value.type && (le.value.activeLayerId = -1),
          le.value.currentShowFontLayerId = n.$id,
          Ne())
      }
      updatePlayState() {
        this.audioTrack.url && (this.audioPlayState = !this.audioPlayState,
          this.audioPlayState ? (Z.setVolume(le.value.volume / 100),
            Z.play(this.audioTrack.url)) : Z.pause())
      }
      updateSpeed() {
        Z.setPlaybackRate(le.value.audioTrack.voiceSpeed)
      }
    }
    const J = e=>{
      MW({
        type: "error",
        message: e
      })
    }
      , Z = mvt({
      timeupdate(e) {
        let t = e.target.currentTime;
        le.value.audioCurrentTime = t / le.value.audioTrack.voiceSpeed,
        "font" === ie.value.type && (le.value.activeLayerId = -1);
        let n = le.value.currentShowFontLayerId
          , r = le.value.layers.filter((e=>"font" === e.type)).find((e=>e.timelineIn <= t && e.timelineOut >= t)) || {
          $id: n
        };
        le.value.currentShowFontLayerId = r.$id,
        n !== r.$id && Ne()
      },
      ended() {
        le.value.audioPlayState = !1,
          Z.updateCurrentTime(0);
        let e = le.value.layers.filter((e=>"font" === e.type))[0] || {
          $id: -1
        };
        le.value.currentShowFontLayerId = e.$id,
          Ne()
      }
    })
      , ee = e=>{
      var t;
      let n = new Q;
      return n.activeLayerId = -1,
        n.lastVideoComposeParams = e.lastVideoComposeParams,
        n.editorValueHtml = e.editorValueHtml,
        ke.choosePerson(e.chooseParams.person.data, n, null == (t = e.layers.find((e=>"person" === e.type))) ? void 0 : t.boxPosition),
        ke.chooseBackground(e.chooseParams.background, n),
        n.chooseParams.voice = JSON.parse(JSON.stringify(e.chooseParams.voice)),
        n.audioTrack = JSON.parse(JSON.stringify(e.audioTrack)),
        e.layers.filter((e=>"font" === e.type)).map((e=>{
            n.layers.push((e=>{
                let t = new X(null);
                for (let n in e) {
                  let r = e[n];
                  -1 === ["string", "number"].indexOf(typeof r) && (r = JSON.parse(JSON.stringify(r))),
                    t[n] = r
                }
                return t
              }
            )(e))
          }
        )),
        n.currentShowFontLayerId = e.currentShowFontLayerId,
        n
    }
      , ne = (e,t=2,n="0")=>(e + "").padStart(t, n)
      , re = (e,t=0)=>{
      if (0 === t)
        e = Math.ceil(e);
      else {
        let n = Math.pow(10, t);
        e = Math.ceil(e * n) / n
      }
      let n = ne(e % 60)
        , r = ne(Math.floor(e % 3600 / 60))
        , o = ne(Math.floor(e / 3600))
        , a = r + ":" + n;
      return "00" !== o && (a = o + ":" + a),
        a
    }
      , oe = yi((()=>re(Math.round(le.value.audioCurrentTime))))
      , ae = yi((()=>re(le.value.audioTrack.duration / le.value.audioTrack.voiceSpeed)))
      , ie = yi((()=>le.value.layers.find((e=>e.$id === le.value.activeLayerId)) || new X("")))
      , se = bt({
      activeIndex: 0,
      list: [new Q]
    })
      , le = yi((()=>se.list[se.activeIndex]))
      , ue = yi((()=>{
        let[e,t] = L.value.split(",").map((e=>parseFloat(e)));
        return [e, t]
      }
    ));
    Jn(yi((()=>le.value.volume)), (()=>{
        Z.setVolume(le.value.volume / 100)
      }
    ));
    const ce = e=>{
      se.activeIndex = e,
        Ne()
    }
      , de = (e,t)=>{
      t && t.stopPropagation();
      let n = new Q;
      ke.chooseVoice({
        item: F.value,
        type: "tts",
        subtitle: []
      }, n),
        e === se.list.length ? se.list.push(n) : se.list.splice(e + 1, 0, n)
    }
      , fe = ()=>{
      le.value.chooseParams.background = {
        align: "",
        imgObj: {},
        itemObj: {},
        type: ""
      }
    }
      , pe = Ft([])
      , he = ()=>{
      let e = new FormData;
      e.append("background_file", pe.value.pop().raw),
        oY.video.backgroundUpload(e).then((e=>{
            let t = e.data;
            ke.chooseBackground({
              itemObj: t,
              imgObj: t,
              type: "upload"
            }, le.value)
          }
        )).catch((()=>{
            J("图片上传失败了, 请检查网络或尝试重新上传")
          }
        ))
    }
      , ve = (e,t=["jpg", "png"])=>{
      let n = (e.name.split(".").pop() || "").toLowerCase()
        , r = -1 !== t.indexOf(n);
      if (!r) {
        let e = "只能上传" + t.join("、") + "格式的文件";
        MW(e)
      }
      return r
    }
      , ge = e=>{
      P.value = "文件上传中,请稍候",
        I.value = !0;
      let t = e.target.files[0];
      if (ve(t, ["mp3", "wav", "m4a", "flac"])) {
        let e = new FormData;
        e.append("audio_file", t),
          oY.video.audioUpload(e).then((e=>{
              let t = e.data || {};
              I.value = !1,
                hn((()=>{
                    ke.chooseVoice({
                      item: t,
                      type: "audio",
                      subtitle: []
                    }, le.value)
                  }
                ))
            }
          )).catch((e=>{
              J("录音上传失败了, 请检查网络或尝试重新上传")
            }
          ))
      }
      e.target.value = ""
    }
      , me = yi((()=>le.value.chooseParams))
      , ye = yi({
      get: ()=>ie.value.boxPosition,
      set(e) {
        ie.value.boxPosition = e
      }
    })
      , be = yi({
      get: ()=>Math.round(ye.value[0] / y.value),
      set(e) {
        ye.value[0] = e * y.value
      }
    })
      , we = yi({
      get: ()=>Math.round(ye.value[1] / y.value),
      set(e) {
        ye.value[1] = e * y.value
      }
    })
      , xe = yi({
      get: ()=>Math.round(ye.value[2] / y.value),
      set(e) {
        ye.value[2] = e * y.value
      }
    })
      , Se = yi({
      get: ()=>Math.round(ye.value[3] / y.value),
      set(e) {
        ye.value[3] = e * y.value
      }
    })
      , Ee = yi({
      get: ()=>Math.round(ie.value.fontSize / y.value),
      set(e) {
        ie.value.fontSize = e * y.value
      }
    })
      , Ae = (e,t)=>{
      e.chooseParams.voice.data = t.item,
        e.chooseParams.voice.type = t.type,
        e.chooseParams.voice.subtitle = t.subtitle
    }
      , Ce = (e,t)=>{
      if (e.audioTrack.duration = 0,
        e.audioTrack.url = "",
        e.audioTrack.durationList = [],
      "audio" === t.type)
        ((e,t)=>{
            I.value = !0,
              P.value = "录音内容识别中",
              oY.video.createSubtitle({
                url: t.item.assets_url
              }).then((n=>{
                  t.subtitle = n.data,
                    Ae(e, t);
                  let r = t.subtitle.map((e=>e.text));
                  e === le.value && a.value ? (a.value.selectAll(),
                    a.value.clear(),
                    a.value.insertText(r.join(""))) : e.editorValueHtml = r.join(""),
                    I.value = !1,
                    e.audioTrack.duration = e.chooseParams.voice.data.duration,
                    e.audioTrack.url = e.chooseParams.voice.data.assets_url,
                    MW({
                      type: "success",
                      message: "内容识别成功"
                    })
                }
              )).catch((e=>{
                  I.value = !1,
                    J("录音内容识别失败了")
                }
              ))
          }
        )(e, t);
      else {
        if ("yizhi" === t.item.source) {
          e.lang = t.item._checked_lang;
          let n = t.item.langList.find((e=>e.microsoftName === t.item._checked_lang));
          n && (V.value = [{
            name: n.name,
            microsoft_name: t.item._checked_lang
          }])
        } else
          e.lang = t.item._checked_lang,
            xt("minimax");
        Ae(e, t)
      }
    }
      , ke = {
      choosePerson(e, t, n) {
        t.chooseParams.person.image.src = e.cover,
          t.chooseParams.person.data = e,
          t.chooseParams.person.image.onload = ()=>{
            let e = t.layers.find((e=>"person" === e.type));
            e ? (e.image = t.chooseParams.person.image,
              e.imageLayerInitPosition()) : (e = new X("person",{
              image: t.chooseParams.person.image
            }),
              t.layers.unshift(e)),
            n && (e.boxPosition = n),
              t.activeLayerId = e.$id,
              Ne()
          }
      },
      chooseVoice(e, t) {
        if ("" !== t.chooseParams.voice.type && t.chooseParams.voice.type !== e.type) {
          let n = {
            title: "",
            content: ""
          };
          "tts" === e.type ? (n.title = "确定要应用当前音色吗？",
            n.content = "应用AI合成音后，「录音」中的内容和设置项将会被清空，需重新「合成声音」") : "audio" === e.type && (n.title = "确定要应用当前录音吗？",
            n.content = "应用录音后，AI合成音设置项将会被清空"),
            XW.alert(n.content, n.title, {
              showCancelButton: !0,
              cancelButtonText: "取消"
            }).then((()=>{
                a.value && a.value.clear(),
                  Ce(t, e)
              }
            ))
        } else
          Ce(t, e)
      },
      chooseVoiceUsingAll(e, t) {
        for (let n = 0; n < se.list.length; n++)
          Ce(se.list[n], e)
      },
      chooseBackground(e, t) {
        t.chooseParams.background = e
      }
    }
      , Te = e=>{
      let t = ke[e.name];
      t && t(e.value, le.value)
    }
      , De = e=>{
      let t = e.value.item
        , n = me.value.voice.data;
      n.template === t.template && n._checked_lang === t._checked_lang && n._checked_role === t._checked_role && n._checked_style === t._checked_style || Te(e)
    }
      , Oe = ()=>new Promise(((e,t)=>{
        oY.worker.getAudioList({
          name: ""
        }).then((t=>{
            var n, r, o, a;
            let i = (t.data || []).sort(((e,t)=>"minimax" === e.source ? -1 : 1))[0];
            if (!i.hasOwnProperty("_checked_role")) {
              let {roleList: e, langList: t, styleList: s} = i;
              i = Object.assign(i, {
                _checked_role: (null == (n = null == e ? void 0 : e[0]) ? void 0 : n.microsoftName) || "",
                _checked_lang: (null == (r = null == t ? void 0 : t.find((e=>"zh-CN" === e.microsoftName))) ? void 0 : r.microsoftName) || (null == (o = null == t ? void 0 : t[0]) ? void 0 : o.microsoftName) || "",
                _checked_style: (null == (a = null == s ? void 0 : s[0]) ? void 0 : a.microsoftName) || ""
              })
            }
            F.value = i,
            i && i.template && e()
          }
        )).catch((()=>{
            t()
          }
        ))
      }
    ));
    Jn(L, (()=>{
        Ne()
      }
    ));
    const _e = Ft([{
        label: "16:9",
        value: "160,90",
        align: "HORIZONTAL"
      }, {
        label: "9:16",
        value: "90,160",
        align: "VERTICAL"
      }])
      , Re = e=>{
        let t = 0;
        ie.value.image.src && (t = ie.value.image.width / ie.value.image.height),
        0 !== t && (2 === e ? ye.value[3] = Math.round(ye.value[2] / t) : 3 === e && (ye.value[2] = Math.round(ye.value[3] * t))),
          Ne()
      }
      , Le = ()=>{
        let e = ie.value;
        for (let t, n = 0; n < le.value.layers.length; n++)
          t = le.value.layers[n],
          "font" === t.type && (t.font = e.font,
            t.fontSize = e.fontSize,
            t.strokeColor = e.strokeColor,
            t.fontColor = e.fontColor,
            t.fontFace.bold = e.fontFace.bold,
            t.fontFace.italic = e.fontFace.italic,
            t.fontFace.underline = e.fontFace.underline,
            t.boxPosition[1] = e.boxPosition[1]);
        MW({
          type: "success",
          message: "字幕样式已同步"
        })
      }
      , Ie = (e,t)=>{
        ie.value[t] = e.target.value,
          Ne()
      }
      , Pe = e=>{
        let t = le.value.layers.filter((e=>"font" === e.type))
          , n = t.findIndex((e=>e.$id === le.value.currentShowFontLayerId))
          , r = t[n + e];
        r && (le.value.currentShowFontLayerId = r.$id,
          le.value.activeLayerId = r.$id,
          Ne())
      }
      , Fe = ()=>{
        XW({
          title: "提示",
          message: "确认要清空字幕吗？",
          showCancelButton: !0,
          cancelButtonText: "点错了",
          confirmButtonText: "确认"
        }).then((e=>{
            le.value.layers = le.value.layers.filter((e=>"font" !== e.type)),
              Ne()
          }
        ))
      }
      , Be = e=>{
        let t = le.value.layers.find((e=>e.$id === le.value.currentShowFontLayerId))
          , n = R.value.getContext("2d").measureText(t.text)
          , r = n.width
          , o = n.actualBoundingBoxAscent + n.actualBoundingBoxDescent
          , a = R.value.width
          , i = R.value.height;
        switch (e) {
          case "left":
            t.boxPosition[0] = t.padding;
            break;
          case "center":
            t.boxPosition[0] = a / 2 - r / 2;
            break;
          case "right":
            t.boxPosition[0] = a - r - t.padding;
            break;
          case "top":
            t.boxPosition[1] = t.padding;
            break;
          case "middle":
            t.boxPosition[1] = i / 2 - o / 2;
            break;
          case "bottom":
            t.boxPosition[1] = i - o - t.padding;
            break;
          case "underline":
            t.fontFace.underline = !t.fontFace.underline;
            break;
          case "bold":
            t.fontFace.bold = !t.fontFace.bold;
            break;
          case "italic":
            t.fontFace.italic = !t.fontFace.italic
        }
        Ne()
      }
      , Ne = ()=>{
        hn((()=>{
            if (R.value) {
              R.value.getContext("2d").clearRect(0, 0, ue.value[0], ue.value[1]);
              let e = document.getElementById("stageCanvas-" + se.activeIndex);
              if (e) {
                e.getContext("2d").clearRect(0, 0, ue.value[0], ue.value[1])
              }
              le.value.layers.forEach((e=>{
                  e.draw()
                }
              ))
            }
          }
        ))
      }
      , Me = e=>{
        let t = R.value.getBoundingClientRect()
          , n = M.value.getBoundingClientRect()
          , [r,o,a,i] = e.boxPosition
          , s = "font" === e.type ? e.padding : 0;
        j.value = {
          top: o + t.top - n.top - s + "px",
          left: r + t.left - n.left - s + "px",
          width: a + "px",
          height: i + "px"
        }
      }
      , je = e=>{
        let t = M.value.getBoundingClientRect()
          , n = e.clientX - t.left
          , r = e.clientY - t.top;
        if (M.value.style.cursor = "default",
          !ie.value.type)
          return;
        let o = parseFloat(j.value.left)
          , a = parseFloat(j.value.top)
          , i = parseFloat(j.value.width)
          , s = parseFloat(j.value.height);
        "font" !== ie.value.type && (n >= o - 5 && n <= o + 6 && r >= a - 5 && r <= a + 6 ? M.value.style.cursor = "nwse-resize" : n >= o + i - 5 && n <= o + i + 6 && r >= a - 5 && r <= a + 6 || n >= o - 5 && n <= o + 6 && r >= a + s - 5 && r <= a + s + 6 ? M.value.style.cursor = "nesw-resize" : n >= o + i - 5 && n <= o + i + 6 && r >= a + s - 5 && r <= a + s + 6 && (M.value.style.cursor = "nwse-resize")),
        n >= o && n <= o + i && r >= a && r <= a + s && (M.value.style.cursor = "move")
      }
      , Ve = e=>{
        e.preventDefault(),
          e.offsetX,
          e.offsetY
      }
      , Ue = e=>{
        if (!e.target.closest(".videoWrap"))
          return;
        let t = R.value.getBoundingClientRect();
        const n = e.clientX - t.left
          , r = e.clientY - t.top;
        let o = le.value.layers.slice().reverse().find((e=>{
            let t = e.boxPosition
              , o = t[0] - e.padding
              , a = t[1] - e.padding;
            return n > o - 5 && n < o + t[2] + 6 && r > a - 5 && r < a + t[3] + 6 && ("font" !== e.type || "font" == e.type && e.$id === le.value.currentShowFontLayerId)
          }
        ));
        if (!o)
          return le.value.activeLayerId = -1,
            void Ne();
        let a = e=>{}
          , i = 1;
        le.value.activeLayerId = o.$id;
        let s = ie.value.padding
          , [l,u,c,d] = ye.value;
        if (l -= s,
          u -= s,
        ie.value.image.src && (i = ie.value.image.height / ie.value.image.width),
        n >= l - 5 && n <= l + 6 && r >= u - 5 && r <= u + 6)
          console.log("左上角"),
            a = e=>{
              const o = e.clientX - t.left
                , a = e.clientY - t.top
                , f = Math.max(n - o, r - a);
              ye.value = [l - f + s, u - f * i + s, c + f, d + f * i].map((e=>Math.round(e))),
                Ne()
            }
            ,
            Ne();
        else if (n >= l + c - 5 && n <= l + c + 6 && r >= u - 5 && r <= u + 6)
          console.log("右上角"),
            a = e=>{
              const o = e.clientX - t.left
                , a = e.clientY - t.top
                , f = Math.max(o - n, r - a);
              ye.value = [l + s, u - f * i + s, c + f, d + f * i].map((e=>Math.round(e))),
                Ne()
            }
            ,
            Ne();
        else if (n >= l - 5 && n <= l + 6 && r >= u + d - 5 && r <= u + d + 6)
          console.log("左下角"),
            a = e=>{
              const o = e.clientX - t.left
                , a = e.clientY - t.top
                , f = Math.max(n - o, a - r);
              ye.value = [l - f + s, u + s, c + f, d + f * i],
                Ne()
            }
            ,
            Ne();
        else if (n >= l + c - 5 && n <= l + c + 6 && r >= u + d - 5 && r <= u + d + 6)
          console.log("右下角"),
            a = e=>{
              const o = e.clientX - t.left
                , a = e.clientY - t.top
                , f = Math.max(o - n, a - r);
              ye.value = [l + s, u + s, c + f, d + f * i].map((e=>Math.round(e))),
                Ne()
            }
            ,
            Ne();
        else {
          if (!(n >= l && n <= l + c && r >= u && r <= u + d))
            return void Ne();
          console.log("移动"),
            a = e=>{
              const o = e.clientX - t.left
                , a = e.clientY - t.top;
              ye.value[0] = Math.round(l - (n - o) + s),
                ye.value[1] = Math.round(u - (r - a) + s),
                Ne()
            }
            ,
            Ne()
        }
        document.body.addEventListener("mousemove", a);
        const f = ()=>{
            document.body.removeEventListener("mousemove", a),
              document.body.removeEventListener("mouseup", f)
          }
        ;
        document.body.addEventListener("mouseup", f)
      }
      , $e = ()=>{
        let e = le.value.chooseParams.background;
        se.list.forEach((t=>{
            t.chooseParams.background.align = e.align,
              t.chooseParams.background.imgObj = e.imgObj,
              t.chooseParams.background.itemObj = e.itemObj,
              t.chooseParams.background.type = e.type
          }
        ))
      }
      , He = e=>{
        a.value = e,
          e.getEditableContainer().addEventListener("click", (e=>{
              -1 !== e.target.className.indexOf("btn-upload") ? document.getElementById("yb-fileUpload").click() : -1 !== e.target.className.indexOf("btn-create") ? b.value && ft() : -1 !== e.target.className.indexOf("insert-pause") || e.target.className.indexOf("voice-select")
            }
          ))
      }
      , ze = {
        placeholder: `<span style="color: rgba(255,255,255,0.5);font-style:normal;font-size:16px;">请输入讲解内容: 你还可以直接 <span class="btn-upload">上传录音</span> <span style="display:${b.value ? "inline" : "none"}">或进行 <span class="btn-create ${b.value ? "" : "btn-disabled"}">抖音链接内容生成</span></span></span>`
      }
      , Ke = e=>{}
      , We = (e,t,n)=>{
        const r = t.clipboardData.getData("text/html");
        let o = document.createElement("div");
        o.innerHTML = r;
        let a = o.children;
        if (a.length > 0 && [].every.call(a, (e=>e.hasAttribute("data-slate-node"))))
          return !0;
        let i = t.clipboardData.getData("text/plain");
        e.insertText(i),
          t.preventDefault(),
          n(!1)
      }
      , Ge = ()=>{
        let e = le.value.chooseParams.voice.data;
        return {
          isVideoWork: !0,
          voice: e.template,
          speechStr: le.value.audioTrack.voiceSpeed.toFixed(2),
          textList: et(le.value),
          oriText: tt(le.value),
          inputLang: le.value.lang,
          sourceType: e.source_type,
          role: e._checked_role,
          lang: e._checked_lang,
          style: e._checked_style,
          volume: 100
        }
      }
      , qe = ()=>{
        let e = Ge();
        const t = AW.service({
          lock: !0,
          text: "声音合成中...",
          background: "rgba(0, 0, 0, 0.7)"
        });
        "yizhi" === le.value.chooseParams.voice.data.source ? oY.video.digitalVideoCompose(e).then((n=>{
            le.value.audioTrack = {
              ...n.data,
              ...e,
              voiceSpeed: Number(e.speechStr)
            },
              le.value.lastVideoComposeParams = JSON.stringify(e),
              t.close()
          }
        )).catch((()=>{
            J("声音合成失败, 请检查网络或尝试重新合成"),
              t.close()
          }
        )) : "minimax" === le.value.chooseParams.voice.data.source && oY.video.composeMinimax(e).then((n=>{
            le.value.lastVideoComposeParams = JSON.stringify(e),
              le.value.chooseParams.voice.subtitle = n.data.subtitleList,
              le.value.audioTrack.duration = n.data.duration,
              le.value.audioTrack.url = n.data.url,
              MW({
                type: "success",
                message: "语音合成成功"
              }),
              t.close()
          }
        )).catch((()=>{
            J("声音合成失败, 请检查网络或尝试重新合成"),
              t.close()
          }
        ))
      }
      , Ye = e=>{
        N.value = !1;
        let t = AW.service({
          lock: !0,
          text: "内容生成中，请稍后",
          background: "rgba(0, 0, 0, 0.7)"
        });
        oY.video.parseDouYinVideo(e).then((e=>{
            let n = e.data || {}
              , r = n.text || ""
              , o = n.fileUploadVO || null;
            a.value.focus(!0),
            "" !== f() && a.value.insertBreak(),
              a.value.insertText(r),
              o ? oY.video.saveAudio({
                fullUrl: o.fullUrl
              }).then((e=>{
                  t.close(),
                    me.value.voice.data = e.data,
                    me.value.voice.type = "dy",
                    me.value.voice.subtitle = [],
                    le.value.audioTrack.url = e.data.assets_url,
                    le.value.audioTrack.duration = e.data.duration
                }
              )).catch((()=>{
                  t.close()
                }
              )) : t.close()
          }
        )).catch((()=>{
            t.close(),
              J("抖音链接解析失败了")
          }
        ))
      }
      , Xe = e=>{
        e.map(((e,t)=>{
            let n = new X("font",{
              text: e.text,
              timelineIn: e.beginTime / 1e3,
              timelineOut: e.endTime / 1e3
            });
            le.value.layers.push(n),
            0 === t && (le.value.activeLayerId = n.$id,
              le.value.currentShowFontLayerId = n.$id)
          }
        )),
          MW({
            type: "success",
            message: "字幕生成成功"
          }),
          Ne()
      }
      , Qe = ()=>{
        o.value = !1;
        let e = le.value.layers.filter((e=>"font" !== e.type));
        Je(e)
      }
      , Je = e=>{
        var t, n;
        le.value.layers = e,
          "audio" === me.value.voice.type ? Xe(me.value.voice.subtitle) : "yizhi" === le.value.chooseParams.voice.data.source ? "tts" !== me.value.voice.type && "dy" !== me.value.voice.type || (I.value = !0,
            P.value = "字幕内容生成中",
            (t = tt(le.value).join(""),
              n = le.value.audioTrack.url,
              oY.video.subtitleComposeTTS({
                sourceText: t,
                ttsUrl: n
              })).then((e=>{
                Xe(e.data),
                  I.value = !1
              }
            )).catch((()=>{
                I.value = !1,
                  J("字幕内容生成失败, 请检查网络或尝试重新生成")
              }
            ))) : "minimax" === le.value.chooseParams.voice.data.source && Xe(me.value.voice.subtitle)
      }
      , Ze = ()=>{
        let e = le.value.layers.filter((e=>"font" !== e.type));
        e.length !== le.value.layers.length ? o.value = !0 : Je(e)
      }
      , et = e=>{
        let t = []
          , n = h(e.editorValueHtml)
          , r = le.value.chooseParams.voice.data.source;
        for (let o, a = 0; a < n.length; a++) {
          o = n[a];
          let e = [];
          for (let t = 0; t < o.length; t++)
            if ("text" === o[t].type)
              e.push(o[t].value);
            else if ("insert-pause" === o[t].type)
              "minimax" === r ? e.push(`<#${parseFloat(o[t].value)}#>`) : "yizhi" === r && e.push(`<break time="${1e3 * parseFloat(o[t].value)}ms"></break>`);
            else if ("voice-select" === o[t].type) {
              let[n,r] = o[t].value.split(" ");
              e.push(`<font voice="${r}">${n}</font>`)
            }
          "" !== e.join("") && t.push("<speak>" + e.join("") + "</speak>")
        }
        return t
      }
      , tt = e=>{
        let t = []
          , n = h(e.editorValueHtml);
        for (let r, o = 0; o < n.length; o++) {
          r = n[o];
          let e = [];
          for (let t = 0; t < r.length; t++)
            "text" === r[t].type && e.push(r[t].value);
          "" !== e.join("") && t.push(e.join(""))
        }
        return t
      }
      , nt = ()=>se.list.map(((e,t)=>{
          let n = (e=>e.layers.filter((e=>"font" === e.type)).map((t=>({
            x: (t.boxPosition[0] + t.textWidth / 2) / y.value,
            y: t.boxPosition[1] / y.value - t.textHeight / 2,
            z: 100,
            font: t.font,
            speed: e.audioTrack.voiceSpeed.toFixed(1),
            content: t.text,
            fontUrl: q.value.get(t.font),
            fontFace: t.fontFace,
            fontSize: Math.floor(t.fontSize / y.value),
            fontColor: t.fontColor,
            backColour: e.chooseParams.font.bgColor,
            outline: Math.floor(t.fontSize / 5),
            outlineColour: t.strokeColor,
            timelineIn: t.timelineIn,
            timelineOut: t.timelineOut,
            textHeight: Math.floor(t.textHeight)
          }))))(e)
            , r = (e=>[{
            duration: e.audioTrack.duration,
            mediaURL: e.audioTrack.url,
            speed: e.audioTrack.voiceSpeed.toFixed(1),
            volume: e.volume,
            durationList: e.audioTrack.durationList
          }])(e);
          return {
            order_by: t,
            model_audio_code: e.chooseParams.voice.data.model_audio_code || "",
            speech_speed: e.audioTrack.voiceSpeed,
            track: {
              background_code: e.chooseParams.background.imgObj.background_code,
              model_person: e.layers.filter((e=>"person" === e.type)).map((t=>({
                x: Math.round(t.boxPosition[0] / y.value),
                y: Math.round(t.boxPosition[1] / y.value),
                w: Math.round(t.boxPosition[2] / y.value),
                h: Math.round(t.boxPosition[3] / y.value),
                scale: y.value,
                speed: e.audioTrack.voiceSpeed.toFixed(1),
                model_person_code: e.chooseParams.person.data.model_person_code
              }))),
              subtitleTrack: n,
              audioTrack: r
            }
          }
        }
      ))
      , rt = e=>{
        let t = {
          pass: !0,
          message: ""
        };
        for (let n = 0; n < se.list.length; n++) {
          let e = se.list[n];
          if ("" === e.chooseParams.voice.type)
            return t.pass = !1,
              t.message = `场景${n + 1}未选择配音`,
              t;
          if ("tts" === e.chooseParams.voice.type) {
            let r;
            if ("yizhi" === e.chooseParams.voice.data.source ? r = e.audioTrack.durationList : "minimax" === e.chooseParams.voice.data.source && (r = e.chooseParams.voice.subtitle),
            !r || 0 === r.length)
              return t.pass = !1,
                t.message = `场景${n + 1}未合成声音`,
                t
          }
          if (!e.chooseParams.background.imgObj.assets_url)
            return t.pass = !1,
              t.message = `场景${n + 1}未选择背景图片`,
              t;
          if (!e.layers.find((e=>"person" === e.type)))
            return t.pass = !1,
              t.message = `场景${n + 1}未选择数字人`,
              t
        }
        return t
      }
      , ot = ()=>{
        let e = se.list.reduce(((e,t)=>e + t.audioTrack.duration), 0);
        Math.ceil(e * r.unit_price);
        let t = rt();
        t.pass ? B.value = !0 : J(t.message)
      }
    ;
    yi((()=>"功能正在努力研发中"));
    const at = async({name: e, resolution: t})=>{
      let n = (await ht()).data.video_code;
      C.setVideoCode(n),
        console.log(n),
        D.value = e;
      let[r,o] = ue.value
        , a = r / o > 1 ? "HORIZONTAL" : "VERTICAL"
        , i = nt()
        , s = {
        video_code: n,
        type: "audio",
        name: D.value,
        align: a,
        is_preview: !1,
        scenes: i,
        resolution: t
      };
      H.show = !0,
        H.loading = !0,
        H.data = {
          assets_url: "",
          name: "",
          duration: "",
          resolution: t,
          align: a,
          cover: ""
        },
        H.isPreview = !1,
        wt(),
        oY.video.createTask(s).then((e=>{
            var t;
            let n = null == (t = null == e ? void 0 : e.data) ? void 0 : t.video_code;
            n && (oY.login.getUserInfo().then((e=>{
                x.setUserInfo(e.data)
              }
            )),
              it(n))
          }
        )).catch((e=>{
            J("视频合成失败"),
              H.show = !1
          }
        ))
    }
      , it = (e,t,n=5e3)=>{
      setTimeout((()=>{
          "/video" === m.path && oY.video.videoTaskDetail({
            video_code: e
          }).then((t=>{
              let n = t.data || {};
              H.data.resolution = n.resolution || "",
                H.data.duration = n.duration || "",
                "IN_PROGRESS" === n.status ? it(e) : "SUCCESS" === n.status ? (H.loading = !1,
                  H.data = n) : (H.show = !1,
                  XW.alert("视频合成失败了", "提示", {
                    autofocus: !1,
                    confirmButtonText: "知道了"
                  }))
            }
          )).catch((e=>{
              H.show = !1,
                J("查询视频合成进度失败")
            }
          ))
        }
      ), n)
    }
      , st = yi((()=>{
        let e = "" !== le.value.editorValueHtml && "" !== f()
          , t = ""
          , n = JSON.stringify(Ge());
        return le.value.lastVideoComposeParams === n && (t = "已合成最新的讲解内容"),
        e || (t = "请先输入讲解内容"),
          t
      }
    ))
      , lt = yi((()=>{
        let e = ""
          , t = JSON.stringify(Ge());
        return "tts" === le.value.chooseParams.voice.type ? "" !== le.value.lastVideoComposeParams && le.value.lastVideoComposeParams === t || (e = "请先合成声音后再生成字幕") : le.value.chooseParams.voice.type,
          e
      }
    ))
      , ut = ()=>{
      let[e,t] = ue.value;
      return {
        transform: `scale(${"horizontal" === (e / t > 1 ? "horizontal" : "vertical") ? 126 / e : 126 / t})`,
        width: e + "px",
        height: t + "px"
      }
    }
      , ct = ()=>{
      let[e,t] = ue.value
        , n = "horizontal" === (e / t > 1 ? "horizontal" : "vertical")
        , r = 126;
      return {
        marginTop: n ? (r - t * (r / e)) / 2 + "px" : 0,
        marginLeft: n ? 0 : (r - e * (r / t)) / 2 + "px"
      }
    }
      , dt = ()=>{
      H.show = !1,
        T.push("/home/worker")
    }
      , ft = ()=>{
      N.value = !0
    }
      , pt = e=>{
      let t = e + "";
      return -1 !== t.indexOf(".") && (t = Number(t).toFixed(2)),
        t
    }
      , ht = ()=>{
      let e = JSON.parse(JSON.stringify(se))
        , t = _e.value.find((e=>e.value === L.value));
      return e.canvasSizeLabel = t.label,
        e.align = t.align,
        oY.video.saveDraft({
          video_code: C.chooseParams.video_code,
          draft_data: JSON.stringify(e),
          cover: le.value.chooseParams.person.image.src,
          name: D.value
        })
    }
      , vt = e=>new Promise((t=>{
        Promise.all(e.filter((e=>!!e)).map((e=>new Promise(((t,n)=>{
            let r = new Image;
            r.src = e,
              r.onload = ()=>{
                t()
              }
              ,
              r.onerror = n
          }
        ))))).finally((()=>{
            t()
          }
        ))
      }
    ))
      , gt = e=>new Promise((t=>{
        setTimeout((()=>{
            t()
          }
        ), e)
      }
    ));
    (()=>{
        let e = G.value;
        for (let t = 0; t < e.length; t++) {
          let n = e[t];
          new FontFace(n.font,`url(${n.value})`).load().then((e=>{
              var t;
              document.fonts.add(e),
                t = e.family,
              le.value.layers.filter((e=>"font" === e.type && e.font === t && e.$id === le.value.currentShowFontLayerId)).length > 0 && Ne()
            }
          ))
        }
      }
    )();
    const mt = (e=0)=>{
        _.value = setTimeout((()=>{
            ht().then((e=>{
                C.setVideoCode(e.data.video_code);
                let t = new Date;
                O.value = `${ne(t.getHours(), 2)}:${ne(t.getMinutes(), 2)}`,
                  mt()
              }
            )).catch((()=>{
                J("自动保存失败"),
                ++e <= 3 && mt(e)
              }
            ))
          }
        ), 1e4)
      }
      , yt = ()=>{
        wt(),
          ht().then((e=>{
              C.setVideoCode(e.data.video_code);
              let t = new Date;
              O.value = `${ne(t.getHours(), 2)}:${ne(t.getMinutes(), 2)}`,
                MW({
                  message: "保存成功",
                  type: "success"
                })
            }
          )).finally((()=>{
              mt()
            }
          ))
      }
      , wt = ()=>{
        clearTimeout(_.value),
          _.value = null
      }
      , xt = e=>{
        oY.video.getLangList({
          source: e
        }).then((e=>{
            V.value = e.data || []
          }
        ))
      }
    ;
    return Lr((()=>{
        (()=>{
            let e, t = document.querySelector("#videoView"), n = getComputedStyle(t), r = parseFloat(n.height), o = parseFloat(n.width);
            e = o < 16 / 9 * r ? [o, r * (o / (16 / 9 * r))].join(",") : [16 * r / 9, r].join(",");
            let a = [9 / 16 * r, r].join(",");
            _e.value = [{
              label: "16:9",
              value: e,
              align: "HORIZONTAL"
            }, {
              label: "9:16",
              value: a,
              align: "VERTICAL"
            }];
            let i = C.chooseParams.size || "16:9"
              , s = _e.value.find((e=>e.label === i));
            L.value = s.value,
              y.value = "HORIZONTAL" === s.align ? Number(e.split(",")[0]) / 1920 : Number(a.split(",")[0]) / 1080
          }
        )(),
          (()=>{
              let e = document.createElement("input");
              e.id = "yb-fileUpload",
                e.setAttribute("type", "file"),
                e.style.width = "0px",
                e.style.height = "0px",
                e.style.opacity = "0",
                e.style.overflow = "hidden",
                e.style.display = "none",
                document.body.appendChild(e),
                e.addEventListener("change", ge)
            }
          )(),
          xt("minimax"),
          g.value = !0,
          document.body.addEventListener("mousedown", Ue),
          M.value.addEventListener("mousemove", je),
          C.chooseParams.video_code ? (Oe(),
            new Promise(((e,t)=>{
                let n = C.chooseParams.video_code;
                oY.video.getDraft({
                  video_code: n
                }).then((t=>{
                    let n = JSON.parse(t.data.draft_data)
                      , r = n.list.map((e=>[e.chooseParams.background.imgObj.assets_url, e.chooseParams.person.data.cover])).flat(2);
                    vt(r).then((()=>{
                        var r;
                        se.list = n.list.map((e=>ee(e))),
                          D.value = (null == (r = t.data) ? void 0 : r.name) || D.value,
                        n.canvasSizeLabel && (L.value = _e.value.find((e=>e.label === n.canvasSizeLabel)).value),
                          setTimeout((async()=>{
                              for (let e = 0; e < se.list.length; e++)
                                e !== n.activeIndex && (ce(e),
                                  await gt(20));
                              ce(n.activeIndex),
                                g.value = !1,
                                e()
                            }
                          ), 0)
                      }
                    ))
                  }
                )).catch((()=>{
                    J("没有查到草稿相关信息"),
                      t()
                  }
                ))
              }
            )).then((()=>{
                mt(),
                  n.value++
              }
            ))) : C.chooseParams.person.model_person_code && vt([C.chooseParams.person.cover]).then((()=>{
              ke.choosePerson(C.chooseParams.person, le.value),
                Oe().then((()=>{
                    se.list.forEach((e=>{
                        e.chooseParams.voice.type || ke.chooseVoice({
                          item: F.value,
                          type: "tts",
                          subtitle: []
                        }, e)
                      }
                    )),
                      g.value = !1,
                      mt()
                  }
                ))
            }
          ))
      }
    )),
      Fr((()=>{
          wt(),
            document.body.removeEventListener("mousedown", Ue),
            M.value.removeEventListener("mousemove", je);
          const e = a.value;
          e && e.destroy();
          let t = document.getElementById("yb-fileUpload");
          t && (t.removeEventListener("change", ge),
            t.parentNode.removeChild(t))
        }
      )),
      (e,t)=>{
        const r = sS
          , a = WC
          , u = rB
          , f = nB
          , h = MA
          , m = qB
          , y = QP
          , b = bj
          , x = C$
          , C = A$
          , _ = yE
          , F = mK
          , K = nF
          , W = EW;
        return rr((Ca(),
          _a("div", Jvt, [Ma("header", null, [Ma("div", {
            class: "left",
            onClick: t[0] || (t[0] = e=>Vt(T).push("/home/worker"))
          }, [Ma("span", Zvt, [ja(r, null, {
            default: Fn((()=>[ja(Vt(vm))])),
            _: 1
          })]), egt]), Ma("div", tgt, [Ma("div", ngt, [rr(Ma("input", {
            id: "videoName",
            type: "text",
            class: "videoName",
            autocomplete: "off",
            "onUpdate:modelValue": t[1] || (t[1] = e=>D.value = e)
          }, null, 512), [[ks, D.value]]), Ma("label", rgt, [Ma("span", ogt, [ja(r, null, {
            default: Fn((()=>[ja(Vt(Pm))])),
            _: 1
          })])]), Ma("span", agt, [Ma("img", {
            width: "18",
            onClick: yt,
            style: {
              "margin-right": "7px"
            },
            src: uJ,
            alt: ""
          }), rr(Ma("span", null, "最近保存 : " + te(O.value), 513), [[$s, "" !== O.value]])])])]), igt]), Ma("main", null, [Ma("div", sgt, [Ma("div", lgt, [ja(a, {
            type: "primary",
            onClick: t[2] || (t[2] = e=>de(se.list.length)),
            style: {
              display: "flex",
              "align-items": "center"
            }
          }, {
            icon: Fn((()=>[ja(r, null, {
              default: Fn((()=>[ja(Vt(Hm))])),
              _: 1
            })])),
            default: Fn((()=>[$a(" 添加场景 ")])),
            _: 1
          }), Ma("div", ugt, te(se.activeIndex + 1) + "/" + te(se.list.length) + "页 ", 1)]), Ma("div", cgt, [Ma("div", dgt, [(Ca(!0),
            _a(ba, null, Yr(se.list, ((e,t)=>(Ca(),
              _a("div", {
                class: Y(["stage", {
                  active: t === se.activeIndex
                }]),
                key: e.$id,
                onClick: e=>ce(t)
              }, [Ma("div", pgt, [Ma("span", {
                class: "btn",
                onClick: n=>((e,t,n)=>{
                    e.stopPropagation();
                    let r = ee(t);
                    se.list.splice(n + 1, 0, r),
                      ce(n + 1)
                  }
                )(n, e, t),
                title: "复制"
              }, vgt, 8, hgt), Ma("span", {
                class: "btn",
                onClick: e=>de(t, e),
                title: "向下添加"
              }, mgt, 8, ggt), Ma("span", {
                class: "btn",
                disabled: 1 === se.list.length,
                onClick: e=>((e,t)=>{
                    if (e.stopPropagation(),
                    1 === se.list.length)
                      return !1;
                    if (se.activeIndex >= t) {
                      let e = Math.max(se.activeIndex - 1, 0);
                      ce(e)
                    }
                    se.list.splice(t, 1)
                  }
                )(e, t),
                title: "删除"
              }, bgt, 8, ygt)]), Ma("div", {
                class: "stage-img-box",
                style: z(ct())
              }, [Ma("div", {
                class: "stage-img",
                style: z(ut())
              }, [rr(Ma("img", {
                src: e.chooseParams.background.imgObj.assets_url,
                style: z({
                  width: ue.value[0] / ue.value[1] > 1 ? ue.value[0] + "px" : "",
                  height: ue.value[0] / ue.value[1] < 1 ? ue.value[1] + "px" : ""
                }),
                alt: ""
              }, null, 12, wgt), [[$s, e.chooseParams.background.imgObj.assets_url]]), Ma("div", xgt, [Ma("canvas", {
                class: Y(["select-none", {
                  "user-stage": !e.chooseParams.background.imgObj.assets_url
                }]),
                id: "stageCanvas-" + t,
                width: parseFloat(L.value.split(",")[0]),
                height: parseFloat(L.value.split(",")[1])
              }, null, 10, Sgt)])], 4)], 4)], 10, fgt)))), 128))])]), Ma("div", Egt, [Agt, rr(Ma("div", null, [(Ca(!0),
            _a(ba, null, Yr(le.value.layers.filter((e=>"font" !== e.type)), ((e,t)=>(Ca(),
              _a("div", {
                class: Y(["layer", {
                  active: e.$id === le.value.activeLayerId
                }]),
                onClick: t=>(e=>{
                    le.value.activeLayerId = e.$id,
                      Ne()
                  }
                )(e)
              }, [Ma("div", kgt, [Ma("img", {
                class: "header-img",
                src: e.image.src,
                alt: ""
              }, null, 8, Tgt)]), Dgt, Ma("div", {
                class: "layer-delete",
                onClick: js((e=>(e=>{
                    "person" === le.value.layers.splice(e, 1)[0].type && (me.value.person.image = new Image,
                      me.value.person.data = {}),
                      Ne()
                  }
                )(t)), ["stop"])
              }, _gt, 8, Ogt)], 10, Cgt)))), 256))], 512), [[$s, le.value.layers.length > 0]]), rr(Ma("div", Rgt, " 暂无内容 ", 512), [[$s, 0 === le.value.layers.length]])])]), Ma("div", Lgt, [Ma("div", {
            class: "videoWrap",
            ref_key: "wrapRef",
            ref: M
          }, [rr(Ma("div", {
            class: "canvasLayerBoxStyle",
            style: z(j.value)
          }, null, 4), [[$s, "" !== ie.value.type]]), Ma("div", Igt, [Ma("div", Pgt, [Ma("div", {
            class: "viewbox backImgView",
            style: z({
              width: ue.value[0] + "px",
              height: ue.value[1] + "px"
            })
          }, [rr(Ma("img", {
            src: me.value.background.imgObj.assets_url,
            style: z({
              width: ue.value[0] / ue.value[1] > 1 ? ue.value[0] + "px" : "",
              height: ue.value[0] / ue.value[1] < 1 ? ue.value[1] + "px" : ""
            }),
            alt: ""
          }, null, 12, Fgt), [[$s, me.value.background.imgObj.assets_url]])], 4), Ma("div", Bgt, [Ma("canvas", {
            onContextmenu: Ve,
            class: Y(["select-none", {
              "user-stage": !me.value.background.imgObj.assets_url
            }]),
            ref_key: "cvs",
            ref: R,
            width: ue.value[0],
            height: ue.value[1]
          }, null, 42, Ngt)])])]), Ma("div", Mgt, [Ma("div", jgt, [Ma("span", Vgt, te(oe.value), 1), Ugt, Ma("span", $gt, te(ae.value), 1)]), Ma("img", {
            class: Y(["switch", {
              disabledPlay: "" === le.value.audioTrack.url
            }]),
            onClick: t[3] || (t[3] = (...e)=>le.value.updatePlayState && le.value.updatePlayState(...e)),
            src: le.value.audioPlayState ? Vt("/state-pause.png") : Vt("/state-play.png")
          }, null, 10, Hgt), ja(hJ, {
            time: le.value.audioTrack.duration / le.value.audioTrack.voiceSpeed,
            current: le.value.audioCurrentTime,
            onChange: le.value.onCurrentChange
          }, null, 8, ["time", "current", "onChange"])])], 512), rr((Ca(),
            _a("div", {
              class: "infoWrap",
              "element-loading-text": P.value
            }, [Ma("div", Kgt, [Ma("div", Wgt, [Ggt, ja(f, {
              modelValue: le.value.lang,
              "onUpdate:modelValue": t[4] || (t[4] = e=>le.value.lang = e),
              placeholder: "Select",
              size: "small",
              style: {
                width: "178px",
                "margin-left": "14px"
              },
              teleported: !1
            }, {
              prefix: Fn((()=>[$a(" 输入语言 ")])),
              default: Fn((()=>[(Ca(!0),
                _a(ba, null, Yr(V.value, (e=>(Ca(),
                  Ra(u, {
                    key: e.microsoft_name,
                    label: e.name,
                    value: e.microsoft_name
                  }, null, 8, ["label", "value"])))), 128))])),
              _: 1
            }, 8, ["modelValue"])]), Ma("div", qgt, [ja(h, {
              class: "box-item",
              effect: "dark",
              placement: "top-start",
              content: "选择合成音",
              "hide-after": v.value
            }, {
              default: Fn((()=>[ja(a, {
                type: le.value.chooseParams.voice.data.cover ? "default" : "primary",
                style: {
                  "margin-right": "20px"
                },
                class: "btn-editor btn-vioce",
                onClick: t[5] || (t[5] = e=>w.value = !0)
              }, {
                default: Fn((()=>[le.value.chooseParams.voice.data.cover ? (Ca(),
                  _a("span", Ygt, [Ma("img", {
                    src: le.value.chooseParams.voice.data.cover,
                    width: "18",
                    alt: ""
                  }, null, 8, Xgt), $a(" " + te(le.value.chooseParams.voice.data.name) + " ", 1)])) : (Ca(),
                  _a("span", Qgt, "选择合成音"))])),
                _: 1
              }, 8, ["type"])])),
              _: 1
            }, 8, ["hide-after"]), "tts" === me.value.voice.type ? (Ca(),
              Ra(h, {
                key: 0,
                class: "box-item",
                effect: "dark",
                placement: "bottom-start",
                content: "插入停顿",
                "hide-after": v.value
              }, {
                default: Fn((()=>[Ma("span", null, [ja(m, {
                  placement: "top",
                  width: 266,
                  trigger: "click",
                  onShow: t[9] || (t[9] = e=>$("insert-pause")),
                  onHide: t[10] || (t[10] = e=>$("insert-pause"))
                }, {
                  reference: Fn((()=>[ja(a, {
                    type: "primary",
                    class: "iconbox"
                  }, {
                    default: Fn((()=>[Ma("div", {
                      class: Y(["btn-act btn-insert-pause", {
                        hover: U.value["insert-pause"]
                      }])
                    }, null, 2)])),
                    _: 1
                  })])),
                  default: Fn((()=>[Ma("div", null, [ja(a, {
                    size: "small",
                    style: {
                      width: "72px",
                      "font-size": "14px"
                    },
                    onClick: t[6] || (t[6] = e=>Vt(l)("0.5s"))
                  }, {
                    default: Fn((()=>[$a("停顿0.5s")])),
                    _: 1
                  }), ja(a, {
                    size: "small",
                    style: {
                      width: "72px",
                      "font-size": "14px"
                    },
                    onClick: t[7] || (t[7] = e=>Vt(l)("1s"))
                  }, {
                    default: Fn((()=>[$a("停顿1s")])),
                    _: 1
                  }), ja(a, {
                    size: "small",
                    style: {
                      width: "72px",
                      "font-size": "14px"
                    },
                    onClick: t[8] || (t[8] = e=>Vt(l)("2s"))
                  }, {
                    default: Fn((()=>[$a("停顿2s")])),
                    _: 1
                  })])])),
                  _: 1
                })])])),
                _: 1
              }, 8, ["hide-after"])) : za("", !0), ja(h, {
              class: "box-item",
              effect: "dark",
              placement: "bottom-start",
              content: "声音设置",
              "hide-after": v.value
            }, {
              default: Fn((()=>[Ma("span", null, [ja(m, {
                placement: "top",
                width: 228,
                trigger: "click",
                onShow: t[13] || (t[13] = e=>$("speed-setting")),
                onHide: t[14] || (t[14] = e=>$("speed-setting"))
              }, {
                reference: Fn((()=>[ja(a, {
                  type: "primary",
                  class: "iconbox"
                }, {
                  default: Fn((()=>[Ma("div", {
                    class: Y(["btn-act btn-speed-setting", {
                      hover: U.value["speed-setting"]
                    }])
                  }, null, 2)])),
                  _: 1
                })])),
                default: Fn((()=>[Ma("div", Jgt, [Ma("div", Zgt, [emt, Ma("div", tmt, [ja(y, {
                  modelValue: le.value.audioTrack.voiceSpeed,
                  "onUpdate:modelValue": t[11] || (t[11] = e=>le.value.audioTrack.voiceSpeed = e),
                  "controls-position": "right",
                  min: .5,
                  max: 2,
                  step: .1,
                  "step-strictly": !0,
                  precision: 1,
                  size: "large",
                  onChange: le.value.updateSpeed
                }, null, 8, ["modelValue", "onChange"])])]), Ma("div", nmt, [rmt, Ma("div", omt, [ja(b, {
                  modelValue: le.value.volume,
                  "onUpdate:modelValue": t[12] || (t[12] = e=>le.value.volume = e),
                  "show-tooltip": !1
                }, null, 8, ["modelValue"]), Ma("div", amt, te(le.value.volume), 1)])])])])),
                _: 1
              })])])),
              _: 1
            }, 8, ["hide-after"]), imt, (Ca(),
              Ra(h, {
                class: "box-item",
                effect: "dark",
                content: rt().message,
                placement: "top-start",
                disabled: rt().pass,
                "hide-after": v.value,
                key: n.value
              }, {
                default: Fn((()=>[(Ca(),
                  Ra(a, {
                    key: n.value,
                    disabled: !rt().pass,
                    type: "primary",
                    class: Y([{
                      "btn-disabled": !rt().pass
                    }, "btn-editor"]),
                    onClick: ot
                  }, {
                    default: Fn((()=>[$a("生成视频")])),
                    _: 1
                  }, 8, ["disabled", "class"]))])),
                _: 1
              }, 8, ["content", "disabled", "hide-after"])), ja(h, {
              class: "box-item",
              effect: "dark",
              content: lt.value,
              placement: "top-start",
              disabled: "" === lt.value,
              "hide-after": v.value
            }, {
              default: Fn((()=>[ja(a, {
                type: "primary",
                disabled: "" !== lt.value,
                onClick: Ze,
                class: Y([{
                  "btn-disabled": "" !== lt.value
                }, "btn-editor"])
              }, {
                default: Fn((()=>[$a("生成字幕")])),
                _: 1
              }, 8, ["disabled", "class"])])),
              _: 1
            }, 8, ["content", "disabled", "hide-after"]), ja(h, {
              class: "box-item",
              effect: "dark",
              content: st.value,
              placement: "top-start",
              disabled: "" === st.value,
              "hide-after": v.value
            }, {
              default: Fn((()=>[rr(ja(a, {
                type: "primary",
                disabled: "" !== st.value,
                class: Y([{
                  "btn-disabled": "" !== st.value
                }, "btn-editor"]),
                onClick: qe
              }, {
                default: Fn((()=>[$a("合成声音")])),
                _: 1
              }, 8, ["disabled", "class"]), [[$s, "tts" === me.value.voice.type]])])),
              _: 1
            }, 8, ["content", "disabled", "hide-after"])])]), Ma("div", smt, [Ma("div", lmt, [Ma("div", umt, [(Ca(),
              Ra(Vt(wit), {
                style: {
                  position: "relative"
                },
                key: le.value.$id,
                modelValue: le.value.editorValueHtml,
                "onUpdate:modelValue": t[15] || (t[15] = e=>le.value.editorValueHtml = e),
                mode: "simple",
                onOnCreated: He,
                onOnChange: Ke,
                onCustomPaste: We,
                onOnBlur: Vt(p),
                defaultConfig: ze
              }, null, 8, ["modelValue", "onOnBlur"])), rr(ja(cht, {
              current: Vt(d).current,
              list: Vt(d).list,
              onUpdateValue: Vt(s),
              style: z(Vt(d).style)
            }, null, 8, ["current", "list", "onUpdateValue", "style"]), [[$s, Vt(d).show]])]), cmt])])], 8, zgt)), [[W, I.value]])]), Ma("div", dmt, ["font" === ie.value.type ? (Ca(),
            _a("div", fmt, [Ma("div", pmt, [ja(C, {
              class: "font-tabs",
              modelValue: A.value,
              "onUpdate:modelValue": t[16] || (t[16] = e=>A.value = e)
            }, {
              default: Fn((()=>[ja(x, {
                label: "字幕样式",
                name: "style"
              }), ja(x, {
                label: "内容",
                name: "content"
              })])),
              _: 1
            }, 8, ["modelValue"]), Ma("div", hmt, [rr(Ma("ul", null, [(Ca(!0),
              _a(ba, null, Yr(le.value.layers.filter((e=>"font" === e.type)), (e=>(Ca(),
                _a("li", vmt, [Ma("div", gmt, [Ma("span", null, te(re(e.timelineIn / le.value.audioTrack.voiceSpeed, 1)), 1), $a(" - "), Ma("span", null, te(re(e.timelineOut / le.value.audioTrack.voiceSpeed, 1)), 1)]), Ma("div", null, [ja(_, {
                  modelValue: e.text,
                  "onUpdate:modelValue": t=>e.text = t,
                  autosize: "",
                  resize: "none",
                  type: "textarea",
                  onKeyup: Ne
                }, null, 8, ["modelValue", "onUpdate:modelValue"])])])))), 256))], 512), [[$s, "content" === A.value]]), rr(Ma("div", mmt, [Ma("div", null, [Ma("div", ymt, [bmt, ja(a, {
              type: "primary",
              style: {
                width: "86px"
              },
              onClick: Le
            }, {
              default: Fn((()=>[$a("应用到全部")])),
              _: 1
            })]), Ma("div", wmt, [Ma("div", xmt, [Smt, ja(y, {
              style: {
                width: "78px"
              },
              modelValue: be.value,
              "onUpdate:modelValue": t[17] || (t[17] = e=>be.value = e),
              "controls-position": "right",
              onChange: Ne
            }, null, 8, ["modelValue"])]), Ma("div", Emt, [Amt, ja(y, {
              style: {
                width: "78px"
              },
              modelValue: we.value,
              "onUpdate:modelValue": t[18] || (t[18] = e=>we.value = e),
              "controls-position": "right",
              onChange: Ne
            }, null, 8, ["modelValue"])])])]), Ma("div", Cmt, [kmt, Ma("div", Tmt, [ja(f, {
              modelValue: ie.value.font,
              "onUpdate:modelValue": t[19] || (t[19] = e=>ie.value.font = e),
              teleported: !1,
              onChange: Ne
            }, {
              default: Fn((()=>[(Ca(!0),
                _a(ba, null, Yr(G.value, (e=>(Ca(),
                  Ra(u, {
                    value: e.font,
                    label: e.name
                  }, null, 8, ["value", "label"])))), 256))])),
              _: 1
            }, 8, ["modelValue"])])]), Ma("div", Dmt, [Ma("div", Omt, [_mt, ja(_, {
              modelValue: Ee.value,
              "onUpdate:modelValue": t[20] || (t[20] = e=>Ee.value = e),
              onChange: Ne
            }, null, 8, ["modelValue"])]), Ma("div", Rmt, [Lmt, Ma("div", Imt, [Ma("input", {
              type: "color",
              value: ie.value.fontColor,
              onInput: t[21] || (t[21] = e=>Ie(e, "fontColor"))
            }, null, 40, Pmt)])]), Ma("div", Fmt, [Bmt, Ma("div", Nmt, [Ma("input", {
              type: "color",
              value: ie.value.strokeColor,
              onInput: t[22] || (t[22] = e=>Ie(e, "strokeColor"))
            }, null, 40, Mmt)])])]), Ma("div", jmt, [Ma("div", Vmt, [ja(h, {
              class: "box-item",
              effect: "dark",
              content: "下划线",
              placement: "top-start",
              "hide-after": v.value
            }, {
              default: Fn((()=>[ja(a, {
                style: {
                  width: "62px"
                },
                type: ie.value.fontFace.underline ? "primary" : "default",
                onClick: t[23] || (t[23] = e=>Be("underline"))
              }, {
                default: Fn((()=>[rr(Ma("img", Umt, null, 512), [[$s, ie.value.fontFace.underline]]), rr(Ma("img", $mt, null, 512), [[$s, !ie.value.fontFace.underline]])])),
                _: 1
              }, 8, ["type"])])),
              _: 1
            }, 8, ["hide-after"]), ja(h, {
              class: "box-item",
              effect: "dark",
              content: "加粗",
              placement: "top-start",
              "hide-after": v.value
            }, {
              default: Fn((()=>[ja(a, {
                style: {
                  width: "62px"
                },
                type: ie.value.fontFace.bold ? "primary" : "default",
                onClick: t[24] || (t[24] = e=>Be("bold"))
              }, {
                default: Fn((()=>[rr(Ma("img", Hmt, null, 512), [[$s, ie.value.fontFace.bold]]), rr(Ma("img", zmt, null, 512), [[$s, !ie.value.fontFace.bold]])])),
                _: 1
              }, 8, ["type"])])),
              _: 1
            }, 8, ["hide-after"]), ja(h, {
              class: "box-item",
              effect: "dark",
              content: "斜体",
              placement: "top-start",
              "hide-after": v.value
            }, {
              default: Fn((()=>[ja(a, {
                style: {
                  width: "62px"
                },
                type: ie.value.fontFace.italic ? "primary" : "default",
                onClick: t[25] || (t[25] = e=>Be("italic"))
              }, {
                default: Fn((()=>[rr(Ma("img", Kmt, null, 512), [[$s, ie.value.fontFace.italic]]), rr(Ma("img", Wmt, null, 512), [[$s, !ie.value.fontFace.italic]])])),
                _: 1
              }, 8, ["type"])])),
              _: 1
            }, 8, ["hide-after"])])]), Ma("div", Gmt, [qmt, Ma("div", Ymt, [ja(h, {
              class: "box-item",
              effect: "dark",
              content: "左对齐",
              placement: "top-start",
              "hide-after": v.value
            }, {
              default: Fn((()=>[Ma("img", {
                class: "cursor-pointer",
                onClick: t[26] || (t[26] = e=>Be("left")),
                height: "16",
                src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAgCAYAAAB6kdqOAAAAAXNSR0IArs4c6QAAAIlJREFUWEftlksOgCAQQ+1pvP9xPM0YFibExJTCiJiUbfmURxnAtlhD8RMRR+0LwP6VTxti5E3IhBgBpv87Q/d6xXar6qX+SYRs6EL89HQsR0jNRE9/KUM9C6hjbIgRM6FUQqPXvuUnKh2ZDb1dqdOPjAUyQ5cylLEgm8OGTIgRYLoz1ESIdZqpn4gsmCFTr7jLAAAAAElFTkSuQmCC",
                alt: ""
              })])),
              _: 1
            }, 8, ["hide-after"]), ja(h, {
              class: "box-item",
              effect: "dark",
              content: "水平居中",
              placement: "top-start",
              "hide-after": v.value
            }, {
              default: Fn((()=>[Ma("img", {
                class: "cursor-pointer",
                onClick: t[27] || (t[27] = e=>Be("center")),
                height: "16",
                src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAgCAYAAAAMq2gFAAAAAXNSR0IArs4c6QAAAHBJREFUSEtjZKATYCTWnv///2szMDCsQ1J/lZGRMYhY/aMWjQYdPK0wYklNxCYkYtWBU+eoRcQGF7I6SNARq3O0ZEAPqdGgo15ZR4WSAms9hRFHoxZhyfDEBR2ukmK0ZBgtGeAhMJoYRhMDsU0KguoAMpmWISopN54AAAAASUVORK5CYII=",
                alt: ""
              })])),
              _: 1
            }, 8, ["hide-after"]), ja(h, {
              class: "box-item",
              effect: "dark",
              content: "右对齐",
              placement: "top-start",
              "hide-after": v.value
            }, {
              default: Fn((()=>[Ma("img", {
                class: "cursor-pointer",
                onClick: t[28] || (t[28] = e=>Be("right")),
                height: "16",
                src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAgCAYAAAB6kdqOAAAAAXNSR0IArs4c6QAAAIBJREFUWEft1FsKgDAMRNFkle7GD3fjKlsQBSmWISXg6/o7lsZjGLeHPX7XPKWUycyW0/2ru88MdIggpHYToe8IXfxL9XHRfOuX9lB3hxhop3qPUHQhst6nh5QkQv8RSijOWFMP0Kojbc5ASixXSN02mtNDSg4hhJSAytkhJdTLK7oIviGEC1lvAAAAAElFTkSuQmCC",
                alt: ""
              })])),
              _: 1
            }, 8, ["hide-after"]), ja(h, {
              class: "box-item",
              effect: "dark",
              content: "顶部对齐",
              placement: "top-start",
              "hide-after": v.value
            }, {
              default: Fn((()=>[Ma("img", {
                class: "cursor-pointer",
                onClick: t[29] || (t[29] = e=>Be("top")),
                height: "16",
                src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAGNJREFUWEdjZGBgYPj//38TAwNDOIhNZ1DHOOqAQRECdI53FOvAaWAgwagDiAoBLOVEHSMj40r0qCNWHbK+UQeMhsBoCIyGwGgIjIbAaAgMrxAgp2lH1RAYdcBoCIyGADkhAADTKNlxAH/zCAAAAABJRU5ErkJggg==",
                alt: ""
              })])),
              _: 1
            }, 8, ["hide-after"]), ja(h, {
              class: "box-item",
              effect: "dark",
              content: "垂直居中",
              placement: "top-start",
              "hide-after": v.value
            }, {
              default: Fn((()=>[Ma("img", {
                class: "cursor-pointer",
                onClick: t[30] || (t[30] = e=>Be("middle")),
                height: "16",
                src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAAXNSR0IArs4c6QAAAGZJREFUSEtjZCAA/v//v46BgUEbSVkQIyPjVUL6iJVnJKRw1AFDJgTIdSjV0sCoA0ZDgOwQwKKRUNlELXlwico46oABDwFCEUps4iJWHbp9oyXhaAgMnxAglJtwyVMtBEYdQG4IAABBKrQZxbiUaAAAAABJRU5ErkJggg==",
                alt: ""
              })])),
              _: 1
            }, 8, ["hide-after"]), ja(h, {
              class: "box-item",
              effect: "dark",
              content: "底部对齐",
              placement: "top-start",
              "hide-after": v.value
            }, {
              default: Fn((()=>[Ma("img", {
                class: "cursor-pointer",
                onClick: t[31] || (t[31] = e=>Be("bottom")),
                height: "16",
                src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAGBJREFUWEft11EKABAQhGFzGvc/jtOseJKnaSOp3/PQ9CUtFWNFRFtjkqqxzYrISVEAAQS+EcgUPfoOUAABBBBAAAEErgk4o3s2Y80D2cOdfRSYAvvlcehOZMYfkwLPBTo66rAhKNL0RgAAAABJRU5ErkJggg==",
                alt: ""
              })])),
              _: 1
            }, 8, ["hide-after"])])]), Ma("div", Xmt, [ja(a, {
              style: {
                height: "24px",
                width: "72px"
              },
              type: "default",
              onClick: t[32] || (t[32] = e=>Pe(-1))
            }, {
              default: Fn((()=>[$a("上一段")])),
              _: 1
            }), ja(a, {
              style: {
                height: "24px",
                width: "72px"
              },
              type: "default",
              onClick: t[33] || (t[33] = e=>Pe(1))
            }, {
              default: Fn((()=>[$a("下一段")])),
              _: 1
            })]), Ma("div", Qmt, [ja(a, {
              style: {
                height: "24px",
                width: "72px"
              },
              type: "default",
              onClick: Fe
            }, {
              default: Fn((()=>[$a("清空字幕")])),
              _: 1
            })])], 512), [[$s, "style" === A.value]])])])])) : za("", !0), "person" === ie.value.type ? (Ca(),
            _a("div", Jmt, [Zmt, Ma("div", eyt, [tyt, Ma("div", nyt, [ryt, ja(y, {
              modelValue: be.value,
              "onUpdate:modelValue": t[34] || (t[34] = e=>be.value = e),
              "controls-position": "right",
              onChange: t[35] || (t[35] = e=>Re(0))
            }, null, 8, ["modelValue"])]), Ma("div", oyt, [ayt, ja(y, {
              modelValue: we.value,
              "onUpdate:modelValue": t[36] || (t[36] = e=>we.value = e),
              "controls-position": "right",
              onChange: t[37] || (t[37] = e=>Re(1))
            }, null, 8, ["modelValue"])])]), Ma("div", iyt, [syt, Ma("div", lyt, [uyt, ja(y, {
              modelValue: xe.value,
              "onUpdate:modelValue": t[38] || (t[38] = e=>xe.value = e),
              "controls-position": "right",
              onChange: t[39] || (t[39] = e=>Re(2))
            }, null, 8, ["modelValue"])]), Ma("div", cyt, [dyt, ja(y, {
              modelValue: Se.value,
              "onUpdate:modelValue": t[40] || (t[40] = e=>Se.value = e),
              "controls-position": "right",
              onChange: t[41] || (t[41] = e=>Re(3))
            }, null, 8, ["modelValue"])]), Ma("div", fyt, [Ma("div", pyt, [ja(b, {
              modelValue: xe.value,
              "onUpdate:modelValue": t[42] || (t[42] = e=>xe.value = e),
              min: 20,
              max: 2e3,
              onInput: t[43] || (t[43] = e=>Re(2))
            }, null, 8, ["modelValue"])])])])])) : za("", !0), "" === ie.value.type ? (Ca(),
            _a("div", hyt, [vyt, Ma("div", gyt, [myt, ja(a, {
              type: "primary",
              onClick: $e
            }, {
              default: Fn((()=>[$a("应用到全部")])),
              _: 1
            })]), Ma("div", yyt, [Ma("div", {
              class: "stage-bg-view-imgbox user-stage",
              style: z({
                width: ue.value[0] / ue.value[1] > 1 ? "100%" : "116px",
                height: ue.value[0] / ue.value[1] > 1 ? "116px" : "100%"
              })
            }, [Ma("img", {
              style: z({
                width: ue.value[0] / ue.value[1] > 1 ? "auto" : "116px",
                height: ue.value[0] / ue.value[1] > 1 ? "116px" : "auto"
              }),
              src: le.value.chooseParams.background.imgObj.assets_url,
              alt: ""
            }, null, 12, byt)], 4), Ma("div", wyt, [Ma("div", null, [ja(F, {
              "file-list": pe.value,
              "onUpdate:fileList": t[44] || (t[44] = e=>pe.value = e),
              class: "upload-demo",
              "before-upload": ve,
              "http-request": he,
              "show-file-list": !1
            }, {
              default: Fn((()=>[ja(a, {
                class: "btn-bg-opacity"
              }, {
                default: Fn((()=>[$a("上传替换")])),
                _: 1
              })])),
              _: 1
            }, 8, ["file-list"]), ja(a, {
              class: "btn-bg-opacity",
              style: {
                "margin-top": "11px"
              },
              onClick: fe
            }, {
              default: Fn((()=>[$a("清空背景")])),
              _: 1
            })])])])])) : za("", !0)]), Ma("div", xyt, [(Ca(!0),
            _a(ba, null, Yr(Vt(S).list, (e=>(Ca(),
              _a("div", {
                class: Y(["tab", {
                  active: Vt(S).current === e
                }]),
                onClick: t=>Vt(E)(e)
              }, [Ma("img", {
                width: "20",
                src: Vt(S).current === e ? e.activeIcon : e.icon,
                alt: ""
              }, null, 8, Eyt), Ma("span", Ayt, te(e.name), 1)], 10, Syt)))), 256))])]), ja(NZ, {
            onClose: Vt(E),
            tab: Vt(S).current,
            chooseParams: me.value,
            onSendData: Te
          }, null, 8, ["onClose", "tab", "chooseParams"]), ja(oht, {
            showCloseIcon: H.isPreview,
            loading: H.loading,
            src: H.data.assets_url,
            show: H.show,
            poster: H.data.cover,
            onClose: t[46] || (t[46] = e=>H.show = !1)
          }, Xr({
            _: 2
          }, [H.isPreview ? void 0 : {
            name: "header",
            fn: Fn((()=>[Ma("div", Cyt, [ja(K, {
              underline: !1,
              onClick: dt,
              type: "primary"
            }, {
              default: Fn((()=>[Ma("span", kyt, [ja(r, null, {
                default: Fn((()=>[ja(Vt(vm))])),
                _: 1
              })]), Tyt])),
              _: 1
            })])])),
            key: "0"
          }, H.isPreview ? void 0 : {
            name: "default",
            fn: Fn((()=>[Ma("div", Dyt, [Oyt, Ma("div", _yt, [Ma("div", Ryt, [Lyt, Ma("span", Iyt, te(H.data.name || D.value), 1)]), Ma("div", Pyt, [Fyt, Ma("span", Byt, te(pt(H.data.duration)) + "秒", 1)]), Ma("div", Nyt, [Myt, Ma("span", jyt, te(H.data.resolution), 1)]), Ma("div", Vyt, [Uyt, Ma("span", $yt, te("HORIZONTAL" === H.data.align ? "16:9" : "9:16"), 1)])]), Ma("div", Hyt, [ja(h, {
              class: "box-item",
              effect: "dark",
              content: "视频合成完成后可以下载",
              placement: "top-start",
              disabled: "" !== H.data.assets_url,
              "hide-after": v.value
            }, {
              default: Fn((()=>[ja(a, {
                type: "primary",
                disabled: "" === H.data.assets_url,
                class: Y([{
                  "btn-disabled": "" !== H.data.assets_url
                }, "download-btn"]),
                onClick: t[45] || (t[45] = e=>{
                    return t = H.data.assets_url,
                      void k.downloadFile(t, {
                        fileName: H.data.name
                      });
                    var t
                  }
                )
              }, {
                default: Fn((()=>[$a("下 载")])),
                _: 1
              }, 8, ["disabled", "class"])])),
              _: 1
            }, 8, ["disabled", "hide-after"])])])])),
            key: "1"
          }]), 1032, ["showCloseIcon", "loading", "src", "show", "poster"]), ja(zvt, {
            onConfirm: at,
            videoName: D.value,
            duration: se.list.reduce(((e,t)=>e + t.audioTrack.duration / t.audioTrack.voiceSpeed), 0),
            show: B.value,
            onClose: t[47] || (t[47] = e=>B.value = !1)
          }, null, 8, ["videoName", "duration", "show"]), ja(kvt, {
            show: N.value,
            onClose: t[48] || (t[48] = e=>N.value = !1),
            onOk: Ye
          }, null, 8, ["show"]), rr(ja(iht, {
            time: Vt(c).time,
            onUpdateTime: Vt(i),
            style: z(Vt(c).style)
          }, null, 8, ["time", "onUpdateTime", "style"]), [[$s, Vt(c).show]]), ja(vht, {
            show: o.value,
            onOk: Qe,
            onClose: t[49] || (t[49] = e=>o.value = !1)
          }, null, 8, ["show"]), ja(fvt), ja(cvt, {
            show: w.value,
            onOk: De,
            onClose: t[50] || (t[50] = e=>w.value = !1),
            currentValue: le.value.chooseParams.voice.data
          }, null, 8, ["show", "currentValue"])])), [[W, g.value]])
      }
  }
})
  , Kyt = function(e) {
  const t = uu(e.routes, e)
    , n = e.parseQuery || Pu
    , r = e.stringifyQuery || Fu
    , o = e.history
    , a = $u()
    , i = $u()
    , s = $u()
    , l = Bt(ql);
  let u = ql;
  wl && e.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
  const c = Sl.bind(null, (e=>"" + e))
    , d = Sl.bind(null, Lu)
    , f = Sl.bind(null, Iu);
  function p(e, a) {
    if (a = xl({}, a || l.value),
    "string" == typeof e) {
      const r = Tl(n, e, a.path)
        , i = t.resolve({
        path: r.path
      }, a)
        , s = o.createHref(r.fullPath);
      return xl(r, i, {
        params: f(i.params),
        hash: Iu(r.hash),
        redirectedFrom: void 0,
        href: s
      })
    }
    let i;
    if ("path"in e)
      i = xl({}, e, {
        path: Tl(n, e.path, a.path).path
      });
    else {
      const t = xl({}, e.params);
      for (const e in t)
        null == t[e] && delete t[e];
      i = xl({}, e, {
        params: d(t)
      }),
        a.params = d(a.params)
    }
    const s = t.resolve(i, a)
      , u = e.hash || "";
    s.params = c(f(s.params));
    const p = function(e, t) {
      const n = t.query ? e(t.query) : "";
      return t.path + (n && "?") + n + (t.hash || "")
    }(r, xl({}, e, {
      hash: (h = u,
        _u(h).replace(ku, "{").replace(Du, "}").replace(Au, "^")),
      path: s.path
    }));
    var h;
    const v = o.createHref(p);
    return xl({
      fullPath: p,
      hash: u,
      query: r === Fu ? Bu(e.query) : e.query || {}
    }, s, {
      redirectedFrom: void 0,
      href: v
    })
  }
  function h(e) {
    return "string" == typeof e ? Tl(n, e, l.value.path) : xl({}, e)
  }
  function v(e, t) {
    if (u !== e)
      return Jl(8, {
        from: t,
        to: e
      })
  }
  function g(e) {
    return y(e)
  }
  function m(e) {
    const t = e.matched[e.matched.length - 1];
    if (t && t.redirect) {
      const {redirect: n} = t;
      let r = "function" == typeof n ? n(e) : n;
      return "string" == typeof r && (r = r.includes("?") || r.includes("#") ? r = h(r) : {
        path: r
      },
        r.params = {}),
        xl({
          query: e.query,
          hash: e.hash,
          params: "path"in r ? {} : e.params
        }, r)
    }
  }
  function y(e, t) {
    const n = u = p(e)
      , o = l.value
      , a = e.state
      , i = e.force
      , s = !0 === e.replace
      , c = m(n);
    if (c)
      return y(xl(h(c), {
        state: "object" == typeof c ? xl({}, a, c.state) : a,
        force: i,
        replace: s
      }), t || n);
    const d = n;
    let f;
    return d.redirectedFrom = t,
    !i && function(e, t, n) {
      const r = t.matched.length - 1
        , o = n.matched.length - 1;
      return r > -1 && r === o && Ol(t.matched[r], n.matched[o]) && _l(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
    }(r, o, n) && (f = Jl(16, {
      to: d,
      from: o
    }),
      R(o, o, !0, !1)),
      (f ? Promise.resolve(f) : x(d, o)).catch((e=>Zl(e) ? Zl(e, 2) ? e : _(e) : O(e, d, o))).then((e=>{
          if (e) {
            if (Zl(e, 2))
              return y(xl({
                replace: s
              }, h(e.to), {
                state: "object" == typeof e.to ? xl({}, a, e.to.state) : a,
                force: i
              }), t || d)
          } else
            e = E(d, o, !0, s, a);
          return S(d, o, e),
            e
        }
      ))
  }
  function b(e, t) {
    const n = v(e, t);
    return n ? Promise.reject(n) : Promise.resolve()
  }
  function w(e) {
    const t = P.values().next().value;
    return t && "function" == typeof t.runWithContext ? t.runWithContext(e) : e()
  }
  function x(e, t) {
    let n;
    const [r,o,s] = function(e, t) {
      const n = []
        , r = []
        , o = []
        , a = Math.max(t.matched.length, e.matched.length);
      for (let i = 0; i < a; i++) {
        const a = t.matched[i];
        a && (e.matched.find((e=>Ol(e, a))) ? r.push(a) : n.push(a));
        const s = e.matched[i];
        s && (t.matched.find((e=>Ol(e, s))) || o.push(s))
      }
      return [n, r, o]
    }(e, t);
    n = zu(r.reverse(), "beforeRouteLeave", e, t);
    for (const a of r)
      a.leaveGuards.forEach((r=>{
          n.push(Hu(r, e, t))
        }
      ));
    const l = b.bind(null, e, t);
    return n.push(l),
      B(n).then((()=>{
          n = [];
          for (const r of a.list())
            n.push(Hu(r, e, t));
          return n.push(l),
            B(n)
        }
      )).then((()=>{
          n = zu(o, "beforeRouteUpdate", e, t);
          for (const r of o)
            r.updateGuards.forEach((r=>{
                n.push(Hu(r, e, t))
              }
            ));
          return n.push(l),
            B(n)
        }
      )).then((()=>{
          n = [];
          for (const r of s)
            if (r.beforeEnter)
              if (Al(r.beforeEnter))
                for (const o of r.beforeEnter)
                  n.push(Hu(o, e, t));
              else
                n.push(Hu(r.beforeEnter, e, t));
          return n.push(l),
            B(n)
        }
      )).then((()=>(e.matched.forEach((e=>e.enterCallbacks = {})),
        n = zu(s, "beforeRouteEnter", e, t),
        n.push(l),
        B(n)))).then((()=>{
          n = [];
          for (const r of i.list())
            n.push(Hu(r, e, t));
          return n.push(l),
            B(n)
        }
      )).catch((e=>Zl(e, 8) ? e : Promise.reject(e)))
  }
  function S(e, t, n) {
    s.list().forEach((r=>w((()=>r(e, t, n)))))
  }
  function E(e, t, n, r, a) {
    const i = v(e, t);
    if (i)
      return i;
    const s = t === ql
      , u = wl ? history.state : {};
    n && (r || s ? o.replace(e.fullPath, xl({
      scroll: s && u && u.scroll
    }, a)) : o.push(e.fullPath, a)),
      l.value = e,
      R(e, t, n, s),
      _()
  }
  let A;
  function C() {
    A || (A = o.listen(((e,t,n)=>{
        if (!F.listening)
          return;
        const r = p(e)
          , a = m(r);
        if (a)
          return void y(xl(a, {
            replace: !0
          }), r).catch(El);
        u = r;
        const i = l.value;
        var s, c;
        wl && (s = Ul(i.fullPath, n.delta),
          c = jl(),
          $l.set(s, c)),
          x(r, i).catch((e=>Zl(e, 12) ? e : Zl(e, 2) ? (y(e.to, r).then((e=>{
              Zl(e, 20) && !n.delta && n.type === Il.pop && o.go(-1, !1)
            }
          )).catch(El),
            Promise.reject()) : (n.delta && o.go(-n.delta, !1),
            O(e, r, i)))).then((e=>{
              (e = e || E(r, i, !1)) && (n.delta && !Zl(e, 8) ? o.go(-n.delta, !1) : n.type === Il.pop && Zl(e, 20) && o.go(-1, !1)),
                S(r, i, e)
            }
          )).catch(El)
      }
    )))
  }
  let k, T = $u(), D = $u();
  function O(e, t, n) {
    _(e);
    const r = D.list();
    return r.length ? r.forEach((r=>r(e, t, n))) : console.error(e),
      Promise.reject(e)
  }
  function _(e) {
    return k || (k = !e,
      C(),
      T.list().forEach((([t,n])=>e ? n(e) : t())),
      T.reset()),
      e
  }
  function R(t, n, r, o) {
    const {scrollBehavior: a} = e;
    if (!wl || !a)
      return Promise.resolve();
    const i = !r && function(e) {
      const t = $l.get(e);
      return $l.delete(e),
        t
    }(Ul(t.fullPath, 0)) || (o || !r) && history.state && history.state.scroll || null;
    return hn().then((()=>a(t, n, i))).then((e=>e && Vl(e))).catch((e=>O(e, t, n)))
  }
  const L = e=>o.go(e);
  let I;
  const P = new Set
    , F = {
    currentRoute: l,
    listening: !0,
    addRoute: function(e, n) {
      let r, o;
      return Gl(e) ? (r = t.getRecordMatcher(e),
        o = n) : o = e,
        t.addRoute(o, r)
    },
    removeRoute: function(e) {
      const n = t.getRecordMatcher(e);
      n && t.removeRoute(n)
    },
    hasRoute: function(e) {
      return !!t.getRecordMatcher(e)
    },
    getRoutes: function() {
      return t.getRoutes().map((e=>e.record))
    },
    resolve: p,
    options: e,
    push: g,
    replace: function(e) {
      return g(xl(h(e), {
        replace: !0
      }))
    },
    go: L,
    back: ()=>L(-1),
    forward: ()=>L(1),
    beforeEach: a.add,
    beforeResolve: i.add,
    afterEach: s.add,
    onError: D.add,
    isReady: function() {
      return k && l.value !== ql ? Promise.resolve() : new Promise(((e,t)=>{
          T.add([e, t])
        }
      ))
    },
    install(e) {
      e.component("RouterLink", Wu),
        e.component("RouterView", Qu),
        e.config.globalProperties.$router = this,
        Object.defineProperty(e.config.globalProperties, "$route", {
          enumerable: !0,
          get: ()=>Vt(l)
        }),
      wl && !I && l.value === ql && (I = !0,
        g(o.location).catch((e=>{}
        )));
      const t = {};
      for (const r in ql)
        Object.defineProperty(t, r, {
          get: ()=>l.value[r],
          enumerable: !0
        });
      e.provide(ju, this),
        e.provide(Vu, wt(t)),
        e.provide(Uu, l);
      const n = e.unmount;
      P.add(e),
        e.unmount = function() {
          P.delete(e),
          P.size < 1 && (u = ql,
          A && A(),
            A = null,
            l.value = ql,
            I = !1,
            k = !1),
            n()
        }
    }
  };
  function B(e) {
    return e.reduce(((e,t)=>e.then((()=>w(t)))), Promise.resolve())
  }
  return F
}({
  routes: [{
    path: "/",
    redirect: "/login"
  }, {
    path: "/login",
    component: ()=>bl((()=>import("./Login-05bb8c13.js")), ["page-webui/Login-05bb8c13.js", "page-webui/Login-8bb3c380.css"])
  }, {
    path: "/home",
    component: lJ,
    redirect: "/home/worker",
    children: [{
      path: "/home/worker",
      meta: {
        icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAA2CAYAAAC1ItuGAAAAAXNSR0IArs4c6QAAA7hJREFUaEPtmU/oFVUUxz/fiqRVIi6iECqopEUUQQgFEURFZFktrDZBuIgIbCOYbTLsfxBGBUGJCYUapIIVEi3yD1FQWlTYXypNKlpoIGqkx/nKHRjn996bee/Nm/mFnuWbO+d+3vece+fce0TLFhEvAp9IWl9natUZ1NSYiJgPvJD8bQMek/TnIP+tAUbETOADYFYB6B/gTkl7+0HWBoyIu4F5kpaMomhEPA/cXnp3Wwa3aCwFI2I2sAK4ITl6RJKVqG0RcR3wRumFQ8CtkvaNDBgRFwAbgHMLTv5Ojg/UIYyIc4D3gfNL45+UtKbKR2WII2IVcG3J0QZJS6uc+3lELAPuL439ErhH0rEqH3UAreJ7gJUo2gOSdgyaICKuANYBZxTG/QcskPRDFZyfVwImFayAlSiaV95tkpxLUywizkrpcWnp4auSVtaBGwbQClgJK1K01ZKe7gP4ELC49OynpN6/jQImFS8BNmYr2srk5hxaKOmr4oQRcTGwCTi78HsA90n6oi5cbQVzhxFhRaxM0b5Pm61zy4vCafMWcHVp3NuSlg8DNwUwbQlzgQtLiZ37tSKPAjNKE70D7Ey/XdZj1R4FngEODgB0NH7JVvfuYl6fWCQRcSbwYFKnGMJh/3AT4x2JV4DXJB3NAf3DjU14b9DHh5IeVkT4++jv5HS0JQb0N9LfytyOpHxy3rRpTq0rS/m93YCfAi6Fcqv8QkyKukdRsd+A35UmvF7SH5OCGOQ3Is7LqqaPi2NOAw4TiVNHwYiYIcmrvVEbW8FUQrn8vwP4BnhO0mdNUTYBeHN2KnupBLQ5K2aflfTXuKBNAN6bQTzeA8RFwMvAm/5+jgo6ScCcyWX8E6OGvQ3AHHSksLcJaNChw942YK7mj9nhbHmdsHcFWAy787Pvgb9rQIPuAeYPOKqOVyxklU+/bWaYnaXv3c50UNDnjVskWckp1jXgb8BSSZ/3k7srwMM+oQGvSxp4o9AF4EeAr9l+r5OkbQI6nCsknVS+V0G2AVg7nF0skqHCOSnABa79Ss5/TeHcWhXCqudNhNjn57VZ3XdRtmWMFc6JKGinqey/BvhakvscjdnYCjZG0sfRacBxFf7fKrir1ANxc+/bcdUY5f2IuDy1LvLXD/nyyNvGVQWHLtG3ACcuxVs03w/elF3Au5uQ204D9upntMg1cKqVBvTN/bsl8ukA6DP2Xfklus8CT/VoGnYF6h7gMl+kntSrSx2iOdk1hnvEXZhbvXsk/ZxPXquZ2AVpPudxHctHGumKjJIAAAAASUVORK5CYII=",
        activeIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAA2CAYAAAC1ItuGAAAAAXNSR0IArs4c6QAAA3RJREFUaEPtmVmoTlEUx38XkSeSB5FCGfIgUlKUlJDMHgwvSh4kxcstwwsyU7pCKYQiQxnKkOTBlCguQubMXfKA0kUu9l9717E79zvnfGdS7nr8zt5r/77/2sPae9VQvG0GrgKH4wxdE6dRhm0mAJusv0vAMuBdJf9FAnYEzgCdAkCfgSnA6+YgkwBOA4YCtVUquhGY6PWVinPTKtgZWAWMtI4WWSWScA4HdnkdGoFxwNs0gN2AY0CHgJMP1vGnmITtgdNAV6/9amBflI84Id4NDPMcCXpxlHP7fSkw22t7G5gB/IzyEQdQKp4CpETQ5gBXIgYYABwCWgXa/QAmA4+j4PQ9DqDaSQEpETStvPGA5lKYtbHTo4/3cTtQFwcuCaAUkBJSJGh7gLXNDDYfWOh9e2rV+541oPz1Bo6bFS1lnGkOTQfueAP2Ak4AbQO//wJmma3mZly4JAo6n1JEygTtkd1sNbecz/3AYK/dATOlViSBCwPUQugH9PAmtvMrRZaYsLbzBjoC1Nvf+oas2iZgndnkv1QAVDSem9X9IDiv3SJpDcyz6gRDmPQPZ9FekdgG7ACaHKB+GJWF9wx9nAMWCFDno87Jf9FqBagzUmels292PmneFGmaWgO9+X1ZgNcApULO4pwQeYH7ScVHAT70RhthFkxDXgQRfruYrOlCsE0LYMJI/D8K6iTRas/aUiuorUDp/yTgHrDBZNfXM6RMDTjG3Mq2eEAnTTK73hyT7zMATQ0400AsDwFRErAV2KvzMwVoboCOSWn8yhRhzx3QgVYb9sIABVpN2AsFdGo+sZl0nNVeCmAw7JqflS78pQIK9BWgF67mrqqlAwqy0ttO6YC6b4y1SoZtl6UCvrTvOTcqbOSlAH61N7Sd5vkk6kWhcMDzgJ7Z3sQ8/goDVDiV9fyVvseAzB0wSTgLXyRJw5kLoB4elfsF7YUN58UYIYxqkjrEuj8fNHlfT7NlpA1nLgrKqdL+IcBdQHWOLC21glnC5KZgnpAtCqZVN1TBW14NRMW9+2lHqrJ/f1u6cN0b9XikbWNQwKFS9LOAexSvcqzE3bQ7jLbVBNe5XoBh9YzE3nPqUCdAvdwf9chzGi+RW92xp7pHdE3ONSFFw0QeM2ysGqBKbw1+rU4Vou7mGUM14jJMpV5drJ65weMWE8uA/TPmbz5T8WjCo0kFAAAAAElFTkSuQmCC",
        k: "worker",
        title: "数字人视频"
      },
      component: ()=>bl((()=>import("./Worker-c5a70254.js")), ["page-webui/Worker-c5a70254.js", "page-webui/Worker-79f5a6a8.css"])
    }, {
      path: "/",
      meta: {
        icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAAoCAYAAAC1mQk2AAAAAXNSR0IArs4c6QAAAyVJREFUaEPdmk2ITmEUx39/KysbyldhR/laKEVJipTCjrCgkIU1O2EQg5IFZjY+FpMpkplZWSGDKI2sWBkLnytFIcxxD/dO13jfufe5d7zvfefZTNM9zznn/5zznHOec14RLzObA+wFFgGzASXfGvTXgFfAM+CcpMEycn8rb2YbgCPAxDLMxnDvV+CApN6iPBVbqqdCoBIsDm5jUcs5sFOAW6yKq1fSviKKObBbgN+vZF2J/r8MDBVhWGLPBGAHsD3FY1DS2iI8HdjzEYFilaQ3RZiV3WNmM4DbKT4maV4Rvg7sxYiNKyW9K8Ks7B4zmwbcTfORNLcI35YDZmZTgK3ACmAW8CUKMgPAVUmPk0NoGWBm5qloF7B7lAje5WlLkrUEMDNbB+wHpudwyw5JZ4KBmdlSYBPwBLgu6XsOYblIat2xWM6SOgw+ApMAj6jJ+gmsDgJmZvOjkutGisnL2PT3c2meQVQHWK1dTyN3PCFpIL5zndEhL0gRng0Ftjk6nbYakjwXHpf0tgzAHMA+AF5Q9Pk9SmSZ2fKovr2Ukt0XCmxLtPlQHeU9Op13AUXdcxRg36IIeDG6Y52SXM5fq0b+6x9LYImwwu5ZB5h7Q7uk1/W8oVHAEvnB7mlmk4EHMQMvHI5JepTl3o0G5voEu6eZeb34CbgpySNc5moGsNLumYnqz3tyZI35X+7YaLr4y8Gj53BEy6N4Fk0VgLmOeyTdyVI25HtVgO2U1B+ieBZtFYB1R254MEvR0O/NBOYdpzZJY1J6NStBp+V6uL/gVUPeaqQVwn3ZBO0tC0/Qw4/HZlceXlIdLRIgqlpSBVcZNe7KPz2PmCa0CL4XWgQ3+9nyHjhd49myLG4ZJmfVEwqsqg/NDmBhygPCHpq+MW4NuOW8NXAtb7TLk5vGqDXwA1gTZLE8ypWhqddXDGzmeGppbwlgsafkab91R13tw5KGWgZY4glmNhXY5p0oYCbwOW6YdkV9/ocJXcsBy+vq43ooMW7HSCd9cpjXxA2mKzX480G6z3qrMn9Ozq7cqDYOpeu9cK0QuPLD9VQYdcv5zyEWj4efQ/wCvnZLvoXwQ9gAAAAASUVORK5CYII=",
        activeIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAAoCAYAAAC1mQk2AAAAAXNSR0IArs4c6QAAAudJREFUaEPdmkuoTVEYx3/XyMiE8irMKK+BUpSkSCnMCAMKGRgzk3dclAy8Jh4DUSTXHRkhF1EiI0YYeI4UhTyu9a+12O32uXuttXdnr33W6Jz2+h7/9X37e63dx/81DdgOzAGmAn2ZZ934OQy8AZ4DJ4HXVYQ65VcB+4HRVZjVSPsd2AXcjOUpYLLUQEKgHBaBWx1rOQE7CshiKS5ZbEeMYgJ2y1rN0V80/y8Af2IYVqAZZayzCdiY4aH3bHkMTwF7kQsUS4B3McxqoJkE3M7wUUCZEcNXwF7mCBcDH2KY1UAzAbib4zM9hm8bgY0D1gOLgCnANxNkngKXgcfuENoETKloC7B1hAh+yaat4bYAWwHsBCZ6uOUZ4HgMsPnAGuAJcA346SHMd0vROyY58zow+AyMARRR3foNLA0FNtOUXNczTF5Z09/31bxkXxGwIpJnxh0P23dL79xZc8izMhtPhAJba05nX4Ek5cJDwPuKAMuAfbIFxSCgVODWQlPfns/8HwwFts4Q7+mgvKLTKSsg1j07AfthIuA5axnJya98/huqE5gTVsU9i4DJG/pNNHw7gjd0BZiTH+OeY4EHloEKh4PAIw/37iow6RPjnqoXvwA3TOuiCOezug6sDvdMGphTTp2Domc2ovkoXranMYtlFdsG3CnTNPB5EsA2m8pgKFDxsu2NA7ti3HB3mZYRzxsDpk5YFUtdpVcjCTorVOH+tK0afKuR5MN91QStkYUS9L/msenKQyXVgcgAkWRJFVNl5I1QVxF8L7QIbrpt+QgcM41nvm1ZYEeG7qAGQoGl2mhqHDA7Y/7gRlO0Gg3IcmrZryY4Gvhl0sqyUItF5M4gkk5zxZBhjhrS/rYA0+n4jN9U2ezVeL5NwJzpxwMbNIkCJgNf7VBHM8WHblMbgXn5dk9fSvTsNdIRe3PoZeIub6p08aeLdDFI5f7ZnV3lq1oxWmkL11TA1XK57k5IltPnEHN74XOIv0R5B+vCpxZZAAAAAElFTkSuQmCC",
        title: "数字人直播",
        k: "live"
      },
      children: [{
        path: "/home/liveRoom",
        meta: {
          k: "liveRoom",
          title: "我的直播间",
          showTips: "liveTips"
        },
        component: ()=>bl((()=>import("./LiveRoom-6214d713.js")), ["page-webui/LiveRoom-6214d713.js", "page-webui/icon-delete-hover-c737346e.js", "page-webui/ProductSelect-7b203103.js", "page-webui/live-10c0af45.js", "page-webui/ProductSelect-a4b7d160.css", "page-webui/LiveRoom-b3f0484d.css"])
      }, {
        path: "/home/product",
        meta: {
          k: "product",
          title: "我的产品",
          showTips: "liveTips"
        },
        component: ()=>bl((()=>import("./Product-4af7d34e.js")), ["page-webui/Product-4af7d34e.js", "page-webui/icon-delete-hover-c737346e.js", "page-webui/live-10c0af45.js", "page-webui/Product-44e8a0bd.css"])
      }, {
        path: "/home/product-new",
        meta: {
          k: "product",
          title: "我的产品",
          showTips: "liveTips",
          hideInMenu: !0
        },
        component: ()=>bl((()=>import("./NewProduct-be97c71c.js")), ["page-webui/NewProduct-be97c71c.js", "page-webui/live-10c0af45.js", "page-webui/MaterialListComp-b0250862.js", "page-webui/useShiftCheck-d38fcfcd.js", "page-webui/useShiftCheck-1c809284.css", "page-webui/icon-delete-hover-c737346e.js", "page-webui/MaterialListComp-9ece6a79.css", "page-webui/el-table-column-89cced53.css", "page-webui/NewProduct-94d8b4e4.css"])
      }, {
        path: "/home/material",
        meta: {
          k: "material",
          title: "我的素材",
          showTips: "liveTips"
        },
        component: ()=>bl((()=>import("./Material-26025bb8.js")), ["page-webui/Material-26025bb8.js", "page-webui/MaterialListComp-b0250862.js", "page-webui/useShiftCheck-d38fcfcd.js", "page-webui/useShiftCheck-1c809284.css", "page-webui/icon-delete-hover-c737346e.js", "page-webui/MaterialListComp-9ece6a79.css", "page-webui/el-table-column-89cced53.css", "page-webui/Material-f4d33252.css"])
      }]
    }, {
      path: "/home/statistic",
      meta: {
        icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAsCAYAAAAXb/p7AAAAAXNSR0IArs4c6QAABNVJREFUWEftmHnIpmMUxn+XXRSyS0RZCtlC/rBNDGVEmTFjhklMyTKjRJQwMUbKNh8zNIQxlkEmNMiEQtki2WokkxFZU/asx3N93Z8e9zzvs32v/5x6+773ec459/We+9z3uc4R45CI2B04GjgU2A7YBvgN+Ar4BHgReE6Sv/cS9bGKiP2BSwD/bZK/Cr3HgQWSPm9Szt93AhgR6wNXAKd0XQj4Fbha0iNdbFsDjIjNgNuAA7ssUKG7BLhWUrTx0wpgRKwL3A0c0sZpC50RSQtb6NEW4GXAzAEO1wCPAq8AXwBOg52Ao4CTgU0r7By9cyU93wSyEWBE7AY8AayTOfsTuMmRlfRH1UIRsUXxfC5wXMX7T/1c0u91INsAvD1Fo+zHJ/MCSSubIuD3EXE5cFqF7jWS7u0NMCK2Al6qiN4iSQvagEsAncP3FTtxQGazStKJ4wE4BZiXOfjGl7OkX9oCTCD3BR6usJkg6bNBvmq3OCKuA07KjJdKykG3whoRTwO7ZsoXS3KOV0oTwHtSGSsbz5H0TCtEmVJEXAVMzR5fL+mOvgBXAD7FZZku6c2eAGcD52e2SyTN7wvwIWC/zHiWJB+czhIRrt9nZoa1B65pi28FjskczpfkctVZImIxcERmOFfSg30jeCFwdmb8uqTTu6KLCFeUl4s6vGFmO1PSa30Bmk4tqzCeIemNLiAjYg5wXmbzvQ/hoEpk3aYt9vsXChazbebY9XeyJC/QKBHhPF4KbJApP1bcp87LgdKm1J1aWLue5vIucI6kr+sWiAjTMzMX1+WyuJZPkrR6vABdpp4Edqlw9G1B8xcByyX9VH4fEdunEzu9qEbrVdguKzjhlU3hb4ygHUTEHoCvnI0HOHQf8k6Jbu1c5O6eNYt/AEyT9PNQACaQbo5GCtruiI5HnBJT6+pv2XmrCI4ZFLXUjPqWggea/veR9xNRNbFtJZ0ApkjuCFxacYHXLeiGybxvYVcW1BlgKZq+I6clMjsoor6OnjU4Sa2j1nuLq0KUGiofCJ/arQFT+NHGXdLHrfaxRql3BMe7cFv7/wG2jdQgvXFFMI1CfIl7cOSD4o9b0O/Sxzm4pu0UoQpkZ4CpqpyQpgw+HDkByNcxoXgvkY4Vktx0tZZWANNJ9ZTAPNAjt75iguAJxOI6DtjpmomISYC5nOvrMMXk9QZJju5AGRjBNLZwMzNhmKgyX46oJ2buS/z/WlIJMCIOAm4GPFloEtOsVUWUTb2cbyYTPiwmuU6HKqqV+3wLmF3FLdcCGBFHJtaS9w5lpx+mgZKnU6sleVazlkSEfeydhkfHF0Rjy5pf65HxGTnL+RfAiDgWuLHmV7/t95JebQpr/j4dtMmpL8lbiDH1L30QJbmGj8o/ACNir2JLHgA2qljc2zhP0vKuwCqAOqoXpRuhKsU+AqaMMfRRhYhw6D2EdMHPxdvpYaO3YGgSEYenPN+kwqlTx2vGGECT0IkVim6MzpLkyjB0iYh9gDsLoJtXOB9t6BURhyWlXMdlyq3lD0NHVnKYQN5f0dD7RphogM67fHL/Y8qD2pZwWMAjwiM+j/pyGTFAd2ozgFml3rV2XjIsYGU/xTkop5nz3t9Xlk+xk9WT/INT3lXebf8FuHRQdygKg4dVdxUYnhq7W/8GbiODsBegh6EAAAAASUVORK5CYII=",
        activeIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAsCAYAAAAXb/p7AAAAAXNSR0IArs4c6QAABHpJREFUWEftmHnoplMUxz9jF4Usg0QUptDMEPKHNYZCFGaYYZpQspeIkiVryjrWkH0ZJjKyZEIZZYtkKxIhsqbsWcf9/Nynnu7c53nu87zv7z+n3t/yPvec+33OPeee7zlTGE22AfYFdgM2BjYC/gC+AT4DlgHPxf8H7TRlkBbMBM7mv99d8k9YtwS4Dviya3H6vC/AVYHzgdl9NwJ+By4GFvfR7QNwHeBmYKc+G2TW3g1cDiwvsVMKcGXgTmDXEqMFaxYCNxasoxTgucD8BoOfAo8ALwNfAYbB5sDewGHA2hk9vXcS8HwXyBKAWwOPAyslxv4Grome/atho/XC9xcCB2Sefx6//7MNZAnAW6I36nbMzNOBpV0eiM/PA47OrL0UuGcUgBsAL2a8d1O8NgrxYQzfF05ix0ThfeCQUQAeAVySGPguXs6/laKL66YDD2d09gG+aLLVdcRXAIcmyvdmQJdifToc6VbJ4rNijGdtdAG8K5axuvJp4btnShEl6y4C5iTfXQncNtSDTwBmcV3mAm8MBHgqcEqi68V92VCADwEzEuXjY+IMwWj9PjZRbE24riO+AdgvMejb+tZD5FZgz0TRe/LBoR48IzCQExLl14BjBqCzorwU6vDqia4V6tWhAKVTizLK84DXe4I0uU5OdH6MSdhUiTprsSHwQmAxUxPD1t/DATcoEePY62m1ZPFjkVc22uiKQRWPCj+Mk1TeAU4MXvm2A6H0TOZiXa6LtfygQEI+btMvAWiZejIkxpYZQ98Hmm8WPgr8kjzfJGas19IqGV1D54Iu95cA1Ma2gFfOmg0G7UPertGtLULsTmvZ/APgSODXcQHUjs2RRFOPjiKGhNWksf7WjZd6sNKRUV8feKD0f4i8F4mqxLZI+gLU6GbAOZkLvG1DGyZ5n8nSiwUNAVgB8Y40jqT2TR71Ono2giv22ihHnPOSMWlCmLUbAlL4qnH/pOgcWxaN4sFR9y7S/x9gkZsm8Yjtgb3EHRyZKH4s/D/EjzFoohRNEXI4hxyxgA6OUwaTIyUA6T4Sincj6ZCh23QVSylAM9UpgTzQkdtQkSA4gZC4NnLAvteMjEMuZ30dp0her4rebbTb5kHpkfTevnWyRI86MZMR+fcK0gRwZ+BawMlCl0iznBBIvYw3w8FkkeQaDjmqldp8E7DjW4Fb5gDuFVlL2jvUjX4Ym22nUxJOZzU50cb2cUh0YCAa67e8rSPjBSnLSQHuD1zd8tZvxeevdLk181zP2ibYl6QtRLX865iIXk0TUge4XTiSB4A1MsY9Rmc0MudRRa+eGYHkTvAjwJnQBEOvFuh6h5AW/FQ8ToeNHsE4ZY8Y52tljBo67rm8AigJnZVZaGN0XKwK4wRX2doh8MvbA9B1M8YnGnoB7h4XpWssU8bMT5OBrGZTkPdnGnpvhFkCNO7Syf3PMQ5aW8IxAnfE56gvlYUCtFNzUuBQqOpdW+clYwRWN1UPM+Pe/5fWs8hgdU6yS4y7prttkvCxaSgMDqvuCBiequ7WfwHXJMOqVFAL3wAAAABJRU5ErkJggg==",
        k: "statistic",
        title: "个人中心"
      },
      component: ()=>bl((()=>import("./Statistic-4499aad2.js")), ["page-webui/Statistic-4499aad2.js", "page-webui/Statistic-95691ba6.css", "page-webui/el-table-column-89cced53.css"])
    }, {
      path: "/home/custom",
      meta: {
        k: "worker",
        hideInMenu: !0
      },
      component: ()=>bl((()=>import("./Custom-01255919.js")), ["page-webui/Custom-01255919.js", "page-webui/Custom-e8acc180.css"])
    }]
  }, {
    path: "/video",
    component: AQ(zyt, [["__scopeId", "data-v-0f5087d7"]])
  }, {
    path: "/createLive",
    component: ()=>bl((()=>import("./createLive-2877ef6f.js")), ["page-webui/createLive-2877ef6f.js", "page-webui/icon-delete-hover-c737346e.js", "page-webui/live-10c0af45.js", "page-webui/useShiftCheck-d38fcfcd.js", "page-webui/useShiftCheck-1c809284.css", "page-webui/ProductSelect-7b203103.js", "page-webui/ProductSelect-a4b7d160.css", "page-webui/createLive-03db09de.css"]),
    meta: {
      showTips: "liveTips"
    }
  }],
  history: ((Wyt = location.host ? Wyt || location.pathname + location.search : "").includes("#") || (Wyt += "#"),
    Wl(Wyt))
});
var Wyt;
const Gyt = Kyt
  , qyt = ["src"]
  , Yyt = {
  class: "text-content"
}
  , Xyt = vr({
  __name: "TeachingVideo",
  props: ["modelValue"],
  emits: ["update:modelValue"],
  setup(e, {emit: t}) {
    const n = e
      , r = Zu()
      , o = Ft()
      , a = yi({
      get: ()=>n.modelValue,
      set(e) {
        t("update:modelValue", e)
      }
    })
      , i = Ft([{
      name: "startLive",
      label: "如何快速开播",
      src: "https://cdn-tx.yunbovtb.com/assets/dp/help/ruhukaibo.mp4",
      path: ["/home/liveRoom"],
      list: ["1、点击【新建直播】", "2、选择已创建好的产品或新建产品", "3、选择背景、数字人主播", "4、添加直播话术、直播间装扮", "5、点击【启动】"]
    }, {
      name: "interaction",
      label: "如何配置聊天互动",
      src: "https://cdn-tx.yunbovtb.com/assets/dp/help/hudongpeizhi.mp4",
      path: ["/createLive"],
      list: ["1、点击【互动】，开启聊天互动按钮", "2、配置平台信息，选择直播平台并复制直播间链接（若未改变直播间，下次开启数字人直播时将自动使用上次地址进行自动连接）", "3、配置需要的互动参数", "4、配置互动聊天开播需要使用开播盒子，首次开播会提示进行下载和安装", "5、开播后可以对互动规则进行修改调整，包括开关状态、问答规则等，修改完后要点击右上角的【保存】内容才会生效。若要修改连接的直播间，需要关闭数字人直播，重新选择平台复制链接后再开播"]
    }, {
      name: "createProduct",
      label: "如何创建产品",
      src: "https://cdn-tx.yunbovtb.com/assets/dp/help/tianjiachanpin.mp4",
      path: ["/home/product", "/home/product-new"],
      list: ["1、点击【新建产品】", "2、添加产品信息", "3、点击【保存】", "4、保存后可重新编辑产品信息或上传产品素材"]
    }])
      , s = yi((()=>{
        let e = {};
        return i.value.forEach((t=>{
            e[t.name] = t
          }
        )),
          e
      }
    ))
      , l = Ft("createProduct")
      , u = yi((()=>s.value[l.value]));
    Jn(r, (()=>{
        let e = r.path
          , t = i.value.find((t=>-1 !== t.path.indexOf(e)));
        t && (l.value = t.name)
      }
    ));
    const c = ()=>{
        o.value && o.value.forEach((e=>{
            e.pause()
          }
        ))
      }
    ;
    return (e,t)=>{
      const n = C$
        , r = A$
        , s = YL;
      return Ca(),
        Ra(s, {
          modelValue: a.value,
          "onUpdate:modelValue": t[1] || (t[1] = e=>a.value = e),
          class: "livemodal",
          style: {
            "border-radius": "6px",
            overflow: "hidden"
          },
          width: "800",
          title: u.value.label
        }, {
          default: Fn((()=>[Ma("div", null, [ja(r, {
            modelValue: l.value,
            "onUpdate:modelValue": t[0] || (t[0] = e=>l.value = e),
            onTabChange: c,
            type: "border-card",
            "tab-position": "left",
            style: {
              "margin-top": "-74px",
              height: "500px"
            }
          }, {
            default: Fn((()=>[(Ca(!0),
              _a(ba, null, Yr(i.value, (e=>(Ca(),
                Ra(n, {
                  label: e.label,
                  name: e.name
                }, {
                  default: Fn((()=>[Ma("video", {
                    controls: "",
                    ref_for: !0,
                    ref_key: "videos",
                    ref: o,
                    src: e.src
                  }, null, 8, qyt), Ma("div", Yyt, [(Ca(!0),
                    _a(ba, null, Yr(e.list, (e=>(Ca(),
                      _a("p", null, te(e), 1)))), 256))])])),
                  _: 2
                }, 1032, ["label", "name"])))), 256))])),
            _: 1
          }, 8, ["modelValue"])])])),
          _: 1
        }, 8, ["modelValue", "title"])
    }
  }
})
  , Qyt = e=>(Ln("data-v-953ccfc3"),
  e = e(),
  In(),
  e)
  , Jyt = {
  key: 0,
  style: {
    position: "absolute",
    bottom: "10px",
    right: "10px",
    width: "30px",
    height: "30px"
  }
}
  , Zyt = Qyt((()=>Ma("audio", {
  class: "ybAudioPlayer",
  id: "ybAudioPlayer"
}, null, -1)))
  , ebt = AQ(vr({
  __name: "App",
  setup(e) {
    const t = Zu()
      , n = Ft(!1);
    return (e,r)=>{
      var o;
      const a = Hr("router-view")
        , i = MA;
      return Ca(),
        _a(ba, null, [ja(a, {
          class: "font-root"
        }), "liveTips" === (null == (o = Vt(t).meta) ? void 0 : o.showTips) ? (Ca(),
          _a("div", Jyt, [ja(i, {
            content: "帮助",
            placement: "top-start"
          }, {
            default: Fn((()=>[Ma("div", {
              class: "tips",
              onClick: r[0] || (r[0] = e=>n.value = !0)
            }, "?")])),
            _: 1
          })])) : za("", !0), Zyt, ja(Xyt, {
          modelValue: n.value,
          "onUpdate:modelValue": r[1] || (r[1] = e=>n.value = e)
        }, null, 8, ["modelValue"])], 64)
    }
  }
}), [["__scopeId", "data-v-953ccfc3"]]);
function tbt(e, t) {
  var n;
  return e = "object" == typeof (n = e) && null !== n ? e : Object.create(null),
    new Proxy(e,{
      get: (e,n,r)=>"key" === n ? Reflect.get(e, n, r) : Reflect.get(e, n, r) || Reflect.get(t, n, r)
    })
}
function nbt(e, {storage: t, serializer: n, key: r, debug: o}) {
  try {
    const o = null == t ? void 0 : t.getItem(r);
    o && e.$patch(null == n ? void 0 : n.deserialize(o))
  } catch (a) {
    o && console.error(a)
  }
}
function rbt(e, {storage: t, serializer: n, key: r, paths: o, debug: a}) {
  try {
    const a = Array.isArray(o) ? function(e, t) {
      return t.reduce(((t,n)=>{
          const r = n.split(".");
          return function(e, t, n) {
            return t.slice(0, -1).reduce(((e,t)=>/^(__proto__)$/.test(t) ? {} : e[t] = e[t] || {}), e)[t[t.length - 1]] = n,
              e
          }(t, r, function(e, t) {
            return t.reduce(((e,t)=>null == e ? void 0 : e[t]), e)
          }(e, r))
        }
      ), {})
    }(e, o) : e;
    t.setItem(r, n.serialize(a))
  } catch (i) {
    a && console.error(i)
  }
}
var obt = function(e={}) {
  return t=>{
    const {auto: n=!1} = e
      , {options: {persist: r=n}, store: o, pinia: a} = t;
    if (!r)
      return;
    if (!(o.$id in a.state.value)) {
      const e = a._s.get(o.$id.replace("__hot:", ""));
      return void (e && Promise.resolve().then((()=>e.$persist())))
    }
    const i = (Array.isArray(r) ? r.map((t=>tbt(t, e))) : [tbt(r, e)]).map((({storage: t=localStorage, beforeRestore: n=null, afterRestore: r=null, serializer: a={
        serialize: JSON.stringify,
        deserialize: JSON.parse
      }, key: i=o.$id, paths: s=null, debug: l=!1})=>{
        var u;
        return {
          storage: t,
          beforeRestore: n,
          afterRestore: r,
          serializer: a,
          key: (null != (u = e.key) ? u : e=>e)("string" == typeof i ? i : i(o.$id)),
          paths: s,
          debug: l
        }
      }
    ));
    o.$persist = ()=>{
      i.forEach((e=>{
          rbt(o.$state, e)
        }
      ))
    }
      ,
      o.$hydrate = ({runHooks: e=!0}={})=>{
        i.forEach((n=>{
            const {beforeRestore: r, afterRestore: a} = n;
            e && (null == r || r(t)),
              nbt(o, n),
            e && (null == a || a(t))
          }
        ))
      }
      ,
      i.forEach((e=>{
          const {beforeRestore: n, afterRestore: r} = e;
          null == n || n(t),
            nbt(o, e),
          null == r || r(t),
            o.$subscribe(((t,n)=>{
                rbt(n, e)
              }
            ), {
              detached: !0
            })
        }
      ))
  }
}();
let abt = function() {
  const e = ae(!0)
    , t = e.run((()=>Ft({})));
  let n = []
    , r = [];
  const o = Ot({
    install(e) {
      rl(o),
        o._a = e,
        e.provide(ol, o),
        e.config.globalProperties.$pinia = o,
        r.forEach((e=>n.push(e))),
        r = []
    },
    use(e) {
      return this._a ? n.push(e) : r.push(e),
        this
    },
    _p: n,
    _a: null,
    _e: e,
    _s: new Map,
    state: t
  });
  return o
}();
abt.use(obt);
const ibt = Qs(ebt);
ibt.use(abt).use(Gyt).use(uG, {
  locale: {
    name: "zh-cn",
    el: {
      colorpicker: {
        confirm: "确定",
        clear: "清空"
      },
      datepicker: {
        now: "此刻",
        today: "今天",
        cancel: "取消",
        clear: "清空",
        confirm: "确定",
        selectDate: "选择日期",
        selectTime: "选择时间",
        startDate: "开始日期",
        startTime: "开始时间",
        endDate: "结束日期",
        endTime: "结束时间",
        prevYear: "前一年",
        nextYear: "后一年",
        prevMonth: "上个月",
        nextMonth: "下个月",
        year: "年",
        month1: "1 月",
        month2: "2 月",
        month3: "3 月",
        month4: "4 月",
        month5: "5 月",
        month6: "6 月",
        month7: "7 月",
        month8: "8 月",
        month9: "9 月",
        month10: "10 月",
        month11: "11 月",
        month12: "12 月",
        weeks: {
          sun: "日",
          mon: "一",
          tue: "二",
          wed: "三",
          thu: "四",
          fri: "五",
          sat: "六"
        },
        months: {
          jan: "一月",
          feb: "二月",
          mar: "三月",
          apr: "四月",
          may: "五月",
          jun: "六月",
          jul: "七月",
          aug: "八月",
          sep: "九月",
          oct: "十月",
          nov: "十一月",
          dec: "十二月"
        }
      },
      select: {
        loading: "加载中",
        noMatch: "无匹配数据",
        noData: "无数据",
        placeholder: "请选择"
      },
      cascader: {
        noMatch: "无匹配数据",
        loading: "加载中",
        placeholder: "请选择",
        noData: "暂无数据"
      },
      pagination: {
        goto: "前往",
        pagesize: "条/页",
        total: "共 {total} 条",
        pageClassifier: "页",
        page: "页",
        prev: "上一页",
        next: "下一页",
        currentPage: "第 {pager} 页",
        prevPages: "向前 {pager} 页",
        nextPages: "向后 {pager} 页",
        deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档"
      },
      messagebox: {
        title: "提示",
        confirm: "确定",
        cancel: "取消",
        error: "输入的数据不合法!"
      },
      upload: {
        deleteTip: "按 delete 键可删除",
        delete: "删除",
        preview: "查看图片",
        continue: "继续上传"
      },
      table: {
        emptyText: "暂无数据",
        confirmFilter: "筛选",
        resetFilter: "重置",
        clearFilter: "全部",
        sumText: "合计"
      },
      tour: {
        next: "下一步",
        previous: "上一步",
        finish: "结束导览"
      },
      tree: {
        emptyText: "暂无数据"
      },
      transfer: {
        noMatch: "无匹配数据",
        noData: "无数据",
        titles: ["列表 1", "列表 2"],
        filterPlaceholder: "请输入搜索内容",
        noCheckedFormat: "共 {total} 项",
        hasCheckedFormat: "已选 {checked}/{total} 项"
      },
      image: {
        error: "加载失败"
      },
      pageHeader: {
        title: "返回"
      },
      popconfirm: {
        confirmButtonText: "确定",
        cancelButtonText: "取消"
      },
      carousel: {
        leftArrow: "上一张幻灯片",
        rightArrow: "下一张幻灯片",
        indicator: "幻灯片切换至索引 {index}"
      }
    }
  }
}),
  ibt.mount("#app");
export {oY as $, Mo as A, es as B, xa as C, ma as D, YL as E, ba as F, bs as G, Ys as H, IC as I, DC as J, OC as K, bi as L, hn as M, YC as N, jC as O, qn as P, rr as Q, Wr as R, Fr as S, wa as T, Ua as U, Ag as V, Yt as W, $s as X, js as Y, Rr as Z, AQ as _, bt as a, Xr as a$, Dt as a0, za as a1, Yr as a2, Ra as a3, Y as a4, Ln as a5, In as a6, Ju as a7, Ha as a8, AD as a9, PB as aA, fG as aB, qq as aC, NX as aD, qm as aE, Rm as aF, Pt as aG, cG as aH, lr as aI, sr as aJ, oe as aK, xr as aL, be as aM, Sa as aN, $n as aO, Gi as aP, en as aQ, nn as aR, tn as aS, R as aT, P as aU, Di as aV, Qs as aW, la as aX, wo as aY, sa as aZ, Js as a_, nF as aa, vO as ab, BX as ac, Qr as ad, TJ as ae, IJ as af, dvt as ag, xe as ah, z as ai, oht as aj, XW as ak, EW as al, LJ as am, MA as an, mpt as ao, nB as ap, bL as aq, rB as ar, Zu as as, Hm as at, sS as au, mK as av, lU as aw, NP as ax, AJ as ay, uU as az, Bg as b, qi as b$, Kt as b0, mr as b1, zi as b2, io as b3, so as b4, co as b5, lo as b6, ao as b7, Ki as b8, uo as b9, Mr as bA, le as bB, Nr as bC, Ht as bD, mn as bE, xt as bF, fi as bG, Hr as bH, Kr as bI, Ti as bJ, cr as bK, Da as bL, Cn as bM, pr as bN, wt as bO, St as bP, Bt as bQ, wi as bR, ki as bS, Se as bT, F as bU, Zr as bV, Wt as bW, Ut as bX, Pa as bY, jt as bZ, ho as b_, En as ba, ae as bb, se as bc, hr as bd, Va as be, rn as bf, Vo as bg, Xs as bh, Si as bi, tl as bj, Ai as bk, Tt as bl, At as bm, Ct as bn, pi as bo, kt as bp, Ot as bq, yo as br, bo as bs, qa as bt, X as bu, Er as bv, Ir as bw, Ar as bx, Vr as by, jr as bz, _a as c, Yi as c0, vo as c1, xi as c2, po as c3, ar as c4, Ts as c5, Ps as c6, Os as c7, _s as c8, ks as c9, e_ as cA, ZO as cB, KD as cC, WD as cD, Sht as cE, Tht as cF, ZI as cG, eP as cH, JI as cI, ght as cJ, mht as cK, yht as cL, XC as cM, qC as cN, pvt as cO, hvt as cP, vvt as cQ, gvt as cR, uJ as cS, bj as cT, Pm as cU, pm as cV, cJ as cW, dJ as cX, Ci as ca, Zt as cb, Yn as cc, Xn as cd, xo as ce, fo as cf, Us as cg, Ei as ch, Pn as ci, gm as cj, vm as ck, ey as cl, ny as cm, ty as cn, qB as co, hG as cp, kJ as cq, CJ as cr, Zat as cs, qme as ct, Yvt as cu, wit as cv, ml as cw, $z as cx, Jj as cy, QP as cz, vr as d, ja as e, $a as f, Ma as g, MW as h, yE as i, sE as j, WC as k, iE as l, La as m, Lr as n, Ca as o, Pr as p, Br as q, Ft as r, Jn as s, te as t, pG as u, ei as v, Fn as w, jo as x, yi as y, Vt as z};
